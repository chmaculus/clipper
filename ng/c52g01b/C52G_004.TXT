!short: ANNOUNCE        Declare a module identifier                                 ^r^CEA^r
'------------------------------------------------------------------------------
 ^bANNOUNCE^b
 Declare a module identifier
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bANNOUNCE <idModule>

 ^bArguments^b

     ^b<idModule>^b is a module identifier name.

 ^bDescription^b

     ANNOUNCE is a declaration statement that defines a module identifier.  A
     linker may use this identifier later to satisfy pending module REQUESTs.
     ANNOUNCE and REQUEST provide a mechanism for managing application
     modules (.prg files).

     Specify ANNOUNCE statements prior to any executable statements in a
     program file.  A source (.prg) file can only have one module identifier;
     all subsequent ANNOUNCE declarations produce a compiler warning and will
     be ignored.  Module identifiers must be unique and should not duplicate
     the name of any procedures or user-defined functions in a source (.prg)
     file.

 ^bExamples^b

     ^b^CFE^b  This example illustrates the ANNOUNCE declaration:

        ANNOUNCE CustomInit

        INIT PROCEDURE MyInit
           ? "Hypothetical Industries, Inc."
           RETURN

        The above program module, CustomInit, should be compiled with the /N
        option.  Subsequently, the program is addressed in the source code of
        another program module through use of the REQUEST statement:

        REQUEST CustomInit

        which causes the module CustomInit to be linked into the resultant
        (.exe) file.
!seealso: "REQUEST" 
'------------------------------------------------------------------------------



!short: BEGIN SEQUENCE  Define a sequence of statements for a BREAK
'------------------------------------------------------------------------------
 ^bBEGIN SEQUENCE^b
 Define a sequence of statements for a BREAK
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBEGIN SEQUENCE
     ^b   <statements>...
     ^b[BREAK [<exp>]]
     ^b   <statements>...
     ^b[RECOVER [USING <idVar>]]
     ^b   <statements>...
     ^bEND [SEQUENCE]

 ^bArguments^b

     ^bBREAK <exp>^b branches execution to the statement immediately
     following the nearest RECOVER statement if one is specified or the
     nearest END SEQUENCE statement.  <exp> is the value returned into the
     <idVar> specified in the USING clause of the RECOVER statement.

     ^bRECOVER USING <idVar>^b defines a recover point in the SEQUENCE
     construct where control branches after a BREAK statement.  If USING
     <idVar> clause is specified, <idVar> receives the value returned by the
     BREAK statement.  In general, this is an error object.

     ^bEND^b defines the end point of the SEQUENCE control structure.  If no
     RECOVER statement is specified, control branches to the first statement
     following the END statement after a BREAK.

 ^bDescription^b

     BEGIN SEQUENCE...END is a control structure used for exception and
     runtime error handling.  It delimits a block of statements, including
     invoked procedures and user-defined functions.  When a BREAK is
     encountered anywhere in a block of statements following the BEGIN
     SEQUENCE statement up to the corresponding RECOVER statement, control
     branches to the program statement immediately following the RECOVER
     statement.  If a RECOVER statement is not specified, control branches to
     the statement following the END statement, terminating the SEQUENCE.  If
     control reaches a RECOVER statement without encountering a BREAK, it
     branches to the statement following the corresponding END.

     The RECOVER statement optionally receives a parameter passed by a BREAK
     statement that is specified with a return value.  This is usually an
     error object, generated and returned by the current error handling block
     defined by ERRORBLOCK().  If an error object is returned, it can be sent
     messages to query information about the error.  With this information, a
     runtime error can be handled within the context of the operation rather
     than in the current runtime error handler.  See the example below.

     Within a SEQUENCE construct there are some restrictions on what
     statements are allowed between the BEGIN SEQUENCE and RECOVER
     statements.  You cannot RETURN, LOOP, or EXIT between a BEGIN SEQUENCE
     and RECOVER statement.  From within the RECOVER statement block,
     however, you can LOOP, EXIT, BREAK, or RETURN since the SEQUENCE is
     essentially completed at that point.  Using LOOP from with the RECOVER
     statement block is useful for reexecuting the SEQUENCE statement block.
     See the example below.

     SEQUENCE constructs are quite flexible.  They can be nested and more
     than one can be defined in the same procedure or user-defined function.
     If more than one SEQUENCE construct is specified, each SEQUENCE should
     delimit one discrete operation.

     For more information on error objects, refer to Error class in this
     chapter.

 ^bExamples^b

     ^b^CFE^b  This code fragment demonstrates a SEQUENCE construct in which
        the BREAK occurs within the current procedure:

        BEGIN SEQUENCE
           <statements>...
           IF lBreakCond
              BREAK
           ENDIF
        RECOVER
           <recovery statements>...
        END

        <recovery statements>...

     ^b^CFE^b  This example demonstrates an error handler returning an error
        object to the variable specified in the USING clause of the RECOVER
        statement:

        LOCAL objLocal, bLastHandler
        //
        // Save current and set new error handler
        bLastHandler := ERRORBLOCK({ |objErr| ;
              MyHandler(objErr, .T.) })
        //
        BEGIN SEQUENCE
           .
           . <operation that might fail>
           .
        RECOVER USING objLocal
           //
           // Send messages to objLocal and handle the error
           ? "Error: "
           IF objLocal:genCode != 0
              ?? objLocal:description
           ENDIF
           .
           .
           .
        END
        //
        // Restore previous error handler
        ERRORBLOCK( bLastHandler )

        FUNCTION MyHandler( objError, lLocalHandler )
           //
           // Handle locally returning the error object
           IF lLocalHandler
              BREAK objError
           ENDIF
           .
           . <other statements to handle the error>
           .
           RETURN NIL

     ^b^CFE^b  This example reexecutes a SEQUENCE statement block by LOOPing
        from within the RECOVER statement block:

        DO WHILE .T.
           BEGIN SEQUENCE
              .
              . <operation that may fail>
              .
           RECOVER
              IF PrintRecover()
                 LOOP      // Repeat the SEQUENCE statement block
              ENDIF
           END
           EXIT            // Escape from the operation
        ENDDO
!seealso: c52g_020.ngo:"Error" c52g_001.ngo:"ERRORBLOCK()" "RETURN" 
'------------------------------------------------------------------------------



!short: DECLARE*        Create and initialize private memory variables and arrays
'------------------------------------------------------------------------------
 ^bDECLARE*^b
 Create and initialize private memory variables and arrays
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDECLARE <identifier> [[:= <initializer>], ... ]

 ^bArguments^b

     ^b<identifier>^b is the name of a private variable or array to create.
     If the <identifier> is followed by square brackets ([ ]), it is created
     as an array.  If the <identifier> is an array, the syntax for specifying
     the number of elements for each dimension is either array[<nElements>,
     <nElements2>,...] or array[<nElements>][<nElements2>]...  The maximum
     number of elements per dimension is 4096.

     ^b<initializer>^b is the optional assignment of a value to a new private
     variable.  An <initializer> expression for a private variable consists
     of the inline assignment operator (:=) followed by any valid CA-Clipper
     expression, including a literal array.  If no explicit <initializer> is
     specified, the variable is given an initial value of NIL.  In the case
     of an array, each element is NIL.  Array identifiers, cannot be given
     values with an <initializer>.

     DECLARE can create, and optionally initialize, a list of variable
     arrays, if definitions are separated by commas.

 ^bDescription^b

     DECLARE is a compatibility statement that is a synonym for the PRIVATE
     statement.  Its general use is not recommended.  PRIVATE should be used
     in all instances.  See PRIVATE for more information.
!seealso: "PRIVATE" 
'------------------------------------------------------------------------------



!short: DO*             Call a procedure
'------------------------------------------------------------------------------
 ^bDO*^b
 Call a procedure
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDO <idProcedure> [WITH <argument list>]

 ^bArguments^b

     ^b<idProcedure>^b is the name of the procedure or user-defined function
     to execute.

     ^bWITH <argument list>^b specifies up to 128 arguments, separated by
     commas, to pass to <idProcedure>.  Each argument may be a single
     variable, field, array, array element, expression, or object.  Arguments
     can be skipped or left off the end of the list.

 ^bDescription^b

     The DO statement calls a procedure or user-defined function, optionally
     passing arguments to the called routine.  It performs the same action as
     a user-defined function or procedure specified on a line by itself with
     the exception that variables other than field variables are passed by
     reference as the default.  In order to pass a field variable as an
     argument, enclose it in parentheses, unless you declare it with the
     FIELD statement or with an alias.

     In CA-Clipper, the number of specified arguments need not match the
     number of specified parameters in the called procedure.  If the number
     of arguments is less than the number of parameters, the parameter
     variables with no corresponding arguments are initialized with a NIL
     value when the procedure is called.  Also, skipping an argument within
     the <argument list> by leaving an empty spot next to the comma
     initializes the corresponding argument to NIL.  To detect the position
     of the last argument passed in the <argument list>, use PCOUNT().  To
     detect a skipped argument, compare the receiving parameter to NIL.

     In addition to calling a procedure or user-defined function, DO also has
     an effect on compilation if you compile the current program file without
     the /M option.  If the CA-Clipper compiler encounters a DO statement and
     the specified procedure has not already been compiled, the compiler
     searches the current directory for a (.prg) file with the same name and
     compiles it.  If the file with the same name as the procedure is not
     found, the called procedure is assumed to be external, and a reference
     is added to the object (.OBJ) file.  At link time, the linker will
     search other object files and libraries for this external reference.

     In CA-Clipper, DO is a compatibility statement and therefore not
     recommended.  Calling a procedure or function on a line by itself is the
     preferred method.  Since this preferred calling convention normally
     passes parameters by value, you must preface an argument with the
     pass-by-reference operator (@) in order to pass by reference.  If you
     are using DO to make a procedure call more readable, a user-defined
     command, specified with the #command directive, can provide greater
     readability without sacrificing the safety of variables passed as
     parameters.

     For more information on passing parameters refer to the Functions and
     Procedures section of the Basic Concepts chapter in the Programming and
     Utilities guide.

 ^bExamples^b

     ^b^CFE^b  This example executes a procedure with no parameters:

        DO AcctsRpt
        AcctsRpt()                           // Preferred method

     ^b^CFE^b  This example executes a procedure passing two constants:

        DO QtrRpt WITH "2nd", "Sales Division"
        QtrRpt("2nd", "Sales Division")     // Preferred method

     ^b^CFE^b  In this example, a procedure is executed with the first
        argument passed by value and the second passed by reference:

        nNumber := 12
        DO YearRpt WITH nNumber + 12, nNumber
        YearRpt(nNumber + 12, @nNumber)     // Preferred method

     ^b^CFE^b  Here, a procedure is invoked with skipped arguments embedded
        in the list of arguments:

        DO DisplayWindow WITH ,,,,"My Window"
        DisplayWindow(,,,,"My Window")      // Preferred method
!seealso: "FUNCTION" "LOCAL" "PARAMETERS" "PROCEDURE" "PUBLIC" "RETURN" 
'------------------------------------------------------------------------------



!short: DO CASE         Execute one of several alternative blocks of statements
'------------------------------------------------------------------------------
 ^bDO CASE^b
 Execute one of several alternative blocks of statements
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDO CASE
     ^bCASE <lCondition1>
     ^b   <statements>...
     ^b[CASE <lCondition2>]
     ^b   <statements>...
     ^b[OTHERWISE]
     ^b   <statements>...
     ^bEND[CASE]

 ^bArguments^b

     ^bCASE <lCondition>^b defines a block of statements to execute if
     <lCondition> evaluates to true (.T.).

     ^bOTHERWISE^b defines a block of statements to execute if none of the
     specified CASE conditions evaluates to true (.T.).

 ^bDescription^b

     DO CASE...ENDCASE is a control structure that executes one of several
     blocks of statements depending on which of the associated conditions is
     true (.T.).  It works by branching execution to the statements following
     the first CASE <lCondition> that evaluates to true (.T.).  Execution
     continues until the next CASE, OTHERWISE, or ENDCASE is encountered.
     Control then branches to the first statement following the next ENDCASE
     statement.

     If none of the CASE conditions evaluates to true (.T.), the statements
     following the OTHERWISE statement are executed up to the matching
     ENDCASE statement.  If an OTHERWISE statement is omitted, control
     branches to the first statement following the matching ENDCASE
     statement.

     You may nest any number of statements, including other control
     structures (i.e., DO WHILE and FOR), within a single DO CASE structure.
     In addition, within a single DO CASE structure, there is no fixed limit
     on the number of CASE statements that a DO CASE structure may contain.

     DO CASE...ENDCASE is identical to IF...ELSEIF...ENDIF with neither
     syntax having a specific advantage over the other.

 ^bExamples^b

     ^b^CFE^b  This example uses DO CASE in a menu structure to branch
        control based on user selection:

        @ 3, 25 PROMPT "First choice"
        @ 4, 25 PROMPT "Second choice"
        MENU TO nChoice
        //
        DO CASE
        CASE nChoice = 0
           RETURN
        CASE nChoice = 1
           ChoiceOne()
        CASE nChoice = 2
           ChoiceTwo()
        ENDCASE
!seealso: "BEGIN SEQUENCE" "DO WHILE" "FOR" "IF" c52g_001.ngo:"IF()" 
'------------------------------------------------------------------------------



!short: DO WHILE        Execute a loop while a condition is true (.T.)
'------------------------------------------------------------------------------
 ^bDO WHILE^b
 Execute a loop while a condition is true (.T.)
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^b[DO] WHILE <lCondition>
     ^b   <statements>...
     ^b   [EXIT]
     ^b   <statements>...
     ^b   [LOOP]
     ^b   <statements>...
     ^bEND[DO]

 ^bArguments^b

     ^b<lCondition>^b is the logical control expression for the DO WHILE
     loop.

     ^bEXIT^b unconditionally branches control from within a DO WHILE or
     FOR...NEXT structure to the statement immediately following the
     corresponding ENDDO or NEXT statement.

     ^bLOOP^b branches control to the most recently executed DO WHILE or FOR
     statement.

 ^bDescription^b

     DO WHILE...ENDDO is a control structure that executes a block of
     statements repetitively, as long as <lCondition> evaluates to true (.T.).
     When the condition evaluates to true (.T.), control passes into the
     structure and proceeds until an EXIT, LOOP, or ENDDO is encountered.
     ENDDO returns control to the DO WHILE statement and the process repeats
     itself.  If an EXIT statement is encountered, control branches to the
     nearest ENDDO or NEXT statement.  If a LOOP statement is encountered,
     control branches to the nearest DO WHILE or FOR statement.  If the
     condition evaluates to false (.F.), the DO WHILE construct terminates and
     control passes to the statement immediately following the ENDDO.

     Use EXIT to terminate a DO WHILE structure based on a condition other
     than the DO WHILE condition.  LOOP, by contrast, prevents execution of
     statements within a DO WHILE based on an intermediate condition, and
     returns to the most recent DO WHILE statement.

     DO WHILE constructs may be nested within any other control structures to
     any depth.  The only requirement is that each control structure be
     properly nested.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a typical control structure for a
        simple grouped report:

        LOCAL cOldSalesman, nTotalAmount
        USE Sales INDEX Salesman NEW
        DO WHILE .NOT. EOF()
           cOldSalesman := Sales->Salesman
           nTotalAmount := 0
           DO WHILE cOldSalesman = Sales->Salesman ;
              .AND. (.NOT. EOF())
              ? Sales->Salesman, Sales->Amount
              nTotalAmount := nTotalAmount + Sales->Amount
              SKIP
           ENDDO
           ? "Total: ", nTotalAmount, "for", cOldSalesman
        ENDDO
        CLOSE Sales

     ^b^CFE^b  This code fragment demonstrates how LOOP can be used to
        provide an intermediate processing condition:

        DO WHILE <lCondition>
           <initial processing>...
           IF <intermediate condition>
              LOOP
           ENDIF
           <continued processing>...
        ENDDO

     ^b^CFE^b  This example demonstrates the use of DO WHILE to emulate a
        repeat until looping construct:

        LOCAL lMore := .T.
        DO WHILE lMore
           <statements>...
           lMore := (<lCondition>)
        ENDDO

     ^b^CFE^b  This example uses a DO WHILE loop to move sequentially through
        a database file:

        DO WHILE .NOT. EOF()
           <statements>...
           SKIP
        ENDDO
!seealso: "BEGIN SEQUENCE" c52g_001.ngo:"DBEVAL()" "DO CASE" "FOR" "IF" c52g_001.ngo:"IF()" "RETURN" 
'------------------------------------------------------------------------------



!short: EXIT PROCEDURE  Declare an exit procedure                                   ^r^CEA^r
'------------------------------------------------------------------------------
 ^bEXIT PROCEDURE^b
 Declare an exit procedure
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bEXIT PROCEDURE <idProcedure>
     ^b   [FIELD <idField list> [IN <idAlias>]]
     ^b   [LOCAL <identifier> [[:= <initializer>]]]
     ^b   [MEMVAR <identifer list>]
     ^b   .
     ^b   . <executable statements>
     ^b   .
     ^b   [RETURN]

 ^bArguments^b

     ^bEXIT PROCEDURE^b declares a procedure that will be executed on program
     termination.

     ^b<idProcedure>^b is the name of the exit procedure to declare. Exit
     procedure names can be any length, but only the first 10 characters are
     significant.  Names may not begin with an underscore but can contain any
     combination of characters, numbers, or underscores.

     ^bFIELD^b declares a list of identifiers to use as field names whenever
     encountered.  If the IN clause is specified, referring to the declared
     name includes an implicit reference to the specified alias.

     ^bLOCAL^b declares and optionally initializes a list of variables or
     arrays whose visibility and lifetime is the current procedure.

     ^bMEMVAR^b declares a list of identifiers to use as private or public
     memory variables or arrays whenever encountered.

     ^bRETURN^b passes control to the next exit procedure or to the operating
     system, if no other exit procedures are pending.

 ^bDescription^b

     The EXIT PROCEDURE statement declares a procedure that will be executed
     upon program termination.  EXIT procedures are called after the last
     executable statement in a CA-Clipper application has completed.  EXIT
     PROCEDUREs can be used to perform common housekeeping tasks such as
     saving configuration settings to a file, closing a log file or
     concluding a communications session.

     The visibility of exit procedures is restricted to the system;
     therefore, it is not possible to call an EXIT PROCEDURE from a procedure
     or user-defined function.  Exit procedures do not receive parameters.

     Once the last executable statement has completed, control passes from
     one EXIT PROCEDURE to the next until all procedures in the exit list
     have been called.  Control then passes to the operating system.

     The ANNOUNCE statement declares a module identifier for a source file
     (.prg).  Once declared, EXIT PROCEDUREs are referenced with this module
     identifier.  An application may use any number of exit procedures by
     explicitly REQUESTing their module identifiers.

     The EXIT PROCEDUREs requested for an appplication are collectively
     referred to as the exit list.  There is no mandatory execution order of
     procedures in the exit list; however, if an EXIT PROCEDURE is declared
     in the same source file (.prg) as the application's primary routine
     (root), it is guaranteed to be the first exit procedure called.

     Termination of a given CA-Clipper application can be attributed to any
     of the following:

     ^b^CFE^b  RETURNing from the primary (root) routine

     ^b^CFE^b  the QUIT command

     ^b^CFE^b  issuing a BREAK without an enclosing BEGIN SEQUENCE...END

     ^b^CFE^b  unrecoverable error

     Execution of an EXIT PROCEDURE cannot be guaranteed when the system
     encounters an unrecoverable error.  If an error is raised during an exit
     procedure, the system returns to DOS.  Pending exit procedures are not
     called.

 ^bExamples^b

     ^b^CFE^b  This example illustrates construction of a simple timing
        mechanism using INIT and EXIT PROCEDUREs:

        // prints the amount of time required to read,
        // sort, and display a list of file names.

        ANNOUNCE MySystem

        STATIC nStart

        PROCEDURE Main()
           AEVAL( ASORT( DIRECTORY( "*.*" ) ),;
              { | aFileInfo | QOUT( aFileInfo[ 1 ] ) } )
           RETURN

        INIT PROCEDURE MyInit()
           nStart := SECONDS()
           RETURN

        EXIT PROCEDURE MyExit()
           ?
           ? "Elapsed Time: "
           ?? SECONDS() - nStart
           RETURN
!seealso: "ANNOUNCE" "REQUEST" "INIT PROCEDURE" 
'------------------------------------------------------------------------------



!short: EXTERNAL*       Declare a list of procedure or function names to the linker ^r^CE4^r
'------------------------------------------------------------------------------
 ^bEXTERNAL*^b
 Declare a list of procedure or user-defined function names to the linker
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bEXTERNAL <idProcedure list>

 ^bArguments^b

     ^b<idProcedure list>^b is the list of procedures, user-defined
     functions, or format procedures to add to the list of routines that will
     be linked into the current executable (.EXE) file.

 ^bDescription^b

     EXTERNAL is a declaration statement that specifies uncoded references to
     the linker.  Like all other declaration statements, an EXTERNAL
     statement must be specified before any executable statements in either
     the program file, or a procedure or user-defined function definition.

     During the compilation of CA-Clipper source code, all explicit
     references to procedures and user-defined functions are made to the
     linker.  In some instances, there may be no references made to procedure
     or user-defined function names until runtime.  EXTERNAL resolves this by
     forcing the named procedures or user-defined functions to be linked even
     if they are not explicitly referenced in the source file.  This is
     important in several instances:

     ^b^CFE^b  Procedures, user-defined functions, or formats referenced with
        macro expressions or variables

     ^b^CFE^b  Procedures and user-defined functions used in REPORT and LABEL
        FORMs and not referenced in the source code

     ^b^CFE^b  User-defined functions used in index keys and not referenced
        in the source code

     ^b^CFE^b  ACHOICE(), DBEDIT(), or MEMOEDIT() user functions

     To group common EXTERNAL declarations together, place them in a header
     file then #include the header file into each program (.prg) file that
     might indirectly use them.

     EXTERNAL is a compatibility statement and therefore not recommended.  It
     is superseded by the REQUEST statement that defines a list of module
     identifiers to the linker.

 ^bExamples^b

     ^b^CFE^b  These examples are equivalent header files consisting of
        common EXTERNAL references for REPORT FORMs:

        // Externals.ch

        EXTERNAL HARDCR
        EXTERNAL TONE
        EXTERNAL MEMOTRAN
        EXTERNAL STRTRAN

        // Externals.ch
        EXTERNAL HARDCR, TONE, MEMOTRAN, STRTRAN
!seealso: c52g_006.ngo:"#include" "REQUEST" 
'------------------------------------------------------------------------------



!short: FIELD           Declare database field names
'------------------------------------------------------------------------------
 ^bFIELD^b
 Declare database field names
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFIELD <idField list> [IN <idAlias>]

 ^bArguments^b

     ^b<idField list>^b is a list of names to declare as fields to the
     compiler.

     ^bIN <idAlias>^b specifies an alias to assume when there are unaliased
     references to the names specified in the <idField list>.  Unaliased
     references to variables in <idField list> are treated as if they are
     preceded by the special field alias (FIELD->).

 ^bDescription^b

     The FIELD statement declares the names of database fields to the
     compiler, and optionally supplies an implicit alias for each name.  This
     allows the compiler to resolve references to variables with no explicit
     alias--by implicitly assuming the specified <idAlias>.  Only explicit,
     unaliased references to the specified fields in the <idField list> are
     affected.  The FIELD statement, like all declarations, has no effect on
     references made within macro expressions or variables.

     The FIELD statement neither opens a database file nor verifies the
     existence of the specified fields.  It is useful primarily to ensure
     correct references to fields whose accessibility is known at runtime.
     Attempting to access the fields when the associated database is not in
     USE will cause an error.

     The scope of the FIELD declaration is the procedure or function in which
     it occurs, or the entire program (.prg) file if the declaration precedes
     all PROCEDURE or FUNCTION declarations and the /N compiler option is
     specified.

     FIELD statements like other declarations must precede any executable
     statements in the procedure or function definition, or the program
     (.prg) file if the declaration has filewide scope.

     FIELD used with the /W compiler option performs compile-time checking
     for undeclared variables.

     For more information on variable declarations and scoping, refer to the
     Variables section in the Basic Concepts chapter of the Programming and
     Utilities guide.

 ^bExamples^b

     ^b^CFE^b  This user-defined function includes statements to declare
        database field names in both the current and Employee work areas:

        FUNCTION DisplayRecord
           FIELD CustNo, OrderNo, Salesman
           FIELD EmpName, EmpCode IN Employee
           USE Employee NEW
           USE Orders NEW
           //
           ? CustNo             // Refers to Orders->CustNo
           ? EmpName            // Refers to Employee->EmpName
           //
           CLOSE Orders
           CLOSE Employee
           RETURN NIL
!seealso: "FUNCTION" "LOCAL" "MEMVAR" "PROCEDURE" "STATIC" 
'------------------------------------------------------------------------------



!short: FOR             Execute a block of statements a specified number of times
'------------------------------------------------------------------------------
 ^bFOR^b
 Execute a block of statements a specified number of times
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFOR <idCounter> := <nStart> TO <nEnd>
     ^b   [STEP <nIncrement>]
     ^b   <statements>...
     ^b   [EXIT]
     ^b   <statements>...
     ^b   [LOOP]
     ^bNEXT

 ^bArguments^b

     ^b<idCounter>^b is the name of the loop control or counter variable.  If
     the specified <idCounter> is not visible or does not exist, a private
     variable is created.

     ^b<nStart>^b is the initial value assigned to <idCounter>.  If
     <nIncrement> is negative, <nStart> must be less than <nEnd>.

     ^bTO <nEnd>^b defines the final value of <idCounter>.  If <nIncrement>
     is negative, <nStart> must be greater than <nEnd>; otherwise, <nStart>
     must be less than <nEnd>.

     ^bSTEP <nIncrement>^b defines the amount <idCounter> is changed for each
     iteration of the loop.  <nIncrement> can be either positive or negative.
     If the STEP clause is not specified, <idCounter> is incremented by one
     for each iteration of the loop.

     ^bEXIT^b unconditionally branches control from within a FOR...NEXT
     construct to the statement immediately following the nearest NEXT
     statement.

     ^bLOOP^b branches control to the most recently executed FOR or DO WHILE
     statement.

 ^bDescription^b

     FOR...NEXT is a control structure that executes a block of statements a
     specified number of times.  The control structure loops from the initial
     value of <idCounter> to the boundary specified by <nEnd>, moving through
     the range of values of the control variable for an increment specified
     by <nIncrement>.  All expressions in the FOR statement are reevaluated
     for each iteration of the loop.  The <nStart> and <nEnd> expressions,
     therefore, can be changed as the control structure operates.

     A FOR loop operates until <idCounter> is greater than <nEnd> or an EXIT
     statement is encountered.  Control then branches to the statement
     following the corresponding NEXT statement.  If a LOOP statement is
     encountered, control branches back to the current FOR statement.

     If <nIncrement> is a negative value, <idCounter> is decremented rather
     than incremented.  The FOR loop, however, continues until <idCounter> is
     less than <nEnd>.  This means that <nEnd> must be less than <nStart>
     when the FOR loop begins.

     FOR loops are useful for traversing arrays where <idCounter> is used as
     the array subscript.  See the example below.

     FOR...NEXT constructs may be nested within any other control structures
     to any depth.  The only requirement is that each control structure is
     properly nested.

 ^bExamples^b

     ^b^CFE^b  This example traverses an array in ascending order:

        nLenArray := LEN(aArray)
        FOR i := 1 TO nLenArray
           <statements>...
        NEXT

     ^b^CFE^b  To traverse an array in descending order:

        nLenArray := LEN(aArray)
        FOR i := nLenArray TO 1 STEP -1
           <statements>...
        NEXT
!seealso: c52g_001.ngo:"AEVAL()" "BEGIN SEQUENCE" "DO CASE" "DO WHILE" "IF" 
'------------------------------------------------------------------------------



!short: FUNCTION        Declare a user-defined function name and formal parameters
'------------------------------------------------------------------------------
 ^bFUNCTION^b
 Declare a user-defined function name and formal parameters
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^b[STATIC] FUNCTION <idFunction>[(<idParam list>)]
     ^b   [LOCAL <identifier> [[:= <initializer>], ... ]]
     ^b   [STATIC <identifier> [[:= <initializer>], ... ]]
     ^b   [FIELD <identifier list> [IN <idAlias>]]
     ^b   [MEMVAR <identifier list>]
     ^b   .
     ^b   . <executable statements>
     ^b   .
     ^b   RETURN <exp>

 ^bArguments^b

     ^b<idFunction>^b is the name of the user-defined function to declare.
     User-defined function names can be any length, but only the first 10
     characters are significant.  Names can contain any combination of
     characters, numbers, or underscores, but must begin with a character or
     an underscore.  Leading underscores are not recommended since they are
     reserved for internal functions.

     ^b<idParam list>^b is the declaration of one or more parameter
     variables.  Variables specified in this list are declared local.

     ^bSTATIC FUNCTION^b declares a user-defined function that can be invoked
     only by procedures and user-defined functions declared in the same
     program (.prg) file.

     ^bLOCAL^b declares and optionally initializes a list of variables or
     arrays whose visibility and lifetime is the current function.

     ^bSTATIC^b declares and optionally initializes a list of variables or
     arrays whose visibility is the current user-defined function and
     lifetime is the duration of the program.

     ^bFIELD^b declares a list of identifiers to use as field names whenever
     encountered.  If the IN clause is specified, referring to the declared
     name includes an implicit reference to the specified alias.

     ^bMEMVAR^b declares a list of identifiers to use as private or public
     memory variables or arrays whenever encountered.

     ^b<identifier>^b and ^b<identifier list>^b are labels to be used as
     variable or array names.

     ^b<initializer>^b is a value to which an array or variable is originally
     set in an inline expression.

     ^bRETURN <exp>^b passes control back to the calling procedure or
     user-defined function, returning the result of <exp> as the value of the
     function.  Each function must have at least one RETURN statement that
     returns a value.  RETURN statements can occur anywhere in the body of a
     function.

 ^bDescription^b

     The FUNCTION statement declares a user-defined function and an optional
     list of local variables to receive parameters often referred to as
     formal parameters.  A user-defined function is a subprogram comprised of
     a set of declarations and statements executed whenever you refer to
     <idFunction> followed by an open and closed parentheses pair.  A function
     definition begins with a FUNCTION statement which is the FUNCTION
     declaration and ends with the next FUNCTION statement, PROCEDURE
     statement, or end of file.

     Functions encapsulate a computational block of code and then later
     create expressions using the value returned.  Functions and procedures
     increase both readability and modularity, isolate change, and help
     manage complexity.

     A function in CA-Clipper is the same as a procedure, except that it must
     return a value.  The returned value can be any data type including an
     array, a code block, or NIL.  Each function must begin with a FUNCTION
     statement and contain at least one RETURN statement with an argument.
     Function declarations cannot be nested within other function
     definitions.  A user-defined function can be used wherever standard
     functions are supported, including expressions.

     The visibility of function names falls into two classes.  Functions that
     are visible anywhere in a program are referred to as public functions
     and declared with a FUNCTION statement.  Functions that are visible only
     within the current program (.prg) file are referred to as static
     functions and declared with a STATIC FUNCTION statement.  Static
     functions have filewide scope.

     Static functions limit visibility of a function name, thereby
     restricting access to the function.  Because of this, subsystems defined
     within a single program (.prg) file can provide an access protocol with
     a series of public functions and conceal the implementation details of
     the subsystem within static functions and procedures.  Since the static
     function references are resolved at compile time, they preempt
     references to public functions which are resolved at link time.  This
     assures that within a program file, a reference to a static function
     executes that function if there is a name conflict with a public
     function.

     For more information on user-defined functions, variable declarations,
     and parameter passing, refer to the Basic Concepts chapter in the
     Programming and Utilities guide.

 ^bNotes^b

     ^b^CFE  Calling a user-defined function:^b Use the same notation to call
        a user-defined function as when calling a standard CA-Clipper
        function:

        <idFunction>([<argument list>])

        You can call a user-defined function within an expression or on a
        line by itself.  If called on a line by itself, the return value is
        ignored.

        You can also call a user-defined function as an aliased expression by
        prefacing it with an alias and enclosing it in parentheses:

        <idAlias>->(<idFunction>(<argument list>))

        When you call a user-defined function as an aliased expression, the
        work area associated with <idAlias> is selected, the expression is
        executed, and the original work area is then reselected.  You can
        specify an aliased expression on a line by itself, as you would any
        other expression.

        A user-defined function in CA-Clipper may call itself recursively.
        This means you can make a reference to a user-defined function in
        statements or expressions of the same user-defined function
        definition.

     ^b^CFE  Parameters:^b User-defined functions, like procedures, can
        receive parameters passed from a calling procedure, user-defined
        function, or DOS command line.  A parameter is a place holder for a
        value or reference.  In CA-Clipper, there are two ways to express
        parameters: you can declare a list of local variable names as a part
        of the FUNCTION declaration (referred to as formal parameters), or
        you can specify a list of private variables in a separate PARAMETERS
        statement.  Note that you cannot mix a declaration of formal
        parameters with a PARAMETERS statement.  Attempting this will result
        in a fatal compiler error.

        Functions receive parameters in the order passed.  In CA-Clipper, the
        number of parameters does not have to match the number of arguments
        passed.  You can skip arguments or omit them from the end of the
        argument list.  A parameter not receiving a value or reference is
        initialized to NIL.  You can skip a parameter by passing NIL.  If
        arguments are specified, PCOUNT() returns the position of the last
        argument passed.

        Parameters specified in a user-defined function can receive arguments
        passed by value or reference.  The default method for expressions and
        variables is by value.  This includes variables that contain
        references to arrays and objects.  All variables except field
        variables, when prefaced with the pass-by-reference operator (@), are
        passed by reference.  Field variables cannot be passed by reference
        and are always passed by value.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a user-defined function that formats
        numeric values as currency:

        ? Currency( 1000 )               // Result: $1,000.00

        FUNCTION Currency( nNumber )
           LOCAL cNumber
           IF nNumber < 0
              cNumber := TRANSFORM(-1 * nNumber, ;
                    "999,999,999,999.99")
              cNumber := PADL("($" + LTRIM(cNumber) + ")", ;
                    LEN(cNumber))
           ELSE
              cNumber := TRANSFORM(nNumber, ;
                    "999,999,999,999.99")
              cNumber := PADL("$" + LTRIM(cNumber), ;
                    LEN(cNumber))
           ENDIF
           RETURN cNumber

     ^b^CFE^b  This example demonstrates a user-defined function that takes a
        character string formatted as a comma-separated list and returns an
        array with one element per item:

        aList := ListAsArray("One, Two")
        // Result: {"One", "Two"}

        FUNCTION ListAsArray( cList )
           LOCAL nPos
           // Define an empty array
           LOCAL aList := {}
           //
           DO WHILE (nPos := AT(",", cList)) != 0
              // Add a new element
              AADD(aList, SUBSTR(cList, 1, nPos - 1))
              cList := SUBSTR(cList, nPos + 1)
           ENDDO
           AADD(aList, cList)
           //
           // Return the array
           RETURN aList

     ^b^CFE^b  This example checks for a skipped argument by comparing the
        parameter to NIL:

        FUNCTION MyFunc( param1, param2, param3 )
           IF param2 == NIL
              param2 := "default value"
           ENDIF
           .
           . <statements>
           .
           RETURN NIL

     ^b^CFE^b  This example uses the user-defined function, Currency()
        (defined above), as an aliased expression:

        USE Invoices NEW
        USE Customer NEW
        ? Invoices->(Currency(Amount))
!seealso: "LOCAL" c52g_001.ngo:"PCOUNT()" "PRIVATE" "PROCEDURE" "RETURN" "STATIC" 
'------------------------------------------------------------------------------



!short: IF              Execute one of several alternative blocks of statements
'------------------------------------------------------------------------------
 ^bIF^b
 Execute one of several alternative blocks of statements
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bIF <lCondition1>
     ^b   <statements>...
     ^b[ELSEIF <lCondition2>]
     ^b   <statements>...
     ^b[ELSE]
     ^b   <statements>...
     ^bEND[IF]

 ^bArguments^b

     ^b<lCondition>^b is a logical control expression.  If it evaluates to
     true (.T.), all following statements are executed until an ELSEIF, ELSE,
     or ENDIF is encountered.

     ^bELSEIF <lCondition>^b identifies statements to execute if the
     associated condition evaluates to true (.T.) and all preceding IF or
     ELSEIF conditions evaluate to false (.F.).  Any number of ELSEIF
     statements can be specified within the same IF...ENDIF control
     structure.

     ^bELSE^b identifies statements to execute if the IF and all preceding
     ELSEIF conditions evaluate to false (.F.).

 ^bDescription^b

     The IF control structure works by branching execution to statements
     following the first true (.T.) evaluation of the IF or any ELSEIF
     condition.  Execution then continues until the next ELSEIF, ELSE, or
     ENDIF is encountered whereupon execution branches to the first statement
     following the ENDIF.

     If no condition evaluates to true (.T.), control passes to the first
     statement following the ELSE statement.  If an ELSE statement is not
     specified, control branches to the first statement following the ENDIF
     statement.

     IF...ENDIF structures may be nested within IF...ENDIF structures and
     other control structure commands.  These structures, however, must be
     nested properly.

     The IF...ELSEIF...ENDIF form of the IF construct is identical to DO
     CASE...ENDCASE.  There is no specific advantage of one syntax over the
     other.  The IF construct is also similar to the IF() function which can
     be used within expressions.

 ^bExamples^b

     ^b^CFE^b  This example evaluates a number of conditions using an
        IF...ELSEIF...ENDIF construct:

        LOCAL nNumber := 0
        //
        IF nNumber < 50
           ? "Less than 50"
        ELSEIF nNumber = 50
           ? "Is equal to 50"
        ELSE
           ? "Greater than 50"
        ENDIF
!seealso: "BEGIN SEQUENCE" "DO CASE" "DO WHILE" "FOR" c52g_001.ngo:"IF()" 
'------------------------------------------------------------------------------



!short: INIT PROCEDURE  Declare an initialization procedure                         ^r^CEA^r
'------------------------------------------------------------------------------
 ^bINIT PROCEDURE^b
 Declare an initialization procedure
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bINIT PROCEDURE <idProcedure> [(<idParam list>)]
     ^b   [FIELD <idField list> [IN <idAlias>]]
     ^b   [LOCAL <identifier> [[:= <initializer>]]]
     ^b   [MEMVAR <identifer list>]
     ^b   .
     ^b   . <executable statements>
     ^b   .
     ^b   [RETURN]

 ^bArguments^b

     ^bINIT PROCEDURE^b declares a procedure that will be executed at program
     startup.

     ^b<idProcedure>^b is the name of the initialization procedure to
     declare. Initialization procedure names can be any length, but only the
     first 10 characters are significant.  Names may not begin with an
     underscore but can contain any combination of characters, numbers, or
     underscores.

     ^b<idParam list>^b is the declaration of one or more parameter
     variables. Variables specified in this list are declared local.

     ^bFIELD^b declares a list of identifiers to use as field names whenever
     encountered.  If the IN clause is specified, referring to the declared
     name includes an implicit reference to the specified alias.

     ^bLOCAL^b declares, and optionally initializes, a list of variables or
     arrays whose visibility and lifetime is the current procedure.

     ^bMEMVAR^b declares a list of identifiers to use as private or public
     memory variables or arrays whenever encountered.

     ^bRETURN^b passes control to the next initialization procedure or the
     first executable routine in the program, if no other initialization
     procedures are pending.

 ^bDescription^b

     The INIT PROCEDURE statement declares a procedure that will be executed
     at program startup.  INIT procedures are called prior to the first
     executable statement in a CA-Clipper  application, and are useful for
     performing common initialization tasks such as reading configuration
     settings, or opening a communications port.

     INIT PROCEDUREs are executed implicitly by CA-Clipper  at program
     startup.  The visibility of initialization procedures is restricted to
     the system; therefore, it is not possible to call an INIT PROCEDURE from
     a procedure or user-defined function.  Each INIT PROCEDURE receives a
     copy of the DOS command line arguments used to invoke the application.

     Control passes from one INIT PROCEDURE to the next until all procedures
     in the initialization list have been called.  Control then passes to the
     first executable statement in the program.

     The ANNOUNCE statement declares a module identifier for a source (.prg)
     file.  Once declared, INIT PROCEDUREs are referenced by this module
     identifier.  An application may use any number of initialization
     procedures by explicitly REQUESTing their module identifiers.

     The INIT PROCEDUREs requested for an appplication are collectively
     referred to as the initialization list.  There is no default execution
     order of procedures in the initialization list; however, the following
     rules apply:

     ^b^CFE^b  The CA-Clipper initialization procedure, CLIPINIT, is always
        called first.

     ^b^CFE^b  If an INIT PROCEDURE is declared in the same source (.prg)
        file as the application's primary (root) routine, it will be the last
        initialization procedure called.

     CLIPINIT is called first to establish system integrity by installing the
     default error recovery system (ErrorSys).  Once CLIPINIT has finished
     executing, control passes to the next INIT PROCEDURE in the
     initialization list.

     If an error is raised during system initialization, the system returns
     to DOS, and pending initialization procedures are not called.

 ^bExamples^b

     ^b^CFE^b  This example uses both INIT and EXIT PROCEDUREs to save and
        restore the context of the operating system.  By simply REQUESTing
        "SaveDos" in your main source file, the context of the operating
        system is preserved:

        ANNOUNCE SaveDos

        #define DOS_SCREEN   1
        #define DOS_ROW      2
        #define DOS_COL      3
        #define DOS_CURSOR   4
        #define DOS_COUNT    4

        STATIC saSaveDos[ SD_COUNT ]

        INIT PROCEDURE dosSave()
           SAVE SCREEN TO saSaveDos[ DOS_SCREEN ]
           saSaveDos[ DOS_ROW ]    := ROW()
           saSaveDos[ DOS_COL ]    := COL()
           saSaveDos[ DOS_CURSOR ] := SETCURSOR()
           RETURN

        EXIT PROCEDURE dosRestore()
           RESTORE SCREEN FROM saSaveDos[ DOS_SCREEN ]
           SETPOS   ( saSaveDos[ DOS_ROW ], saSaveDos[ DOS_COL ] )
           SETCURSOR( saSaveDos[ DOS_CURSOR ] )
           RETURN
!seealso: "ANNOUNCE" "REQUEST" "EXIT PROCEDURE" 
'------------------------------------------------------------------------------



!short: LOCAL           Declare and initialize local variables and arrays
'------------------------------------------------------------------------------
 ^bLOCAL^b
 Declare and initialize local variables and arrays
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bLOCAL <identifier> [[:= <initializer>], ... ]

 ^bArguments^b

     ^b<identifier>^b is the name of a variable or array to declare local.
     If the <identifier> is followed by square brackets ([ ]), it is created
     as an array.  If the <identifier> is an array, the syntax for specifying
     the number of elements for each dimension can be array[<nElements>,
     <nElements2>,...] or array[<nElements>][<nElements2>]...  The maximum
     number of elements per dimension is 4096.  The maximum number of
     dimensions per array is limited only by available memory.

     ^b<initializer>^b is the optional assignment of a value to a new local
     variable.  Array identifiers, however, cannot be given values with an
     <initializer>.  An <initializer> for a local variable consists of the
     inline assignment operator (:=) followed by any valid CA-Clipper
     expression including a literal array.  If no explicit <initializer> is
     specified, the variable is given an initial value of NIL.  In the case
     of an array, each element is NIL.

     ^bNote: ^b The macro operator (&) cannot be used in a LOCAL declaration
     statement.

 ^bDescription^b

     LOCAL is a declaration statement that declares one or more variables or
     arrays local to the current procedure or user-defined function and must
     occur before any executable statement including PRIVATE, PUBLIC, and
     PARAMETERS.  Local variable declarations hide all inherited private
     variables and visible public variables with the same name.  A LOCAL
     statement, however, that declares a variable name which is already
     declared causes a fatal compiler error and no object file (.OBJ) is
     generated.  This error can happen as a result of two declarations for
     the same variable name in the same routine, or as the result of
     redeclaring a variable with filewide scope.  Declaration statements
     include FIELD, MEMVAR, and STATIC.

     Local variables are visible only within the current procedure or
     user-defined function, and unlike private variables, are not visible
     within invoked routines.  Local variables are created automatically each
     time the procedure in which they were declared begins executing.  They
     continue to exist and retain their values until the declaring procedure
     or user-defined function returns control to the code that invoked it.
     If a procedure or user-defined function is invoked recursively (calls
     itself), each recursive activation creates a new set of local variables.

     The initial value of local variables and array elements is NIL if not
     explicitly initialized, either in the initializer list or by assignment.
     The initializer expression can be any valid CA-Clipper expression,
     including function calls.  Note that an array declaration cannot have an
     initializer.

     The maximum number of local variables in a program is limited only by
     available memory.  Arrays, however, assigned to a local variable are
     still limited to 4096 elements per dimension.

     For more information on variable declarations and scoping, refer to the
     Variables section in the Basic Concepts chapter of the Programming and
     Utilities guide.

 ^bNotes^b

     ^b^CFE  Inspecting local variables within the Debugger:^b To access
        local variable names within The CA-Clipper Debugger, you must compile
        program (.prg) files using the /B option so that local variable
        information is included in the object file.

     ^b^CFE  Local parameters:^b Declare a list of local parameters as a part
        of a FUNCTION or PROCEDURE declaration by enclosing the list of
        parameters in parentheses following the <idFunction>:

        FUNCTION <idFunction>(<idParam list>)

        Declaration of local parameters supersedes creation of private
        parameters with the PARAMETERS statement.

     ^b^CFE  Macro expressions:^b You cannot refer to local variables within
        macro variables and expressions.  If you refer to a local variable
        within a macro variable, a private or public variable with the same
        name will be referenced instead.  If no such variable exists, a
        runtime error will be generated.

     ^b^CFE  Memory files:^b Local variables cannot be SAVED to or RESTOREd
        from memory (.mem) files.

     ^b^CFE  Type of a local variable:^b Since TYPE() uses the macro operator
        (&) to evaluate its argument, it cannot be used to determine the type
        of a local or static variable or an expression containing a local or
        static variable reference.  The VALTYPE() function provides this
        facility.  VALTYPE() evaluates its argument and returns the type of
        the return value.

 ^bExamples^b

     ^b^CFE^b  This example declares two local arrays and two local
        variables:

        LOCAL aArray1[20, 10], aArray2[20][10], var1, var2

     ^b^CFE^b  This example declares two local variables with initializers.
        The first is initialized to a date value and the second to a literal
        array:

        LOCAL dWhen := DATE()
        LOCAL aVegies := {"Tomato", "Chickadee", "Butterbean"}
!seealso: "FUNCTION" "PARAMETERS" "PRIVATE" "PROCEDURE" "PUBLIC" "STATIC" 
'------------------------------------------------------------------------------



!short: MEMVAR          Declare private and public variable names
'------------------------------------------------------------------------------
 ^bMEMVAR^b
 Declare private and public variable names
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMEMVAR <idMemvar list>

 ^bArguments^b

     ^b<idMemvar list>^b is a list of public and private variable names to
     declare to the compiler.

 ^bDescription^b

     MEMVAR is a declaration statement that causes the compiler to resolve
     references to variables specified without an explicit alias by
     implicitly assuming the memory variable alias (MEMVAR->).  Only
     explicit, unaliased references to the specified variables are affected.
     MEMVAR, like all declaration statements, has no effect on references
     made within macro expressions or variables.

     The MEMVAR statement neither creates the variables nor verifies their
     existence.  Its primary effect is to ensure correct references to
     variables whose existence is known to be guaranteed at runtime.  At
     runtime, the specified variables must be created using the PRIVATE,
     PARAMETERS or PUBLIC statements.  This can occur in the procedure
     containing the MEMVAR declaration or in a higher-level procedure.
     Attempting to access the variables before they are created will cause an
     error.

     The scope of the MEMVAR declaration is the procedure or function in
     which it occurs, or the entire source file if it precedes any PROCEDURE
     or FUNCTION statements and the /N compiler option is used.  The /N
     option suppresses automatic definition of a procedure with the same name
     as the program (.prg) file.

     Like other declaration statements, MEMVAR must precede any executable
     statements including PARAMETERS, PUBLIC, and PRIVATE statements in a
     procedure or function definition; or the program (.prg) file if the
     declaration has filewide scope.

     MEMVAR can be used in conjunction with the /W compiler option--which
     generates warning messages for ambiguous variable references--to perform
     compile-time checking for undeclared variables.

     For more information on variable declarations and scoping, refer to the
     Variables section in the Basic Concepts chapter of the Programming and
     Utilities guide.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates the relationship between a private
        and field variable with the same name.  The private variable is
        declared with the MEMVAR statement:

        FUNCTION Example
           MEMVAR amount, address
           PRIVATE amount := 100
           USE Customer NEW
           //
           ? amount          // Refers to amount private variable
           ? Customer->Amount
                             // Refers to Amount field variable
           //
           RETURN NIL
!seealso: "FIELD" "LOCAL" "PRIVATE" "PUBLIC" "STATIC" 
'------------------------------------------------------------------------------



!short: PARAMETERS      Create private parameter variables
'------------------------------------------------------------------------------
 ^bPARAMETERS^b
 Create private parameter variables
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bPARAMETERS <idPrivate list>

 ^bArguments^b

     ^b<idPrivate list>^b is one or more parameter variables separated by
     commas.  The number of receiving variables does not have to match the
     number of arguments passed by the calling procedure or user-defined
     function.

 ^bDescription^b

     The PARAMETERS statement creates private variables to receive passed
     values or references.  Receiving variables are referred to as
     parameters.  The values or references actually passed by a procedure or
     user-defined function invocation are referred to as arguments.

     When a PARAMETERS statement executes, all variables in the parameter
     list are created as private variables and all public or private
     variables with the same names are hidden until the current procedure or
     user-defined function terminates.  A PARAMETERS statement is an
     executable statement and therefore can occur anywhere in a procedure or
     user-defined function, but must follow all compile-time variable
     declarations, such as FIELD, LOCAL, MEMVAR, and STATIC.

     Parameters can also be declared as local variables if specified as a
     part of the PROCEDURE or FUNCTION declaration statement (see the
     example).  Parameters specified in this way are referred to as formal
     parameters.  Note that you cannot specify both formal parameters and a
     PARAMETERS statement with a procedure or user-defined function
     definition.  Attempting to do this results in a fatal compiler error and
     an object file is not generated.

     In CA-Clipper the number of arguments and parameters do not have to
     match.  If you specify more arguments than parameters, the extra
     arguments are ignored.  If you specify fewer arguments specified than
     parameters, the extra parameters are created with a NIL value.  If you
     skip an argument, the corresponding parameter is initialized to NIL.
     The PCOUNT() function returns the position of the last argument passed
     in the list of arguments.  This is different than the number of
     parameters passed since it includes skipped parameters.

     For more information on passing parameters, refer to the Functions and
     Procedures section in the Basic Concepts chapter of the Programming and
     Utilities guide.

 ^bExamples^b

     ^b^CFE^b  This user-defined function receives values passed into private
        parameters with a PARAMETERS statement:

        FUNCTION MyFunc
           PARAMETERS cOne, cTwo, cThree
           ? cOne, cTwo, cThree
           RETURN NIL

     ^b^CFE^b  This example is similar, but receives values passed into local
        variables, by declaring the parameter variables within the FUNCTION
        declaration:

        FUNCTION MyFunc( cOne, cTwo, cThree )
           ? cOne, cTwo, cThree
           RETURN NIL
!seealso: "FUNCTION" "LOCAL" c52g_001.ngo:"PCOUNT()" "PRIVATE" "PROCEDURE" "STATIC" 
'------------------------------------------------------------------------------



!short: PRIVATE         Create and initialize private memory variables and arrays
'------------------------------------------------------------------------------
 ^bPRIVATE^b
 Create and initialize private memory variables and arrays
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bPRIVATE <identifier> [[:= <initializer>], ... ]

 ^bArguments^b

     ^b<identifier>^b is the name of a private variable or array to create.
     If the <identifier> is followed by square brackets ([ ]), an array is
     created and assigned to the <identifier>.  When the <identifier>
     specification indicates an array, the syntax for specifying the number
     of elements for each dimension can be array[<nElements>,
     <nElements2>,...] or array[<nElements>][<nElements2>]...  The maximum
     number of elements per dimension is 4096.  The maximum number of
     dimensions is limited only by available memory.

     ^b<initializer>^b is the optional assignment of a value to a new private
     variable.  An array cannot be given values with an <initializer>.  An
     <initializer> for a private variable consists of the inline assignment
     operator (:=) followed by any valid CA-Clipper expression including a
     literal array.  If no explicit <initializer> is specified, the variable
     is initialized to NIL.  In the case of an array, each element is
     initialized to NIL.

     You can create, and optionally, initialize a list of variables and
     arrays with one PRIVATE statement, if the definitions are separated by
     commas.

 ^bDescription^b

     The PRIVATE statement creates variables and arrays visible within the
     current and invoked procedures or user-defined functions.  The class of
     variable is said to have dynamic scope.  Private variables exist for the
     duration of the active procedure or until explicitly released with CLEAR
     ALL, CLEAR MEMORY, or RELEASE.  When a private variable or array is
     created, existing and visible private and public variables of the same
     name are hidden until the current procedure or user-defined function
     terminates.

     Attempting to specify a PRIVATE variable that conflicts with a previous
     FIELD, LOCAL, or STATIC declaration of the same name results in a fatal
     compiler error.  This is true regardless of the scope of the
     declaration.

     PRIVATE statements are executable statements and therefore must be
     specified within the body of a procedure or user-defined function and
     must follow all variable declarations: such as FIELD, LOCAL, MEMVAR, and
     STATIC.

     In addition to the PRIVATE statement, private variables are also created
     in two other ways:

     ^b^CFE^b  Assignment to a variable that does not exist or is not visible
        will create a private variable

     ^b^CFE^b  Parameters received using the PARAMETERS statement are created
        as private variables with the same lifetime and visibility

     No more than 2048 private and public variables and arrays can
     simultaneously exist in a single program.

     For more information on variable declarations and scoping, refer to the
     Variables section in the Basic Concepts chapter of the Programming and
     Utilities guide.

 ^bNotes^b

     ^b^CFE  Compatibility:^b The ALL, LIKE, and EXCEPT clauses of the
        PRIVATE statement supported by other dBASE dialects are not supported
        by CA-Clipper.

 ^bExamples^b

     ^b^CFE^b  This example creates two PRIVATE arrays and three other
        PRIVATE variables:

        PRIVATE aArray1[10], aArray2[20], var1, var2, var3

     ^b^CFE^b  This example creates a multidimensional private array using
        each element addressing convention:

        PRIVATE aArray[10][10][10], aArray2[10, 10, 10]

     ^b^CFE^b  This example uses PRIVATE statements to create and initialize
        arrays and variables:

        PRIVATE aArray := { 1, 2, 3, 4 }, ;
              aArray2 := ARRAY(12, 24)
        PRIVATE cChar := SPACE(10), cColor := SETCOLOR()
!seealso: "FIELD" "LOCAL" "MEMVAR" "PARAMETERS" "PUBLIC" "STATIC" 
'------------------------------------------------------------------------------



!short: PROCEDURE       Declare a procedure name and formal parameters
'------------------------------------------------------------------------------
 ^bPROCEDURE^b
 Declare a procedure name and formal parameters
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^b[STATIC] PROCEDURE <idProcedure> [(<idParam list>)]
     ^b   [FIELD <idField list> [IN <idAlias>]
     ^b   [LOCAL <identifier> [[:= <initializer>], ... ]]
     ^b   [MEMVAR <identifier list>]
     ^b   [STATIC <identifier> [[:= <initializer>], ... ]]
     ^b   .
     ^b   . <executable statements>
     ^b   .
     ^b   [RETURN]

 ^bArguments^b

     ^b<idProcedure>^b is the name of the procedure to declare.  Procedure
     names can be any length, but only the first 10 characters are
     significant.  Names can contain any combination of characters, numbers,
     or underscores, but leading underscores are reserved.

     ^b<idParam list>^b is the declaration of one or more parameter
     variables.  Variables specified in this list are declared local.

     ^bSTATIC PROCEDURE^b declares a procedure that can be called only by
     procedures and user-defined functions declared in the same program
     (.prg) file.

     ^bFIELD^b declares a list of identifiers, <idField list>, to use as
     field names whenever encountered.  If the IN clause is specified,
     referring to the declared name, <idAlias>, is a reference to the
     appropriate work area of the specified database.

     ^bLOCAL^b declares and optionally initializes a list of variables or
     arrays whose visibility and lifetime is the current procedure.

     ^b<identifier>, <identifier list>^b is a label or labels used as
     variable or array names.  If the <identifier> is followed by square
     brackets ([ ]), it is created as an array.  If the <identifier> is an
     array, the syntax for specifying the number of elements for each
     dimension can be array[<nElements>, <nElements2>,...] or
     array[<nElements>][<nElements2>]...  The maximum number of elements per
     dimension is 4096.  The maximum number of dimensions per array is
     limited only by available memory.

     ^b<initializer>^b is the value to which an optional inline assignment
     sets the <identifier> variable, essentially, the assignment operator,
     (:=), followed by any valid CA-Clipper expression, including a literal
     array.  If no <initializer> is specified, variables are initialized to
     NIL.  In the case of arrays, all element are initialized to NIL.

     ^bMEMVAR^b declares a list of identifiers, <identifier list>, to use as
     private or public memory variables or arrays whenever encountered.

     ^bSTATIC^b declares and, optionally, initializes a list of variables or
     arrays whose visibility is the current procedure and whose lifetime is
     the duration of the program.

     ^bRETURN^b passes control back to the calling procedure or user-defined
     function.  If a RETURN is not specified, control passes back to the
     calling routine when the procedure definitions ends.  In all cases, the
     compiler terminates the procedure definition when it encounters another
     PROCEDURE statement, FUNCTION statement, or end of file character.

 ^bDescription^b

     The PROCEDURE statement declares a procedure and an optional list of
     local variables to receive parameters passed from a calling routine.  A
     procedure is a subprogram comprised of a set of declarations and
     statements executed whenever you refer to <idProcedure> followed by an
     open and close parentheses pair or with the DO statement.  A procedure
     definition begins with a PROCEDURE statement and ends with the next
     PROCEDURE statement, FUNCTION statement, or end of file.

     Procedures that encapsulate computational blocks of code to provide
     readability and modularity, isolate change, and help manage complexity.

     A procedure in CA-Clipper is the same as a user-defined function, with
     the exception that it always returns NIL.  Each procedure must begin
     with a PROCEDURE statement and may optionally contain a RETURN statement
     to return control to the calling procedure or user-defined function.  A
     RETURN statement, however, is not required.  Procedure declarations
     cannot be nested within other procedure definitions.

     The visibility of procedure names falls into two classes.  Procedures
     that are visible anywhere in a program are referred to as public
     procedures and declared with a PROCEDURE statement.  Procedures that are
     visible only within the current program (.prg) file are referred to as
     static procedures and declared with a STATIC PROCEDURE statement.
     Static procedures have filewide scope.

     Static procedures are quite useful for a number of reasons.  First, they
     limit visibility of a procedure name thereby restricting access to the
     procedure.  Because of this, subsystems defined within a single program
     (.prg) file can provide an access protocol with a series of public
     procedures and conceal the implementation details of the subsystem
     within static procedures and functions.  Second, since the static
     procedure references are resolved at compile time, they preempt
     references to public procedures and functions which are resolved at link
     time.  This assures that, within a program file, a reference to a static
     procedure executes that procedure if there is a name conflict with a
     public procedure or function.

     For more information on procedures, variable declarations, and parameter
     passing, refer to the Basic Concepts chapter in the Programming and
     Utilities guide.

 ^bNotes^b

     ^b^CFE  Calling a procedure:^b There are two ways to call a procedure in
        CA-Clipper.  First, and the preferred way, is the function-calling
        convention.  Here you call the procedure as you would a CA-Clipper
        function, on a line by itself:

        <idProcedure>([<argument list>])

        The second and obsolete way is the command-calling convention using
        the DO...WITH command.  The two methods of calling procedures differ
        only in the default method of passing parameters.  The
        function-calling convention passes variables by value as a default
        whereas the command-calling convention passes them by reference as a
        default.

        A procedure can also be called as an aliased expression if it is
        prefaced with an alias and invoked using the function-calling
        convention, like this:

        <idAlias> ->(<idProcedure>(<argument list>))

        When called as an aliased expression, the work area associated with
        <idAlias> is selected, the procedure is executed, then the original
        work area is reselected.  Like an expression or function, an aliased
        procedure can be specified on a line by itself.

        A procedure in CA-Clipper may call itself recursively.  This means
        you can call a procedure in the same procedure definition.

     ^b^CFE  Parameters:^b Procedures like user-defined functions can receive
        parameters passed from a calling procedure, user-defined function, or
        the DOS command line.  A parameter is a place for a value or
        reference.  In CA-Clipper, there are two ways to receive parameters:
        a list of local variable names can be declared as a part of the
        PROCEDURE declaration (referred to as formal parameters) or a list of
        private variables can be specified in a separate  PARAMETERS
        statement.  Note that you cannot mix a declaration of formal
        parameters with a PARAMETERS statement.  Attempting this will cause a
        fatal compiler error.

        Procedures receive parameters in the order passed.  In CA-Clipper,
        the number of parameters need not match the number of arguments
        passed.  Arguments can be skipped or left off the end of the argument
        list.  A parameter not receiving a value or reference is initialized
        to NIL.  If arguments are specified, PCOUNT() returns the position of
        the last argument passed.

        Parameters specified in a procedure can receive arguments passed by
        value or by reference.  The default method for expressions and
        variables depends on the calling convention.  With the function-
        calling convention, the default passing method for expressions and
        variables is by value.  This includes variables containing references
        to arrays and objects.  With the command-calling convention, the
        default method for passing variables is by reference, except for
        field variables which are always passed by value.  Whenever a field
        variable is passed, it must be specified enclosed in parentheses
        unless declared with the FIELD statement.  Failure to do so will
        generate a runtime error.

 ^bExamples^b

     ^b^CFE^b  This example shows a skeleton of a typical CA-Clipper
        procedure that uses lexical variables:

        PROCEDURE Skeleton( cName, cClassRoom, nBones, ;
                            nJoints )
           LOCAL nCrossBones, aOnHand := {"skull", ;
                                          "metacarpals"}
           STATIC nCounter := 0
           .
           . <executable statements>
           .
           RETURN

     ^b^CFE^b  This example determines whether an argument was skipped by
        comparing the parameter to NIL:

        PROCEDURE MyProc( param1, param2, param3 )
           IF param2 != NIL
              param2 := "default value"
           ENDIF
           .
           . <statements>
           .
           RETURN

     ^b^CFE^b  This example invokes the procedure, UpdateAmount(), as an
        aliased expression:

        USE Invoices NEW
        USE Customer NEW
        Invoices->(UpdateAmount(Amount + Amount * nInterest))
!seealso: "FUNCTION" "LOCAL" c52g_001.ngo:"PCOUNT()" "PRIVATE" "RETURN" "STATIC" 
'------------------------------------------------------------------------------



!short: PUBLIC          Create and initialize public memory variables and arrays
'------------------------------------------------------------------------------
 ^bPUBLIC^b
 Create and initialize public memory variables and arrays
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bPUBLIC <identifier> [[:= <initializer>], ... ]

 ^bArguments^b

     ^b<identifier>^b is the name of a public variable or array to create.
     If the <identifier> is followed by square brackets ([ ]), it is created
     as an array.  If the <identifier> is an array, the syntax for specifying
     the number of elements for each dimension can be array[<nElements>,
     <nElements2>,...] or array[<nElements>][<nElements2>]...  The maximum
     number of elements per dimension is 4096.  The maximum number of
     dimensions per array is limited only by available memory.

     ^b<initializer>^b is the optional assignment of a value to a new public
     variable.  Array identifiers, however, cannot be given values with an
     <initializer>.  An <initializer> for a public variable consists of the
     inline assignment operator (:=) followed by any valid CA-Clipper
     expression including a literal array.  Except for arrays, if no
     <initializer> is specified, public variables are initialized to false
     (.F.).  This is an exception to the general rule that uninitialized
     variables are NIL.  With arrays, however, the initial value of each
     element is NIL.

     A list of variables and arrays can be created and optionally initialized
     with one PUBLIC statement if each definition is separated by a comma.

 ^bDescription^b

     The PUBLIC statement creates variables and arrays visible to all
     procedures and user-defined functions in a program.  Public variables
     exist for the duration of the program or until explicitly released with
     CLEAR ALL, CLEAR MEMORY, or RELEASE.  Declaring private, local, or
     static variables or arrays with the same name as existing public
     variables temporarily hides those public variables until the overriding
     variables are released or are no longer visible.  An attempt to create a
     public variable with the same name as an existing and visible private
     variable is simply ignored (see Notes below for an exception).

     Attempting to specify a PUBLIC variable that conflicts with a previous
     FIELD, LOCAL, or STATIC declaration of the same name results in a fatal
     compiler error.  This is true regardless of the scope of the
     declaration.

     PUBLIC statements are executable statements and therefore must be
     specified within the body of a procedure or user-defined function
     definition.  They also must follow all compile-time declarations: such
     as FIELD, LOCAL, MEMVAR, and STATIC.

     The maximum number of public and private variables and arrays that can
     simultaneously exist in a single program is 2048.

     For more information on variable declarations and scoping, refer to the
     Variables section in the Basic Concepts chapter of the Programming and
     Utilities guide.

 ^bNotes^b

     ^b^CFE  PUBLIC Clipper:^b To include CA-Clipper extensions in a program
        and still allow the program to run under dBASE III PLUS, the special
        public variable, Clipper, is initialized to true (.T.) when created
        PUBLIC.

     ^b^CFE  Public array name conflicts with existing private variables:^b
        The statement, PUBLIC x[10], will not create the public array x if
        there is already a private or public variable x.  It will, however,
        destroy the contents of the existing x, replacing it with a reference
        to a ten element array.

 ^bExamples^b

     ^b^CFE^b  This example creates two PUBLIC arrays and one PUBLIC
        variable:

        PUBLIC aArray1[10, 10], var2
        PUBLIC aArray2[20][10]

     ^b^CFE^b  The following PUBLIC statements create variables and
        initialize them with values:

        PUBLIC cString := SPACE(10), cColor := SETCOLOR()
        PUBLIC aArray := {1, 2, 3}, aArray2 := ARRAY(12, 24)
!seealso: "LOCAL" "MEMVAR" "PARAMETERS" "PRIVATE" "STATIC" 
'------------------------------------------------------------------------------



!short: REQUEST         Declare a module request list                               ^r^CEA^r
'------------------------------------------------------------------------------
 ^bREQUEST^b
 Declare a module request list
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bREQUEST <idModule list>

 ^bArguments^b

     ^b<idModule list>^b is the list of modules that will be linked into the
     current executable (.EXE) file.

 ^bDescription^b

     REQUEST is a declaration statement that defines a list of module
     identifiers to the linker.  Like all other declaration statements, a
     REQUEST statement must be specified before any executable statements in
     either the program file, or a procedure or user-defined function
     definition.

     During the compilation of CA-Clipper source code, all explicit
     references to procedures and user-defined functions are made to the
     linker.  In some instances, within a source file, there may be no
     references made to procedure or user-defined function names until
     runtime.  REQUEST resolves this situation by forcing the named
     procedures or user-defined functions to be linked even if they are not
     explicitly referenced in the source file.  This is important in several
     instances:

     ^b^CFE^b  Procedures, user-defined functions, or formats referenced with
        macro expressions or variables

     ^b^CFE^b  Procedures and user-defined functions used in REPORT and LABEL
        FORMs and not referenced in the source code

     ^b^CFE^b  User-defined functions used in index keys and not referenced
        in the source code

     ^b^CFE^b  ACHOICE(), DBEDIT(), or MEMOEDIT() user functions

     ^b^CFE^b  Initialization procedures declared with the INIT PROCEDURE
        statement

     ^b^CFE^b  Exit procedures declared with the EXIT PROCEDURE statement

     To group common REQUESTs together, place them in a header file and then
     #include the header file into each program file (.prg) that might
     indirectly use them.

 ^bExamples^b

     ^b^CFE^b  This example shows a typical header file consisting of common
        REQUESTs for REPORT FORMs:

        // Request.ch

        REQUEST HARDCR
        REQUEST TONE
        REQUEST MEMOTRAN
        REQUEST STRTRAN
!seealso: "ANNOUNCE" "EXIT PROCEDURE" "EXTERNAL*" "INIT PROCEDURE" 
'------------------------------------------------------------------------------



!short: RETURN          Terminate a procedure, user-defined function, or program
'------------------------------------------------------------------------------
 ^bRETURN^b
 Terminate a procedure, user-defined function, or program
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bRETURN [<exp>]

 ^bArguments^b

     ^b<exp>^b is an expression of any type that evaluates to the return
     value for user-defined functions.  If a user-defined function terminates
     without executing a RETURN statement, the return value is NIL.

 ^bDescription^b

     RETURN terminates a procedure, user-defined function, or program by
     returning control to either the calling procedure or user-defined
     function.  When RETURN executes in the highest level procedure, control
     passes to the operating system.  All private variables created and local
     variables declared in the current procedure or user-defined function are
     released when control returns to the calling procedure.

     There can be more than one RETURN in a procedure or user-defined
     function.  A procedure or user-defined function need not, however, end
     with a RETURN.  Since user-defined functions must return values, each
     must contain at least one RETURN statement with an argument.

     ^bNote: ^b A procedure or user-defined function definition is terminated
     by a PROCEDURE statement, a FUNCTION statement, or end of file but not
     by a RETURN statement

 ^bNotes^b

     ^b^CFE  Arrays:^b Since array is a data type like any other data type,
        instances of array type are really values like character strings, and
        therefore, can be RETURNed from a user-defined function.

     ^b^CFE  RETURN TO MASTER:^b CA-Clipper does not support RETURN TO MASTER
        or any other form of RETURN specifying the level of the call to
        return to.  You can, however, simulate these operations with BEGIN
        SEQUENCE...END.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate the general form of the RETURN
        statement in a procedure and in a user-defined function:

        PROCEDURE <idProcedure>
           //
           <statements>...
           //
           RETURN

        FUNCTION <idFunction>
           //
           <statements>...
           //
           RETURN <expReturn>

     ^b^CFE^b  This example returns an array, created in a user-defined
        function, to a calling procedure or user-defined function:

        FUNCTION PassArrayBack
           PRIVATE aArray[10][10]
           aArray[1][1] = "myString"
           RETURN aArray
!seealso: "BEGIN SEQUENCE" "FUNCTION" "PROCEDURE" "PUBLIC" c52g_002.ngo:"QUIT" 
'------------------------------------------------------------------------------



!short: STATIC          Declare and initialize static variables and arrays
'------------------------------------------------------------------------------
 ^bSTATIC^b
 Declare and initialize static variables and arrays
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSTATIC <identifier> [[:= <initializer>], ... ]

 ^bArguments^b

     ^b<identifier>^b is the name of the variable or array to declare static.
     If the <identifier> is followed by square brackets ([ ]), it is created
     as an array.  If the <identifier> is an array, the syntax for specifying
     the number of elements for each dimension can be array[<nElements>,
     <nElements2>,...] or array[<nElements>] [<nElements2>]...  The maximum
     number of elements per dimension is 4096.  The maximum number of
     dimensions is limited only by available memory.

     ^b<initializer>^b is the optional assignment of a value to a new static
     variable.  An <initializer> for a static variable consists of the inline
     assignment operator (:=) followed by a compile-time constant expression
     consisting entirely of constants and operators or a literal array.  If
     no explicit <initializer> is specified, the variable is given an initial
     value of NIL.  In the case of an array, each element is NIL.  Array
     identifiers cannot be given values with an <initializer>.

     ^bNote: ^b The macro operator (&) cannot be used in a STATIC declaration
     statement.

 ^bDescription^b

     The STATIC statement declares variables and arrays that have a lifetime
     of the entire program but are only visible within the entity that
     creates them.  Static variables are visible only within a procedure or
     user-defined function if declared after a PROCEDURE or FUNCTION
     statement.  Static variables are visible to all procedures and functions
     in a program file (.prg) (i.e., have filewide scope) if they are
     declared before the first procedure or user-defined function definition
     in the file.  Use the /N compiler option to compile a program with
     filewide variable scoping.

     All static variables in a program are created when the program is first
     invoked, and all values specified in a static <initializer> are assigned
     to the variable before the beginning of program execution.

     Declarations of static variables within a procedure or user-defined
     function must occur before any executable statement including PRIVATE,
     PUBLIC, and PARAMETERS.  If a variable of the same name is declared
     FIELD, LOCAL, or MEMVAR within the body of a procedure or user-defined
     function, a compiler error occurs and no object file (.OBJ) is
     generated.

     The maximum number of static variables in a program is limited only by
     available memory.

 ^bNotes^b

     ^b^CFE  Inspecting static variables within the Debugger:^b To access
        static variable names within The CA-Clipper Debugger, you must
        compile program files (.prg) using the /B option so that static
        variable information is included in the object file (.OBJ).

     ^b^CFE  Macro expressions:^b You may not refer to static variables
        within macro expressions or variables.  If a static variable is
        referred to within a macro expression or variable, a private or
        public variable of the same name will be accessed instead.  If no
        such variable exists, a runtime error will be generated.

     ^b^CFE  Memory files:^b Static variables cannot be SAVED to or RESTOREd
        from memory files (.mem).

     ^b^CFE  Type of a static local variable:^b Since TYPE() uses the macro
        operator (&) to evaluate its argument, you cannot use TYPE() to
        determine the type of a local or static variable or an expression
        containing a local or static variable reference.  The VALTYPE()
        function provides this facility by evaluating the function argument
        and returning the data type of its return value.

 ^bExamples^b

     ^b^CFE^b  This example declares static variables both with and without
        initializers:

        STATIC aArray1[20, 10], aArray2[20][10]
        STATIC cVar, cVar2
        STATIC cString := "my string", var
        STATIC aArray := {1, 2, 3}

     ^b^CFE^b  This example manipulates a static variable within a user-defined
        function.  In this example, a count variable increments itself each
        time the function is called:

        FUNCTION MyCounter( nNewValue )
           STATIC nCounter := 0      // Initial value assigned once
           IF nNewValue != NIL
              nCounter:= nNewValue   // New value for nCounter
           ELSE
              nCounter++             // Increment nCounter
           ENDIF
           RETURN nCounter

     ^b^CFE^b  This example demonstrates a static variable declaration that
        has filewide scope.  In this code fragment, aArray is visible to both
        procedures that follow the declaration:

        STATIC aArray := {1, 2, 3, 4}

        FUNCTION One
           ? aArray[1]               // Result: 1
           RETURN NIL

        FUNCTION Two
           ? aArray[3]               // Result: 3
           RETURN NIL
!seealso: "FUNCTION" "LOCAL" "PARAMETERS" "PRIVATE" "PROCEDURE" "PUBLIC" 
'------------------------------------------------------------------------------



