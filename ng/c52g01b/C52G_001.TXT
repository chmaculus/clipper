!short: AADD()          Add a new element to the end of an array
'------------------------------------------------------------------------------
 ^bAADD()^b
 Add a new element to the end of an array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bAADD(<aTarget>, <expValue>) --> Value

 ^bArguments^b

     ^b<aTarget>^b is the array to add a new element to.

     ^b<expValue>^b is the value assigned to the new element.

 ^bReturns^b

     AADD() evaluates <expValue> and returns its value.  If <expValue> is not
     specified, AADD() returns NIL.

 ^bDescription^b

     AADD() is an array function that increases the actual length of the
     target array by one.  The newly created array element is assigned the
     value specified by <expValue>.

     AADD() is used to dynamically grow an array.  It is useful for building
     dynamic lists or queues.  A good example of this is the GetList array
     used by the GET system to hold Get objects.  After a READ or CLEAR GETS,
     GetList becomes an empty array.  Each time you execute an @...GET
     command, the GET system uses AADD() to add a new element to the end of
     the GetList array, and then assigns a new Get object to the new element.

     AADD() is similar to ASIZE() but only adds one element at a time;
     ASIZE() can grow or shrink an array to a specified size.  AADD(),
     however, has the advantage that it can assign a value to the new
     element, while ASIZE() cannot.  AADD() may also seem similar to AINS(),
     but they are different:  AINS() moves elements within an array, but it
     does not change the array's length.

     ^bNote: ^b If <expValue> is another array, the new element in the target
     array will contain a reference to the array specified by <expValue>.

 ^bExamples^b

     ^b^CFE^b  These examples demonstrate the effects of multiple invocations
        of AADD() to an array:

        aArray := {}               // Result: aArray is an empty array
        AADD(aArray, 5)            // Result: aArray is { 5 }
        AADD(aArray, 10)           // Result: aArray is { 5, 10 }
        AADD(aArray, { 12, 10 })   // Result: aArray is
                                   // { 5, 10, { 12, 10 } }

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "AINS()" "ASIZE()" 
'------------------------------------------------------------------------------



!short: ABS()           Return the absolute value of a numeric expression
'------------------------------------------------------------------------------
 ^bABS()^b
 Return the absolute value of a numeric expression
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bABS(<nExp>) --> nPositive

 ^bArguments^b

     ^b<nExp>^b is the numeric expression to evaluate.

 ^bReturns^b

     ABS() returns a number representing the absolute value of its argument.
     The return value is a positive number or zero.

 ^bDescription^b

     ABS() is a numeric function that determines the magnitude of a numeric
     value independent of its sign.  It lets you, for example, obtain the
     difference between two numbers as a positive value without knowing in
     advance which of the two is larger.

     As a formalism, ABS(x) is defined in terms of its argument, x, as
     follows: if x >= 0, ABS(x) returns x; otherwise, ABS(x) returns the
     negation of x.

 ^bExamples^b

     ^b^CFE^b  These examples show typical results from ABS():

        nNum1 := 100
        nNum2 := 150
        ? nNum1 - nNum2                // Result: -50
        ? ABS(nNum1 - nNum2)           // Result: 50
        ? ABS(nNum2 - nNum1)           // Result: 50
        ? ABS(-12)                     // Result: 12
        ? ABS(0)                       // Result: 0

 ^bFiles:^b  Library is CLIPPER.LIB.

!seealso: 
'------------------------------------------------------------------------------



!short: ACHOICE()       Execute a pop-up menu
'------------------------------------------------------------------------------
 ^bACHOICE()^b
 Execute a pop-up menu
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bACHOICE(<nTop>, <nLeft>, <nBottom>, <nRight>,
     ^b   <acMenuItems>,
     ^b   [<alSelectableItems> | <lSelectableItems>],
     ^b   [<cUserFunction>],
     ^b   [<nInitialItem>],
     ^b   [<nWindowRow>]) --> nPosition

 ^bArguments^b

     ^b<nTop>, <nLeft>^b and ^b<nBottom>, <nRight>^b are the upper left and lower
     right window coordinates.  Row values can range from zero to MAXROW()
     and column values can range from zero to MAXCOL().

     ^b<acMenuItems>^b is an array of character strings to display as the
     menu items.  The individual menu items are later identified by their
     numeric positions in this array.

     ^b<alSelectableItems>^b is a parallel array of logical values--one
     element for each item in <acMenuItems>--that specify the selectable menu
     items.  Elements can be logical values or character strings.  ACHOICE()
     will not permit a null string and stops displaying if it encounters one.
     If the element is a character string, it is evaluated as a macro
     expression which should evaluate to a logical data type.  In either
     case, a value of false (.F.) means that the corresponding menu item is
     not available, and a value of true (.T.) means that it is available.  If
     you specify <lSelectableItems> instead of an array, false (.F.) makes
     all menu items unavailable and true (.T.) makes all menu items
     available.  By default, all menu items are available for selection.

     ^b<cUserFunction>^b is the name of a user-defined function that executes
     when an unrecognizable key is pressed.  Specify the function name as a
     character expression without parentheses or arguments.  Note that the
     behavior of ACHOICE() is affected by the presence of this argument.
     Refer to the discussion below for further information.

     ^b<nInitialItem>^b is the position in the <acMenuItems> array of the
     item that will be highlighted when the menu is initially displayed.  If
     you specify an unavailable menu item or no argument at all, the initial
     menu item is the first selectable item in the array.

     ^b<nWindowRow>^b is the window row number on which the initial menu item
     will appear.  Row numbering begins with zero.  By default, the initial
     menu item appears as close to the top of the window as possible, without
     leaving any empty rows at the bottom.  Thus, if there are enough menu
     items following the initial one to fill up the window, the initial form
     will appear on the first row (row zero) of the menu.  This function
     argument is used to control the initial menu appearance when there are
     more menu items than will fit in the window.

     As with all functions, optional arguments are omitted by using a comma
     instead of the actual argument.

 ^bReturns^b

     ACHOICE() returns the numeric position in the <acMenuItems> array of the
     menu item selected.  If the selection process is aborted, ACHOICE()
     returns zero.

 ^bDescription^b

     ACHOICE() is a user interface function that can create various kinds of
     pop-up menus.  Each menu uses an array of character strings as menu
     items and a parallel array of logical values to determine whether items
     are selectable.  When you invoke ACHOICE(), the list of menu items is
     displayed within the specified window coordinates.  When the user
     presses Return, the current item is selected, and ACHOICE() returns the
     position of the menu item in <acMenuItems>.  When the user presses Esc,
     ACHOICE() aborts and returns zero.

     The menu items scroll if the number of items in <acMenuItems> exceeds
     the number of rows in the menu window, and the user attempts to move the
     highlight beyond the top or bottom of the menu window.  Note that the
     highlight does not wrap when you reach the top or bottom of the list of
     items.  Pressing the first letter does, however, wrap the highlight
     within the set of items whose first letter matches the key you press.

     ^b^CFE  Navigating the menu:^b ACHOICE() has two modes depending on
        whether the <cUserFunction> argument is specified.  If it is not
        specified the following navigation keys are active:

        ^bACHOICE() Keys (No User Function)^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bKey            Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        Uparrow        Go to previous item
        Dnarrow        Go to next item
        Home           Go to first item in menu
        End            Go to last item in menu
        Ctrl-Home      Go to first item in window
        Ctrl-End       Go to last item in window
        PgUp           Go to previous page
        PgDn           Go to next page
        Ctrl-PgUp      Go to the first item in menu
        Ctrl-PgDn      Go to last item in menu
        Return         Select current item
        Esc            Abort selection
        Leftarrow      Abort selection
        Rightarrow     Abort selection
        First Letter   Go to next item beginning with first letter
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^b^CFE  Color:^b Menu items are displayed in standard color, the
        highlight in enhanced color, and the unavailable items in the
        unselected color.  For example, the following color statement:

        SETCOLOR("W+/N, BG+/B, , , W/N")

        displays a menu that is bright white on black, the highlight is
        bright cyan on blue, and the unavailable menu items are dim white on
        black.

     ^b^CFE  User function:^b Like the other user interface functions,
        ACHOICE() supports a user function.  The user function is specified
        when you want to nest ACHOICE() invocations to create hierarchical
        menus or to redefine keys.

        When a user function is specified, ACHOICE() processes only a limited
        set of keys automatically.  These are listed in the table below.  All
        other keys generate a key exception which passes control to the user
        function for handling.  Control is also passed to the user function
        when ACHOICE() goes idle (i.e., when there are no more keys to
        process).

        ^bACHOICE() Keys (User Function Specified)^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bKey            Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        Uparrow        Go to previous item
        Dnarrow        Go to next item
        Ctrl-Home      Go to first item in window
        Ctrl-End       Go to last item in window
        PgUp           Go to previous page
        PgDn           Go to next page
        Ctrl-PgUp      Go to the first item in menu
        Ctrl-PgDn      Go to last item in menu
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

        When ACHOICE() executes the user function, it automatically passes
        the following three parameters:

        ^b-^b  The current ACHOICE() mode

        ^b-^b  The current element in the array of items

        ^b-^b  The relative row position within the menu window

        The mode indicates the current state of ACHOICE() depending on the
        key pressed and the action taken by ACHOICE() prior to executing the
        user function.  The mode parameter has the following possible values:

        ^bACHOICE() Modes^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bMode    Achoice.ch     Description^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0       AC_IDLE        Idle
        1       AC_HITTOP      Attempt to cursor past top of list
        2       AC_HITBOTTOM   Attempt to cursor past bottom of list
        3       AC_EXCEPT      Keystroke exceptions
        4       AC_NOITEM      No selectable items
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

        After the user function has performed whatever operations are
        appropriate to the ACHOICE() mode or LASTKEY(), it must RETURN a
        value requesting ACHOICE() to perform an operation from the following
        set of actions:

        ^bACHOICE() User Function Return Values^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bValue   Achoice.ch     Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0       AC_ABORT       Abort selection
        1       AC_SELECT      Make selection
        2       AC_CONT        Continue ACHOICE()
        3       AC_GOTO        Go to the next item whose first character
                               matches the key pressed
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bExamples^b

     ^b^CFE^b  This example uses two literal arrays to specify the menu items
        and selection criteria.  After the menu is displayed and the user
        makes a selection, the name of the selected menu item is displayed:

        acMenuItems := {"One", "Two", "-------", "Three"}
        alSelectableItems := {.T., .T., .F., .T.}
        nPosition := ACHOICE(10, 10, 12, 15, acMenuItems,;
                             alSelectableItems)
        ? acMenuItems[nPosition]

     ^b^CFE^b  This example declares an array of menu items and supplies a
        user-defined function which displays a message with each highlighted
        choice:

        #include "achoice.ch"
        #include "inkey.ch"

        PROCEDURE Main()

           LOCAL acMenuItems[4], cUserFunction, nRetVal
           LOCAL nKey, nPos

           acMenuItems[1] := "Add"
           acMenuItems[2] := "Edit"
           acMenuItems[3] := "Delete"
           acMenuItems[4] := "Update"

           CLS

           nPos := ACHOICE( 10, 10, 13, 15, acMenuItems,;
                           .T., "cUserFunction" )
           DO CASE
           CASE nPos == 1
              //  Put ADD routine here
           CASE nPos == 2
              //  Put EDIT routine here
           CASE nPos == 3
              //  Put DELETE routine here
           CASE nPos ==4
              //  Put UPDATE routine here
           ENDCASE

        RETURN


        FUNCTION cUserFunction( nMode, nCurElement, nRowPos )

           LOCAL nRetVal := AC_CONT     // Default, Continue
           LOCAL nKey := LASTKEY()

           DO CASE
        // After all pending keys are processed, display message
           CASE nMode == AC_IDLE
           DO CASE
              CASE nCurElement == 1
                 @ 22, 5 SAY " Adding   "
              CASE nCurElement == 2
                 @ 22, 5 SAY " Editing  "
              CASE nCurElement ==  3
                 @ 22, 5 SAY " Deleting "
              CASE nCurElement ==  4
                 @ 22, 5 SAY " Updating "
           ENDCASE

              nRetVal := AC_CONT            // Continue ACHOICE()

           CASE nMode == AC_HITTOP          // Attempt to go past Top
              TONE( 100, 3 )
           CASE nMode == AC_HITBOTTOM       // Attempt to go past
                                            // Bottom
              TONE( 100, 3 )

           CASE nMode == AC_EXCEPT          // Key Exception
              DO CASE
              CASE nKey == K_RETURN         // If RETURN key, select
                 nRetVal := AC_SELECT
              CASE nKey == K_ESC            // If ESCAPE key, abort
                 nRetVal := AC_ABORT
              OTHERWISE
                    nRetVal := AC_GOTO      // Otherwise, go to item
              ENDCASE
           ENDCASE

        RETURN nRetVal

     ^b^CFE^b  The next example declares the arrays, specifies a selection
        condition for one of the menu items, and supplies a user function:

        EXTERNAL UPDATED
        //
        FUNCTION MyMenu
           LOCAL acMenuItems[4], alSelectableItems[4],;
                  cUserFunction := "DoIt"
           //
           acMenuItems[1] := "Add Record"
           acMenuItems[2] := "Edit Record"
           acMenuItems[3] := "Delete Record"
           acMenuItems[4] := "Update Record"
           //
           alSelectableItems[1] := .T.
           alSelectableItems[2] := .T.
           alSelectableItems[3] := .T.
           alSelectableItems[4] := "!UPDATED()"
           // Selection condition

           RETURN ACHOICE(10, 10, 12, 15, acMenuItems,;
              alSelectableItems, cUserFunction)

     ^b^CFE^b  This example uses two arrays to specify menu items and
        corresponding action blocks.  After the menu is displayed and the
        user makes a selection, the ACHOICE() return value is used to
        determine which action block of the aActionItems array is evaluated:

        PROCEDURE Main()
           LOCAL nChoice
           LOCAL aMenuItems := { "Add Record   ", ;
                                 "Edit Record  ", ;
                                 "Delete Record", ;
                                 "Update Record"   }

           LOCAL aActionItems := { {|| AddFunc()  }, ;
                                   {|| EditFunc() }, ;
                                   {|| DelFunc()  }, ;
                                   {|| UpdFunc()  }  }

           nChoice := ACHOICE( 10, 10, 13, 22, aMenuItems )

           IF nChoice == 0
              QUIT      // ESCAPE was pressed
           ENDIF

           EVAL( aActionItems[nChoice] )

        RETURN

 ^bFiles:^b  Library is EXTEND.LIB, header files are Achoice.ch and Inkey.ch.
!seealso: c52g_002.ngo:"MENU TO" "SETCOLOR()" c52g_009.ngo:"Inkey codes" 
'------------------------------------------------------------------------------



!short: ACLONE()        Duplicate a nested or multidimensional array
'------------------------------------------------------------------------------
 ^bACLONE()^b
 Duplicate a nested or multidimensional array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bACLONE(<aSource>) --> aDuplicate

 ^bArguments^b

     ^b<aSource>^b is the array to duplicate.

 ^bReturns^b

     ACLONE() returns a duplicate of <aSource>.

 ^bDescription^b

     ACLONE() is an array function that creates a complete duplicate of the
     <aSource> array.  If <aSource> contains subarrays, ACLONE() creates
     matching subarrays and fills them with copies of the values in the
     <aSource> subarrays.  ACLONE() is similar to ACOPY(), but ACOPY() does
     not duplicate nested arrays.

 ^bExamples^b

     ^b^CFE^b  This example creates an array then duplicates it using
        ACLONE().  The first array is then altered, but the duplicate copy is
        unaffected:

        LOCAL aOne, aTwo
        aOne := { 1, 2, 3 }        // Result: aOne is {1, 2, 3}
        aTwo := ACLONE(aOne)       // Result: aTwo is {1, 2, 3}
        aOne[1] := 99              // Result: aOne is {99, 2, 3}
                                   // aTwo is still {1, 2, 3}

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ACOPY()" "ADEL()" "AINS()" "ASIZE()" 
'------------------------------------------------------------------------------



!short: ACOPY()         Copy elements from one array to another
'------------------------------------------------------------------------------
 ^bACOPY()^b
 Copy elements from one array to another
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bACOPY(<aSource>, <aTarget>,
     ^b   [<nStart>], [<nCount>], [<nTargetPos>]) --> aTarget

 ^bArguments^b

     ^b<aSource>^b is the array to copy elements from.

     ^b<aTarget>^b is the array to copy elements to.

     ^b<nStart>^b is the starting element position in the <aSource> array.
     If not specified, the default value is one.

     ^b<nCount>^b is the number of elements to copy from the <aSource> array
     beginning at the <nStart> position.  If <nCount> is not specified, all
     elements in <aSource> beginning with the starting element are copied.

     ^b<nTargetPos>^b is the starting element position in the <aTarget> array
     to receive elements from <aSource>.  If not specified, the default value
     is one.

 ^bReturns^b

     ACOPY() returns a reference to the target array, <aTarget>.

 ^bDescription^b

     ACOPY() is an array function that copies elements from the <aSource>
     array to the <aTarget> array.  The <aTarget> array must already exist
     and be large enough to hold the copied elements.  If the <aSource> array
     has more elements, some elements will not be copied.

     ACOPY() copies values of all data types including NIL and code blocks.
     If an element of the <aSource> array is a subarray, the corresponding
     element in the <aTarget> array will contain a reference to the subarray.
     Thus, ACOPY() will not create a complete duplicate of a multidimensional
     array.  To do this, use the ACLONE() function.

 ^bExamples^b

     ^b^CFE^b  This example creates two arrays, each filled with a value.
        The first two elements from the source array are then copied into the
        target array:

        LOCAL nCount := 2, nStart := 1, aOne, aTwo
        aOne := { 1, 1, 1 }
        aTwo := { 2, 2, 2 }
        ACOPY(aOne, aTwo, nStart, nCount)
        // Result: aTwo is now { 1, 1, 2 }

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ACLONE()" "ADEL()" "AEVAL()" "AFILL()" "AINS()" "ASORT()" 
'------------------------------------------------------------------------------



!short: ADEL()          Delete an array element
'------------------------------------------------------------------------------
 ^bADEL()^b
 Delete an array element
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bADEL(<aTarget>, <nPosition>) --> aTarget

 ^bArguments^b

     ^b<aTarget>^b is the array to delete an element from.

     ^b<nPosition>^b is the position of the target array element to delete.

 ^bReturns^b

     ADEL() returns a reference to the target array, <aTarget>.

 ^bDescription^b

     ADEL() is an array function that deletes an element from an array.  The
     contents of the specified array element is lost, and all elements from
     that position to the end of the array are shifted up one element.  The
     last element in the array becomes NIL.

     ^bWarning! ^b CA-Clipper implements multidimensional arrays by nesting
     arrays within other arrays.  If the <aTarget> array is a
     multidimensional array, ADEL() can delete an entire subarray specified
     by <nPosition>, causing <aTarget> to describe an array with a different
     structure than the original.

 ^bExamples^b

     ^b^CFE^b  This example creates a constant array of three elements, and
        then deletes the second element.  The third element is moved up one
        position, and the new third element is assigned a NIL:

        LOCAL aArray
        aArray := { 1, 2, 3 }      // Result: aArray is
                                   // now { 1, 2, 3 }
        ADEL(aArray, 2)            // Result: aArray is
                                   // now { 1, 3, NIL }

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ACOPY()" "AFILL()" "AINS()" 
'------------------------------------------------------------------------------



!short: ADIR()*         Fill a series of arrays with directory information
'------------------------------------------------------------------------------
 ^bADIR()*^b
 Fill a series of arrays with directory information
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bADIR([<cFilespec>],
     ^b   [<aFilenames>],
     ^b   [<aSizes>],
     ^b   [<aDates>],
     ^b   [<aTimes>],
     ^b   [<aAttributes>]) --> nFiles

 ^bArguments^b

     ^b<cFilespec>^b is the path specification of files to include in the
     scan of the DEFAULT directory.  It is a standard file specification that
     can include the wildcard characters * and ?, as well as a drive and path
     reference.  If omitted, the default specification is *.*.

     ^b<aFilenames>^b is the array to fill with the filenames matching
     <cFilespec>.  Each element contains the filename and extension as a
     character string in all uppercase letters.

     ^b<aSizes>^b is the array to fill with the sizes of the corresponding
     files in the <aFilenames> array.  Each element is numeric data type.

     ^b<aDates>^b is the array to fill with the dates of the corresponding
     files in the <aFilenames> array.  Each element is a date data type.

     ^b<aTimes>^b is the array to fill with the times of the corresponding
     files in the <aFilenames> array.  Each element filled contains a
     character string of the form: hh:mm:ss.

     ^b<aAttributes>^b is the array to fill with attributes of the
     corresponding files in the <aFilenames> array.  Each element is a
     character string.  If <aAttributes> is specified, hidden, system, and
     directory files are included as well as normal files.  If <aAttributes>
     is not specified only normal files are included.

 ^bReturns^b

     ADIR() returns the number of files matching the directory skeleton
     described in <cFilespec>.

 ^bDescription^b

     ADIR() is an array function that performs two basic operations.  First,
     it returns the number of files matching the file specification.  Second,
     it fills a series of arrays with filenames, sizes, dates, times, and
     attributes.

     ADIR() is a compatibility function and therefore not recommended.  It is
     superseded by the DIRECTORY() function which returns all file
     information in a multidimensional array.

 ^bNotes^b

     ^b^CFE  Directories:^b If you specify the <aAttributes> argument and
        <cFilespec> is *.*, directories will be included in <aFilenames>.  In
        the <aAttributes> array, directories are indicated with an attribute
        value of "D."  If ADIR() is executed within a subdirectory, the first
        two entries of the <aFilenames> array are "." and "..", the parent
        and current directory aliases.  The date and time of last update are
        reported for directories, but the size of a directory is always zero.

 ^bExamples^b

     ^b^CFE^b  This example creates an array to hold the names of all (.txt)
        files in the current DEFAULT directory, then uses AEVAL() to list
        them to the console:

        LOCAL aFiles[ADIR("*.TXT")]
        ADIR("*.TXT", aFiles)
        AEVAL(aFiles, { |element| QOUT(element) })

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "ACHOICE()" "AEVAL()" "ASCAN()" "ASORT()" "DIRECTORY()" "LEN()" 
'------------------------------------------------------------------------------



!short: AEVAL()         Execute a code block for each element in an array
'------------------------------------------------------------------------------
 ^bAEVAL()^b
 Execute a code block for each element in an array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bAEVAL(<aArray>, <bBlock>,
     ^b   [<nStart>], [<nCount>]) --> aArray

 ^bArguments^b

     ^b<aArray>^b is the array to traverse.

     ^b<bBlock>^b is a code block to execute for each element encountered.

     ^b<nStart>^b is the starting element.  If not specified, the default is
     element one.

     ^b<nCount>^b is the number of elements to process from <nStart>.  If not
     specified, the default is all elements to the end of the array.

 ^bReturns^b

     AEVAL() returns a reference to <aArray>.

 ^bDescription^b

     AEVAL() is an array function that evaluates a code block once for each
     element of an array, passing the element value and the element index as
     block parameters.  The return value of the block is ignored.  All
     elements in <aArray> are processed unless either the <nStart> or the
     <nCount> argument is specified.

     AEVAL() makes no assumptions about the contents of the array elements it
     is passing to the block.  It is assumed that the supplied block knows
     what type of data will be in each element.

     AEVAL() is similar to DBEVAL() which applies a block to each record of a
     database file.  Like DBEVAL(), AEVAL() can be used as a primitive for
     the construction of iteration commands for both simple and complex array
     structures.

     Refer to the Code Blocks section in the Basic Concepts chapter of the
     Programming and Utilities guide for more information on the theory and
     syntax of code blocks.

 ^bExamples^b

     ^b^CFE^b  This example uses AEVAL() to display an array of filenames and
        file sizes returned from the DIRECTORY() function:

        #include "Directry.ch"
        //
        LOCAL aFiles := DIRECTORY("*.dbf"), nTotal := 0
        AEVAL(aFiles,;
           { | aDbfFile |;
              QOUT(PADR(aDbfFile[F_NAME], 10), aDbfFile[F_SIZE]),;
              nTotal += aDbfFile[F_SIZE]);
           } )
        //
        ?
        ? "Total Bytes:", nTotal

     ^b^CFE^b  This example uses AEVAL() to build a list consisting of
        selected items from a multidimensional array:

        #include "Directry.ch"
        //
        LOCAL aFiles := DIRECTORY("*.dbf"), aNames := {}
        AEVAL(aFiles,;
           { | file | AADD(aNames, file[F_NAME]) };
           )

     ^b^CFE^b  This example changes the contents of the array element
        depending on a condition.  Notice the use of the codeblock
        parameters: */

        LOCAL aArray[6]
        AFILL(aArray,"old")
        AEVAL(aArray,;
        {|cValue,nIndex| IF(cValue == "old",;
                         aArray[nIndex] := "new",)})

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBEVAL()" "EVAL()" "QOUT()" 
'------------------------------------------------------------------------------



!short: AFIELDS()*      Fill arrays with the structure of the current database file
'------------------------------------------------------------------------------
 ^bAFIELDS()*^b
 Fill arrays with the structure of the current database file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bAFIELDS([<aFieldNames>], [<aTypes>],
     ^b   [<aWidths>], [<aDecimals>]) --> nFields

 ^bArguments^b

     ^b<aFieldNames>^b is the array to fill with field names.  Each element
     is a character string.

     ^b<aTypes>^b is the array to fill with the type of fields in
     <aFieldNames>.  Each element is a character string.

     ^b<aWidths>^b is the array to fill with the widths of fields in
     <aFieldNames>.  Each element is numeric data type.

     ^b<aDecimals>^b is the array to fill with the number of decimals defined
     for fields in <aFieldNames>.  Each element is numeric data type.  If the
     field type is not numeric, the <aDecimals> element is zero.

 ^bReturns^b

     AFIELDS() returns the number of fields or the length of the shortest
     array argument, whichever is less.  If no arguments are specified, or if
     there is no file in USE in the current work area, AFIELDS() returns
     zero.

 ^bDescription^b

     AFIELDS() is an array function that fills a series of arrays (structure
     attribute arrays) with the structure of a database file currently open,
     one element in each array per field.  AFIELDS() works like ADIR(),
     filling a series of existing arrays with information.  To use AFIELDS(),
     you must first create the arrays to hold the database structure
     information, each with the same number of elements as the number of
     fields (i.e. FCOUNT()).  Once the structure attribute arrays are
     created, you can then invoke AFIELDS() to fill the structure arrays with
     information about each field.

     By default, AFIELDS() operates on the currently selected work area.  It
     can  operate on an unselected work area if you specify it within an
     aliased expression (see example below).

     AFIELDS() is a compatibility function and therefore is not recommended.
     It is superseded by DBSTRUCT() which does not require the existence of
     any arrays prior to invocation and returns a multidimensional array
     containing the current database file structure.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates how AFIELDS() and ACHOICE() can be
        used together to create a fields picklist:

        USE Sales NEW
        PRIVATE aFieldNames[FCOUNT()]
        AFIELDS(aFieldNames)
        @ 1, 0 TO 10, 10 DOUBLE
        nChoice := ACHOICE(2, 1, 9, 9, aFieldNames)
        @ 12, 0 SAY IF(nChoice != 0, aFieldNames[nChoice],;
                       "None selected")
        RETURN

     ^b^CFE^b  This example uses AFIELDS() with an aliased expression to fill
        arrays with the structure of Sales.dbf, open in an unselected work
        area:

        LOCAL aFieldNames, aTypes, aWidths, aDecimals
        USE Sales NEW
        USE Customer NEW
        //
        aFieldNames := Sales->(ARRAY(FCOUNT()))
        aTypes := Sales->(ARRAY(FCOUNT()))
        aWidths := Sales->(ARRAY(FCOUNT()))
        aDecimals := Sales->(ARRAY(FCOUNT()))
        //
        Sales->(AFIELDS(aFieldNames, aTypes, ;
                aWidths, aDecimals))

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "ACHOICE()" "ADIR()*" "AEVAL()" "ASCAN()" "DBCREATE()" "DBSTRUCT()" 
'------------------------------------------------------------------------------



!short: AFILL()         Fill an array with a specified value
'------------------------------------------------------------------------------
 ^bAFILL()^b
 Fill an array with a specified value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bAFILL(<aTarget>, <expValue>,
     ^b   [<nStart>], [<nCount>]) --> aTarget

 ^bArguments^b

     ^b<aTarget>^b is the array to fill.

     ^b<expValue>^b is the value to place in each array element.  It can be
     an expression of any valid data type.

     ^b<nStart>^b is the position of the first element to fill.  If this
     argument is omitted, the default value is one.

     ^b<nCount>^b is the number of elements to fill starting with element
     <nStart>.  If this argument is omitted, elements are filled from the
     starting element position to the end of the array.

 ^bReturns^b

     AFILL() returns a reference to <aTarget>.

 ^bDescription^b

     AFILL() is an array function that fills the specified array with a
     single value of any data type (including an array, code block, or NIL)
     by assigning <expValue> to each array element in the specified range.

     ^bWarning! ^b AFILL() cannot be used to fill multidimensional arrays.
     CA-Clipper implements multidimensional arrays by nesting arrays within
     other arrays.  Using AFILL() with a multidimensional array will
     overwrite subarrays used for the other dimensions of the array.

 ^bExamples^b

     ^b^CFE^b  This example, creates a three-element array.  The array is
        then filled with the logical value, (.F.).  Finally, elements in
        positions two and three are assigned the new value of true (.T.):

        LOCAL aLogic[3]
        // Result: aLogic is { NIL, NIL, NIL }

        AFILL(aLogic, .F.)
        // Result: aLogic is { .F., .F., .F. }

        AFILL(aLogic, .T., 2, 2)
        // Result: aLogic is { .F., .T., .T. }

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "AADD()" "AEVAL()" "DBSTRUCT()" "DIRECTORY()" 
'------------------------------------------------------------------------------



!short: AINS()          Insert a NIL element into an array
'------------------------------------------------------------------------------
 ^bAINS()^b
 Insert a NIL element into an array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bAINS(<aTarget>, <nPosition>) --> aTarget

 ^bArguments^b

     ^b<aTarget>^b is the array into which a new element will be inserted.

     ^b<nPosition>^b is the position at which the new element will be
     inserted.

 ^bReturns^b

     AINS() returns a reference to the target array, <aTarget>.

 ^bDescription^b

     AINS() is an array function that inserts a new element into a specified
     array.  The newly inserted element is NIL data type until a new value is
     assigned to it.  After the insertion, the last element in the array is
     discarded, and all elements after the new element are shifted down one
     position.

     ^bWarning! ^b AINS() must be used carefully with multidimensional
     arrays.  Multidimensional arrays in CA-Clipper are implemented by
     nesting arrays within other arrays.  Using AINS() in a multidimensional
     array discards the last element in the specified target array which, if
     it is an array element, will cause one or more dimensions to be lost.
     To insert a new dimension into an array, first add a new element to the
     end of the array using AADD() or ASIZE() before using AINS().

 ^bExamples^b

     ^b^CFE^b  This example demonstrates the effect of using AINS() on an
        array:

        LOCAL aArray
        aArray := { 1, 2, 3 }      // Result: aArray is
                                   // now { 1, 2, 3 }
        AINS(aArray, 2)            // Result: aArray is
                                   // now { 1, NIL, 2 }

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "AADD()" "ACOPY()" "ADEL()" "AEVAL()" "AFILL()" "ASIZE()" 
'------------------------------------------------------------------------------



!short: ALERT()         Display a simple modal dialog box
'------------------------------------------------------------------------------
 ^bALERT()^b
 Display a simple modal dialog box
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bALERT( <cMessage>, [<aOptions>] ) --> nChoice

 ^bArguments^b

     ^b<cMessage>^b is the message text displayed, centered, in the alert
     box.  If the message contains one or more semicolons, the text after the
     semicolons is centered on succeeding lines in the dialog box.

     ^b<aOptions>^b defines a list of up to 4 possible responses to the
     dialog box.

 ^bReturns^b

     ALERT() returns a numeric value indicating which option was chosen.  If
     the Esc key is pressed, the value returned is zero.

 ^bDescription^b

     The ALERT() function creates a simple modal dialog.  It is useful in
     error handlers and other "pause" functions.  The user can respond by
     moving a highlight bar and pressing the Return or SpaceBar keys, or by
     pressing the key corresponding to the first letter of the option.  If
     <aOptions> is not supplied, a single "Ok" option is presented.

     ALERT() is sensitive to the presence or absence of the CA-Clipper
     full-screen I/O system.  If the full-screen system is not present,
     ALERT() uses standard I/O to display the message and options tty-style
     (i.e. 80-column, without word wrap, each line ended with carriage
     return/linefeed).

 ^bExamples^b

     ^b^CFE^b  This example demonstrates use of an alert dialog box .  First,
        the array of options is defined, the ALERT() function gets the user's
        selection, and finally, the user's choice is handled with a DO
        CASE...ENDCASE control structure:

        #define AL_SAVE     1
        #define AL_CANCEL   2
        #define AL_CONT     3

        // Define an array of options
        aOptions := {"Save", "Don't Save", "Continue"}

        // Display the dialog box and get the user's selection
        nChoice  := ALERT("File has changed...", aOptions)

        // Handle the user's request
        DO CASE
        CASE nChoice == AL_SAVE
           ? "Save"
        CASE nChoice == AL_CANCEL
           ? "Don't Save"
        CASE nChoice == AL_CONT
           ? "Continue"
        OTHERWISE
           ? "Escape"
        ENDCASE
        //
        RETURN

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"@...PROMPT" c52g_002.ngo:"MENU TO" 
'------------------------------------------------------------------------------



!short: ALIAS()         Return a specified work area alias
'------------------------------------------------------------------------------
 ^bALIAS()^b
 Return a specified work area alias
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bALIAS([<nWorkArea>]) --> cAlias

 ^bArguments^b

     ^b<nWorkArea>^b is any work area number.

 ^bReturns^b

     ALIAS() returns the alias of the specified work area as a character
     string.  If <nWorkArea> is not specified, the alias of the current work
     area is returned.  If there is no database file in USE for the specified
     work area, ALIAS() returns a null string ("").

 ^bDescription^b

     ALIAS() is a database function that determines the alias of a specified
     work area.  An alias is the name assigned to a work area when a database
     file is USEd.  The actual name assigned is either the name of the
     database file, or a name explicitly assigned with the ALIAS clause of
     the USE command.

     ALIAS() is the inverse of the SELECT() function.  ALIAS() returns the
     alias name given the work area number, and SELECT() returns the work
     area number given the alias name.

     ^b^CFE^b  This example returns the name of the previously selected work
        area:

        USE File1 NEW ALIAS Test1
        nOldArea := SELECT()
        USE File2 NEW ALIAS Test2
        ? ALIAS( nOldArea )            // Returns Test1

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"SELECT" "SELECT()" c52g_002.ngo:"USE" 
'------------------------------------------------------------------------------



!short: ALLTRIM()       Remove leading and trailing spaces from a character string
'------------------------------------------------------------------------------
 ^bALLTRIM()^b
 Remove leading and trailing spaces from a character string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bALLTRIM(<cString>) --> cTrimString

 ^bArguments^b

     ^b<cString>^b is the character expression to trim.

 ^bReturns^b

     ALLTRIM() returns a character string with leading and trailing spaces
     removed.

 ^bDescription^b

     ALLTRIM() is a character function that removes both leading and trailing
     spaces from a string.  It is related to LTRIM() and RTRIM() which remove
     leading and trailing spaces, respectively.  The inverse of ALLTRIM(),
     LTRIM(), and RTRIM() are the PADC(), PADL(), and PADR() functions which
     center, left-justify, or right-justify, character strings by padding
     them with fill characters.

 ^bExamples^b

     ^b^CFE^b  This example creates a string with both leading and trailing
        spaces, and then trims them with ALLTRIM():

        cString := SPACE(10) + "string" + SPACE(10)
        ? LEN(cString)                     // Result: 26
        ? LEN(ALLTRIM(cString))            // Result: 6

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "LTRIM()" "PAD()" "RTRIM()" 
'------------------------------------------------------------------------------



!short: ALTD()          Invoke The CA-Clipper Debugger
'------------------------------------------------------------------------------
 ^bALTD()^b
 Invoke The CA-Clipper Debugger
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bALTD([<nAction>]) --> NIL

 ^bArguments^b

     ^b<nAction>^b defines what action ALTD() performs when invoked.  The
     following is a complete list of <nAction> values and their actions:

     ^bALTD() Actions^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bArgument     Action^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     None         Invokes the Debugger if it is enabled
     0            Disables Alt-D
     1            Enables Alt-D
     Other        No action
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bReturns^b

     ALTD() always returns NIL.

 ^bDescription^b

     ALTD() performs differently depending on its argument as shown in the
     table above.  For more information on using the Debugger, refer to The
     CA-Clipper Debugger chapter in the Programming and Utilities guide.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a series of manifest constants that
        can be used as arguments for ALTD() before invoking the debugger
        programmatically:

        #define ALTD_DISABLE   0
        #define ALTD_ENABLE    1
        //
        ALTD(ALTD_ENABLE)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"SET ESCAPE" "SETCANCEL()" 
'------------------------------------------------------------------------------



!short: ARRAY()         Create an uninitialized array of specified length
'------------------------------------------------------------------------------
 ^bARRAY()^b
 Create an uninitialized array of specified length
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bARRAY(<nElements> [, <nElements>...]) --> aArray

 ^bArguments^b

     ^b<nElements>^b is the number of elements in the specified dimension.
     The maximum number of elements in a dimension is 4096.  Arrays in
     CA-Clipper can have an unlimited number of dimensions.

 ^bReturns^b

     ARRAY() returns an array of specified dimensions.

 ^bDescription^b

     ARRAY() is an array function that returns an uninitialized array with
     the specified number of elements and dimensions.  If more than one
     <nElements> argument is specified, a multidimensional array is created
     with the number of dimensions equal to the number of <nElements>
     arguments specified.  Any <nElements> that is itself an array creates a
     nested array.

     In CA-Clipper, there are several ways to create an array.  You can
     declare an array using a declaration statement such as LOCAL or STATIC;
     you can create an array using a PRIVATE or PUBLIC statement; you can
     assign a literal array to an existing variable; or you can use the
     ARRAY() function.  ARRAY() has the advantage that it can create arrays
     within expressions or code blocks.

 ^bExamples^b

     ^b^CFE^b  This example creates a one-dimensional array of five elements
        using the ARRAY() function, and then shows the equivalent action by
        assigning a literal array of NIL values:

        aArray := ARRAY(5)
        aArray := { NIL, NIL, NIL, NIL, NIL }

     ^b^CFE^b  This example shows three different statements which create the
        same multidimensional array:

        aArray := ARRAY(3, 2)
        aArray := { {NIL, NIL}, {NIL, NIL}, {NIL, NIL} }
        aArray := { ARRAY(2), ARRAY(2), ARRAY(2) }

     ^b^CFE^b  This example creates a nested, multidimensional array:

        aArray := ARRAY(3, {NIL,NIL})

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "AADD()" "ADEL()" "AFILL()" "AINS()" c52g_004.ngo:"LOCAL" c52g_004.ngo:"PUBLIC" c52g_004.ngo:"STATIC" 
'------------------------------------------------------------------------------



!short: ASC()           Convert a character to its ASCII value
'------------------------------------------------------------------------------
 ^bASC()^b
 Convert a character to its ASCII value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bASC(<cExp>) --> nCode

 ^bArguments^b

     ^b<cExp>^b is the character expression to convert to a number.

 ^bReturns^b

     ASC() returns an integer numeric value in the range of zero to 255,
     representing the ASCII value of <cExp>.

 ^bDescription^b

     ASC() is a character conversion function that returns the ASCII value of
     the leftmost character in a character string.  ASC() is used primarily
     on expressions requiring numeric calculations on the ASCII value of a
     character.  CHR() and ASC() are inverse functions.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate various results of ASC():

        ? ASC("A")                    // Result: 65
        ? ASC("Apple")                // Result: 65
        ? ASC("a")                    // Result: 97
        ? ASC("Z") - ASC("A")         // Result: 25
        ? ASC("")                     // Result: 0

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CHR()" "INKEY()" "STR()" "VAL()" c52g_009.ngo:"Inkey codes" 
'------------------------------------------------------------------------------



!short: ASCAN()         Scan an array for a value or until block returns true (.T.)
'------------------------------------------------------------------------------
 ^bASCAN()^b
 Scan an array for a value or until a block returns true (.T.)
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bASCAN(<aTarget>, <expSearch>,
     ^b   [<nStart>], [<nCount>]) --> nStoppedAt

 ^bArguments^b

     ^b<aTarget>^b is the array to scan.

     ^b<expSearch>^b is either a simple value to scan for, or a code block.
     If <expSearch> is a simple value it can be character, date, logical, or
     numeric type.

     ^b<nStart>^b is the starting element of the scan.  If this argument is
     not specified, the default starting position is one.

     ^b<nCount>^b is the number of elements to scan from the starting
     position.  If this argument is not specified, all elements from the
     starting element to the end of the array are scanned.

 ^bReturns^b

     ASCAN() returns a numeric value representing the array position of the
     last element scanned.  If <expSearch> is a simple value, ASCAN() returns
     the position of the first matching element, or zero if a match is not
     found.  If <expSearch> is a code block, ASCAN() returns the position of
     the element where the block returned true (.T.).

 ^bDescription^b

     ASCAN() is an array function that scans an array for a specified value
     and operates like SEEK when searching for a simple value.  The
     <expSearch> value is compared to the target array element beginning with
     the leftmost character in the target element and proceeding until there
     are no more characters left in <expSearch>.  If there is no match,
     ASCAN() proceeds to the next element in the array.

     Since ASCAN() uses the equal operator (=) for comparisons, it is
     sensitive to the status of EXACT.  If EXACT is ON, the target array
     element must be exactly equal to the result of <expSearch> to match.

     If the <expSearch> argument is a code block, ASCAN() scans the <aTarget>
     array executing the block for each element accessed.  As each element is
     encountered, ASCAN() passes the element's value as an argument to the
     code block, and then performs an EVAL() on the block.  The scanning
     operation stops when the code block returns true (.T.), or ASCAN()
     reaches the last element in the array.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates scanning a three-element array using
        simple values and a code block as search criteria.  The code block
        criteria shows how to perform a case-insensitive search:

        aArray := { "Tom", "Mary", "Sue" }
        ? ASCAN(aArray, "Mary")             // Result: 2
        ? ASCAN(aArray, "mary")             // Result: 0
        //
        ? ASCAN(aArray, { |x| UPPER(x) ;
              == "MARY" })                  // Result: 2

     ^b^CFE^b  This example demonstrates scanning for multiple instances of a
        search argument after a match is found:

        LOCAL aArray := { "Tom", "Mary", "Sue",;
                           "Mary" }, nStart := 1
        //
        // Get last array element position
        nAtEnd := LEN(aArray)
        DO WHILE (nPos := ASCAN(aArray, "Mary", ;
                     nStart)) > 0
           ? nPos, aArray[nPos]
           //
           // Get new starting position and test
           // boundary condition
           IF (nStart := ++nPos) > nAtEnd
              EXIT
           ENDIF
        ENDDO

     ^b^CFE^b  This example scans a two dimensional array using a code block.
        Note that the parameter aVal in the code block is an array:

        LOCAL aArr:={}
        CLS
        AADD(aArr,{"one","two"})
        AADD(aArr,{"three","four"})
        AADD(aArr,{"five","six"})
        ? ASCAN(aArr, {|aVal| aVal[2] == "four"})         // Returns 2

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "AEVAL()" "EVAL()" 
'------------------------------------------------------------------------------



!short: ASIZE()         Grow or shrink an array
'------------------------------------------------------------------------------
 ^bASIZE()^b
 Grow or shrink an array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bASIZE(<aTarget>, <nLength>) --> aTarget

 ^bArguments^b

     ^b<aTarget>^b is the array to grow or shrink.

     ^b<nLength>^b is the new size of the array.

 ^bReturns^b

     ASIZE() returns a reference to the target array, <aTarget>.

 ^bDescription^b

     ASIZE() is an array function that changes the actual length of the
     <aTarget> array.  The array is shortened or lengthened to match the
     specified length.  If the array is shortened, elements at the end of the
     array are lost.  If the array is lengthened, new elements are added to
     the end of the array and assigned NIL.

     ASIZE() is similar to AADD() which adds a single new element to the end
     of an array and optionally assigns a new value at the same time.  Note
     that ASIZE() is different from AINS() and ADEL(), which do not actually
     change the array's length.

 ^bExamples^b

     ^b^CFE^b  These examples demonstrate adding new elements and deleting
        existing elements:

        aArray := { 1 }          // Result: aArray is { 1 }
        ASIZE(aArray, 3)         // Result: aArray is { 1, NIL, NIL }
        ASIZE(aArray, 1)         // Result: aArray is { 1 }

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "AADD()" "ADEL()" "AFILL()" "AINS()" 
'------------------------------------------------------------------------------



!short: ASORT()         Sort an array
'------------------------------------------------------------------------------
 ^bASORT()^b
 Sort an array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bASORT(<aTarget>, [<nStart>],
     ^b   [<nCount>], [<bOrder>]) --> aTarget

 ^bArguments^b

     ^b<aTarget>^b is the array to sort.

     ^b<nStart>^b is the first element of the sort.  If not specified, the
     default starting position is one.

     ^b<nCount>^b is the number of elements to sort.  If not specified, all
     elements in the array beginning with the starting element are sorted.

     ^b<bOrder>^b is an optional code block used to determine sorting order.
     If not specified, the default order is ascending.

 ^bReturns^b

     ASORT() returns a reference to the <aTarget> array.

 ^bDescription^b

     ASORT() is an array function that sorts all or part of an array
     containing elements of a single data type.  Data types that can be
     sorted include character, date, logical, and numeric.

     If the <bOrder> argument is not specified, the default order is
     ascending.  Elements with low values are sorted toward the top of the
     array (first element), while elements with high values are sorted toward
     the bottom of the array (last element).

     If the <bOrder> block argument is specified, it is used to determine the
     sorting order.  Each time the block is evaluated, two elements from the
     target array are passed as block parameters.  The block must return true
     (.T.) if the elements are in sorted order.  This facility can be used to
     create a descending or dictionary order sort.  See the examples below.

     When sorted, character strings are ordered in ASCII sequence; logical
     values are sorted with false (.F.) as the low value; date values are
     sorted chronologically; and numeric values are sorted by magnitude.

     ^bNote: ^b Because CA-Clipper implements multidimensional arrays by
     nesting subarrays within other arrays, ASORT() will not directly sort a
     multidimensional array.  To sort a nested array, you must supply a code
     block which properly handles the subarrays.

 ^bExamples^b

     ^b^CFE^b  This example creates an array of five unsorted elements, sorts
        the array in ascending order, then sorts the array in descending
        order using a code block:

        aArray := { 3, 5, 1, 2, 4 }
        ASORT(aArray)
        // Result: { 1, 2, 3, 4, 5 }

        ASORT(aArray,,, { |x, y| x > y })
        // Result: { 5, 4, 3, 2, 1 }

     ^b^CFE^b  This example sorts an array of character strings in ascending
        order, independent of case.  It does this by using a code block that
        converts the elements to uppercase before they are compared:

        aArray := { "Fred", Kate", "ALVIN", "friend" }
        ASORT(aArray,,, { |x, y| UPPER(x) < UPPER(y) })

     ^b^CFE^b  This example sorts a nested array using the second element of
        each subarray:

        aKids := { {"Mary", 14}, {"Joe", 23}, {"Art", 16} }
        aSortKids := ASORT(aKids,,, { |x, y| x[2] < y[2] })

        Result:

        { {"Mary", 14}, {"Art", 16}, {"Joe", 23} }

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "ASCAN()" "EVAL()" c52g_002.ngo:"SORT" 
'------------------------------------------------------------------------------



!short: AT()            Return the position of a substring within a character string
'------------------------------------------------------------------------------
 ^bAT()^b
 Return the position of a substring within a character string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bAT(<cSearch>, <cTarget>) --> nPosition

 ^bArguments^b

     ^b<cSearch>^b is the character substring for which to search.

     ^b<cTarget>^b is the character string to search.

 ^bReturns^b

     AT() returns the position of the first instance of <cSearch> within
     <cTarget> as an integer numeric value.  If <cSearch> is not found, AT()
     returns zero.

 ^bDescription^b

     AT() is a character function used to determine the position of the first
     occurrence of a character substring within another string.  If you only
     need to know whether a substring exists within another string, use the $
     operator.  To find the last instance of a substring within a string, use
     RAT().

 ^bExamples^b

     ^b^CFE^b  These examples show typical use of AT():

        ? AT("a", "abcde")                  // Result: 1
        ? AT("bcd", "abcde")                // Result: 2
        ? AT("a", "bcde")                   // Result: 0

     ^b^CFE^b  This example splits a character string based on the position
        of a comma within the target string:

        cTarget := "Langtree, Lilly"
        ? SUBSTR(cTarget, 1, AT(",", cTarget) - 1)
        // Result: Langtree

        ? SUBSTR(cTarget, AT(",", cTarget) + 2)
        // Result: Lilly

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "RAT()" "STRTRAN()" "SUBSTR()" 
'------------------------------------------------------------------------------



!short: ATAIL()         Return the highest numbered element of an array
'------------------------------------------------------------------------------
 ^bATAIL()^b
 Return the highest numbered element of an array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bATAIL(<aArray>) --> Element

 ^bArguments^b

     ^b<aArray>^b is the array.

 ^bReturns^b

     ATAIL() returns either a value or a reference to an array or object.
     The array is not changed.

 ^bDescription^b

     ATAIL() is an array function that returns the highest numbered element
     of an array.  It can be used in applications as shorthand for
     <aArray>[LEN(<aArray>)] when you need to obtain the last element of an
     array.

 ^bExamples^b

     ^b^CFE^b  The following example creates a literal array and returns that
        last element of the array:

        aArray := {"a", "b", "c", "d"}
        ? ATAIL(aArray)                     // Result: d

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "LEN()" 
'------------------------------------------------------------------------------



!short: BIN2I()         Convert a 16-bit signed integer to a numeric value
'------------------------------------------------------------------------------
 ^bBIN2I()^b
 Convert a 16-bit signed integer to a numeric value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBIN2I(<cSignedInt>) --> nNumber

 ^bArguments^b

     ^b<cSignedInt>^b is a character string in the form of a 16-bit signed
     integer number--least significant byte first.  Only the first two
     characters are used by the function; all others are ignored.

 ^bReturns^b

     BIN2I() returns an integer numeric value.

 ^bDescription^b

     BIN2I() is a low-level file function that is used with FREAD() to
     convert a two-byte character string formatted as a signed integer to a
     CA-Clipper numeric data type.  This is most useful when you are reading
     foreign file types and want to read numeric data in its native format.

 ^bExamples^b

     ^b^CFE^b  This example opens a database file using low-level file
        functions and reads the date of last update (bytes 1-3).  The result
        is the same as with LUPDATE():

        #include "Fileio.ch"
        //
        nHandle := FOPEN("Sales.dbf", FO_READ)
        //
        // Point to byte 1 in the file
        FSEEK(nHandle, 1, FS_SET)
        //
        // Read date of last update
        nYear := BIN2I(FREADSTR(nHandle, 1) + CHR(0))
        nMonth := BIN2I(FREADSTR(nHandle, 1) + CHR(0))
        nDay := BIN2I(FREADSTR(nHandle, 1) + CHR(0))
        //
        ? LTRIM(STR(nMonth)), LTRIM(STR(nDay)), LTRIM(STR(nYear))
        FCLOSE(nHandle)

 ^bFiles:^b  Library is EXTEND.LIB, source file is SOURCE\SAMPLE\EXAMPLEA.ASM.
!seealso: "BIN2L()" "BIN2W()" "FREAD()" "FREADSTR()" "I2BIN()" "L2BIN()" 
'------------------------------------------------------------------------------



!short: BIN2L()         Convert a 32-bit signed integer to a numeric value
'------------------------------------------------------------------------------
 ^bBIN2L()^b
 Convert a 32-bit signed integer to a numeric value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBIN2L(<cSignedInt>) --> nNumber

 ^bArguments^b

     ^b<cSignedInt>^b is a character string in the form of a 32-bit signed
     integer number--least significant byte first.  Only the first four
     characters are used by the function; all others are ignored.

 ^bReturns^b

     BIN2L() returns an integer numeric value.

 ^bDescription^b

     BIN2L() is a low-level file function that is used with FREAD() to
     convert a four-byte character string formatted as a signed integer to a
     CA-Clipper numeric data type.  This is most useful when you are reading
     foreign file types and want to read numeric data in its native format.

 ^bExamples^b

     ^b^CFE^b  This example opens a database file using low-level file
        functions and reads the number of records (bytes 4-7).  The result is
        the same as with LASTREC():

        #include "Fileio.ch"
        //
        nHandle := FOPEN("Sales.dbf", FO_READ)
        // Note:  Sales.dbf contains 84 records
        //
        // Point to byte 4
        FSEEK(nHandle, 4, FS_SET)
        //
        // Read the number of records
        cRecords := SPACE(4)
        FREAD(nHandle, @cRecords, 4)
        //
        ? LTRIM(STR(BIN2L(cRecords)))         // Result: 84
        FCLOSE(nHandle)

 ^bFiles:^b  Library is EXTEND.LIB, source file is SOURCE\SAMPLE\EXAMPLEA.ASM.
!seealso: "BIN2I()" "BIN2W()" "FREAD()" "FREADSTR()" "I2BIN()" "L2BIN()" 
'------------------------------------------------------------------------------



!short: BIN2W()         Convert a 16-bit unsigned integer to a numeric value
'------------------------------------------------------------------------------
 ^bBIN2W()^b
 Convert a 16-bit unsigned integer to a numeric value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBIN2W(<cUnsignedInt>) --> nNumber

 ^bArguments^b

     ^b<cUnsignedInt>^b is a character string in the form of a 16-bit
     unsigned integer number--least significant byte first.  Only the first
     two characters are used by the function; all others are ignored.

 ^bReturns^b

     BIN2W() returns an integer numeric value.

 ^bDescription^b

     BIN2W() is a low-level file function that is used with FREAD() to
     convert a two-byte character string formatted as an unsigned integer to
     a CA-Clipper numeric data type.  This is most useful when you are
     reading from a binary file and want to read data in its native format.

 ^bExamples^b

     ^b^CFE^b  This example opens a database file using low-level file
        functions and reads the number of bytes per record (bytes 10-11).
        The result is the same as with RECSIZE():

        #include "Fileio.ch"
        //
        nHandle := FOPEN("Sales.dbf", FO_READ)
        // Note:  The length of a record in Sales.dbf is 124
        //
        // Point to byte 10, the first record size byte
        FSEEK(nHandle, 10, FS_SET)
        //
        // Read record size
        cRecSize := SPACE(2)
        FREAD(nHandle, @cRecSize, 2)
        //
        ? LTRIM(STR(BIN2W(cRecSize)))            // Result: 124
        FCLOSE(nHandle)

 ^bFiles:^b  Library is EXTEND.LIB, source file is SOURCE\SAMPLE\EXAMPLEA.ASM.
!seealso: "BIN2I()" "BIN2L()" "FREAD()" "FREADSTR()" "I2BIN()" "L2BIN()" 
'------------------------------------------------------------------------------



!short: BOF()           Determine when beginning of file is encountered
'------------------------------------------------------------------------------
 ^bBOF()^b
 Determine when beginning of file is encountered
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBOF() --> lBoundary

 ^bReturns^b

     BOF() returns true (.T.) after an attempt to SKIP backward beyond the
     first logical record in a database file; otherwise, it returns false
     (.F.).  If there is no database file open in the current work area,
     BOF() returns false (.F.).  If the current database file contains no
     records, BOF() returns true (.T.).

 ^bDescription^b

     BOF() is a database function used to test for a boundary condition when
     you are moving the record pointer backward through a database file using
     the SKIP command.  A simple usage example is a descending order record
     list with an ascending order index file.  A more sophisticated example
     is a screen paging routine that pages forward or backward through the
     current database file based on the key the user presses.  When the user
     attempts to page backward, you would use BOF() to test for a beginning
     of file condition before using the SKIP command to move the record
     pointer and repaint the screen.

     Once BOF() is set to true (.T.), it retains its value until there is
     another attempt to move the record pointer.

     By default, BOF() operates on the currently selected work area.  It can
     be made to operate on an unselected work area by specifying it within an
     aliased expression (see example below).

     The SKIP command is the only record movement command that can set BOF()
     to true (.T.).

 ^bExamples^b

     ^b^CFE^b  This example demonstrates BOF() by attempting to move the
        record pointer before the first record:

        USE Sales NEW
        ? RECNO(), BOF()               // Result: 1 .F.
        SKIP -1
        ? RECNO(), BOF()               // Result: 1 .T.

     ^b^CFE^b  This example uses aliased expressions to query the value of
        BOF() in unselected work areas:

        USE Sales NEW
        USE Customer NEW
        USE Invoices NEW
        ? Sales->(BOF()), Customer->(BOF())

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "EOF()" c52g_002.ngo:"SKIP" 
'------------------------------------------------------------------------------



!short: BREAK()         Branch out of a BEGIN SEQUENCE...END construct
'------------------------------------------------------------------------------
 ^bBREAK()^b
 Branch out of a BEGIN SEQUENCE...END construct
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBREAK(<exp>) --> NIL

 ^bArguments^b

     ^b<exp>^b is the value passed to the RECOVER clause, if any.  Note that
     <exp> is not optional.  NIL may be specified if there is no break value.

 ^bReturns^b

     BREAK() always returns NIL.

 ^bDescription^b

     The BREAK() function is identical in functionality to the BREAK
     statement.  The function must be executed during a SEQUENCE.

 ^bExamples^b

     ^b^CFE^b  This example illustrates exiting a SEQUENCE from a code block:

        bSave := ERRORBLOCK( {|x| BREAK(x)} )

        BEGIN SEQUENCE
           .
           .
           .
        RECOVER USING objError
           .
           .
           .
        END

        ERRORBLOCK(bSave)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_004.ngo:"BEGIN SEQUENCE" 
'------------------------------------------------------------------------------



!short: BROWSE()*       Browse records within a window                              ^r^CE4^r
'------------------------------------------------------------------------------
 ^bBROWSE()*^b
 Browse records within a window
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBROWSE([<nTop>], [<nLeft>],
     ^b   [<nBottom>], [<nRight>]) --> lSuccess

 ^bArguments^b

     ^b<nTop>^b, ^b<nLeft>^b, ^b<nBottom>^b, and ^b<nRight>^b define the
     window coordinates.  If not specified, the default window coordinates
     are 1, 0 to MAXROW(), and MAXCOL().

 ^bReturns^b

     BROWSE() returns false (.F.) if there is no database file in use;
     otherwise, it returns true (.T.).

 ^bDescription^b

     BROWSE() is a user interface function that invokes a general purpose
     table-oriented browser and editor for records in the current work area.
     For a list of the navigation keys which are used by BROWSE(), refer to
     the DBEDIT() function.

 ^bNotes^b

     ^b^CFE^b  ^bStatus line:^b BROWSE() supports a status line in the upper
        right corner of the browse window indicating one of the following:

        ^bBROWSE() Status Line Messages^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bMessage   Meaning^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        <new>     Append mode
        <bof>     Top of file
        <delete>  Current record is deleted
        Record    Record number display
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^b^CFE^b  BROWSE() has the following three modes:

        ^b-^b  ^bBrowsing:^b This is the default mode of BROWSE().  Pressing
           any DBEDIT() navigation key moves the highlight to a new column or
           row.

        ^b-^b  ^bField edit:^b Pressing Return on any field enters field edit
           using a GET.  Pressing Return terminates the edit mode, saving the
           changes.  Esc terminates without saving changes.  Since the field
           edit mode uses GET, all navigation and editing keys are READ keys.

        ^b-^b  ^bAppend:^b GOing BOTTOM with Ctrl-PgDn and then pressing
           Dnarrow enters append mode with the indicating message "<new>" on
           the status line.  A new blank record is then inserted.  Pressing
           Uparrow terminates the append mode, saving the new record if data
           has been entered.  If no data has been entered, the new record is
           not saved.

 ^bExamples^b

     ^b^CFE^b  This is an example of browsing a file:

        USE File1 NEW
        BROWSE()

 ^bFiles:^b  Library is EXTEND.LIB, source file is SOURCE\SAMPLE\BROWSE.PRG.
!seealso: "DBEDIT()*" 
'------------------------------------------------------------------------------



!short: CDOW()          Convert a date value to a character day of the week
'------------------------------------------------------------------------------
 ^bCDOW()^b
 Convert a date value to a character day of the week
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCDOW(<dExp>) --> cDayName

 ^bArguments^b

     ^b<dExp>^b is the date value to convert.

 ^bReturns^b

     CDOW() returns the name of the day of the week as a character string.
     The first letter is uppercase and the rest of the string is lowercase.
     For a null date value, CDOW() returns a null string ("").

 ^bDescription^b

     CDOW() is a date conversion function used in formatting date displays
     for reports, labels, and screens.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate CDOW():

        ? DATE()                      // Result: 09/01/90
        ? CDOW(DATE())                // Result: Friday
        ? CDOW(DATE() + 7)            // Result: Friday
        ? CDOW(CTOD("06/12/90"))      // Result: Tuesday

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CTOD()" "DATE()" "DAY()" "DOW()" 
'------------------------------------------------------------------------------



!short: CHR()           Convert an ASCII code to a character value
'------------------------------------------------------------------------------
 ^bCHR()^b
 Convert an ASCII code to a character value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCHR(<nCode>) --> cChar

 ^bArguments^b

     ^b<nCode>^b is an ASCII code in the range of zero to 255.

 ^bReturns^b

     CHR() returns a single character value whose ASCII code is specified by
     <nCode>.

 ^bDescription^b

     CHR() is a numeric conversion function that converts an ASCII code to a
     character.  It is the inverse of ASC().  CHR() serves a number of common
     tasks including:

     ^b^CFE^b  Sending control codes and graphics characters to the screen or
        printer

     ^b^CFE^b  Ringing the bell

     ^b^CFE^b  Converting INKEY() return values to characters

     ^b^CFE^b  Stuffing the keyboard buffer

 ^bNotes^b

     ^b^CFE  The null character:^b CHR(0) has a length of one and is treated
        like any other character.  This lets you send it to any device or
        file, including a database file.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate CHR() with various arguments:

        ? CHR(72)                   // Result: H
        ? CHR(ASC("A") + 32)        // Result: a
        ? CHR(7)                    // Result: bell sounds

     ^b^CFE^b  These lines of code show the difference between a null string
        and the null character:

        ? LEN("")                   // Result: 0
        ? LEN(CHR(0))               // Result: 1

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ASC()" "INKEY()" c52g_009.ngo:"Inkey codes" 
'------------------------------------------------------------------------------



!short: CMONTH()        Convert a date to a character month name
'------------------------------------------------------------------------------
 ^bCMONTH()^b
 Convert a date to a character month name
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCMONTH(<dDate>) --> cMonth

 ^bArguments^b

     ^b<dDate>^b is the date value to convert.

 ^bReturns^b

     CMONTH() returns the name of the month as a character string from a date
     value with the first letter uppercase and the rest of the string
     lowercase.  For a null date value, CMONTH() returns a null string ("").

 ^bDescription^b

     CMONTH() is a date conversion function useful for creating formatted
     date strings that can be used in reports, labels, or screens.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate CMONTH():

        ? CMONTH(DATE())              // Result: September
        ? CMONTH(DATE() + 45)         // Result: October
        ? SUBSTR(CMONTH(DATE()), 1, 3) +;
           STR(DAY(DATE()))           // Result: Sep 1

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CDOW()" "DATE()" "DAY()" "MONTH()" "YEAR()" 
'------------------------------------------------------------------------------



!short: COL()           Return the screen cursor column position
'------------------------------------------------------------------------------
 ^bCOL()^b
 Return the screen cursor column position
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCOL() --> nCol

 ^bReturns^b

     COL() returns an integer numeric value.  The range of the return value
     is zero to MAXCOL().

 ^bDescription^b

     COL() is a screen function that returns the current column position of
     the cursor.  The value of COL() changes whenever the cursor position
     changes on the screen.  Both console and full-screen commands can change
     the cursor position.  In addition, COL() is automatically set to zero
     whenever a CLEAR, CLEAR SCREEN, or CLS command is executed.

     Use COL() to position the cursor to a column relative to the current
     column.  It is generally used in combination with ROW() and all
     variations of the @ command.  In particular, use COL() and ROW() to
     create screen position-independent procedures or functions that pass the
     upper left row and column as parameters.

     If DEVICE is SET TO PRINTER, all the output of @...SAY commands is
     directed to the printer and PROW() and PCOL() are updated instead of
     ROW() and COL().  Use these functions when you need to determine the
     position of the printhead.

 ^bExamples^b

     ^b^CFE^b  This example displays a Customer name beginning at column 10.
        The customer's account status is then displayed to the right of the
        last character of the customer name using COL():

        USE Sales NEW

        CLS
        @ 1, 10 SAY "Customer Name: " + TRIM(Customer)
        @ ROW(), COL() + 1 SAY "Account status: " + Status

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"@...SAY" "MAXCOL()" "PCOL()" "PROW()" "QOUT()" "ROW()" 
'------------------------------------------------------------------------------



!short: COLORSELECT()   Activate attribute in current color settings                ^r^CEA^r
'------------------------------------------------------------------------------
 ^bCOLORSELECT()^b
 Activate attribute in current color settings
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCOLORSELECT(<nColorIndex>) --> NIL

 ^bReturns^b

     Always returns NIL.

 ^bArguments^b

     ^b<nColorIndex>^b is a number corresponding to the oridnal positions in
     the current list of color attributes, as set by SETCOLOR().

 ^bDescription^b

     COLORSELECT() activates the specified color pair from the current list
     of color attributes (established by SETCOLOR()).  Manifest constants for
     <nColorIndex> are defined in COLOR.CH:

     ^bCOLOR.CH constants^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bConstant          Value^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     CLR_STANDARD      0
     CLR_ENHANCED      1
     CLR_BORDER        2
     CLR_BACKGROUND    3
     CLR_UNSELECTED    4
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     COLORSELECT() does not alter the current SET Color setting.

     This table describes the scope of the CA-Clipper color settings affected
     by SETCOLOR():

     ^bColor settings^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bSetting        Scope^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Standard       All screen output commands and functions
     Enhanced       Gets and selection highlights
     Border         Screen border (not supported on EGA and VGA monitors)
     Background     Not supported
     Unselected     Unselected Gets
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bExamples^b

     ^b^CFE^b  This example demonstrates use of COLORSELECT() with the
        COLOR.CH manifest constants:

        USE Sales NEW
        ? SETCOLOR()                  // displays "W/B,N/B,W/N,W/N,W/N"
                                      // in white on blue

        COLORSELECT(CLR_ENHANCED)     // enhanced is active color pair
        ? "I'm black and blue"        // displayed in black on blue
        COLORSELECT(CLR_STANDARD)     // restore standard color

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Color.ch.
!seealso: "SETCOLOR()" 
'------------------------------------------------------------------------------



!short: CTOD()          Convert a date string to a date value
'------------------------------------------------------------------------------
 ^bCTOD()^b
 Convert a date string to a date value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCTOD(<cDate>) --> dDate

 ^bArguments^b

     ^b<cDate>^b is a character string consisting of numbers representing the
     month, day, and year separated by any character other than a number.
     The month, day, and year digits must be specified in accordance with the
     SET DATE format.  If the century digits are not specified, the century
     is determined by the rules of SET EPOCH.

 ^bReturns^b

     CTOD() returns a date value.  If <cDate> is not a valid date, CTOD()
     returns an empty date.

 ^bDescription^b

     CTOD() is a character conversion function that converts a character
     string to a date.  To initialize an empty date for date entry, specify
     <cDate> as a null string (""), SPACE(8), or "  /  /  ".

     CTOD() is used whenever you need a literal date value.  Some examples
     are:

     ^b^CFE^b  Initializing a variable to a date value

     ^b^CFE^b  Specifying a literal date string as an argument of a RANGE
        clause of @...GET

     ^b^CFE^b  Specifying a literal date string in order to perform date
        arithmetic

     ^b^CFE^b  Comparing the result of a date expression to a literal date
        string

     ^b^CFE^b  REPLACEing a date field with a literal date string

     CTOD() is the inverse of DTOC() which converts a date value to a
     character string in the format specified by SET DATE and SET CENTURY.
     DTOS() also converts a date value to a character string in the form
     yyyymmdd.

 ^bExamples^b

     ^b^CFE^b  This example uses CTOD() to initialize two date variables,
        using one as a GET and the other for RANGE validation:

        SET CENTURY ON
        dBegin := CTOD("01-26-1876")
        dCurrent := CTOD("")
        @ 10, 10 SAY "Enter date:" GET dCurrent ;
              RANGE dBegin, DATE()
        READ

     ^b^CFE^b  This example uses CTOD() to create a date value within a FOR
        condition:

        USE Inventory NEW
        REPLACE ALL Inventory->Price WITH ;
           Inventory->Price * 1.1 FOR ;
           Inventory->InvDate < CTOD("10/10/90")

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DATE()" "DTOC()" "DTOS()" c52g_002.ngo:"SET CENTURY" c52g_002.ngo:"SET DATE" c52g_002.ngo:"SET EPOCH" 
'------------------------------------------------------------------------------



!short: CURDIR()        Return the current DOS directory
'------------------------------------------------------------------------------
 ^bCURDIR()^b
 Return the current DOS directory
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCURDIR([<cDrivespec>]) --> cDirectory

 ^bArguments^b

     ^b<cDrivespec>^b specifies the letter of the disk drive to query.  If
     not specified, the default is the current DOS drive.

 ^bReturns^b

     CURDIR() returns the current DOS directory of the drive specified by
     <cDrivespec> as a character string without either leading or trailing
     backslash (\) characters.

     If an error occurs, or the current directory of the specified drive is
     the root directory, CURDIR() returns a null string ("").

 ^bDescription^b

     CURDIR() is an environment function that gives you the name of the
     current DOS directory, ignoring the SET DEFAULT and SET PATH settings.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate various CURDIR() results:

        ? CURDIR("E:")     // Result: null string--root directory
        ? CURDIR("C")      // Result: CLIPPER5\SOURCE
        ? CURDIR("C:")     // Result: CLIPPER5\SOURCE
        ? CURDIR()         // Result: null string--root directory
        ? CURDIR("A")      // Result: null string--drive not ready

     ^b^CFE^b  This example changes the current DOS directory to a new value
        if it does not match a specified directory:

        IF CURDIR("C:") != "CLIPPER5\SOURCE"
           RUN CD \CLIPPER5\SOURCE
        ENDIF

 ^bFiles^b Library is EXTEND.LIB, source file is SOURCE\SAMPLE\EXAMPLEA.ASM.
!seealso: "FILE()" 
'------------------------------------------------------------------------------



!short: DATE()          Return the system date as a date value
'------------------------------------------------------------------------------
 ^bDATE()^b
 Return the system date as a date value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDATE() --> dSystem

 ^bReturns^b

     DATE() returns the system date as a date value.

 ^bDescription^b

     DATE() is a date function that provides a means of initializing memory
     variables to the current date, comparing other date values to the
     current date, and performing date arithmetic relative to the current
     date.

     The display format for dates is controlled by the SET DATE command.  The
     default format is mm/dd/yy.

 ^bExamples^b

     ^b^CFE^b  These examples show the DATE() function used in various ways:

        ? DATE()                 // Result: 09/01/90
        ? DATE() + 30            // Result: 10/01/90
        ? DATE() - 30            // Result: 08/02/90
        dDate := DATE()
        ? CMONTH(dDate)          // Result: September

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CTOD()" "DTOC()" "DTOS()" c52g_002.ngo:"SET CENTURY" c52g_002.ngo:"SET DATE" 
'------------------------------------------------------------------------------



!short: DAY()           Return the day of the month as a numeric value
'------------------------------------------------------------------------------
 ^bDAY()^b
 Return the day of the month as a numeric value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDAY(<dDate>) --> nDay

 ^bArguments^b

     ^b<dDate>^b is a date value to convert.

 ^bReturns^b

     DAY() returns a number in the range of zero to 31 as an integer numeric
     value.  If the month is February, leap years are considered.  If the
     date argument is February 29 and the year is not a leap year, DAY()
     returns zero.  If the date argument is empty, DAY() returns zero.

 ^bDescription^b

     DAY() is a date conversion function used to convert a date value to the
     day of a month.  This function is used in combination with CMONTH() and
     YEAR() to format dates.  In addition, it is often used in various date
     calculations.

 ^bExamples^b

     ^b^CFE^b  These examples show the DAY() function used several ways:

        ? DATE()                       // Result: 09/01/90
        ? DAY(DATE())                  // Result: 1
        ? DAY(DATE()) + 1              // Result: 2
        ? DAY(CTOD(""))                // Result: 0

     ^b^CFE^b  This example uses DAY() in combination with CMONTH() and
        YEAR() to format a date value:

        ? CMONTH(DATE()) + STR(DAY(DATE())) +;
           "," + STR(YEAR(DATE()))     // Result: June 15, 1990

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CDOW()" "CMONTH()" "DOW()" "MONTH()" "STR()" "YEAR()" 
'------------------------------------------------------------------------------



!short: DBAPPEND()      Add a new record
'------------------------------------------------------------------------------
 ^bDBAPPEND()^b
 Add a new record
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBAPPEND() --> NIL

 ^bReturns^b

     DBAPPEND() always returns NIL.

 ^bDescription^b

     DBAPPEND() adds a new record to the database (.dbf) file associated with
     the current work area.  If successfully added, each field in the record
     is set to the empty value for its data type and the new record becomes
     the current record.

     DBAPPEND() performs the same function as the standard APPEND BLANK
     command.  For more information, refer to the APPEND BLANK command.

 ^bNotes^b

     ^b^CFE  Logical records:^b DBAPPEND() does not respect logical
        visibility.  That is, if the record is successfully added, it becomes
        the current record regardless of any index or filter condition.

     ^b^CFE  Network environment:^b For a shared database on a network,
        DBAPPEND() automatically places a record lock on the new record.  If
        the record cannot be locked, it is not added and a recoverable runtime
        error occurs.  The default CA-Clipper error handler handles this error
        by setting the system NETERR() status to true (.T.) and continuing
        execution.  For more information, refer to the Network Programming
        chapter in the Programming and Utilities guide.

 ^bExamples^b

     ^b^CFE^b  The following example appends a blank record, checks for a
        network error and updates the data:

        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        .
        . <statements>
        .
        DBAPPEND()

        IF !NETERR()
           Sales->FirstName := cFirst
           Sales->LastName := cLast
        ELSE
           ? "Append operation failed"
           BREAK
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"APPEND BLANK" 
'------------------------------------------------------------------------------



!short: DBCLEARFIL()    Clear a filter condition
'------------------------------------------------------------------------------
 ^bDBCLEARFILTER()^b
 Clear a filter condition
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCLEARFILTER() --> NIL

 ^bReturns^b

     DBCLEARFILTER() always returns NIL.

 ^bDescription^b

     DBCLEARFILTER() clears the logical filter condition, if any, for the
     current work area.

     DBCLEARFILTER() performs the same function as the standard SET FILTER
     command with no expression specified.  For more information, refer to
     the SET FILTER command.

 ^bNotes^b

     ^b^CFE  Logical records:^b DBCLEARFILTER() affects the logical
        visibility of records in the current work area.  For more
        information, refer to DBSETFILTER() and the SET FILTER command.

 ^bExamples^b

     ^b^CFE^b  The following example sets a filter, LISTs data as filtered
        and then clears the filter:

        USE Employee NEW
        DBSETFILTER( {|| Age < 40}, "Age < 40" )
        LIST Employee->Name
        DBCLEARFILTER()
        DBCLEARFILTER()

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBFILTER()" "DBSETFILTER()" c52g_002.ngo:"SET DELETED" c52g_002.ngo:"SET FILTER" 
'------------------------------------------------------------------------------



!short: DBCLEARIND()    Close all indexes for the current work area
'------------------------------------------------------------------------------
 ^bDBCLEARINDEX()^b
 Close all indexes for the current work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCLEARINDEX() --> NIL

 ^bReturns^b

     DBCLEARINDEX() always returns NIL.

 ^bDescription^b

     DBCLEARINDEX() closes any active indexes for the current work area.  Any
     pending index updates are written and the index files are closed.

     DBCLEARINDEX() performs the same function as the standard SET INDEX
     command with no indexes specified.  For more information, refer to the
     SET INDEX command.

 ^bExamples^b

     ^b^CFE^b  The following example clears index files if any are set:

        cLast := "Winston"
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "FIRSTNAM" )
        DBSETINDEX( "LASTNAME" )
        //
        IF INDEXORD() > 0             // is there an index?
           DBCLEARINDEX()             // clear index files
        ELSE
           COPY TO FILE TEMP SDF      // copy to SDF in natural
        ENDIF                         // order

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBREINDEX()" "DBSETINDEX()" "DBSETORDER()" c52g_002.ngo:"SET INDEX" 
'------------------------------------------------------------------------------



!short: DBCLEARREL()    Clear active relations
'------------------------------------------------------------------------------
 ^bDBCLEARRELATION()^b
 Clear active relations
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCLEARRELATION() --> NIL

 ^bReturns^b

     DBCLEARRELATION() always returns NIL.

 ^bDescription^b

     DBCLEARRELATION() clears any active relations for the current work area.

     DBCLEARRELATION() performs the same function as the standard SET
     RELATION TO command with no clauses specified.  For more information,
     refer to the SET RELATION command.

 ^bExamples^b

     ^b^CFE^b  The following example sets a relation, lists data and then
        clears the relation:

        USE Employee NEW
        USE Department NEW INDEX Dept
        //
        SELECT Employee
        DBSETRELATION("Department", ;
           {|| Employee->Dept}, "Employee->Dept")
        LIST Employee->Name, Department->Name
        DBCLEARRELATION()

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBSETRELAT()" c52g_002.ngo:"SET RELATION" 
'------------------------------------------------------------------------------



!short: DBCLOSEALL()    Close all occupied work areas
'------------------------------------------------------------------------------
 ^bDBCLOSEALL()^b
 Close all occupied work areas
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCLOSEALL() --> NIL

 ^bReturns^b

     DBCLOSEALL() always returns NIL.

 ^bDescription^b

     DBCLOSEALL() releases all occupied work areas from use.  It is
     equivalent to calling DBCLOSEAREA() on every occupied work area.
     DBCLOSEAREA() has the same effect as the standard CLOSE DATABASES
     command.  For more information, refer to the USE and CLOSE commands.

 ^bExamples^b

     ^b^CFE^b  The following example closes all work areas:

        cLast := "Winston"
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "SALEFNAM" )
        DBSETINDEX( "SALELNAM" )
        //
        DBUSEAREA( .T., "DBFNTX", "Colls", "Colls", .T. )
        DBSETINDEX( "COLLFNAM" )
        DBSETINDEX( "COLLLNAM" )
        //
        DBSELECTAREA( "Sales" )      // select "Sales" work area
        //
        IF ( Sales->(DBSEEK(cLast)) )
           IF Sales->( DELETED() )
              IF RLOCK()
                 Sales->( DBRECALL() )
                 ? "Record deleted: ", Sales( DELETED() )
              ENDIF
           ENDIF
        ELSE
           ? "Not found"
        ENDIF
        DBCLOSEALL()                 // close all work areas

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"CLOSE" "DBCLOSEAREA()" "DBUSEAREA()" c52g_002.ngo:"SELECT" c52g_002.ngo:"USE" 
'------------------------------------------------------------------------------



!short: DBCLOSEAREA()   Close a work area
'------------------------------------------------------------------------------
 ^bDBCLOSEAREA()^b
 Close a work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCLOSEAREA() --> NIL

 ^bReturns^b

     DBCLOSEAREA() always returns NIL.

 ^bDescription^b

     DBCLOSEAREA() releases the current work area from use.  Pending updates
     are written, pending locks are released, and any resources associated
     with the work area are closed or released.  DBCLOSEAREA() is equivalent
     to the standard CLOSE command or the USE command with no clauses.  For
     more information, refer to the USE and CLOSE commands.

 ^bExamples^b

     ^b^CFE^b  The following example closes a work area via an alias
        reference:

        cLast := "Winston"

        //
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "SALEFNAM" )
        DBSETINDEX( "SALELNAM" )
        //
        DBUSEAREA( .T., "DBFNTX", "Colls", "Colls", .T. )
        DBSETINDEX( "COLLFNAM" )
        DBSETINDEX( "COLLLNAM" )
        //
        DBSELECTAREA( "Sales" )      // select "Sales" work area
        //
        IF ( Sales->(DBSEEK(cLast)) )
           IF Sales->( DELETED() ) .AND. Sales->( RLOCK() )
              Sales->( DBRECALL() )
              ? "Record deleted: ", Sales( DELETED() )
           ENDIF
        ELSE
           ? "Not found"
           Colls->( DBCLOSEAREA() )
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"CLOSE" "DBCLOSEALL()" "DBCOMMIT()" "DBUSEAREA()" c52g_002.ngo:"USE" 
'------------------------------------------------------------------------------



!short: DBCOMMIT()      Flush pending updates
'------------------------------------------------------------------------------
 ^bDBCOMMIT()^b
 Flush pending updates
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCOMMIT() --> NIL

 ^bReturns^b

     DBCOMMIT() always returns NIL.

 ^bDescription^b

     DBCOMMIT() causes all updates to the current work area to be written to
     disk.  All updated database and index buffers are written to DOS and a
     DOS COMMIT request is issued for the database (.dbf) file and any index
     files associated with the work area.

     DBCOMMIT() performs the same function as the standard COMMIT command
     except that it operates only on the current work area.  For more
     information, refer to the COMMIT command.

 ^bNotes^b

     ^b^CFE  Network environment:^b DBCOMMIT() makes database updates visible
        to other processes.  To insure data integrity, issue DBCOMMIT()
        before an UNLOCK operation.  For more information, refer to the
        Network Programming chapter in the Programming and Utilities guide.

     ^b^CFE^b  DBCOMMIT() uses DOS interrupt 21h function 68h to perform the
        solid-disk write.  It is up to the network operating system to
        properly implement this request.  Check with the network vendor to
        see if this is supported.

 ^bExamples^b

     ^b^CFE^b  In this example, COMMIT is used to force a write to disk after
        a series of memory variables are assigned to field variables:

        USE Sales EXCLUSIVE NEW
        MEMVAR->Name := Sales->Name
        MEMVAR->Amount := Sales->Amount
        //
        @ 10, 10 GET MEMVAR->Name
        @ 11, 10 GET MEMVAR->Amount
        READ
        //
        IF UPDATED()
           APPEND BLANK
           REPLACE Sales->Name WITH MEMVAR->Name
           REPLACE Sales->Amount WITH MEMVAR->Amount
           Sales->( DBCOMMIT() )
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"CLOSE" c52g_002.ngo:"COMMIT" "DBCLOSEALL()" "DBCOMMITALL()" "DBUNLOCK()" 
'------------------------------------------------------------------------------



!short: DBCOMMITALL()   Flush pending updates in all work areas
'------------------------------------------------------------------------------
 ^bDBCOMMITALL()^b
 Flush pending updates in all work areas
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCOMMITALL() --> NIL

 ^bReturns^b

     DBCOMMITALL() always returns NIL.

 ^bDescription^b

     DBCOMMITALL() causes all pending updates to all work areas to be written
     to disk.  It is equivalent to calling DBCOMMIT() for every occupied work
     area.

     For more information, refer to DBCOMMIT() and the COMMIT command.

 ^bNotes^b

     ^b^CFE^b  DBCOMMITALL() uses DOS interrupt 21h function 68h to perform
        the solid-disk write.  It is up to the network operating system to
        properly implement this request.  Check with the network vendor to
        see if this is supported.

 ^bExamples^b

     ^b^CFE^b  The following example writes all pending updates to disk:

        cLast := "Winston"
        //
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "SALEFNAM" )
        DBSETINDEX( "SALELNAM" )
        //
        DBUSEAREA( .T., "DBFNTX", "Colls", "Colls", .T. )
        DBSETINDEX( "COLLFNAM" )
        DBSETINDEX( "COLLLNAM" )

        DBSELECTAREA( "Sales" )      // select "Sales" work area

        IF ( Sales->(DBSEEK(cLast)) )
           IF Sales->( DELETED() ) .AND. Sales( RLOCK() )
              Sales->( DBRECALL() )
              ? "Deleted record has been recalled."
           ENDIF
        ELSE
           ? "Not found"
        ENDIF
        //
        // processing done, write updates to disk and close
        DBCOMMITALL()
        DBCLOSEALL()
        QUIT

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"CLOSE" c52g_002.ngo:"COMMIT" "DBCLOSEALL()" "DBCOMMIT()" "DBUNLOCK()" 
'------------------------------------------------------------------------------



!short: DBCREATE()      Create a database file from a database structure array      ^r^CE4^r
'------------------------------------------------------------------------------
 ^bDBCREATE()^b
 Create a database file from a database structure array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCREATE(<cDatabase>, <aStruct>
     ^b   [<cDriver>]) --> NIL

 ^bArguments^b

     ^b<cDatabase>^b is the name of the new database file, with an optional
     drive and directory, specified as a character string.  If specified
     without an extension (.dbf) is assumed.

     ^b<aStruct>^b is an array that contains the structure of <cDatabase> as
     a series of subarrays, one per field.  Each subarray contains the
     definition of each field's attributes and has the following structure:

     ^bField Definition Subarray^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bPosition     Metasymbol     Dbstruct.ch^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     1            cName          DBS_NAME
     2            cType          DBS_TYPE
     3            nLength        DBS_LEN
     4            nDecimals      DBS_DEC
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^b<cDriver>^b specifies the replaceable database driver (RDD) to use to
     process the current work area.  <cDriver> is name of the RDD specified
     as a character expression.  If you specify <cDriver> as a literal value,
     you must enclose it in quotes.

 ^bReturns^b

     DBCREATE() always returns NIL.

 ^bDescription^b

     DBCREATE() is a database function that creates a database file from an
     array containing the structure of the file.  You may create the array
     programmatically or by using DBSTRUCT().  DBCREATE() is similar to the
     CREATE FROM command which creates a new database file structure from a
     structure extended file.  Use CREATE or COPY STRUCTURE EXTENDED commands
     to create a structure extended file.

     Before using DBCREATE(), you must first create the <aStruct> array and
     fill it with the field definition arrays according to the structure in
     Field Definition Subarray table (above).  There are some specific rules
     for creating a field definition array, including:

     ^b^CFE^b  Specify all field attributes with a value of the proper data
        type for the attribute.  The decimals attribute must be
        specified--even for non-numeric fields.  If the field does not have a
        decimals attribute, specify zero.

     ^b^CFE^b  Specify the type attribute using the first letter of the data
        type as a minimum.  Use longer and more descriptive terms for
        readability.  For example, both "C" and "Character" can be specified
        as the type attribute for character fields.

     ^b^CFE^b  In CA-Clipper, character fields contain up to 64,000
        characters.  Unlike the CREATE FROM command, DBCREATE() does not use
        the decimals attribute to specify the high-order part of the field
        length.  Specify the field length directly, regardless of its
        magnitude.

     To make references to the various elements of the field definition
     subarray more readable, the header file called Dbstruct.ch is supplied
     which contains the #defines to assign a name to the array position for
     each field attribute.  It is located in \CLIPPER5\INCLUDE.

 ^bExamples^b

     ^b^CFE^b  This example creates an empty array and then adds field
        definition subarrays using the AADD() function before creating
        People.dbf.  You might use this technique to add field definitions to
        your structure array dynamically:

        aDbf := {}
        AADD(aDbf, { "Name", "C", 25, 0 })
        AADD(aDbf, { "Address", "C", 1024, 0 })
        AADD(aDbf, { "Phone", "N", 13, 0 })
        //
        DBCREATE("People", aDbf)

     ^b^CFE^b  This example performs the same types of actions but declares
        the structure array as a two-dimensional array, and then uses
        subscript addressing to specify the field definitions.  It will be
        created using the DBFMDX RDD:

        #include "Dbstruct.ch"
        //
        LOCAL aDbf[1][4]
        aDbf[1][ DBS_NAME ] := "Name"
        aDbf[1][ DBS_TYPE ] := "Character"
        aDbf[1][ DBS_LEN ]  := 25
        aDbf[1][ DBS_DEC ]  := 0
        //
        DBCREATE("Name", aDbf, "DBFMDX")

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Dbstruct.ch.
!seealso: "AFIELDS()*" c52g_002.ngo:"COPY STRU EXTE" c52g_002.ngo:"CREATE FROM" "DBSTRUCT()" 
'------------------------------------------------------------------------------



!short: DBCREATEIND()   Create an index file
'------------------------------------------------------------------------------
 ^bDBCREATEINDEX()^b
 Create an index file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCREATEINDEX(<cIndexName>, <cKeyExpr>,
     ^b   <bKeyExpr>, [<lUnique>]) --> NIL

 ^bArguments^b

     ^b<cIndexName>^b is a character value that specifies the filename of the
     index file to be created.

     ^b<cKeyExpr>^b is a character value that expresses the index key
     expression in textual form.

     ^b<bKeyExpr>^b is a code block that expresses the index key expression
     in executable form.

     ^b<lUnique>^b is an optional logical value that specifies whether a
     unique index is to be created.  If <lUnique> is omitted, the current
     global _SET_UNIQUE setting is used.

 ^bReturns^b

     DBCREATEINDEX() always returns NIL.

 ^bDescription^b

     DBCREATEINDEX() creates an index for the database (.dbf) file associated
     with the current work area.  If the work area has active indexes, they
     are closed.  After the new index is created, it becomes the controlling
     index for the work area and is positioned to the first logical record.

     DBCREATEINDEX() performs the same function as the standard INDEX
     command.  For more information, refer to the INDEX command.

 ^bNotes^b

     ^b^CFE  Side effects:^b DBCREATEINDEX() is guaranteed to create an index
        that, when made active, will impose the specified logical order on
        the database.  The key expression is not necessarily evaluated at any
        particular time, by any particular means, or on any particular record
        or series of records.  If the key expression relies on information
        external to the database file or work area, the effect is
        unpredictable.  If the key expression changes the state of the work
        area (e.g., by moving to a different record or changing the contents
        of a record), the effect is unpredictable.

     ^b^CFE  Evaluation context:^b When the key expression is evaluated, the
        associated work area is automatically selected as the current work
        area before the evaluation; the previously selected work area is
        automatically restored afterward.

     ^b^CFE  Network environment:^b DBCREATEINDEX() creates the new index for
        the exclusive use of the current process.

 ^bExamples^b

     ^b^CFE^b  This example creates an index file, Name, indexed on the Name
        field:

        USE Employees NEW
        DBCREATEINDEX( "Name", "Name", { || Name })

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBREINDEX()" "DBSETINDEX()" "DBSETORDER()" c52g_002.ngo:"INDEX" 
'------------------------------------------------------------------------------



!short: DBDELETE()      Mark a record for deletion
'------------------------------------------------------------------------------
 ^bDBDELETE()^b
 Mark a record for deletion
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBDELETE() --> NIL

 ^bReturns^b

     DBDELETE() always returns NIL.

 ^bDescription^b

     DBDELETE() marks the current record as deleted.  Records marked for
     deletion can be filtered using SET DELETED or removed from the file
     using the PACK command.

     DBDELETE() performs the same function as the standard DELETE command
     with a scope of the current record.  For more information, refer to the
     DELETE command.

 ^bNotes^b

     ^b^CFE  Logical records:^b If the global _SET_DELETED status is true
        (.T.), deleted records are not logically visible.  That is, database
        operations which operate on logical records will not consider records
        marked for deletion.  Note, however, that if _SET_DELETED is true
        (.T.) when the current record is marked for deletion, the record
        remains visible until it is no longer the current record.

     ^b^CFE  Network environment:^b For a shared database on a network,
        DBDELETE() requires the current record to be locked.  For more
        information, refer to the Network Programming chapter of the
        Programming and Utilities guide.

 ^bExamples^b

     ^b^CFE^b  The following example deletes a record after a successful
        record lock:

        cLast := "Winston"
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "LASTNAME" )
        //
        IF ( Sales->(DBSEEK(cLast)) )
           IF Sales->( RLOCK() )
              Sales->( DBDELETE() )
              ? "Record deleted: ", Sales( DELETED() )
           ELSE
              ? "Unable to lock record..."
           ENDIF
        ELSE
           ? "Not found"
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBRECALL()" c52g_002.ngo:"DELETE" c52g_002.ngo:"RECALL" 
'------------------------------------------------------------------------------



!short: DBEDIT()*       Browse records in a table layout                            ^r^CE4^r
'------------------------------------------------------------------------------
 ^bDBEDIT()*^b
 Browse records in a table layout
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBEDIT([<nTop>], [<nLeft>],
     ^b   [<nBottom>], <nRight>],
     ^b   [<acColumns>],
     ^b   [<cUserFunction>],
     ^b   [<acColumnSayPictures> | <cColumnSayPicture>],
     ^b   [<acColumnHeaders> | <cColumnHeader>],
     ^b   [<acHeadingSeparators> | <cHeadingSeparator>],
     ^b   [<acColumnSeparators> | <cColumnSeparator>],
     ^b   [<acFootingSeparators> | <cFootingSeparator>],
     ^b   [<acColumnFootings> | <cColumnFooting>]) --> NIL

 ^bArguments^b

     ^b<nTop>^b, ^b<nLeft>^b, ^b<nBottom>^b, and ^b<nRight>^b define the
     upper left and lower right coordinates of the DBEDIT() window.  Row
     values can range from zero to MAXROW() and column positions can range
     from zero to MAXCOL().  If not specified, the default coordinates are 0,
     0, MAXROW(), and MAXCOL().

     ^b<acColumns>^b is an array of character expressions containing database
     field names or expressions to use as column values for each row
     displayed.  If this argument is not specified, DBEDIT() displays all
     fields in the current work area as columns.

     ^b<cUserFunction>^b is the name of a user-defined function that executes
     when an unrecognizable key is pressed or there are no keys pending in
     the keyboard buffer.  Specify the function name as a character
     expression without parentheses or arguments.  Note that the behavior of
     DBEDIT() is affected by the presence of this argument.  Refer to the
     discussion below for more information.

     ^b<acColumnSayPictures>^b is a parallel array of picture clauses to
     format each column.  Specifying <cColumnSayPicture> instead of an array
     displays all columns with the same format.  Refer to TRANSFORM() or
     @...SAY for more information on pictures.

     ^b<acColumnHeaders>^b is a parallel array of character expressions that
     define the headings for each column.  Specifying <cColumnHeader> gives
     the same heading for all columns.  To display a multiline heading, embed
     a semicolon in the heading expression where you want the string to
     break.  If not specified, column headings are taken from the <acColumns>
     array, or the field names in the current work area if the <acColumns>
     argument is not specified.

     ^b<acHeadingSeparators>^b is a parallel array of character expressions
     that define the characters used to draw horizontal lines separating
     column headings from the field display area. Specifying
     <cHeadingSeparator> instead of an array uses the same heading separator
     for all columns.  If this argument is not specified, the default
     separator is a double graphics line.

     ^b<acColumnSeparators>^b is a parallel array of character expressions
     that define the characters used to draw vertical lines separating the
     columns.  Specifying <cColumnSeparator> instead of an array uses the
     same separator for all columns.  If this argument is not specified, the
     default separator is a single graphics line.

     ^b<acFootingSeparators>^b is a parallel array of character expressions
     that define the characters used to draw horizontal lines separating
     column footings from the field display area.  Specifying
     <cFootingSeparator> instead of an array uses the same footing separator
     for all columns.  If this argument is not specified, there is no footing
     separator.

     ^b<acColumnFootings>^b is a parallel array of character expressions that
     define footings for each column.  Specifying <cColumnFooting> instead of
     an array gives the same footing for all columns.  To display a multiline
     footing, embed a semicolon in the footing expression where you want the
     string to break.  If this argument is not specified, there are no column
     footings.

 ^bReturns^b

     DBEDIT() always returns NIL.

 ^bDescription^b

     DBEDIT() is a user interface and compatibility function that displays
     records from one or more work areas in a table form.  The DBEDIT()
     window display is a grid of cells divided into columns and rows.
     Columns correspond to database fields and rows correspond to database
     records.  Each column is defined by an element of the <acColumns> array.
     The display width of each column is determined by the evaluation of the
     column expression in <acColumns> array or the column picture specified
     in the <acColumnSayPictures> array.

     All cursor movement keys are handled within DBEDIT(), including PgUp,
     PgDn, Home, End, the four arrow keys, and all Ctrl key combinations that
     produce cursor movement.  The navigation keys that DBEDIT() responds to
     when a user function argument is not specified are listed in the Active
     Keys table below:

     ^bDBEDIT() Active Keys^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bKey                 Action^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Uparrow             Up one row
     Dnarrow             Down one row
     Leftarrow           Column left
     Rightarrow          Column right
     Ctrl-Leftarrow      Pan left one column
     Ctrl-Rightarrow     Pan right one column
     Home                Leftmost current screen column
     End                 Rightmost current screen column
     Ctrl-Home           Leftmost column
     Ctrl-End            Rightmost column
     PgUp                Previous screen
     PgDn                Next screen
     Ctrl-PgUp           First row of current column
     Ctrl-PgDn           Last row of current column
     Return              Terminate DBEDIT()
     Esc                 Terminate DBEDIT()
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     When the user function argument (<cUserFunction>) is specified, all keys
     indicated in the Active Keys table are active with the exception of Esc
     and Return.  When DBEDIT() calls the user function, it automatically
     passes two arguments:

     ^b^CFE^b  The current mode passed as a numeric value

     ^b^CFE^b  The index of the current column in <acColumns> passed as a
        numeric value

     The mode parameter indicates the current state of DBEDIT() depending on
     the last key executed.  The possible mode values are listed in the
     DBEDIT() Modes table below:

     ^bDBEDIT() Modes^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bStatus  Dbedit.ch      Description^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     0       DE_IDLE        Idle, any cursor movement keystrokes have been
                            handled and no keystrokes are pending
     1       DE_HITTOP      Attempt to cursor past top of file
     2       DE_HITBOTTOM   Attempt to cursor past bottom of file
     3       DE_EMPTY       No records in work area
     4       DE_EXCEPT      Key exception
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     The index parameter points to the position of the current column
     definition in the <acColumns> array.  If <acColumns> is not specified,
     the index parameter points to the position of the field in the current
     database structure.  Access the field name using FIELD().

     A user-defined function must return a value that indicates to DBEDIT()
     the action to perform.  The User Function Return Values table below
     lists the possible return values and the corresponding actions:

     ^bDBEDIT() User Function Return Values^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bValue   Dbedit.ch      Description^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     0       DE_ABORT       Abort DBEDIT()
     1       DE_CONT        Continue DBEDIT()
     2       DE_REFRESH     Force reread/repaint and continue; after repaint,
                            process keys and go to idle
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     A number of instances effect calls to the user function:

     ^b^CFE^b  A key exception occurs.  This happens when DBEDIT() fetches a
        keystroke that it does not recognize from the keyboard.  Any pending
        keys remain in the keyboard buffer until fetched within the user
        function or until DBEDIT() continues.

     ^b^CFE^b  DBEDIT() enters the idle mode (i.e., all pending keys have
        been processed).  This happens when the keyboard is empty or after a
        screen refresh.  In this instance, there is one call to the user
        function and then DBEDIT() waits for a key.

     ^b^CFE^b  Beginning or end of file is encountered.  This is the same as
        idle.  All executable keys are performed, and there is one call to
        the user function with the appropriate status message.

     Note that when DBEDIT() is first executed, all keys pending in the
     keyboard buffer are executed and then DBEDIT() enters the idle mode with
     a user function call.  If no keys are pending, the idle mode is
     immediate.

     The user function should handle all modes and status messages received
     from DBEDIT().

     A user-defined function must assure that the DBEDIT() status is
     equivalent to DE_EXCEPT (4) otherwise the value of LASTKEY() is
     meaningless and a Return value of DE_REFRESH (2) will place the
     application into an endless loop.

     FUNCTION DBEditFunc ( nMode, nColumnPos )
        LOCAL RetVal := DE_CONT

        IF ( nMode == DE_EXCEPT )
           IF ( LASTKEY() == K_F5 )
              RetVal := DE_REFRESH
           ENDIF
        ENDIF
     RETURN(  RetVal )

     DBEDIT() is fully reentrant, which means you can make nested calls to
     it.  Using this feature, you can have multiple browse windows on the
     screen at the same time.

     DBEDIT() is a compatibility function and, therefore, no longer
     recommended as a programmable browse facility.  As such, it is
     superseded by the TBrowse object class.  For more information, refer to
     TBrowse class in this chapter.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a generic call to DBEDIT():

        USE Names NEW
        DBEDIT()

     ^b^CFE^b  This example demonstrates calling DBEDIT() with a user
        function:

        #include "dbedit.ch"
        #include "inkey.ch"

        // Array must be visible to other user-defined programs in
        // program

        STATIC acColumns := {}

        PROCEDURE Main()

           USE Names NEW
           INDEX ON Names->Lastname + Names->FirstName TO Names

           CLS

           acColumns := { "LastName", "FirstName" }

           DBEDIT( 5, 5, 20, 70, acColumns, "UserFunc" )

        RETURN


        FUNCTION UserFunc( nMode, nCol )
           LOCAL nKey := LASTKEY()
           LOCAL nRetVal := DE_CONT         // Default return value

           DO CASE
           CASE nMode == DE_IDLE
              nRetVal := IdleFunc()
           CASE nMode == DE_HITTOP
              TONE( 100, 3 )
           CASE nMode == DE_HITBOTTOM
              TONE( 100, 3 )
              nRetVal := AppendFunc( nKey )
           CASE nMode == DE_EMPTY
              nRetVal := EmptyFunc()
           CASE nMode == DE_EXCEPT
              nRetVal := ExceptFunc( nKey, nCol )
           OTHERWISE
              TONE( 100, 3 )
           ENDCASE

        RETURN nRetVal

        FUNCTION AppendFunc( nKey )
           LOCAL nRetVal := DE_CONT         // Default return value

           IF nKey == K_DOWN                // If DOWN ARROW
              APPEND BLANK                  // Append blank record
        // Note: The appended record will appear at the top of the
        //       DBEDIT() screen when the database file is indexed.

              nRetVal := DE_REFRESH         // Refresh screen
           ENDIF


        RETURN nRetVal

        FUNCTION ExceptFunc( nKey, nCol )
           LOCAL nRetVal := DE_CONT         // Default return value

           DO CASE
           CASE nKey == K_ESC               // If ESCAPE
              nRetVal := DE_ABORT           // Exit
           CASE nKey == K_RETURN            // If RETURN
              nRetVal := EditFunc( nCol )   // Function to edit
                                            // field

           // Toggle DELETED status
           CASE nKey == K_DEL .AND. LASTREC() != 0  // DELETE pressed
              IF DELETED()
                 RECALL
              ELSE
                 DELETE
              ENDIF
           OTHERWISE
                 TONE( 100, 1 )
           ENDCASE

        RETURN nRetVal


        FUNCTION EditFunc( nCol )
           LOCAL cIndexVal         // Value of current key expression
           LOCAL nRetVal           // Return value
           LOCAL nField            // Position of current field
           LOCAL cFieldVal         // Value of current field
           LOCAL nCursSave         // Preserve state of cursor

           // This will return an error if no index is open
           cIndexVal := &( INDEXKEY(0) )

           nField := FIELDPOS( acColumns[nCol] )

           IF nField != 0
              nCursSave := SETCURSOR()         // Save state of cursor
              SETCURSOR(1)                     // Change cursor shape
              cFieldVal := FIELDGET( nField )  // Save contents
                                               // of field
              @ ROW(), COL() GET cFieldVal     // GET new value
              READ
              FIELDPUT( nField, cFieldVal )    // REPLACE with
                                               // new value
              SETCURSOR( nCursSave )           // Restore cursor
                                               // shape
           ENDIF


           IF cIndexVal != &( INDEXKEY(0) )    // If key expression
                                               // changed

              nRequest := DE_REFRESH           // Refresh screen
           ELSE                                // Otherwise
              nRequest := DE_CONT              // Continue
           ENDIF

        RETURN nRequest

        FUNCTION IdleFunc()
           // Idle routine
        RETURN DE_CONT

        FUNCTION EmptyFunc()
           // Empty Records routine
        RETURN DE_CONT

 ^bFiles:^b  Library is EXTEND.LIB, header files are Dbedit.ch and Inkey.ch.
!seealso: c52g_002.ngo:"@...GET" "ACHOICE()" "BROWSE()*" "MEMOEDIT()" "TRANSFORM()" 
'------------------------------------------------------------------------------



!short: DBEVAL()        Evaluate a code block for records matching a scope/condition
'------------------------------------------------------------------------------
 ^bDBEVAL()^b
 Evaluate a code block for each record matching a scope and condition
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBEVAL(<bBlock>,
     ^b   [<bForCondition>],
     ^b   [<bWhileCondition>],
     ^b   [<nNextRecords>],
     ^b   [<nRecord>],
     ^b   [<lRest>]) --> NIL

 ^bArguments^b

     ^b<bBlock>^b is a code block to execute for each record processed.

     ^b<bForCondition>^b is an optional condition specified as a code block
     that is evaluated for each record in the scope.  It provides the same
     functionality as the FOR clause of record processing commands.

     ^b<bWhileCondition>^b is an optional condition specified as a code block
     that is evaluated for each record from the current record until the
     condition returns false (.F.).  It provides the same functionality as
     the WHILE clause of record processing commands.

     ^b<nNextRecords>^b is an optional number that specifies the number of
     records to process starting with the current record.  It is the same as
     the NEXT clause.

     ^b<nRecord>^b is an optional record number to process.  If this argument
     is specified, <bBlock> will be evaluated for the specified record.  This
     argument is the same as the RECORD clause.

     ^b<lRest>^b is an optional logical value that determines whether the
     scope of DBEVAL() is all records, or, starting with the current record,
     all records to the end of file.  This argument corresponds to the REST
     and ALL clauses of record processing commands.  If true (.T.) , the
     scope is REST; otherwise, the scope is ALL records.  If <lRest> is not
     specified the scope defaults to ALL.

 ^bReturns^b

     DBEVAL() always returns NIL.

 ^bDescription^b

     DBEVAL() is a database function that evaluates a single block for each
     record within the current work area that matches a specified scope
     and/or condition.  On each iteration, DBEVAL() evaluates the specified
     block.  All records within the scope or matching the condition are
     processed until the end of file is reached.

     By default, DBEVAL() operates on the currently selected work area.  It
     will operate on an unselected work area if you specify it as part of an
     aliased expression.

     DBEVAL() is similar to AEVAL() which applies a block to each element in
     an array.  Like AEVAL(), DBEVAL() can be used as a primitive for the
     construction of user-defined commands that process database files.  In
     fact, many of the standard CA-Clipper database processing commands are
     created using DBEVAL().

     Refer to the Code Blocks section in the Basic Concepts chapter of the
     Programming and Utilities guide for more information on the syntax and
     theory of code blocks; refer also to the Database System section in the
     Basic Concepts chapter for information on record scoping and conditions;
     and refer to the CA-Clipper standard header file, STD.CH, found in
     \CLIPPER5\INCLUDE for examples of CA-Clipper database command
     definitions that use DBEVAL().

 ^bExamples^b

     ^b^CFE^b  This example uses DBEVAL() to implement Count(), a
        user-defined function that counts the number of records in a work
        area matching a specified scope.  The scope is passed as an array to
        Count().  To make the example more interesting, there is a
        user-defined command to create the scope array, thereby allowing you
        to specify the scope in a familiar form.  Additionally, there is a
        set of manifest constants that define the attributes of the scope
        object:

        // Scope command definition
        #command CREATE SCOPE <aScope> [FOR <for>] ;
           [WHILE <while>] [NEXT <next>] [RECORD <rec>] ;
           [<rest:REST>] [ALL];
        =>;
           <aScope> := { <{for}>, <{while}>, <next>, ;
              <rec>, <.rest.> }
        //

        // Scope attribute constants
        #define FOR_COND     1
        #define WHILE_COND   2
        #define NEXT_SCOPE   3
        #define REC_SCOPE    4
        #define REST_SCOPE   5
        //
        // Create a scope and count records using it
        LOCAL mySet, myCount
        USE Customer NEW
        CREATE SCOPE mySet FOR Customer = "Smith" WHILE ;
                  Zip > "90000"
        myCount := Count( mySet )
        RETURN

        FUNCTION Count( aScope )
           LOCAL nCount := 0
           DBEVAL( {|| nCount++},;
              aScope[ FOR_COND ],;
              aScope[ WHILE_COND ],;
              aScope[ NEXT_SCOPE ],;
              aScope[ REC_SCOPE ],;
              aScope[ REST_SCOPE ];
           )
           RETURN nCount

 ^bFiles:^b  Library is CLIPPER.LIB
!seealso: "AEVAL()" "EVAL()" 
'------------------------------------------------------------------------------



!short: DBF()*          Return current alias name
'------------------------------------------------------------------------------
 ^bDBF()*^b
 Return current alias name
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBF() --> cAlias

 ^bReturns^b

     DBF() returns the alias of the current work area as a character string.
     If there is no active database file in the current work area, DBF()
     returns a null string ("").

 ^bDescription^b

     DBF() is a compatibility function that replicates the DBF() function in
     dBASE III PLUS.  CA-Clipper implements it by invoking the ALIAS()
     function without an argument.

     DBF() is a compatibility function and, therefore, no longer recommended.
     It is superseded entirely by the ALIAS() function.

 ^bFiles:^b  Library is EXTEND.LIB, source file is SOURCE\SAMPLE\DBF.PRG.
!seealso: "ALIAS()" "USED()" 
'------------------------------------------------------------------------------



!short: DBFILTER()      Return the current filter expression as a character string
'------------------------------------------------------------------------------
 ^bDBFILTER()^b
 Return the current filter expression as a character string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBFILTER() --> cFilter

 ^bReturns^b

     DBFILTER() returns the filter condition defined in the current work area
     as a character string.  If no FILTER has been SET, DBFILTER() returns a
     null string ("").

 ^bDescription^b

     DBFILTER() is a database function used to save and reexecute an active
     filter by returning the filter expression as a character string that can
     be later recompiled and executed using the macro operator (&).  This
     function operates like the DBRELATION() and DBRSELECT() functions which
     save and reexecute the linking expression of a relation within a work
     area.

     Since each work area can have an active filter, DBFILTER() can return
     the filter expression of any work area.  This is done by referring to
     DBFILTER() within an aliased expression as demonstrated below.

 ^bNotes^b

     ^b^CFE  Declared variables:^b A character string returned by DBFILTER()
        may not operate correctly when recompiled and executed using the
        macro operator (&) if the original filter expression contained
        references to local or static variables, or otherwise depended on
        compile-time declarations.

 ^bExamples^b

     ^b^CFE^b  This example opens two database files, sets two filters, then
        displays the filter expressions for both work areas:

        USE Customer INDEX Customer NEW
        SET FILTER TO Last = "Smith"
        USE Invoices INDEX Invoices NEW
        SET FILTER TO CustId = "Smi001"
        SELECT Customer
        //
        ? DBFILTER()                  // Result: Last = "Smith"
        ? Invoices->(DBFILTER())      // Result: Custid = "Smi001"

     ^b^CFE^b  This user-defined function, CreateQry(), uses DBFILTER() to
        create a memory file containing the current filter expression in the
        private variable cFilter:

        FUNCTION CreateQry( cQryName )

           PRIVATE cFilter := DBFILTER()
           SAVE ALL LIKE cFilter TO (cQryName + ".qwy")
           RETURN NIL

     ^b^CFE^b  You can later RESTORE a query file with this user-defined
        function, SetFilter():

        FUNCTION SetFilter()
        PARAMETER cQryName
           RESTORE FROM &cQryName..qwy ADDITIVE
           SET FILTER TO &cFilter.
           RETURN NIL

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBRELATION()" "DBRSELECT()" c52g_002.ngo:"SET FILTER" 
'------------------------------------------------------------------------------



!short: DBGOBOTTOM()    Move to the last logical record
'------------------------------------------------------------------------------
 ^bDBGOBOTTOM()^b
 Move to the last logical record
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBGOBOTTOM() --> NIL

 ^bReturns^b

     DBGOBOTTOM() always returns NIL.

 ^bDescription^b

     DBGOBOTTOM() moves to last logical record in the current work area.

     DBGOBOTTOM() performs the same function as the standard GO BOTTOM
     command.  For more information, refer to the GO command.

 ^bNotes^b

     ^b^CFE  Logical records:^b DBGOBOTTOM() operates on logical records.  If
        there is an active index, DBGOBOTTOM() moves to the last record in
        indexed order.  If a filter is set, only records which meet the
        filter condition are considered.

     ^b^CFE  Controlling order:^b If more than one index is active in the
        work area, the operation is performed using the controlling order as
        set by DBSETORDER() or the SET ORDER command.  For more information,
        refer to the SET ORDER command.

     ^b^CFE  Network environment:^b For a shared file on a network, moving to
        a different record may cause updates to the current record to become
        visible to other processes.  For more information, refer to the
        Network Programming chapter in the Programming and Utilities guide.

 ^bExamples^b

     ^b^CFE^b  The following example uses DBGOBOTTOM() to position the record
        pointer on the last logical record:

        cLast := "Winston"
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "LASTNAME" )
        //
        Sales->( DBGOBOTTOM() )
        IF ( Sales->Last == "Winston" )
           IF RLOCK()
              Sales->( DBDELETE() )
              ? "Record deleted: ", Sales( DELETED() )
           ELSE
              ? "Unable to lock record..."
           ENDIF
        END

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "BOF()" "DBGOTOP()" "DBSEEK()" "DBSKIP()" "EOF()" c52g_002.ngo:"GO" 
'------------------------------------------------------------------------------



!short: DBGOTO()        Move to the record having the specified record number
'------------------------------------------------------------------------------
 ^bDBGOTO()^b
 Move to the record having the specified record number
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBGOTO(<nRecordNumber>) --> NIL

 ^bArguments^b

     ^b<nRecordNumber>^b is a numeric value that specifies the record number
     of the desired record.

 ^bReturns^b

     DBGOTO() always returns NIL.

 ^bDescription^b

     DBGOTO() moves to the record whose record number is equal to
     <nRecordNumber>.  If no such record exists, the work area is positioned
     to LASTREC() + 1 and both EOF() and BOF() return true (.T.).

     DBGOTO() performs the same function as the standard GO command.  For
     more information, refer to the GO command.

 ^bNotes^b

     ^b^CFE  Logical records:^b DBGOTO() does not respect logical visibility.
        That is, if the specified record exists, it will become the current
        record regardless of any index or filter condition.

     ^b^CFE  Network environment:^b For a shared file on a network, moving to
        a different record may cause updates to the current record to become
        visible to other processes.  For more information, refer to the
        Network Programming chapter in the Programming and Utilities guide.

 ^bExamples^b

     ^b^CFE^b  The following example uses DBGOTO() to iteratively process
        every fourth record:

        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        //
        // toggle every fourth record
        DO WHILE !EOF()
           DBGOTO( RECNO() + 4 )
           Sales->Group := "Bear"
        ENDDO

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "BOF()" "DBGOBOTTOM()" "DBGOTOP()" "DBSEEK()" "DBSKIP()" "EOF()" c52g_002.ngo:"GO" 
'------------------------------------------------------------------------------



!short: DBGOTOP()       Move to the first logical record
'------------------------------------------------------------------------------
 ^bDBGOTOP()^b
 Move to the first logical record
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBGOTOP() --> NIL

 ^bReturns^b

     DBGOTOP() always returns NIL.

 ^bDescription^b

     DBGOTOP() moves to the first logical record in the current work area.

     DBGOTOP() performs the same function as the standard GO TOP command.
     For more information, refer to the GO TOP command.

 ^bNotes^b

     ^b^CFE  Logical records:^b DBGOTOP() operates on logical records.  If
        there is an active index, DBGOTOP() moves to the first record in
        indexed order.  If a filter is set, only records which meet the
        filter condition are considered.

     ^b^CFE  Controlling order:^b If more than one index is active in the
        work area, the operation is performed using the controlling order as
        set by DBSETORDER() or the SET ORDER command.  For more information,
        refer to the SET ORDER command.

     ^b^CFE  Network environment:^b For a shared file on a network, moving to
        a different record may cause updates to the current record to become
        visible to other processes.  For more information, refer to the
        Network Programming chapter in the Programming and Utilities guide.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates the typical use of DBGOTOP():

        DBGOTOP()
        WHILE ( !EOF() )
           ? FIELD->Name
           DBSKIP()
        END

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "BOF()" "DBGOBOTTOM()" "DBSEEK()" "DBSKIP()" "EOF()" c52g_002.ngo:"GO" 
'------------------------------------------------------------------------------



!short: DBRECALL()      Reinstate a record marked for deletion
'------------------------------------------------------------------------------
 ^bDBRECALL()^b
 Reinstate a record marked for deletion
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBRECALL() --> NIL

 ^bReturns^b

     DBRECALL() always returns NIL.

 ^bDescription^b

     DBRECALL() causes the current record to be reinstated if it is marked
     for deletion.

     DBRECALL() performs the same function as the RECALL command.  For more
     information, refer to the DELETE and RECALL commands.

 ^bNotes^b

     ^b^CFE  Logical records:^b Reinstating a deleted record affects the
        record's logical visibility if the global _SET_DELETED status is true
        (.T.).  For more information, refer to the DBDELETE() function and
        the DELETE and RECALL commands.

     ^b^CFE  Network environment:^b For a shared database on a network,
        DBRECALL() requires the current record to be locked.  For more
        information, refer to the Network Programming chapter in the
        Programming and Utilities guide.

 ^bExamples^b

     ^b^CFE^b  The following example recalls a record if it is deleted and
        attempts to lock the record if successful:

        cLast := "Winston"
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "LASTNAME" )
        //
        IF ( Sales->(DBSEEK(cLast)) )
           IF Sales->( DELETED() )

              IF Sales( RLOCK() )
                 Sales( DBRECALL() )
                 ? "Record recalled"
              ELSE
                 ? "Unable to lock record..."
              ENDIF
           ENDIF
        ELSE
           ? "Not found"
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBDELETE()" c52g_002.ngo:"DELETE" c52g_002.ngo:"RECALL" 
'------------------------------------------------------------------------------



!short: DBREINDEX()     Recreate all active indexes for the current work area
'------------------------------------------------------------------------------
 ^bDBREINDEX()^b
 Recreate all active indexes for the current work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBREINDEX() --> NIL

 ^bReturns^b

     DBREINDEX() always returns NIL.

 ^bDescription^b

     DBREINDEX() rebuilds all active indexes associated with the current work
     area.  After the indexes are recreated, the work area is moved to the
     first logical record in the controlling order.

     DBREINDEX() performs the same function as the standard REINDEX command.
     For more information, refer to the REINDEX command.

 ^bExamples^b

     ^b^CFE^b  The following example reindexes the work area:

        cLast := "Winston"
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "LASTNAME" )
        //
        IF ( Sales->(DBSEEK(cLast)) )
           IF RLOCK()
              DELETE FOR Sales->LastName == "Winston"
              Sales->( DBREINDEX() )
           ELSE
              ? "Unable to lock record..."
           ENDIF
        ELSE
           ? "Not found"
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBCLEARIND()" "DBCREATEIND()" "DBSETINDEX()" "DBSETORDER()" c52g_002.ngo:"REINDEX" 
'------------------------------------------------------------------------------



!short: DBRELATION()    Return the linking expression of a specified relation
'------------------------------------------------------------------------------
 ^bDBRELATION()^b
 Return the linking expression of a specified relation
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBRELATION(<nRelation>) --> cLinkExp

 ^bArguments^b

     ^b<nRelation>^b is the position of the desired relation in the list of
     current work area relations.  The relations are numbered according to
     the order in which they were defined with SET RELATION.

 ^bReturns^b

     DBRELATION() returns a character string containing the linking
     expression of the relation specified by <nRelation>.  If there is no
     RELATION SET for <nRelation>, DBRELATION() returns a null string ("").

 ^bDescription^b

     DBRELATION() is a database function used with DBRSELECT() to determine
     the linking expression and work area of an existing relation created
     with the SET RELATION command.

     DBRELATION() returns the linking expression defined by the TO clause.
     DBRSELECT() returns the work area linked as defined by the INTO clause.

     By default, DBRELATION() operates on the currently selected work area.
     It will operate on an unselected work area if you specify it as part of
     an aliased expression (see example below).

 ^bNotes^b

     ^b^CFE  Declared variables:^b A character string returned by
        DBRELATION() may not operate correctly when recompiled and executed
        using the macro operator (&) if the original expression contained
        references to local or static variables, or otherwise depends on
        compile-time declarations.

 ^bExamples^b

     ^b^CFE^b  This example opens three database files, sets two child
        relations from the parent work area, and then displays the linking
        expression to the second child work area:

        USE Invoices INDEX Invoices NEW
        USE BackOrder INDEX BackOrder NEW
        USE Customer INDEX Customer NEW
        SET RELATION TO CustNum INTO Invoices, OrderNum ;
              INTO BackOrder
        //

        ? DBRELATION(2)               // Result: OrderNum

     ^b^CFE^b  Later you can query the same linking expression from an
        unselected work area by using an aliased expression like this:

        USE Archive NEW
        ? Customer->(DBRELATION(2))   // Result: OrderNum

     ^b^CFE^b  This example is a user-defined function, Relation(), that
        returns the results of both DBRELATION() and DBRSELECT() as an array:

        FUNCTION Relation( nRelation )
           RETURN { DBRELATION(nRelation), ;
                 ALIAS(DBRSELECT(nRelation)) }

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBFILTER()" "DBRSELECT()" c52g_002.ngo:"SET RELATION" 
'------------------------------------------------------------------------------



!short: DBRSELECT()     Return the target work area number of a relation
'------------------------------------------------------------------------------
 ^bDBRSELECT()^b
 Return the target work area number of a relation
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBRSELECT(<nRelation>) --> nWorkArea

 ^bArguments^b

     ^b<nRelation>^b is the position of the desired relation in the list of
     current work area relations.  The relations are numbered according to
     the order in which they were defined with SET RELATION.

 ^bReturns^b

     DBRSELECT() returns the work area number of the relation specified by
     <nRelation> as an integer numeric value.  If there is no RELATION SET
     for <nRelation>, DBRSELECT() returns zero.

 ^bDescription^b

     DBRSELECT() is a database function used in combination with DBRELATION()
     to determine the work area and linking expression of an existing
     relation created with the SET RELATION command.  DBRSELECT() returns the
     work area defined by the INTO clause.  DBRELATION() returns the linking
     expression defined by the TO clause.  To determine the alias of the
     relation instead of the work area number, use the expression
     ALIAS(DBRSELECT(<nRelation>)).

     By default, DBRSELECT() operates on the currently selected work area.
     It will operate on an unselected work area if you specify it as part of
     an aliased expression (see example below).

 ^bExamples^b

     ^b^CFE^b  This example opens three database files, sets two child
        relations from the parent work area, then displays the linking
        expression to the second child work area as well as the target work
        area of the relation:

        USE Invoices INDEX Invoices NEW
        USE BackOrder INDEX BackOrder NEW
        USE Customer INDEX Customer NEW
        SET RELATION TO CustNum INTO Customer, ;
              OrderNum INTO BackOrder
        //
        ? DBRELATION(2), DBRSELECT(2)    // Result: OrderNum 3
        ? ALIAS(DBRSELECT(2))            // Result: BACKORDER

     ^b^CFE^b  Later, you can query the same information from an unselected
        work area by using an aliased expression:

        USE Archive NEW
        ? Customer->(DBRELATION(2))      // Result: OrderNum
        ? Customer->(DBRSELECT(2))       // Result: 3

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBFILTER()" "DBRELATION()" c52g_002.ngo:"SET RELATION" 
'------------------------------------------------------------------------------



!short: DBSEEK()        Move to the record having the specified key value
'------------------------------------------------------------------------------
 ^bDBSEEK()^b
 Move to the record having the specified key value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSEEK(<expKey>, [<lSoftSeek>]) --> lFound

 ^bArguments^b

     ^b<expKey>^b is a value of any type that specifies the key value
     associated with the desired record.

     ^b<lSoftSeek>^b is an optional logical value that specifies whether a
     soft seek is to be performed.  This determines how the work area is
     positioned if the specified key value is not found (see below).  If
     <lSoftSeek> is omitted, the current global _SET_SOFTSEEK setting is
     used.

 ^bReturns^b

     DBSEEK() returns true (.T.) if the specified key value was found;
     otherwise, it returns false (.F.).

 ^bDescription^b

     DBSEEK() moves to the first logical record whose key value is equal to
     <expKey>.  If such a record is found, it becomes the current record and
     DBSEEK() returns true (.T.).  Otherwise, DBSEEK() returns false (.F.)
     and the positioning of the work area is as follows: for a normal (not
     soft) seek, the work area is positioned to LASTREC() + 1 and EOF()
     returns true (.T.); for a soft seek, the work area is positioned to the
     first record whose key value is greater than the specified key value.
     If no such record exists, the work area is positioned to LASTREC() + 1
     and EOF() returns true (.T.).

     For a work area with no active indexes, DBSEEK() has no effect.

     DBSEEK() performs the same function as the standard SEEK command.  For
     more information, refer to the SEEK command.

 ^bNotes^b

     ^b^CFE  Logical records:^b DBSEEK() operates on logical records.
        Records are considered in indexed order.  If a filter is set, only
        records which meet the filter condition are considered.

     ^b^CFE  Controlling order:^b If the work area has more than one active
        index, the operation is performed using the controlling order as set
        by DBSETORDER() or the SET ORDER command.  For more information,
        refer to the SET ORDER command.

     ^b^CFE  Network environment:^b For a shared file on a network, moving to
        a different record may cause updates to the current record to become
        visible to other processes.  For more information, refer to the
        Network Programming chapter in the Programming and Utilities guide.

 ^bExamples^b

     ^b^CFE^b  In this example, DBSEEK() moves the pointer to the record in
        the database, Employee, in which the value in FIELD 밹Name matches
        the entered value of cName:

        ACCEPT "Employee name: " TO cName
        IF ( Employee->(DBSEEK(cName)) )
           Employee->(ViewRecord())
        ELSE
           ? "Not found"
        END

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBGOBOTTOM()" "DBGOTOP()" "DBSKIP()" "EOF()" "FOUND()" c52g_002.ngo:"SEEK" 
'------------------------------------------------------------------------------



!short: DBSELECTAR()    Change the current work area
'------------------------------------------------------------------------------
 ^bDBSELECTAREA()^b
 Change the current work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSELECTAREA(<nArea> | <cAlias>) --> NIL

 ^bArguments^b

     ^b<nArea>^b is a numeric value between zero and 250, inclusive, that
     specifies the work area being selected.

     ^b<cAlias>^b is a character value that specifies the alias of a
     currently occupied work area being selected.

 ^bReturns^b

     DBSELECTAREA() always returns NIL.

 ^bDescription^b

     DBSELECTAREA() causes the specified work area to become the current work
     area.  All subsequent database operations will apply to this work area
     unless another work area is explicitly specified for an operation.
     DBSELECTAREA() performs the same function as the standard SELECT
     command.  For more information, refer to the SELECT command.

 ^bNotes^b

     ^b^CFE  Selecting zero:^b Selecting work area zero causes the lowest
        numbered unoccupied work area to become the current work area.

     ^b^CFE  Aliased expressions:^b The alias operator (->) can temporarily
        select a work area while an expression is evaluated and automatically
        restore the previously selected work area afterward.  For more
        information, refer to the alias operator (->).

 ^bExamples^b

     ^b^CFE^b  The following example selects a work area via the alias name:

        cLast := "Winston"
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "SALEFNAM" )
        DBSETINDEX( "SALELNAM" )
        //
        DBUSEAREA( .T., "DBFNTX", "Colls", "Colls", .T. )
        DBSETINDEX( "COLLFNAM" )
        DBSETINDEX( "COLLLNAM" )
        //
        DBSELECTAREA( "Sales" )      // select "Sales" work area
        //
        IF ( Sales->(DBSEEK(cLast)) )
           IF Sales->( DELETED() ) .AND. Sales->( RLOCK() )
              Sales->( DBRECALL() )
              ? "Deleted record has been recalled."
           ENDIF
        ELSE
           ? "Not found"
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBUSEAREA()" c52g_002.ngo:"SELECT" "SELECT()" c52g_002.ngo:"USE" 
'------------------------------------------------------------------------------



!short: DBSETDRIVER()   Return the default database driver and set a new driver
'------------------------------------------------------------------------------
 ^bDBSETDRIVER()^b
 Return the default database driver and optionally set a new driver
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSETDRIVER([<cDriver>]) --> cCurrentDriver

 ^bArguments^b

     ^b<cDriver>^b is an optional character value that specifies the name of
     the database driver that should be used to activate and manage new work
     areas when no driver is explicitly specified.

 ^bReturns^b

     DBSETDRIVER() returns the name of the current default driver.

 ^bDescription^b

     DBSETDRIVER() sets the database driver to be used when activating new
     work areas without specifying a driver.  If the specified driver is not
     available to the application, the call has no effect.  DBSETDRIVER()
     returns the name of the current default driver, if any.

 ^bExamples^b

     ^b^CFE^b  This example makes the "DBFNDX" driver the default driver.  If
        the driver is unavailable, a message is issued:

        DBSETDRIVER("DBFNDX")
        IF ( DBSETDRIVER() <> "DBFNDX" )
           ? "DBFNDX driver not available"
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBUSEAREA()" c52g_002.ngo:"USE" 
'------------------------------------------------------------------------------



!short: DBSETFILTER()   Set a filter condition
'------------------------------------------------------------------------------
 ^bDBSETFILTER()^b
 Set a filter condition
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSETFILTER(<bCondition>, [<cCondition>]) --> NIL

 ^bArguments^b

     ^b<bCondition>^b is a code block that expresses the filter condition in
     executable form.

     ^b<cCondition>^b is an optional character value that expresses the
     filter condition in textual form.  If <cCondition> is omitted, the
     DBSETFILTER() function will return an empty string for the work area.

 ^bReturns^b

     DBSETFILTER() always returns NIL.

 ^bDescription^b

     DBSETFILTER() sets a logical filter condition for the current work area.
     When a filter is set, records which do not meet the filter condition are
     not logically visible.  That is, database operations which act on
     logical records will not consider these records.

     The filter expression supplied to DBSETFILTER() evaluates to true (.T.)
     if the current record meets the filter condition; otherwise, it should
     evaluate to false (.F.).

     The filter expression may be a code block (<bCondition>) or both a code
     block and equivalent text (<cCondition>).  If both versions are
     supplied, they must express the same condition.  If the text version is
     omitted, DBFILTER() will return an empty string for the work area.

     DBSETFILTER() performs the same function as the standard SET FILTER
     command.  For more information, refer to the SET FILTER command.

 ^bNotes^b

     ^b^CFE  Logical records:^b DBSETFILTER() affects the logical visibility
        of records (see above).

     ^b^CFE  Side effects:^b Setting a filter condition is only guaranteed to
        restrict visibility of certain records as described above.  The
        filter expression is not necessarily evaluated at any particular
        time, by any particular means, or on any particular record or series
        of records.  If the filter expression relies on information external
        to the database file or work area, the effect is unpredictable.  If
        the filter expression changes the state of the work area (e.g., by
        moving to a different record or changing the contents of a record),
        the effect is unpredictable.

     ^b^CFE  Evaluation context:^b When the filter expression is evaluated,
        the associated work area is automatically selected as the current
        work area before the evaluation; the previously selected work area is
        automatically restored afterward.

 ^bExamples^b

     ^b^CFE^b  This example limits data access to records in which the Age
        field value is less than 40:

        USE Employee NEW
        DBSETFILTER( {|| Age < 40}, "Age < 40" )
        DBGOTOP()

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBCLEARFIL()" "DBFILTER()" c52g_002.ngo:"SET DELETED" c52g_002.ngo:"SET FILTER" 
'------------------------------------------------------------------------------



!short: DBSETINDEX()    Open an index
'------------------------------------------------------------------------------
 ^bDBSETINDEX()^b
 Open an index
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSETINDEX(<cIndexName>) --> NIL

 ^bArguments^b

     ^b<cIndexName>^b is a character value that specifies the filename of the
     index file to be opened.

 ^bReturns^b

     DBSETINDEX() always returns NIL.

 ^bDescription^b

     DBSETINDEX() opens an index file for the current work area.  Any index
     files already associated with the work area continue to be active.  If
     the newly opened index is the only index associated with the work area,
     it becomes the controlling index; otherwise, the controlling order
     remains unchanged.

     After the new index file is opened, the work area is positioned to the
     first logical record in the controlling order.

     DBSETINDEX() performs the same function as the standard SET INDEX
     command or the INDEX clause of the USE command.  For more information,
     refer to the SET INDEX command.

 ^bNotes^b

     ^b^CFE  Logical records:^b Activating an index affects the logical order
        of records in the work area.  That is, when an index is active,
        commands which operate on logical records process records in indexed
        order.  If the controlling index is a unique index, records with
        duplicate index keys are not logically visible.

     ^b^CFE  Network environment:^b DBSETINDEX() opens the index for shared
        access if the associated database file was opened for shared access.
        Otherwise, the index opens for exclusive access.

 ^bExamples^b

     ^b^CFE^b  The following example sets multiple indexes:

        cLast := "Winston"
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "FIRSTNAM" )
        DBSETINDEX( "LASTNAME" )
        //
        IF ( Sales->(DBSEEK(cLast)) )
           IF Sales->( DELETED() ) .AND. Sales->( RLOCK() )

              Sales->( DBRECALL() )
              ? "Deleted record has been recalled."
           ENDIF
        ELSE
           ? "Not found"
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBCLEARIND()" "DBCREATEIND()" "DBREINDEX()" "DBSETORDER()" c52g_002.ngo:"SET INDEX" 
'------------------------------------------------------------------------------



!short: DBSETORDER()    Set the controlling order
'------------------------------------------------------------------------------
 ^bDBSETORDER()^b
 Set the controlling order
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSETORDER(<nOrderNum>) --> NIL

 ^bArguments^b

     ^b<nOrderNum>^b is a numeric value that specifies which of the active
     indexes is to be the controlling index.

 ^bReturns^b

     DBSETORDER() always returns NIL.

 ^bDescription^b

     DBSETORDER() controls which of the current work area's active indexes is
     the controlling index.  The controlling index is the index which
     determines the logical order of records in the work area.

     Active indexes are numbered from 1 to the number of active indexes,
     based on the order in which the indexes were opened.  <nOrderNum>
     specifies the number of the desired index.

     DBSETORDER() performs the same function as the standard SET ORDER
     command.  For more information, refer to the SET ORDER command.

 ^bNotes^b

     ^b^CFE  Setting order to zero:^b Setting order to zero causes the work
        area to be accessed in natural (record number) order.  Only the
        logical order of the records is affected; any open indexes continue
        to be active and are properly maintained.

 ^bExamples^b

     ^b^CFE^b  This example sets the second named index, Age, as the
        controlling index:

        USE Employee NEW
        SET INDEX TO Name, Age

        DBSETORDER(2)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBCLEARIND()" "DBCREATEIND()" "DBREINDEX()" "DBSETINDEX()" c52g_002.ngo:"SET ORDER" 
'------------------------------------------------------------------------------



!short: DBSETRELAT()    Relate two work areas
'------------------------------------------------------------------------------
 ^bDBSETRELATION()^b
 Relate two work areas
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSETRELATION(<nArea> | <cAlias>, <bExpr>, [<cExpr>])
     ^b   --> NIL

 ^bArguments^b

     ^b<nArea>^b is a numeric value that specifies the work area number of
     the child work area.

     ^b<cAlias>^b is a character value that specifies the alias of the child
     work area.

     ^b<bExpr>^b is a code block that expresses the relational expression in
     executable form.

     ^b<cExpr>^b is an optional character value that expresses the relational
     expression in textual form.  If <cExpr> is omitted, the DBRELATION()
     function returns an empty string for the relation.

 ^bReturns^b

     DBSETRELATION() always returns NIL.

 ^bDescription^b

     DBSETRELATION() relates the work area specified by <nArea> or <cAlias>
     (the child work area), to the current work area (the parent work area).
     Any existing relations remain active.

     Relating work areas synchronizes the child work area with the parent
     work area.  This is achieved by automatically repositioning the child
     work area whenever the parent work area moves to a new record.  If there
     is an active index in the child work area, moving the parent work area
     causes an automatic SEEK operation in the child work area; the seek key
     is based on the expression specified by <bExpr> and/or <cExpr>.  If the
     child work area has no active index, moving the parent work area causes
     an automatic GOTO in the child work area; the record number for the GOTO
     is based on the expression specified by <bExpr> and/or <cExpr>.

     The relational expression may be a code block (<bExpr>) or both a code
     block and equivalent text (<cExpr>).  If both versions are supplied,
     they must be equivalent.  If the text version is omitted, DBRELATION()
     will return an empty string for the relation.

     DBSETRELATION() performs the same function as the standard SET RELATION
     command with the ADDITIVE clause.  For more information, refer to the
     SET RELATION command.

 ^bNotes^b

     ^b^CFE  Side effects:^b DBSETRELATION() is only guaranteed to
        synchronize the work areas as described above.  The relational
        expression is not necessarily evaluated at any particular time, by
        any particular means, or on any particular record or series of
        records.  If the relational expression relies on information external
        to the parent work area or its associated database file, the effect
        is unpredictable.  If the expression changes the state of either work
        area (e.g., by moving to a different record or changing the contents
        of a record), the effect is unpredictable.

     ^b^CFE  Evaluation context:^b When the relational expression is
        evaluated, the parent work area is automatically selected as the
        current work area before the evaluation; the previously selected work
        area is automatically restored afterward.

     ^b^CFE  Soft seeking:^b Seek operations that occur as part of relational
        positioning are never soft seeks.  If a relational movement is
        unsuccessful, the child work area is positioned to LASTREC() + 1, its
        FOUND() status returns false (.F.), and its EOF() status returns true
        (.T.).

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a typical use of the DBSETRELATION()
        function:

        USE Employee NEW
        USE Department NEW INDEX Dept
        SELECT Employee
        DBSETRELATION("Department", {|| Employee->Dept},;
                        "Employee->Dept")
        LIST Employee->Name, Department->Name

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBCLEARREL()" "DBRELATION()" "DBRSELECT()" "FOUND()" c52g_002.ngo:"SET RELATION" 
'------------------------------------------------------------------------------



!short: DBSKIP()        Move relative to the current record
'------------------------------------------------------------------------------
 ^bDBSKIP()^b
 Move relative to the current record
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSKIP([<nRecords>]) --> NIL

 ^bArguments^b

     ^b<nRecords>^b is the number of logical records to move, relative to the
     current record.  A positive value means to skip forward, and a negative
     value means to skip backward.  If <nRecords> is omitted, a value of 1 is
     assumed.

 ^bReturns^b

     DBSKIP() always returns NIL.

 ^bDescription^b

     DBSKIP() moves either forward or backward relative to the current
     record.  Attempting to skip forward beyond the last record positions the
     work area to LASTREC() + 1 and EOF() returns true (.T.).  Attempting to
     skip backward beyond the first record positions the work area to the
     first record and BOF() returns true (.T.).

     DBSKIP() performs the same function as the standard SKIP command.  For
     more information, refer to the SKIP command.

 ^bNotes^b

     ^b^CFE  Logical records:^b DBSKIP() operates on logical records.  If
        there is an active index, records are considered in indexed order.
        If a filter is set, only records which meet the filter condition are
        considered.

     ^b^CFE  Controlling order:^b If the work area has more than one active
        index, the skip operation is performed using the controlling order as
        set by DBSETORDER() or the SET ORDER command.  For more information,
        refer to the SET ORDER command.

     ^b^CFE  Network environment:^b For a shared file on a network, moving to
        a different record may cause updates to the current record to become
        visible to other processes.  For more information, refer to the
        Network Programming chapter in the Programming and Utilities guide.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a typical use of the DBSKIP()
        function:

        DBGOTOP()
        DO WHILE ( !EOF() )
           ? FIELD->Name
           DBSKIP()
        ENDDO

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "BOF()" "DBGOBOTTOM()" "DBGOTOP()" "DBSEEK()" "EOF()" c52g_002.ngo:"SKIP" 
'------------------------------------------------------------------------------



!short: DBSTRUCT()      Create an array containing the structure of a database file
'------------------------------------------------------------------------------
 ^bDBSTRUCT()^b
 Create an array containing the structure of a database file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSTRUCT() --> aStruct

 ^bReturns^b

     DBSTRUCT() returns the structure of the current database file in an
     array whose length is equal to the number of fields in the database
     file.  Each element of the array is a subarray containing information
     for one field.  The subarrays have the following format:

     ^bDBSTRUCT() Return Array^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bPosition     Metasymbol     Dbstruct.ch^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     1            cName          DBS_NAME
     2            cType          DBS_TYPE
     3            nLength        DBS_LEN
     4            nDecimals      DBS_DEC
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     If there is no database file in USE in the current work area, DBSTRUCT()
     returns an empty array ({}).

 ^bDescription^b

     DBSTRUCT() is a database function that operates like COPY STRUCTURE
     EXTENDED by creating an array of structure information rather than a
     database file of structure information.  There is another function,
     DBCREATE(), that can create a database file from the structure array.

     By default, DBSTRUCT() operates on the currently selected work area.  It
     will operate on an unselected work area if you specify it as part of an
     aliased expression as shown below.

     Note, a header file, Dbstruct.ch, located in \CLIPPER5\INCLUDE contains
     a series of manifest constants for each field attribute.

 ^bExamples^b

     ^b^CFE^b  This example opens two database files then creates an array
        containing the database structure using DBSTRUCT() within an aliased
        expression.  The field names are then listed using AEVAL():

        #include "Dbstruct.ch"
        //
        LOCAL aStruct
        USE Customer NEW
        USE Invoices NEW
        //
        aStruct := Customer->(DBSTRUCT())
        AEVAL( aStruct, {|aField| QOUT(aField[DBS_NAME])} )

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Dbstruct.ch.
!seealso: "AFIELDS()*" c52g_002.ngo:"COPY STRU EXTE" 
'------------------------------------------------------------------------------



!short: DBUNLOCK()      Release all locks for the current work area
'------------------------------------------------------------------------------
 ^bDBUNLOCK()^b
 Release all locks for the current work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBUNLOCK() --> NIL

 ^bReturns^b

     DBUNLOCK() always returns NIL.

 ^bDescription^b

     DBUNLOCK() releases any record or file locks obtained by the current
     process for the current work area.  DBUNLOCK() is only meaningful on a
     shared database in a network environment.

     DBUNLOCK() performs the same function as the standard UNLOCK command.
     For more information, refer to the UNLOCK command.

 ^bNotes^b

     ^b^CFE  Network environment:^b Releasing locks may cause updates to the
        database to become visible to other processes.  For more information,
        refer to the Network Programming chapter in the Programming and
        Utilities guide.

 ^bExamples^b

     ^b^CFE^b  The following example illustrates a basic use of the
        DBUNLOCK() function:

        cLast := "Winston"
        USE Sales SHARED NEW VIA "DBFNTX"
        DBSETINDEX( "LASTNAME" )
        //
        IF ( Sales->(DBSEEK(cLast)) )
           IF Sales->( RLOCK() )
              Sales->( DBDELETE() )
              ? "Record deleted: ", Sales( DELETED() )
              Sales->( DBUNLOCK() )
           ELSE
              ? "Unable to lock record..."
           ENDIF
        ELSE
           ? "Not found"
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBUNLOCKALL()" "FLOCK()" "RLOCK()" c52g_002.ngo:"UNLOCK" 
'------------------------------------------------------------------------------



!short: DBUNLOCKALL()   Release all locks for all work areas
'------------------------------------------------------------------------------
 ^bDBUNLOCKALL()^b
 Release all locks for all work areas
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBUNLOCKALL() --> NIL

 ^bReturns^b

     DBUNLOCKALL() always returns NIL.

 ^bDescription^b

     DBUNLOCKALL() releases any record or file locks obtained by the current
     process for any work area.  DBUNLOCKALL() is only meaningful on a shared
     database in a network environment.  It is equivalent to calling
     DBUNLOCK() on every occupied work area.

     DBUNLOCKALL() performs the same function as the UNLOCK ALL command.  For
     more information, refer to the UNLOCK ALL command.

 ^bExamples^b

     ^b^CFE^b  The following example marks a record for deletion if an
        RLOCK() attempt is successful, then clears all locks in all work
        areas:

        cLast := "Winston"
        USE Sales SHARED NEW VIA "DBFNTX"
        DBSETINDEX( "SALEFNAM" )
        DBSETINDEX( "SALELNAM" )
        //
        USE Colls SHARED NEW VIA "DBFNTX"
        DBSETINDEX( "COLLFNAM" )
        DBSETINDEX( "COLLLNAM" )
        //
        DBSELECTAREA( "Sales" )     // select "Sales" work area
        //
        IF ( Colls->(DBSEEK(cLast)) )
           IF Colls->( DELETED() )
              ? "Record deleted: ", Colls->( DELETED() )
              IF Colls->( RLOCK() )
                 Colls->( DBRECALL() )
                 ? "Record recalled..."
              ENDIF
           ENDIF
        ELSE
           ? "Not found"
           DBUNLOCKALL()            // remove all locks in
        ENDIF                       // all work areas

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBUNLOCK()" "FLOCK()" "RLOCK()" c52g_002.ngo:"UNLOCK" 
'------------------------------------------------------------------------------



!short: DBUSEAREA()     Use a database file in a work area
'------------------------------------------------------------------------------
 ^bDBUSEAREA()^b
 Use a database file in a work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBUSEAREA( [<lNewArea>], [<cDriver>], <cName>, [<xcAlias>],
     ^b   [<lShared>], [<lReadonly>]) --> NIL

 ^bArguments^b

     ^b<lNewArea>^b is an optional logical value.  A value of true (.T.)
     selects the lowest numbered unoccupied work area as the current work
     area before the use operation.  If <lNewArea> is false (.F.) or omitted,
     the current work area is used; if the work area is occupied, it is
     closed first.

     ^b<cDriver>^b is an optional character value.  If present, it specifies
     the name of the database driver which will service the work area.  If
     <cDriver> is omitted, the current default driver is used (see note
     below).

     ^b<cName>^b specifies the name of the database (.dbf) file to be opened.

     ^b<xcAlias>^b is an optional character value.  If present, it specifies
     the alias to be associated with the work area.  The alias must
     constitute a valid CA-Clipper identifier.  A valid <xcAlias> may be any
     legal identifier (i.e., it must begin with an alphabetic character and
     may contain numeric or alphabetic characters and the underscore).
     Within a single application, CA-Clipper will not accept duplicate
     aliases.  If <xcAlias> is omitted, a default alias is constructed from
     <cName>.

     ^b<lShared>^b is an optional logical value.  If present, it specifies
     whether the database (.dbf) file should be accessible to other processes
     on a network.  A value of true (.T.) specifies that other processes
     should be allowed access; a value of false (.F.) specifies that the
     current process is to have exclusive access.  If <lShared> is omitted,
     the current global _SET_EXCLUSIVE setting determines whether shared
     access is allowed.

     ^b<lReadonly>^b is an optional logical value that specifies whether
     updates to the work area are prohibited.  A value of true (.T.)
     prohibits updates; a value of false (.F.) permits updates.  A value of
     true (.T.) also permits read-only access to the specified database
     (.dbf) file.  If <lReadonly> is omitted, the default value is false
     (.F.).

 ^bReturns^b

     DBUSEAREA() always returns NIL.

 ^bDescription^b

     DBUSEAREA() associates the specified database (.dbf) file with the
     current work area.

     DBUSEAREA() performs the same function as the standard USE command.  For
     more information, refer to the USE command.

 ^bNotes^b

     ^b^CFE  Current driver:^b If no driver is specified in the call to
        DBUSEAREA() the default driver is used.  If more than one driver is
        available to the application, the default driver is the driver
        specified in the most recent call to DBSETDRIVER().  If DBSETDRIVER()
        has not been called, the name of the default driver is undetermined.

 ^bExamples^b

     ^b^CFE^b  This example is a typical use of the DBUSEAREA() function:

        DBUSEAREA(.T., "DBFNDX", "Employees")

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBCLOSEAREA()" "DBSETDRIVER()" "SELECT()" "SET()" c52g_002.ngo:"USE" 
'------------------------------------------------------------------------------



!short: DELETED()       Return the deleted status of the current record
'------------------------------------------------------------------------------
 ^bDELETED()^b
 Return the deleted status of the current record
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDELETED() --> lDeleted

 ^bReturns^b

     DELETED() returns true (.T.) if the current record is marked for
     deletion; otherwise, it returns false (.F.).  If there is no database
     file in USE in the current work area, DELETED() returns false (.F.).

 ^bDescription^b

     DELETED() is a database function that determines if the current record
     in the active work area is marked for deletion.  Since each work area
     with an open database file can have a current record, each work area has
     its own DELETED() value.

     By default, DELETED() operates on the currently selected work area.  It
     will operate on an unselected work area if you specify it as part of an
     aliased expression (see example below).

     In applications, DELETED() is generally used to query the deleted status
     as a part of record processing conditions, or to display the deleted
     status as a part of screens and reports.

 ^bExamples^b

     ^b^CFE^b  This example uses DELETED() in the current and in an
        unselected work area:

        USE Customer NEW

        USE Sales NEW
        ? DELETED()                     // Result: .F.
        DELETE
        ? DELETED()                     // Result: .T.
        ? Customer->(DELETED())         // Result: .F.

     ^b^CFE^b  This example uses DELETED() to display a record's deleted
        status in screens and reports:

        @ 1, 65 SAY IF(DELETED(), "Inactive", "Active")

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"DELETE" c52g_002.ngo:"PACK" c52g_002.ngo:"RECALL" c52g_002.ngo:"SET DELETED" 
'------------------------------------------------------------------------------



!short: DESCEND()       Create a descending index key value
'------------------------------------------------------------------------------
 ^bDESCEND()^b
 Create a descending index key value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDESCEND(<exp>) --> ValueInverted

 ^bArguments^b

     ^b<exp>^b is any valid expression of character, date, logical, or
     numeric type.  Memo type is treated in the same way as character type.

 ^bReturns^b

     DESCEND() returns an inverted expression of the same data type as the
     <exp>, except for dates which return a numeric value.  A DESCEND() of
     CHR(0) always returns CHR(0).

 ^bDescription^b

     DESCEND() is a conversion function that returns the inverted form of the
     specified expression to be used with INDEX to create descending order
     indexes.  Specify that part of the index expression you want to be
     descending as the DESCEND() argument.  To subsequently perform a lookup
     with SEEK, specify DESCEND() in the search expression.

 ^bNotes^b

     ^b^CFE^b  The preferred way to create a descending index is to use the
        DESCENDing clause of the INDEX command.  Using DESCENDING is the same
        as specifying the DESCEND() function, but without the performance
        penalty during index updates.  If you create a DESCENDING index, you
        won't need to use the DESCEND() function during a SEEK.  DESCENDING
        is an attribute of the (.ntx) file, where it is stored and used for
        REINDEXing purposes.

 ^bExamples^b

     ^b^CFE^b  This example uses DESCEND() in an INDEX expression to create a
        descending order date index:

        USE Sales NEW
        INDEX ON DESCEND(OrdDate) TO SalesDate

        Later, use DESCEND() to SEEK on the descending index:

        SEEK DESCEND(dFindDate)

     ^b^CFE^b  This example illustrates how to create a descending order
        index using more than one data type.  Here, the key is created using
        the concatenation of date and character fields after the appropriate
        type conversion has taken place.  This example uses STR() instead of
        DTOS() since DESCEND() of a date returns a numeric value:

        USE Sales NEW
        INDEX ON STR(DESCEND(SaleDate)) + Salesman TO LastSale

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: c52g_002.ngo:"FIND*" c52g_002.ngo:"INDEX" c52g_002.ngo:"SEEK" 
'------------------------------------------------------------------------------



!short: DEVOUT()        Write a value to the current device
'------------------------------------------------------------------------------
 ^bDEVOUT()^b
 Write a value to the current device
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDEVOUT(<exp>, [<cColorString>]) --> NIL

 ^bArguments^b

     ^b<exp>^b is the value to display.

     ^b<cColorString>^b is an optional argument that defines the display
     color of <exp>.  If the current DEVICE setting is SCREEN, the output is
     displayed in the specified color.

     If not specified, <exp> is displayed as the standard color of the
     current system color as defined by SETCOLOR().  <cColorString> is a
     character expression containing the standard color setting.  If you want
     to specify a literal color setting, enclose it in quote marks.

 ^bReturns^b

     DEVOUT() always returns NIL.

 ^bDescription^b

     DEVOUT() is a full-screen display function that writes the value of a
     single expression to the current device at the current cursor or
     printhead position.  Use DEVOUT() with DEVPOS() in STD.CH to implement
     the @...SAY command.

 ^bExamples^b

     ^b^CFE^b  This example shows the relationship between the DEVOUT()
        function and the @...SAY command:

        DEVPOS(10, 10)
        DEVOUT("Hello there", "BG+/B"))
        //
        @ 10, 10 SAY "Hello there" COLOR "BG+/B"

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "COL()" "DEVPOS()" "QOUT()" "ROW()" "SETPOS()" c52g_010.ngo:"Colors" 
'------------------------------------------------------------------------------



!short: DEVOUTPICT()    Write a value to the current device using a picture clause
'------------------------------------------------------------------------------
 ^bDEVOUTPICT()^b
 Write a value to the current device using a picture clause
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDEVOUTPICT(<exp>, <cPicture>, [<cColorString>])
     ^b   --> NIL

 ^bArguments^b

     ^b<exp>^b is the value to display.

     ^b<cPicture>^b defines the formatting control for the display of <exp>.
     The picture specified here is the same as one used with @...SAY or
     TRANSFORM and can include both templates and functions.

     ^b<cColorString>^b is an optional argument that defines the display
     color of <exp>.  If the current DEVICE is SCREEN, output displays in the
     specified color.

     If not specified, <exp> displays as the standard color of the current
     system color as defined by SETCOLOR().  <cColorString> is a character
     expression containing the standard color setting.  If you want to
     specify a literal color setting, it must be enclosed in quote marks.

 ^bReturns^b

     DEVOUTPICT() always returns NIL.

 ^bDescription^b

     DEVOUTPICT() is a full-screen display function that writes the value of
     a single expression to the current device at the current cursor or
     printhead position.  DEVOUTPICT() is used in combination with DEVPOS()
     in STD.CH to implement the @...SAY command used with a PICTURE clause.

 ^bExamples^b

     ^b^CFE^b  This example shows the relationship between the DEVOUTPICT()
        function and the @...SAY command:

        DEVPOS(10, 10)

        DEVOUTPICT("Hello there", "@!", "BG+/B"))
        //
        @ 10, 10 SAY "Hello there" PICTURE "@!" COLOR "BG+/B"

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"@...SAY" "DEVOUT()" "DEVPOS()" "SETPOS()" "TRANSFORM()" c52g_010.ngo:"Colors" 
'------------------------------------------------------------------------------



!short: DEVPOS()        Move the cursor or printhead to a new position
'------------------------------------------------------------------------------
 ^bDEVPOS()^b
 Move the cursor or printhead to a new position depending on the current
 device
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDEVPOS(<nRow>, <nCol>) --> NIL

 ^bArguments^b

     ^b<nRow>^b and ^b<nCol>^b are the new row and column positions of the
     cursor or printhead.

 ^bReturns^b

     DEVPOS() always returns NIL.

 ^bDescription^b

     DEVPOS() is an environment function that moves the screen or printhead
     depending on the current DEVICE.  If DEVICE is SET to SCREEN, DEVPOS()
     behaves like SETPOS(), moves the cursor to the specified location, and
     updates ROW() and COL() with the new cursor position.

     If DEVICE is SET to PRINTER, DEVPOS() moves the printhead instead.  It
     does this by sending the number of linefeed and/or formfeed characters
     to the printer, advancing the printhead to the new position.  If the
     current SET MARGIN value is greater than zero, it is added to <nCol>.
     The printhead is then advanced to the specified <nRow> and <nCol>
     position and PROW() and PCOL() are updated.  If either <nRow> or <nCol>
     are less than the current PROW() and PCOL() values, the printhead is
     moved according to the following special rules:

     ^b^CFE^b  If <nRow> is less than PROW(), an automatic EJECT (CHR(12)) is
        sent to the printer followed by the number of linefeed characters
        (CHR(10)) required to position the printhead on <nRow> of the
        following page.

     ^b^CFE^b  If <nCol> including the current SET MARGIN value is less than
        PCOL(), a carriage return character (CHR(13)) and the number of space
        characters required to position the printhead at <nCol> are sent to
        the printer.

     To circumvent these rules, use SETPRC() to reset PROW() and PCOL() to
     new values before using DEVPOS().  See the SETPRC() discussion for more
     information.

     If the printer is redirected to a file using the SET PRINTER command,
     DEVPOS() updates the file instead of the printer.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"@...SAY" "DEVOUT()" "PCOL()" "PROW()" c52g_002.ngo:"SET DEVICE" "SETPOS()" 
'------------------------------------------------------------------------------



!short: DIRECTORY()     Create an array of directory and file information
'------------------------------------------------------------------------------
 ^bDIRECTORY()^b
 Create an array of directory and file information
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDIRECTORY(<cDirSpec>, [<cAttributes>]) --> aDirectory

 ^bArguments^b

     ^b<cDirSpec>^b identifies the drive, directory and file specification
     for the directory search.  Wildcards are allowed in the file
     specification.  If <cDirSpec> is omitted, the default value is *.*.

     ^b<cAttributes>^b specifies inclusion of files with special attributes
     in the returned information.  <cAttributes> is a string containing one
     or more of the following characters:

     ^bDIRECTORY() Attributes^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bAttribute    Meaning^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     H            Include hidden files
     S            Include system files
     D            Include directories
     V            Search for the DOS volume label and exclude all other files
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     Normal files are always included in the search, unless you specify V.

 ^bReturns^b

     DIRECTORY() returns an array of subarrays, with each subarray containing
     information about each file matching <cDirSpec>.  The subarray has the
     following structure:

     ^bDIRECTORY() Subarray Structure^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bPosition     Metasymbol     Directry.ch^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     1            cName          F_NAME
     2            cSize          F_SIZE
     3            dDate          F_DATE
     4            cTime          F_TIME
     5            cAttributes    F_ATT
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     If no files are found matching <cDirSpec> or if <cDirSpec> is an illegal
     path or file specification, DIRECTORY() returns an empty ({}) array.

 ^bDescription^b

     DIRECTORY() is an environment function that returns information about
     files in the current or specified directory.  It is similar to ADIR(),
     but returns a single array instead of adding values to a series of
     existing arrays passed by reference.

     Use DIRECTORY() to perform actions on groups of files.  In combination
     with AEVAL(), you can define a block that can be applied to all files
     matching the specified <cDirSpec>.

     The header file, Directry.ch, in \CLIPPER5\INCLUDE subdirectory contains
     #defines for the subarray subscripts so references to each file subarray
     is more readable.

 ^bExamples^b

     ^b^CFE^b  This example creates an array of information about files in
        the current directory and then lists the names of the files using
        AEVAL() and QOUT():

        #include "Directry.ch"
        //
        aDirectory := DIRECTORY("*.*", "D")
        AEVAL( aDirectory, {|aFile| QOUT(aFile[F_NAME])} )

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Directry.ch.
!seealso: "AEVAL()" "CURDIR()" 
'------------------------------------------------------------------------------



!short: DISKSPACE()     Return the space available on a specified disk
'------------------------------------------------------------------------------
 ^bDISKSPACE()^b
 Return the space available on a specified disk
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDISKSPACE([<nDrive>]) --> nBytes

 ^bArguments^b

     ^b<nDrive>^b is the number of the drive to query, where one is drive A,
     two is B, three is C, etc.  The default is the current DOS drive if
     <nDrive> is omitted or specified as zero.

 ^bReturns^b

     DISKSPACE() returns the number of bytes of empty space on the specified
     disk drive as an integer numeric value.

 ^bDescription^b

     DISKSPACE() is an environment function that determines the number of
     available bytes remaining on the specified disk drive.  It is useful
     when COPYing or SORTing to another drive to determine if there is enough
     space available before initiating the operation.  You may also use
     DISKSPACE() with RECSIZE() and RECCOUNT() to create a procedure to back
     up database files.

     DISKSPACE() ignores the SET DEFAULT drive setting.

 ^bExamples^b

     ^b^CFE^b  This example is a user-defined function that demonstrates the
        use of DISKSPACE() to back up a database file to another drive:

        FUNCTION BackUp( cTargetFile, cTargetDrive )
           LOCAL nSpaceNeeded, nTargetDrive
           //
           nSpaceNeeded := INT((RECSIZE() * ;
              LASTREC()) + HEADER() + 1)
           nTargetDrive := ASC(UPPER(cTargetDrive)) - 64
           //
           IF DISKSPACE(nTargetDrive) < nSpaceNeeded
              RETURN .F.
           ENDIF
           COPY TO (cTargetDrive + ":" + cTargetFile)
           //
           RETURN .T.

 ^bFiles:^b  Library is EXTEND.LIB, source file is EXAMPLEC.C.
!seealso: "LASTREC()" "LUPDATE()" "RECSIZE()" 
'------------------------------------------------------------------------------



!short: DISPBEGIN()     Begin buffering screen output                               ^r^CE4^r
'------------------------------------------------------------------------------
 ^bDISPBEGIN()^b
 Begin buffering screen output
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDISPBEGIN() --> NIL

 ^bReturns^b

     DISPBEGIN() always returns NIL.

 ^bDescription^b

     DISPBEGIN() is a screen function that informs the CA-Clipper display
     output system that the application is about to perform a series of
     display operations.

     Use DISPBEGIN() with DISPEND() to allow the display output system to
     buffer display updates.  Display output which occurs after DISPBEGIN()
     but before DISPEND() is allowed to accumulate in internal buffers.  When
     DISPEND() executes, any pending updates appear on the physical display.
     This is useful in applications where complex screen displays are slow
     and the appearance of performance is desired.

     DISPBEGIN() and DISPEND() calls are optional.  They are not required for
     normal output.

 ^bNotes^b

     ^b^CFE  Nested calls:^b DISPBEGIN() calls are nested internally.  If
        several DISPBEGIN() calls occur, buffering is allowed until a
        corresponding number of DISPEND() calls occur.

     ^b^CFE  Guaranteed operations:^b Display updates performed between
        DISPBEGIN() and DISPEND() are not guaranteed to be buffered--some
        updates may become visible before DISPEND() is called.  However, all
        updates are guaranteed to be visible after the closing call to
        DISPEND().

     ^b^CFE  Terminal operations:^b Terminal input operations such as INKEY()
        or READ should not be performed between DISPBEGIN() and DISPEND().
        Doing this may cause input or display output to be lost.

     ^b^CFE  Incompatible operations:^b Display output by other than the
        CA-Clipper display functions (e.g., by add-on libraries or by DOS via
        OUTSTD(), etc.) may not be compatible with DISPBEGIN() and DISPEND().
        Output may be lost.

 ^bExamples^b

     ^b^CFE^b  This example buffers screen output, updates the screen, then
        displays the buffered screen output:

        DISPBEGIN()            // Start screen buffering
        //
        SETPOS(10, 10)
        DISPOUT("A display update")
        SETPOS(11, 10)
        DISPOUT("Another display update")
        //
        DISPEND()              // Display buffered screen data

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DISPEND()" 
'------------------------------------------------------------------------------



!short: DISPBOX()       Display a box on the screen
'------------------------------------------------------------------------------
 ^bDISPBOX()^b
 Display a box on the screen
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDISPBOX(<nTop>, <nLeft>, <nBottom>, <nRight>,
     ^b   [<cnBoxString>], [<cColorString>]) --> NIL

 ^bArguments^b

     ^b<nTop>^b, ^b<nLeft>^b, ^b<nBottom>^b, and ^b<nRight>^b define the
     coordinates of the box.  DISPBOX() draws a box using row values from
     zero to MAXROW(), and column values from zero to MAXCOL().  If <nBottom>
     and <nRight> are larger than MAXROW() and MAXCOL(), the bottom-right
     corner is drawn off the screen.

     ^b<cnBoxString>^b is a numeric or character expression that defines the
     border characters of the box.  If specified as a numeric expression, a
     value of 1 displays a single-line box and a value of 2 displays a
     double-line box.  All other numeric values display a single-line box.

     If <cnBoxString> is a character expression, it specifies the characters
     to be used in drawing the box.  This is a string of eight border
     characters and a fill character.  If <cnBoxString> is specified as a
     single character, that character is used to draw the whole box.

     If this argument is not specified, a single-line box is drawn.

     ^b<cColorString>^b defines the display color of the box that is drawn.
     If not specified, the box is drawn using the standard color setting of
     the current system color as defined by SETCOLOR().

 ^bReturns^b

     DISPBOX() always returns NIL.

 ^bDescription^b

     DISPBOX() is a screen function that draws a box at the specified display
     coordinates in the specified color.  If you specify <cnBoxString>,
     DISPBOX() draws a box on the screen using configurable border and fill
     characters.  DISPBOX() draws the box using <cnBoxString> starting from
     the upper lefthand corner, proceeding clockwise and filling the screen
     region with the ninth character.  If the ninth character is not
     specified, the screen region within the box is not painted.  Existing
     text and color remain unchanged.

     After DISPBOX() executes, the cursor is located in the upper corner of
     the boxed region at <nTop> + 1 and <nLeft> + 1.  ROW() and COL() are
     also updated to reflect the new cursor position.

     Note that Box.ch, located in \INCLUDE, provides constants for various
     border configurations.

 ^bExamples^b

     ^b^CFE^b  This code example displays a double-line box using a numeric
        value to specify the box border:

        #define B_SINGLE   1
        #define B_DOUBLE   2
        //
        DISPBOX(1, 1, 10, 10, B_DOUBLE, "BG+/B")

     ^b^CFE^b  This example displays a single-line top and double-line side
        box by specifying border characters with a manifest constant defined
        in Box.ch:

        #include "Box.ch"
        //
        DISPBOX(1, 1, 10, 10, B_SINGLE_DOUBLE, "BG+/B")

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Box.ch.
!seealso: c52g_002.ngo:"@...BOX" c52g_002.ngo:"@...TO" c52g_013.ngo:"Box characters" c52g_010.ngo:"Colors" 
'------------------------------------------------------------------------------



!short: DISPCOUNT()     Return the number of pending DISPEND() requests             ^r^CE4^r
'------------------------------------------------------------------------------
 ^bDISPCOUNT()^b
 Return the number of pending DISPEND() requests
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDISPCOUNT() --> nDispCount

 ^bReturns^b

     DISPCOUNT() Returns the number of DISPEND() calls required to restore
     the original display context.

 ^bDescription^b

     You can use DISPCOUNT() to determine the current display context.
     CA-Clipper uses display contexts to buffer and and to supervise screen
     output operations.

     Each call to DISPBEGIN() defines a new display context.  Output to the
     display context is suppressed until a matching DISPEND() statement
     executes.

     Since you may nest DISPBEGIN() calls, use DISPCOUNT() to determine
     whether there are pending screen refresh requests.

 ^bExamples^b

     ^b^CFE^b  This example saves the setting of DISPCOUNT(), then releases
        all pending display contexts before writing to the screen:

        PROCEDURE ForceDisplay(cExp)
           LOCAL nSavCount

        nSavCount := DISPCOUNT()

        //  Discard pending display contexts
        DO WHILE ( DISPCOUNT() > 0)
           DISPEND()
        ENDDO

        DISPOUT(cExp)

        //  "Rewind" the current display context

        DO WHILE (DISPCOUNT() < nSavCount )
           DISPBEGIN()
        ENDDO

        RETURN

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DISPBEGIN()" "DISPEND()" 
'------------------------------------------------------------------------------



!short: DISPEND()       Display buffered screen updates                             ^r^CE4^r
'------------------------------------------------------------------------------
 ^bDISPEND()^b
 Display buffered screen updates
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDISPEND() --> NIL

 ^bReturns^b

     DISPEND() always returns NIL.

 ^bDescription^b

     DISPEND() is a screen function that informs the CA-Clipper display
     output system that the application has finished performing a series of
     display operations.

     DISPEND() is used in concert with DISPBEGIN() so the display output
     system can buffer display updates.  This can be important for
     applications in which complex screen displays are slow and the
     appearance of performance is desired.

     For more information, refer to DISPBEGIN()

 ^bExamples^b

     ^b^CFE^b  This example buffers screen output, updates the screen, then
        displays the buffered screen output:

        DISPBEGIN()            // Start screen buffering
        //
        SETPOS(10, 10)
        DISPOUT("A display update")
        SETPOS(11, 10)
        DISPOUT("Another display update")
        //
        DISPEND()              // Display buffered screen data

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DISPBEGIN()" 
'------------------------------------------------------------------------------



!short: DISPOUT()       Write a value to the display
'------------------------------------------------------------------------------
 ^bDISPOUT()^b
 Write a value to the display
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDISPOUT(<exp>, [<cColorString>]) --> NIL

 ^bArguments^b

     ^b<exp>^b is the value to display.

     ^b<cColorString>^b is an optional argument that defines the display
     color of <exp>.  If unspecified, <exp> is displayed as the standard
     color of the current system color as defined by SETCOLOR().
     <cColorString> is a character expression containing the standard color
     setting.  You can specify a literal color setting, if you enclose it in
     quote marks.

 ^bReturns^b


     DISPOUT() always returns NIL.

 ^bDescription^b

     DISPOUT() is a simple output function that writes the value of a single
     expression to the display at the current cursor position.  This function
     ignores the SET DEVICE setting; output always goes to the screen.  You
     can only use this function within a procedure or function.

 ^bExamples^b

     ^b^CFE^b  This example performs screen output at a specified location in
        different colors.  Note how the cursor position is saved and restored
        using ROW(), COL(), and SETPOS():

        PROCEDURE Showit
           LOCAL nRow, nCol
           ? nCol := COL()           // save original
           ?? nRow := ROW()          // cursor position

           INKEY(2)

           SETPOS(nRow, nCol)
           DISPOUT("This is a test of DISPOUT()")
           ? COL()                   // display current
           ?? ROW()                  // cursor position

           INKEY(2)

           SETPOS(nRow, nCol)
           DISPOUT(space(26))        // clear original position
           SET DEVICE TO PRINTER     // ignores SET DEVICE
           SETPOS(nRow, nCol)        // display at
           DISPOUT("           all through")
                                     // original position


           RETURN

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "COL()" "OUTSTD()" "QOUT()" "ROW()" "SETPOS()" c52g_010.ngo:"Colors" 
'------------------------------------------------------------------------------



!short: DOSERROR()      Return the last DOS error number
'------------------------------------------------------------------------------
 ^bDOSERROR()^b
 Return the last DOS error number
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDOSERROR([<nNewOsCode>]) --> nOsCode

 ^bArguments^b

     ^b<nNewOsCode>,^b if specified, alters the value returned by DOSERROR().
     The value must be a numeric value that reflects a DOS error number.

 ^bReturns^b

     DOSERROR() returns the DOS error number as an integer numeric value.

 ^bDescription^b

     DOSERROR() is an error function that returns the last DOS error code
     associated with an activation of the runtime error block.  When a
     runtime error occurs, the DOSERROR() function is set to the current DOS
     error if the operation has an associated DOS error.  The function value
     is retained until another runtime error occurs.  If the failed operation
     has no associated DOS error, the DOSERROR() returns zero.  With
     low-level file functions, FERROR() returns the same value as DOSERROR().

     Through use of the optional <nNewOsCode>, you may customize to the
     reporting activation, the returned value for any DOS error.

     For a complete list of DOS error numbers and accompanying descriptions,
     refer to the Error Messages and Appendices guide.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ERRORBLOCK()" "FERROR()" 
'------------------------------------------------------------------------------



!short: DOW()           Convert a date value to a numeric day of the week
'------------------------------------------------------------------------------
 ^bDOW()^b
 Convert a date value to a numeric day of the week
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDOW(<dDate>) --> nDay

 ^bArguments^b

     ^b<dDate>^b is a date value to convert.

 ^bReturns^b

     DOW() returns the day of the week as a number between zero and seven.
     The first day of the week is one (Sunday) and the last day is seven
     (Saturday).  If <dDate> is empty, DOW() returns zero.

 ^bDescription^b

     DOW() is a date conversion function that converts a date value to a
     number identifying the day of the week.  It is useful when you want date
     calculations on a weekly basis.  DOW() is similar to CDOW() which
     returns the day of week as a character string instead of a number.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate CDOW() and its relationship to
        DOW():

        ? DATE()                      // Result: 09/01/89
        ? DOW(DATE())                 // Result: 3
        ? CDOW(DATE())                // Result: Tuesday
        ? DOW(DATE() - 2)             // Result: 1
        ? CDOW(DATE() - 2)            // Result: Sunday

     ^b^CFE^b  This is a user-defined function that uses DOW() to calculate
        the date of last Monday from any other date:

        FUNCTION LastMonday(dDate)
           RETURN (dDate - DOW(dDate) + 2)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CDOW()" "DATE()" "DAY()" 
'------------------------------------------------------------------------------



!short: DTOC()          Convert a date value to a character string
'------------------------------------------------------------------------------
 ^bDTOC()^b
 Convert a date value to a character string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDTOC(<dDate>) --> cDate

 ^bArguments^b

     ^b<dDate>^b is the date value to convert.

 ^bReturns^b

     DTOC() returns a character string representation of a date value.  The
     return value is formatted in the current date format.  The default
     format is mm/dd/yy.  A null date returns a string of spaces equal in
     length to the current date format.

 ^bDescription^b

     DTOC() is a date conversion function used for formatting purposes when
     you want to display the date in the SET DATE format when a character
     expression is required (in a LABEL FORM, for example).  If you need a
     specialized date format, you can use TRANSFORM() or a custom expression.

     If you are INDEXing a date in combination with a character string, use
     DTOS() instead of DTOC() to convert the date value to a character
     string.

 ^bExamples^b

     ^b^CFE^b  These examples show general uses of DTOC():

        ? DATE()                       // Result: 09/01/90
        ? DTOC(DATE())                 // Result: 09/01/90
        ? "Today is " + DTOC(DATE())
                                       // Result: Today is 09/01/90

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CTOD()" "DATE()" "DTOS()" c52g_002.ngo:"SET CENTURY" c52g_002.ngo:"SET DATE" 
'------------------------------------------------------------------------------



!short: DTOS()          Convert a date value to a string formatted as yyyymmdd
'------------------------------------------------------------------------------
 ^bDTOS()^b
 Convert a date value to a character string formatted as yyyymmdd
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDTOS(<dDate>) --> cDate

 ^bArguments^b

     ^b<dDate>^b is the date value to convert.

 ^bReturns^b

     DTOS() returns a character string eight characters long in the form,
     yyyymmdd.  When <dDate> is a null date (CTOD("")), DTOS() returns a
     string of eight spaces.  The return value is not affected by the current
     date format.

 ^bDescription^b

     DTOS() is a date conversion function that is used when creating index
     expressions consisting of a date value and a character expression.
     DTOS() converts a date value to a character string that can be
     concatenated to any other character expression.  The return value is
     structured to preserve date order (year, month, and day).

 ^bExamples^b

     ^b^CFE^b  These examples illustrate DTOS() in conjunction with several
        other functions:

        ? DATE()                      // Result: 09/01/90
        ? DTOS(DATE())                // Result: 19900901
        ? LEN(DTOS(CTOD("")))         // Result: 8

     ^b^CFE^b  This example demonstrates how to create an index with a
        compound date and character key using DTOS():

        USE Sales NEW
        INDEX ON DTOS(Date) + Salesman TO DateName

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CTOD()" "DATE()" "DTOC()" c52g_002.ngo:"INDEX" 
'------------------------------------------------------------------------------



!short: EMPTY()         Determine if the result of an expression is empty
'------------------------------------------------------------------------------
 ^bEMPTY()^b
 Determine if the result of an expression is empty
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bEMPTY(<exp>) --> lEmpty

 ^bArguments^b

     ^b<exp>^b is an expression of any data type.

 ^bReturns^b

     EMPTY() returns true (.T.) if the expression results in an empty value;
     otherwise, it returns false (.F.).  The criteria for determining whether
     a value is considered empty depends on the data type of <exp> according
     to the following rules:

     ^bList of Empty Values^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bData Type    Contents^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Array        Zero-length
     Character    Spaces, tabs, CR/LF, or ("")
     Numeric      0
     Date         Null(CTOD(""))
     Logical      False (.F.)
     Memo         Same as character
     NIL          NIL
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bDescription^b

     The EMPTY() function has a number of uses.  You can use it to determine
     if a user entered a value into a GET object before committing changes to
     a database file.  It can also determine whether a formal parameter is
     NIL or unsupplied.  In addition, it can test an array for zero-length.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate use of EMPTY() against several
        different data types:

        ? EMPTY(SPACE(5)), EMPTY("")        // Result: .T. .T.
        ? EMPTY(0), EMPTY(CTOD(""))         // Result: .T. .T.
        ? EMPTY(.F.), EMPTY(NIL)            // Result: .T. .T.

     ^b^CFE^b  This example uses EMPTY() to determine whether the user
        entered a value into the first Get object before writing the new
        value to the database file:

        LOCAL cCust := SPACE(15), nAmount := 0
        USE Sales NEW
        @ 10, 10 GET cCust
        @ 11, 10 GET nAmount PICTURE "999.99"
        READ
        //
        IF !EMPTY(cCust)
           APPEND BLANK
           REPLACE Sales->Cust WITH cCust, Sales->Amount ;
              WITH nAmount
        ENDIF

     ^b^CFE^b  This example uses EMPTY() as part of the VALID clause to force
        the user to enter data into the current Get object:

        LOCAL cCode := SPACE(5)
        @ 2, 5 SAY "Enter code" GET cCode VALID !EMPTY(cCode)
        READ

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "LEN()" 
'------------------------------------------------------------------------------



!short: EOF()           Determine when end of file is encountered
'------------------------------------------------------------------------------
 ^bEOF()^b
 Determine when end of file is encountered
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bEOF() --> lBoundary

 ^bReturns^b

     EOF() returns true (.T.) when an attempt is made to move the record
     pointer beyond the last logical record in a database file; otherwise, it
     returns false (.F.).  If there is no database file open in the current
     work area, EOF() returns false (.F.).  If the current database file
     contains no records, EOF() returns true (.T.).

 ^bDescription^b

     EOF() is a database function used to test for an end of file boundary
     condition when the record pointer is moving forward through a database
     file.  Any command that can move the record pointer can set EOF().

     The most typical application is as a part of the <lCondition> argument
     of a DO WHILE construct that sequentially processes records in a
     database file.  Here <lCondition> would include a test for .NOT. EOF(),
     forcing the DO WHILE loop to terminate when EOF() returns true (.T.).

     EOF() and FOUND() are often used interchangeably to test whether a SEEK,
     FIND, or LOCATE command failed.  With these commands, however, FOUND()
     is preferred.

     When EOF() returns true (.T.), the record pointer is positioned at
     LASTREC() + 1 regardless of whether there is an active SET FILTER or SET
     DELETED is ON.  Further attempts to move the record pointer forward
     return the same result without error.  Once EOF() is set to true (.T.),
     it retains its value until there is another attempt to move the record
     pointer.

     By default, EOF() operates on the currently selected work area.  It can
     be made to operate on an unselected work area by specifying it within an
     aliased expression (see example below).

 ^bExamples^b

     ^b^CFE^b  This example demonstrates EOF() by deliberately moving the
        record pointer beyond the last record:

        USE Sales
        GO BOTTOM
        ? EOF()            // Result: .F.
        SKIP
        ? EOF()            // Result: .T.

     ^b^CFE^b  This example uses aliased expressions to query the value of
        EOF() in unselected work areas:

        USE Sales NEW
        USE Customer NEW
        ? Sales->(EOF())
        ? Customer->(EOF())

     ^b^CFE^b  This example illustrates how EOF() can be used as part of a
        condition for sequential database file operations:

        USE Sales INDEX CustNum NEW
        DO WHILE !EOF()
           nOldCust := Sales->CustNum
           nTotalAmount := 0
           DO WHILE nOldCust = Sales->CustNum .AND. (!EOF())
              ? Sales->CustNum, Sales->Description, ;
                    Sales->SaleAmount
              nTotalAmount += Sales->SaleAmount
              SKIP
           ENDDO
           ? "Total amount: ", nTotalAmount
        ENDDO

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "BOF()" "FOUND()" c52g_002.ngo:"GO" "LASTREC()" c52g_002.ngo:"LOCATE" c52g_002.ngo:"SEEK" c52g_002.ngo:"SKIP" 
'------------------------------------------------------------------------------



!short: ERRORBLOCK()    Post a code block to execute when a runtime error occurs
'------------------------------------------------------------------------------
 ^bERRORBLOCK()^b
 Post a code block to execute when a runtime error occurs
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bERRORBLOCK([<bErrorHandler>]) --> bCurrentErrorHandler

 ^bArguments^b

     ^b<bErrorHandler>^b is the code block to execute whenever a runtime
     error occurs.  When evaluated, the <bErrorHandler> is passed an error
     object as an argument by the system.

 ^bReturns^b

     ERRORBLOCK() returns the current error handling code block.  If no error
     handling block has been posted since the program was invoked,
     ERRORBLOCK() returns the default error handling block.

 ^bDescription^b

     ERRORBLOCK() is an error function that defines an error handler to
     execute whenever a runtime error occurs.  Specify the error handler as a
     code block with the following form:

     { |<objError>| <expression list>,... }

     Where <objError> is an error object containing information about the
     error.  Within the code block, messages can be sent to the error object
     to obtain information about the error.  Returning true (.T.) from the
     error handling block retries the failed operation and false (.F.)
     resumes processing.

     The error handling code block can be specified either as a list of
     expressions or as a call to a user-defined function.  A call to a
     user-defined function is more useful since you can use CA-Clipper
     control statements instead of expressions.  This is particularly the
     case if there is a BEGIN SEQUENCE pending and you want to BREAK to the
     nearest RECOVER statement.

     As this implies, error handling blocks can be used in combination with
     BEGIN SEQUENCE...END control structures.  Within an error handling
     block, you handle device, low-level, and common errors that have a
     general recovery mechanism.  If the operation needs specific error
     handling, define a BEGIN SEQUENCE then BREAK to the RECOVER statement,
     returning the error object for local processing.  See the example below.

     If no <bErrorHandler> has been specified using ERRORBLOCK() and a
     runtime error occurs, the default error handling block is evaluated.
     This error handler displays a descriptive message to the screen, sets
     the ERRORLEVEL() to 1, then QUITs the program.

     Since ERRORBLOCK() returns the current error handling block, it is
     possible to specify an error handling block for an operation saving the
     current error handling block, then restore it after the operation has
     completed.  Also, error handlers specified as code blocks, can be passed
     to procedures and user-defined functions, and RETURNed as values.

     For more information on the structure and operations of error objects,
     refer to the Error class entry in this chapter and the Error Handling
     Strategies chapter in the Programming and Utilities guide.

 ^bExamples^b

     ^b^CFE^b  This code fragment posts, then calls an error handling block
        when there is an error within a BEGIN SEQUENCE construct:

        LOCAL bErrorHandler, bLastHandler, objErr
        bErrorHandler := { |objError| ;
              MyErrorHandler(objError) }
        //
        // Save current handler
        bLastHandler := ERRORBLOCK(bErrorHandler)
        //
        BEGIN SEQUENCE
           .
           . <operation statements>
           .
        // Receive error object from BREAK
        RECOVER USING objErrorInfo
           .
           . <recovery statements>
           .
        END
        ERRORBLOCK(bLastHandler)   // Restore handler
        RETURN

        FUNCTION MyErrorHandler( objError )
           //
           BREAK objError          // Return error object to RECOVER
           RETURN NIL

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_004.ngo:"BEGIN SEQUENCE" 
'------------------------------------------------------------------------------



!short: ERRORLEVEL()    Set the CA-Clipper return code
'------------------------------------------------------------------------------
 ^bERRORLEVEL()^b
 Set the CA-Clipper return code
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bERRORLEVEL([<nNewReturnCode>]) --> nCurrentReturnCode

 ^bArguments^b

     ^b<nNewReturnCode>^b is the new return code setting.  This can be a
     value between zero and 255.  The default value at startup is zero.  If
     not specified, ERRORLEVEL() reports the current setting without
     assigning a new value.

 ^bReturns^b

     ERRORLEVEL() returns the current CA-Clipper exit code as a numeric
     value, if one has been set using ERRORLEVEL() with an argument;
     otherwise, it returns zero.

 ^bDescription^b

     ERRORLEVEL() is a dual purpose environment function.  It returns the
     current CA-Clipper return code and optionally sets a new return code.
     The return code is a value set by a child process so the parent process
     can test the termination state of the child process.  Typically, the
     parent process is DOS and the child process is an application program.
     Retrieve a return code with the DOS ERRORLEVEL command or INT 21
     Function 4Dh.

     When a CA-Clipper program terminates, the return code is set to 1 if the
     process ends with a fatal error.  If the process ends normally, the
     return code is set to zero, or the last ERRORLEVEL() set in the program.

     Typically, you would set a return code with ERRORLEVEL() to indicate an
     error state to the program that invoked the current CA-Clipper program.
     In most cases this is the application batch file.  Here you would test
     the return code using the DOS ERRORLEVEL command.  Refer to your DOS
     manual for more information.

 ^bNotes^b

     ^b^CFE^b  ERRORLEVEL() is not updated after a RUN command terminates.
        To obtain the return code of the invoked program, you must create an
        assembler or C routine that queries the child process return code
        using INT 21 Function 4Dh.  Refer to your DOS Technical Reference
        manual for more information.

 ^bExamples^b

     ^b^CFE^b  This example saves the current CA-Clipper return code, then
        sets a new value:

        nOldCode := ERRORLEVEL()      // Get current error level
        ERRORLEVEL(1)                 // Set new error level

     ^b^CFE^b  This example uses ERRORLEVEL() to set a return code that can
        be tested by the parent process:

        #define ERR_FILE_MISSING      255
        #define ERR_POST_INCOMPLETE   254
        //
        IF !FILE("Sysfile.dbf")
           @ 0, 0
           @ 1, 0
           @ 0, 0 SAY "Fatal error: System ;
                       file is missing...quitting"
           ERRORLEVEL(ERR_FILE_MISSING)
           QUIT
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"QUIT" 
'------------------------------------------------------------------------------



!short: EVAL()          Evaluate a code block
'------------------------------------------------------------------------------
 ^bEVAL()^b
 Evaluate a code block
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bEVAL(<bBlock>, [<BlockArg list>]) --> LastBlockValue

 ^bArguments^b

     ^b<bBlock>^b is the code block to evaluate.

     ^b<BlockArg list>^b is a list of arguments to send to the code block
     before it is evaluated.

 ^bReturns^b

     EVAL() returns the value of the last expression within the block.  A
     code block can return a value of any type.

 ^bDescription^b

     EVAL() is a code block function.  It is the most basic code block
     evaluation facility in the CA-Clipper system.  A code block is a special
     data value that refers to a piece of compiled program code.  For more
     information on code blocks, refer to the Basic Concepts chapter in the
     Programming and Utilities guide.

     To execute or evaluate a code block, call EVAL() with the block value
     and any parameters.  The parameters are supplied to the block when it is
     executed.  Code blocks may be a series of expressions separated by
     commas.  When a code block is evaluated, the returned value is the value
     of the last expression in the block.

     The CA-Clipper compiler usually compiles a code block at compile time.
     There are, however, occasions at runtime, when you may need to compile a
     code block from a character string.  You can do this by using the macro
     operator (&).

     EVAL() is often used to create iterator functions.  These are functions
     that apply a block to each member of a data structure.  AEVAL(),
     ASORT(), ASCAN(), and DBEVAL() are iterator functions (e.g., AEVAL()
     applies a block to each element within an array).

 ^bExamples^b

     ^b^CFE^b  This example creates a code block that increments a number
        then evaluates it:

        bBlock := { |nArg| nArg + 1 }
        ? EVAL(bBlock, 1)                     // Result: 2

     ^b^CFE^b  This example demonstrates compiling a code block at runtime
        using the macro operator (&):

        // Compile a string to a block
        bBlock := &("{ |nArg| nArg + 1 }")

        // Evaluate the block
        ? EVAL(bBlock, 1)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "AEVAL()" "ASCAN()" "ASORT()" "DBEVAL()" 
'------------------------------------------------------------------------------



!short: EXP()           Calculate e**x
'------------------------------------------------------------------------------
 ^bEXP()^b
 Calculate e**x
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bEXP(<nExponent>) --> nAntilogarithm

 ^bArguments^b

     ^b<nExponent>^b is the natural logarithm for which a numeric value is to
     be calculated.

 ^bReturns^b

     EXP() returns a numeric value that is equivalent to the value e raised
     to the specified power.

 ^bDescription^b

     EXP() is a mathematical function that calculates the value, y, (the
     antilogarithm) of the following equation:

     ^be**x = y

     Where e is the base of natural logarithms (2.71828...) and x is
     <nExponent>.  The maximum value of <nExponent> is 45 before a numeric
     overflow occurs.  EXP() and LOG() are inverse functions.

     The number of decimal places displayed is determined solely by SET
     DECIMALS regardless of the current SET FIXED value.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates several invocations of EXP():

        ? EXP(1)                      // Result: 2.72
        SET DECIMALS TO 10
        ? EXP(1)                      // Result: 2.7182818285
        ? LOG(EXP(1))                 // Result: 1.0000000000

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "LOG()" c52g_002.ngo:"SET DECIMALS" c52g_002.ngo:"SET FIXED" 
'------------------------------------------------------------------------------



!short: FCLOSE()        Close an open binary file and write DOS buffers to disk
'------------------------------------------------------------------------------
 ^bFCLOSE()^b
 Close an open binary file and write DOS buffers to disk
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFCLOSE(<nHandle>) --> lError

 ^bArguments^b

     ^b<nHandle>^b is the file handle obtained previously from FOPEN() or
     FCREATE().

 ^bReturns^b

     FCLOSE() returns false (.F.) if an error occurs while writing;
     otherwise, it returns true (.T.).

 ^bDescription^b

     FCLOSE() is a low-level file function that closes binary files and
     forces the associated DOS buffers to be written to disk.  If the
     operation fails, FCLOSE() returns false (.F.).  FERROR() can then be
     used to determine the reason for the failure.  For example, attempting
     to use FCLOSE() with an invalid handle returns false (.F.), and FERROR()
     returns DOS error 6, invalid handle.  See FERROR() for a complete list
     of error numbers.

     ^bWarning!^b  This function allows low-level access to DOS files and
     devices.  It should be used with extreme care and requires a thorough
     knowledge of the operating system.

 ^bExamples^b

     ^b^CFE^b  This example uses FCLOSE() to close a newly created binary
        file and displays an error message if the close fails:

        #include "Fileio.ch"
        //
        nHandle := FCREATE("Testfile", FC_NORMAL)
        IF !FCLOSE(nHandle)
           ? "Error closing file, error number: ", FERROR()
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "FCREATE()" "FERROR()" "FOPEN()" 
'------------------------------------------------------------------------------



!short: FCOUNT()        Return the number of fields in the current (.dbf) file
'------------------------------------------------------------------------------
 ^bFCOUNT()^b
 Return the number of fields in the current (.dbf) file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFCOUNT() --> nFields

 ^bReturns^b

     FCOUNT() returns the number of fields in the database file in the
     current work area as an integer numeric value.  If there is no database
     file open, FCOUNT() returns zero.

 ^bDescription^b

     FCOUNT() is a database function.  It is useful in applications
     containing data-independent programs that can operate on any database
     file.  These include generalized import/export and reporting programs.
     Typically, you use FCOUNT() to establish the upper limit of a FOR...NEXT
     or DO WHILE loop that processes a single field at a time.

     By default, FCOUNT() operates on the currently selected work area.

 ^bExamples^b

     ^b^CFE^b  This example illustrates FCOUNT(), returning the number of
        fields in the current and an unselected work area:

        USE Sales NEW
        USE Customer NEW
        ? FCOUNT()                     // Result: 5
        ? Sales->(FCOUNT())            // Result: 8

     ^b^CFE^b  This example uses FCOUNT() to DECLARE an array with field
        information:

        LOCAL aFields := ARRAY(FCOUNT())
        AFIELDS(aFields)

     ^b^CFE^b  This example uses FCOUNT() as the upper boundary of a FOR loop
        that processes the list of current work area fields:

        LOCAL nField
        USE Sales NEW
        FOR nField := 1 TO FCOUNT()
           ? FIELD(nField)
        NEXT

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "FIELDNAME()" "TYPE()" 
'------------------------------------------------------------------------------



!short: FCREATE()       Create and/or truncate a binary file to zero-length
'------------------------------------------------------------------------------
 ^bFCREATE()^b
 Create and/or truncate a binary file to zero-length
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFCREATE(<cFile>, [<nAttribute>]) --> nHandle

 ^bArguments^b

     ^b<cFile>^b is the name of the file to create.  If the file already
     exists, its length is truncated to zero without warning.

     ^b<nAttribute>^b is one of the binary file attributes shown in the table
     below.  If this argument is omitted, the default value is zero.

     ^bBinary File Attributes^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bValue   Fileio.ch     Attribute  Description^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     0       FC_NORMAL     Normal     Create normal read/write file (default)
     1       FC_READONLY   Read-only  Create read-only file
     2       FC_HIDDEN     Hidden     Create hidden file
     4       FC_SYSTEM     System     Create system file
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bReturns^b

     FCREATE() returns the DOS file handle number of the new binary file in
     the range of zero to 65,535.   If an error occurs, FCREATE() returns  -1
     and FERROR() is set to indicate an error code.

 ^bDescription^b

     FCREATE() is a low-level file function that either creates a new file or
     opens and truncates an existing file.  If <cFile> does not exist, it is
     created and opened for writing.  If it does exist and can be opened for
     writing, it is truncated to zero-length.  If it cannot be opened for
     writing, FCREATE() returns -1 and FERROR() returns the appropriate error
     value.

     When FCREATE() successfully creates a new file, the file is left open in
     compatibility sharing mode and read/write access mode.  The file
     attribute specified by the <nAttribute> argument is applied to the new
     file when it is closed, allowing writing to a newly created read-only
     file.  For a list of access modes, see FOPEN().

     Since a file handle is required in order to identify an open file to
     other file functions, always assign the return value from FCREATE() to a
     variable for later use.

     Like other file functions, FCREATE() does not use either the DEFAULT or
     PATH settings for its operation.  Instead, it writes to the current DOS
     directory unless a path is explicitly stated.

     ^bWarning! ^b This function allows low-level access to DOS files and
     devices.  It should be used with extreme care and requires a thorough
     knowledge of the operating system.

 ^bExamples^b

     ^b^CFE^b  This example creates a file called Testfile and opens it for
        reading and writing:

        #include "Fileio.ch"

        //
        IF (nHandle := FCREATE("Testfile", FC_NORMAL)) == -1
           ? "File cannot be created:", FERROR()
           BREAK
        ELSE
           FWRITE(nHandle, "Hello there")
           FCLOSE(nHandle)
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Fileio.ch.
!seealso: "FCLOSE()" "FERROR()" "FOPEN()" 
'------------------------------------------------------------------------------



!short: FERASE()        Delete a file from disk
'------------------------------------------------------------------------------
 ^bFERASE()^b
 Delete a file from disk
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFERASE(<cFile>) --> nSuccess

 ^bArguments^b

     ^b<cFile>^b is the name of the file to be deleted from disk, including
     extension, optionally preceded by a drive and/or path specification.

 ^bReturns^b

     FERASE() returns -1 if the operation fails and zero if it succeeds.  In
     the case of a failure, FERROR() can be used to determine the nature of
     the error.

 ^bDescription^b

     FERASE() is a file function that deletes a specified file from disk.
     FERASE() is the same as the ERASE command but returns a value and can be
     specified within an expression.  When FERASE() is called, <cFile> is
     deleted from disk only if found in the current DOS directory or in the
     directory explicitly specified as part of the filename.  Like the other
     file functions and commands, FERASE() does not use either SET DEFAULT or
     SET PATH to locate <cFile>.

     ^bWarning! ^b Files must be CLOSEd before removing them with FERASE().

 ^bExamples^b

     ^b^CFE^b  This example deletes a set of files matching a wildcard
        pattern:

        #include "Directry.ch"
        AEVAL(DIRECTORY("*.BAK"), { |aFile| ;
           FERASE(aFile[F_NAME]) })

     ^b^CFE^b  This example erases a file and displays a message if the
        operation fails:

        IF FERASE("AFile.txt") == -1
           ? "File erase error:", FERROR()
           BREAK
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"CLOSE" c52g_002.ngo:"ERASE" "FERROR()" "FRENAME()" c52g_002.ngo:"RENAME" 
'------------------------------------------------------------------------------



!short: FERROR()        Test for errors after a binary file operation
'------------------------------------------------------------------------------
 ^bFERROR()^b
 Test for errors after a binary file operation
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFERROR() --> nErrorCode

 ^bReturns^b

     FERROR() returns the DOS error from the last file operation as an
     integer numeric value.  If there is no error, FERROR() returns zero.

     ^bFERROR() Return Values^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bError   Meaning^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     0       Successful
     2       File not found
     3       Path not found
     4       Too many files open
     5       Access denied
     6       Invalid handle
     8       Insufficient memory
     15      Invalid drive specified
     19      Attempted to write to a write-protected disk
     21      Drive not ready
     23      Data CRC error
     29      Write fault
     30      Read fault
     32      Sharing violation
     33      Lock Violation
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bDescription^b

     FERROR() is a low-level file function that indicates a DOS error after a
     file function is used.  These functions include FCLOSE(), FCREATE(),
     FERASE(), FOPEN(), FREAD(), FREADSTR(), and FRENAME().  FERROR() retains
     its value until the next execution of a file function.

     ^bWarning! ^b This function allows low-level access to DOS files and
     devices.  It should be used with extreme care and requires a thorough
     knowledge of the operating system.

 ^bExamples^b

     ^b^CFE^b  This example tests FERROR() after the creation of a binary
        file and displays an error message if the create fails:

        #include "Fileio.ch"
        //
        nHandle := FCREATE("Temp.txt", FC_NORMAL)
        IF FERROR() != 0
           ? "Cannot create file, DOS error ", FERROR()
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DOSERROR()" "FCLOSE()" "FCREATE()" "FOPEN()" "FWRITE()" 
'------------------------------------------------------------------------------



!short: FIELDBLOCK()    Return a set-get code block for a given field
'------------------------------------------------------------------------------
 ^bFIELDBLOCK()^b
 Return a set-get code block for a given field
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFIELDBLOCK(<cFieldName>) --> bFieldBlock

 ^bArguments^b

     ^b<cFieldName>^b is the name of the field to which the set-get block
     will refer.

 ^bReturns^b

     FIELDBLOCK() returns a code block that, when evaluated, sets (assigns)
     or gets (retrieves) the value of the given field.  If <cFieldName> does
     not exist in the current work area, FIELDBLOCK() returns NIL.

 ^bDescription^b

     FIELDBLOCK() is a database function that builds a code block.  When
     executed with an argument, the code block created by this function
     assigns the value of the argument to <cFieldName>.  When executed
     without an argument, the code block retrieves the value of <cFieldName>.

     Note that the specified field variable may not exist when the code block
     is created but must exist before the code block is executed.

 ^bNotes^b

     ^b^CFE  Work area:^b The code block returned by FIELDBLOCK() sets or
        gets the value of the specified field in whatever work area is
        current when the block is run.  For example, given work areas 1 and
        2, both containing field FName:

        SELECT 1
        FName:= "Kate"
        SELECT 2
        FName := "Cindy"
        bFName := FIELDBLOCK("FName")

        SELECT 1
        ? EVAL(bFName)               // Result: "Kate"
        SELECT 2
        ? EVAL(bFName)               // Result: "Cindy"

        The function FIELDWBLOCK() provides a set-get block for a field in a
        specific work area.

 ^bExamples^b

     ^b^CFE^b  This example compares FIELDBLOCK() to a code block created
        using the macro operator.  Note that using FIELDBLOCK() avoids the
        speed and size overhead of the macro operator:

        // Set-Get block defined using macro operator
        bSetGet := &( "{ |setVal| IF( setVal == NIL,;
                        FName, FName := setVal ) }" )
        // Set-Get block defined using FIELDBLOCK()

        // bSetGet created here is the functional
        // equivalent of bSetGet above
        bSetGet := FIELDBLOCK("FName")

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "FIELDWBLOCK()" "MEMVARBLOCK()" 
'------------------------------------------------------------------------------



!short: FIELDGET()      Retrieve the value of a field variable
'------------------------------------------------------------------------------
 ^bFIELDGET()^b
 Retrieve the value of a field using the ordinal position of the field in the
 database structure
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFIELDGET(<nField>) --> ValueField

 ^bArguments^b

     ^b<nField>^b is the ordinal position of the field in the record
     structure for the current work area.

 ^bReturns^b

     FIELDGET() returns the value of the specified field.  If <nField> does
     not correspond to the position of any field in the current database
     file, FIELDGET() returns NIL.

 ^bDescription^b

     FIELDGET() is a database function that retrieves the value of a field
     using its position within the database file structure rather than its
     field name.  Within generic database service functions this allows,
     among other things, the retrieval of field values without use of the
     macro operator.

 ^bExamples^b

     ^b^CFE^b  This example compares FIELDGET() to functionally equivalent
        code that uses the macro operator to retrieve the value of a field:

        LOCAL nField := 1, FName, FVal
        USE Customer NEW
        //
        // Using macro operator
        FName := FIELD( nField )         // Get field name
        FVal := &FName                   // Get field value
        // Using FIELDGET()
        FVal := FIELDGET( nField )       // Get field value

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "FIELDPUT()" 
'------------------------------------------------------------------------------



!short: FIELDNAME()     Return a field name from the current (.dbf) file
'------------------------------------------------------------------------------
 ^bFIELDNAME()/FIELD()^b
 Return a field name from the current (.dbf) file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFIELDNAME/FIELD(<nPosition>) --> cFieldName

 ^bArguments^b

     ^b<nPosition>^b is the position of a field in the database file
     structure.

 ^bReturns^b

     FIELDNAME() returns the name of the specified field as a character
     string.  If <nPosition> does not correspond to an existing field in the
     current database file or if no database file is open in the current work
     area, FIELDNAME() returns a null string ("").

 ^bDescription^b

     FIELDNAME() is a database function that returns a field name using an
     index to the position of the field name in the database structure.  Use
     it in data-independent applications where the field name is unknown.  If
     information for more than one field is required, use AFIELDS() to create
     an array of field information or COPY STRUCTURE EXTENDED to create a
     database of field information.

     If you need additional database file structure information, use TYPE()
     and LEN().  To obtain the number of decimal places for a numeric field,
     use the following expression:

     LEN(SUBSTR(STR(<idField>), RAT(".", ;
                   STR(<idField>)) + 1))

     By default, FIELDNAME() operates on the currently selected work area as
     shown in the example below.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate FIELDNAME() used with several other
        functions:

        USE Sales
        ? FIELDNAME(1)              // Result: BRANCH
        ? FCOUNT()                  // Result: 5
        ? LEN(FIELDNAME(0))         // Result: 0
        ? LEN(FIELDNAME(40))        // Result: 0

     ^b^CFE^b  This example uses FIELDNAME() to list the name and type of
        each field in Customer.dbf:

        USE Customer NEW
        FOR nField := 1 TO FCOUNT()
           ? PADR(FIELDNAME(nField), 10),;
                  VALTYPE(&(FIELDNAME(nField)))
        NEXT

     ^b^CFE^b  This example accesses fields in unselected work areas using
        aliased expressions:

        USE Sales NEW
        USE Customer NEW
        USE Invoices NEW
        //
        ? Sales->(FIELDNAME(1))            // Result: SALENUM
        ? Customer->(FIELDNAME(1))         // Result: CUSTNUM

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DBSTRUCT()" "FCOUNT()" "LEN()" "VALTYPE()" 
'------------------------------------------------------------------------------



!short: FIELDPOS()      Return the position of a field in a work area
'------------------------------------------------------------------------------
 ^bFIELDPOS()^b
 Return the position of a field in a work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFIELDPOS(<cFieldName>) --> nFieldPos

 ^bArguments^b

     ^b<cFieldName>^b is the name of a field in the current or specified work
     area.

 ^bReturns^b

     FIELDPOS() returns the position of the specified field within the list
     of fields associated with the current or specified work area.  If the
     current work area has no field with the specified name, FIELDPOS()
     returns zero.

 ^bDescription^b

     FIELDPOS() is a database function that is the inverse of the FIELDNAME()
     function.  FIELDPOS() is most often used with the FIELDPUT() and
     FIELDGET() functions.

     FIELDPOS() return the names of fields in any unselected work area by
     referring to the function using an aliased expression.  See the example
     below.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a typical specification of the
        FIELDPOS() function:

        USE Customer NEW
        ? FIELDPOS("Name")                     // Result: 1
        ? FIELDGET(FIELDPOS("Name"))           // Result: Kate

     ^b^CFE^b  This example uses FIELDPOS() to return the position of a
        specified field in a unselected work area:

        USE Customer NEW
        USE Invoices NEW
        ? Customer->(FIELDPOS("Name"))         // Result: 1
        ? Customer->(FIELDGET(FIELDPOS("Name")))
                                               // Result: Kate

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "FIELDGET()" "FIELDPUT()" 
'------------------------------------------------------------------------------



!short: FIELDPUT()      Set the value of a field variable
'------------------------------------------------------------------------------
 ^bFIELDPUT()^b
 Set the value of a field variable using the ordinal position of the field in
 the database structure
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFIELDPUT(<nField>, <expAssign>) --> ValueAssigned

 ^bArguments^b

     ^b<nField>^b is the ordinal position of the field in the current
     database file.

     ^b<expAssign>^b is the value to assign to the given field.  The data
     type of this expression must match the data type of the designated field
     variable.

 ^bReturns^b

     FIELDPUT() returns the value assigned to the designated field.  If
     <nField> does not correspond to the position of any field in the current
     database file, FIELDPUT() returns NIL.

 ^bDescription^b

     FIELDPUT() is a database function that assigns <expAssign> to the field
     at ordinal position <nField> in the current work area.  This function
     allows you to set the value of a field using its position within the
     database file structure rather than its field name.  Within generic
     database service functions this allows, among other things, the setting
     of field values without use of the macro operator.

 ^bExamples^b

     ^b^CFE^b  This example compares FIELDPUT() to functionally equivalent
        code that uses the macro operator to set the value of a field:

        // Using macro operator
        FName := FIELD(nField)           // Get field name
        FIELD->&FName := FVal            // Set field value
        // Using FIELDPUT()
        FIELDPUT(nField, FVal)           // Set field value

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "FIELDGET()" 
'------------------------------------------------------------------------------



!short: FIELDWBLOCK()   Return a set-get code block for a field in a given work area
'------------------------------------------------------------------------------
 ^bFIELDWBLOCK()^b
 Return a set-get code block for a field in a given work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFIELDWBLOCK(<cFieldName>, <nWorkArea>)
     ^b   --> bFieldWBlock

 ^bArguments^b

     ^b<cFieldName>^b is the name of the field specified as a character
     string.

     ^b<nWorkArea>^b is the work area number where the field resides
     specified as a numeric value.

 ^bReturns^b

     FIELDWBLOCK() returns a code block that, when evaluated, sets (assigns)
     or gets (retrieves) the value of <cFieldName> in the work area
     designated by <nWorkArea>.  If <cFieldName> does not exist in the
     specified work area, FIELDWBLOCK() returns NIL.

 ^bDescription^b

     FIELDWBLOCK() is a database function that builds a code block.  When
     evaluated with the EVAL() function, the code block first selects the
     designated <nWorkArea>.  If an argument was passed, the code block then
     assigns the value of the argument to <cFieldName>.  If no argument was
     passed, the code block retrieves the value of <cFieldName>.  The
     original work area is then reselected before the code block returns
     control.

     Note that the specified field variable may not exist when the code block
     is created but must exist before the code block is executed.

 ^bNotes^b

     ^b^CFE^b  FIELDWBLOCK() is similar to FIELDBLOCK(), except that
        FIELDBLOCK() incorporates a fixed work area into the set-get block.

 ^bExamples^b

     ^b^CFE^b  This example compares FIELDWBLOCK() to a code block created
        using the macro operator.  Note that using FIELDWBLOCK() avoids the
        speed and size overhead of the macro operator:

        // Set-Get block for work area 1 defined with
        // macro operator
        bSetGet := &( "{ |setVal| IF( setVal == NIL, ;
           1->FName, 1->FName := setVal ) }" )
        // Set-Get block defined using FIELDWBLOCK()

        // bSetGet created here is the functional
        // equivalent of bSetGet above
        bSetGet := FIELDWBLOCK("FName", 1)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "FIELDBLOCK()" "MEMVARBLOCK()" 
'------------------------------------------------------------------------------



!short: FILE()          Determine if files exists
'------------------------------------------------------------------------------
 ^bFILE()^b
 Determine if files exist in the CA-Clipper default directory or path
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFILE(<cFilespec>) --> lExists

 ^bArguments^b

     ^b<cFilespec>^b is in the current CA-Clipper default directory and path.
     It is a standard file specification that can include the wildcard
     characters * and ? as well as a drive and path reference.  Explicit
     references to a file must also include an extension.

 ^bReturns^b

     FILE() returns true (.T.) if there is a match for any file matching the
     <cFilespec> pattern; otherwise, it returns false (.F.).

 ^bDescription^b

     FILE() is an environment function that determines whether any file
     matching a file specification pattern is found.  FILE() searches the
     specified directory if a path is explicitly specified.

     If a path is not specified,  FILE() searches the current CA-Clipper
     default directory and then the CA-Clipper path.  In no case is the DOS
     path searched.  Note also that FILE() does not recognize hidden or
     system files in its search.

 ^bExamples^b

     ^b^CFE^b  In this example FILE() attempts to find Sales.dbf in other
        than the current CA-Clipper default:

        ? FILE("Sales.dbf")               // Result: .F.
        ? FILE("\APPS\DBF\Sales.dbf")     // Result: .T.
        //
        SET PATH TO \APPS\DBF
        ? FILE("Sales.dbf")               // Result: .T.
        //
        SET PATH TO
        SET DEFAULT TO \APPS\DBF\
        ? FILE("Sales.dbf")               // Result: .T.
        ? FILE("*.dbf")                   // Result: .T.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"SET DEFAULT" c52g_002.ngo:"SET PATH" 
'------------------------------------------------------------------------------



!short: FKLABEL()*      Return function key name
'------------------------------------------------------------------------------
 ^bFKLABEL()*^b
 Return function key name
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFKLABEL(<nFunctionKey>) --> cKeyLabel

 ^bReturns^b

     FKLABEL() returns a character string representing the name of the
     function key specified by the numeric argument, <nFunctionKey>.  If this
     argument is less than one or greater than 40, the function returns a
     null ("") string.

 ^bDescription^b

     FKLABEL() is a compatibility function used to replicate the FKLABEL()
     function in dBASE III PLUS.  As a general principle, the use of this
     function is not recommended and not needed in CA-Clipper.  The function
     keys are labeled Fn, where n ranges from one to 40 and corresponds
     directly to the FKLABEL() argument.

 ^bFiles:^b  Library is EXTEND.LIB, source file is SOURCE\SAMPLE\FKLABEL.PRG.
!seealso: c52g_002.ngo:"SET FUNCTION" 
'------------------------------------------------------------------------------



!short: FKMAX()*        Return number of function keys as a constant
'------------------------------------------------------------------------------
 ^bFKMAX()*^b
 Return number of function keys as a constant
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFKMAX() --> nFunctionKeys

 ^bDescription^b

     FKMAX() is a compatibility function used to replicate the FKMAX()
     function in dBASE III PLUS.  As a general principle, the use of this
     function is not recommended and not needed in CA-Clipper.  It simply
     returns a constant value of 40.

 ^bFiles:^b  Library is EXTEND.LIB, source file is SOURCE\SAMPLE\FKMAX.PRG.
!seealso: c52g_006.ngo:"#define" c52g_002.ngo:"SET FUNCTION" 
'------------------------------------------------------------------------------



!short: FLOCK()         Lock an open and shared database file
'------------------------------------------------------------------------------
 ^bFLOCK()^b
 Lock an open and shared database file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFLOCK() --> lSuccess

 ^bReturns^b

     FLOCK() returns true (.T.) if an attempt to lock a database file in USE
     in the current work area succeeds; otherwise, it returns false (.F.).
     For more information on file locking, refer to the Network Programming
     chapter in the Programming and Utilities guide.

 ^bDescription^b

     FLOCK() is a database function used in network environments to lock an
     open and shared database file, preventing other users from updating the
     file until the lock is released.  Records in the locked file are
     accessible for read-only operations.

     FLOCK() is related to USE...EXCLUSIVE and RLOCK().  USE...EXCLUSIVE
     opens a database file so that no other user can open the same file at
     the same time and is the most restrictive locking mechanism in
     CA-Clipper.  RLOCK() is the least restrictive and attempts to place an
     update lock on a shared record, precluding other users from updating the
     current record.  FLOCK() falls in the middle.

     FLOCK() is used for operations that access the entire database file.
     Typically, these are commands that update the file with a scope or a
     condition such as DELETE or REPLACE ALL.  The following is a list of
     such commands:

     ^bCommands that require an FLOCK()^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bCommand                       Mode^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     APPEND FROM                   FLOCK() or USE...EXCLUSIVE
     DELETE (multiple records)     FLOCK() or USE...EXCLUSIVE
     RECALL (multiple records)     FLOCK() or USE...EXCLUSIVE
     REPLACE (multiple records)    FLOCK() or USE...EXCLUSIVE
     UPDATE ON                     FLOCK() or USE...EXCLUSIVE
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     For each invocation of FLOCK(), there is one attempt to lock the
     database file, and the result is returned as a logical value.  A file
     lock fails if another user currently has a file or record lock for the
     same database file or EXCLUSIVE USE of the database file.  If FLOCK() is
     successful, the file lock remains in place until you UNLOCK, CLOSE the
     DATABASE, or RLOCK().

     By default, FLOCK() operates on the currently selected work area as
     shown in the example below.

 ^bNotes^b

     ^b^CFE  SET RELATION:^b CA-Clipper does not automatically lock all work
        areas in the relation chain when you lock the current work area, and
        an UNLOCK has no effect on related work areas.

 ^bExamples^b

     ^b^CFE^b  This example uses FLOCK() for a batch update of prices in
        Inventory.dbf:

        USE Inventory NEW
        IF FLOCK()
           REPLACE ALL Inventory->Price WITH ;
                 Inventory->Price * 1.1
        ELSE
           ? "File not available"
        ENDIF

     ^b^CFE^b  This example uses an aliased expression to attempt a file lock
        in an unselected work area:

        USE Sales NEW
        USE Customer NEW
        //
        IF !Sales->(FLOCK())
           ? "Sales is in use by another"
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "RLOCK()" c52g_002.ngo:"SET EXCLUSIVE*" c52g_002.ngo:"UNLOCK" c52g_002.ngo:"USE" 
'------------------------------------------------------------------------------



!short: FOPEN()         Open a binary file
'------------------------------------------------------------------------------
 ^bFOPEN()^b
 Open a binary file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFOPEN(<cFile>, [<nMode>]) --> nHandle

 ^bArguments^b

     ^b<cFile>^b is the name of the file to open including the path if there
     is one.

     ^b<nMode>^b is the requested DOS open mode indicating how the opened
     file is to be accessed.  The open mode is composed of elements from the
     two types of modes described in the tables below.  If just the Access
     Mode is used, the file is opened non-sharable.  The default open mode is
     zero, which indicates non-sharable and read-only.

     ^bFOPEN() Access Modes^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bMode    Fileio.ch      Operation^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     0       FO_READ        Open for reading (default)
     1       FO_WRITE       Open for writing
     2       FO_READWRITE   Open for reading or writing
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     The Sharing Modes determine how other processes may access the file.

     The Access Modes in combination (+) with the Sharing modes determine the
     accessibility of the file in a network environment.

     ^bFOPEN() Sharing Modes ^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bMode    Fileio.ch      Operation^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     0       FO_COMPAT      Compatibility mode (default)
     16      FO_EXCLUSIVE   Exclusive use
     32      FO_DENYWRITE   Prevent others from writing
     48      FO_DENYREAD    Prevent others from reading
     64      FO_DENYNONE    Allow others to read or write
     64      FO_SHARED      Same as FO_DENYNONE
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bReturns^b

     FOPEN() returns the file handle of the opened file in the range of zero
     to 65,535.  If an error occurs, FOPEN() returns -1.

 ^bDescription^b

     FOPEN() is a low-level file function that opens an existing binary file
     for reading and writing, depending on the <nMode> argument.  Whenever
     there is an open error, FERROR()to return the DOS error number.  For
     example, if the file does not exist, FOPEN() returns -1 and FERROR()
     returns 2 to indicate that the file was not found.  See FERROR() for a
     complete list of error numbers.

     If the specified file is opened successfully, the value returned is the
     DOS handle for the file.  This value is similar to an alias in the
     database system and is required to identify the open file to other file
     functions.  It is, therefore, important to assign the return value to a
     variable for later use as in the example below.

     ^bWarning! ^b This function allows low-level access to DOS files and
     devices.  It should be used with extreme care and requires a thorough
     knowledge of the operating system.

 ^bNotes^b

     ^b^CFE  Accessing files in other directories:^b FOPEN() does not obey
        either SET DEFAULT or SET PATH.  Instead, it searches the current DOS
        directory and path setting unless a path is explicitly stated as part
        of the <cFile> argument.

 ^bExamples^b

     ^b^CFE^b  This example uses FOPEN() to open a file with  sharable
        read/write status and displays an error message if the open fails:

        #include "Fileio.ch"
        //
        nHandle := FOPEN("Temp.txt", FO_READWRITE + FO_SHARED)
        IF FERROR() != 0
           ? "Cannot open file, DOS error ", FERROR()
           BREAK
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Fileio.ch.
!seealso: "FCLOSE()" "FCREATE()" "FERROR()" 
'------------------------------------------------------------------------------



!short: FOUND()         Determine if the previous search operation succeeded
'------------------------------------------------------------------------------
 ^bFOUND()^b
 Determine if the previous search operation succeeded
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFOUND() --> lSuccess

 ^bReturns^b

     FOUND() returns true (.T.) if the last search command was successful;
     otherwise, it returns false (.F.).

 ^bDescription^b

     FOUND() is a database function that determines whether a search
     operation (i.e., FIND, LOCATE, CONTINUE, SEEK, or SET RELATION)
     succeeded.  When any of these commands are executed, FOUND() is set to
     true (.T.) if there is a match; otherwise, it is set to false (.F.).

     If the search command is LOCATE or CONTINUE, a match is the next record
     meeting the scope and condition.  If the search command is FIND, SEEK or
     SET RELATION, a match is the first key in the controlling index that
     equals the search argument.  If the key value equals the search
     argument, FOUND() is true (.T.); otherwise, it is false (.F.).

     The value of FOUND() is retained until another record movement command
     is executed.  Unless the command is another search command, FOUND() is
     automatically set to false (.F.).

     Each work area has a FOUND() value.  This means that if one work area
     has a RELATION set to a child work area, querying FOUND() in the child
     returns true (.T.) if there is a match.

     By default, FOUND() operates on the currently selected work area.  It
     can be made to operate on an unselected work area by specifying it
     within an aliased expression (see example below).

     FOUND() will return false (.F.) if there is no database open in the
     current work area.

 ^bExamples^b

     ^b^CFE^b  This example illustrates the behavior of FOUND() after a
        record movement command:

        USE Sales INDEX Sales
        ? INDEXKEY(0)            // Result: SALESMAN
        SEEK "1000"
        ? FOUND()                // Result: .F.
        SEEK "100"
        ? FOUND()                // Result: .T.
        SKIP
        ? FOUND()                // Result: .F.

     ^b^CFE^b  This example tests a FOUND() value in an unselected work area
        using an aliased expression:

        USE Sales INDEX Sales NEW
        USE Customer INDEX Customer NEW
        SET RELATION TO CustNum INTO Sales
        //
        SEEK "Smith"
        ? FOUND(), Sales->(FOUND())

     ^b^CFE^b  This code fragment processes all Customer records with the key
        value "Smith" using FOUND() to determine when the key value changes:

        USE Customer INDEX Customer NEW
        SEEK "Smith"
        DO WHILE FOUND()
           .
           . <statements>
           .
           SKIP
           LOCATE REST WHILE Name == "Smith"
        ENDDO

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "EOF()" c52g_002.ngo:"LOCATE" c52g_002.ngo:"SEEK" c52g_002.ngo:"SET RELATION" c52g_002.ngo:"SET SOFTSEEK" 
'------------------------------------------------------------------------------



!short: FREAD()         Read characters from a binary file into a buffer variable
'------------------------------------------------------------------------------
 ^bFREAD()^b
 Read characters from a binary file into a buffer variable
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFREAD(<nHandle>, @<cBufferVar>, <nBytes>) --> nBytes

 ^bArguments^b

     ^b<nHandle>^b is the file handle obtained from FOPEN(), FCREATE(), or
     predefined by DOS.

     ^b<cBufferVar>^b is the name of an existing and initialized character
     variable used to store data read from the specified file.  The length of
     this variable must be greater than or equal to <nBytes>.  <cBufferVar>
     must be passed by reference and, therefore, must be prefaced by the
     pass-by-reference operator (@).

     ^b<nBytes>^b is the number of bytes to read into the buffer.

 ^bReturns^b

     FREAD() returns the number of bytes successfully read as an integer
     numeric value.  A return value less than <nBytes> or zero indicates end
     of file or some other read error.

 ^bDescription^b

     FREAD() is a low-level file function that reads characters from a binary
     file into an existing character variable.  It reads from the file
     starting at the current DOS file pointer position, advancing the file
     pointer by the number of bytes read.  All characters are read including
     control, null, and high-order (above CHR(127)) characters.

     FREAD() is similar in some respects to both FREADSTR() and FSEEK().
     FREADSTR() reads a specified number of bytes from a file up to the next
     null (CHR(0)) character.  FSEEK() moves the file pointer without
     reading.

     If there is an error during the file read, FERROR() returns the DOS
     error number.  See FERROR() for the list of error numbers.

     ^bWarning! ^b This function allows low-level access to DOS files and
     devices.  It should be used with extreme care and requires a thorough
     knowledge of the operating system.

 ^bExamples^b

     ^b^CFE^b  This example uses FREAD() after successfully opening a file to
        read 128 bytes into a buffer area:

        #define F_BLOCK      128

        //
        cBuffer := SPACE(F_BLOCK)
        nHandle := FOPEN("Temp.txt")
        //
        IF FERROR() != 0
           ? "File open error:", FERROR()
        ELSE
           IF FREAD(nHandle, @cBuffer, F_BLOCK) <> F_BLOCK
              ? "Error reading Temp.txt"
           ENDIF
           FCLOSE(nHandle)
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "BIN2I()" "BIN2L()" "BIN2W()" "FERROR()" "FWRITE()" 
'------------------------------------------------------------------------------



!short: FREADSTR()      Read characters from a binary file
'------------------------------------------------------------------------------
 ^bFREADSTR()^b
 Read characters from a binary file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFREADSTR(<nHandle>, <nBytes>) --> cString

 ^bArguments^b

     ^b<nHandle>^b is the file handle obtained from FOPEN(), FCREATE(), or
     predefined by DOS.

     ^b<nBytes>^b is the number of bytes to read, beginning at the current
     DOS file pointer position.

 ^bReturns^b

     FREADSTR() returns a character string up to 65,535 (64K) bytes.  A null
     return value ("") indicates an error or end of file.

 ^bDescription^b

     FREADSTR() is a low-level file function that reads characters from an
     open binary file beginning with the current DOS file pointer position.
     Characters are read up to <nBytes> or until a null character (CHR(0)) is
     encountered.  All characters are read including control characters
     except for CHR(0).  The file pointer is then moved forward <nBytes>.  If
     <nBytes> is greater than the number of bytes from the pointer position
     to the end of the file, the file pointer is positioned to the last byte
     in the file.

     ^bWarning! ^b This function allows low-level access to DOS files and
     devices.  It should be used with extreme care and requires a thorough
     knowledge of the operating system.

 ^bExamples^b

     ^b^CFE^b  This example displays the ASCII values of the first 16 bytes
        of a text file:

        #include "Fileio.ch"
        //
        nHandle := FOPEN("New.txt", FC_NORMAL)
        IF FERROR() != 0
           ? "File open error:", FERROR()
        ELSE
           cString := FREADSTR(nHandle, 16)
           ? cString
           FCLOSE(nHandle)
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "BIN2I()" "BIN2L()" "BIN2W()" "FERROR()" "FREAD()" "FSEEK()" 
'------------------------------------------------------------------------------



!short: FRENAME()       Change the name of a file
'------------------------------------------------------------------------------
 ^bFRENAME()^b
 Change the name of a file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFRENAME(<cOldFile>, <cNewFile>) --> nSuccess

 ^bArguments^b

     ^b<cOldFile>^b is the name of the file to rename, including the file
     extension.  A drive letter and/or path name may also be included as part
     of the filename.

     ^b<cNewFile>^b is the new name of the file, including the file
     extension.  A drive letter and/or path name may also be included as part
     of the name.

 ^bReturns^b

     FRENAME() returns -1 if the operation fails and zero if it succeeds.  In
     the case of a failure, FERROR() can be used to determine the nature of
     the error.

 ^bDescription^b

     FRENAME() is a file function that changes the name of a specified file
     to a new name and is identical to the RENAME command.

     When FRENAME() is called, <cOldFile> is renamed only if it is located in
     the current DOS directory or in the specified path.  FRENAME() does not
     use SET DEFAULT or SET PATH to locate <cOldFile>.

     If the source directory is different from the target directory, the file
     moves to the target directory.  In the instance that either <cNewFile>
     exists or is currently open, FRENAME() fails and returns -1, indicating
     that it did not perform its designated action.  The nature of the error
     can be determined with FERROR().

     ^bWarning! ^b Files must be CLOSEd before renaming.  Attempting to
     rename an open file will produce unpredictable results.  When a database
     file is renamed, the associated memo (.dbt) file must also be renamed.
     Failure to do so may compromise the integrity of your databases.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a file rename:

        IF FRENAME("OldFile.txt", "NewFile.txt") == -1
           ? "File error:", FERROR()
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"CLOSE" c52g_002.ngo:"ERASE" "FERASE()" "FERROR()" "FILE()" c52g_002.ngo:"RENAME" 
'------------------------------------------------------------------------------



!short: FSEEK()         Set a binary file pointer to a new position
'------------------------------------------------------------------------------
 ^bFSEEK()^b
 Set a binary file pointer to a new position
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFSEEK(<nHandle>, <nOffset>, [<nOrigin>]) --> nPosition

 ^bArguments^b

     ^b<nHandle>^b is the file handle obtained from FOPEN(), FCREATE(), or
     predefined by DOS.

     ^b<nOffset>^b is the number of bytes to move the file pointer from the
     position defined by <nOrigin>.  It can be a positive or negative number.
     A positive number moves the pointer forward, and a negative number moves
     the pointer backward in the file.

     ^b<nOrigin>^b defines the starting location of the file pointer before
     FSEEK() is executed.  The default value is zero, representing the
     beginning of file.  If <nOrigin> is the end of file, <nOffset> must be
     zero or negative.

     ^bMethods of Moving the File Pointer^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bOrigin  Fileio.ch      Description^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     0       FS_SET         Seek from beginning of file
     1       FS_RELATIVE    Seek from the current pointer position
     2       FS_END         Seek from end of file
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bReturns^b

     FSEEK() returns the new position of the file pointer relative to the
     beginning of file (position 0) as an integer numeric value.  This value
     is without regard to the original position of the file pointer.

 ^bDescription^b

     FSEEK() is a low-level file function that moves the file pointer forward
     or backward in an open binary file without actually reading the contents
     of the specified file.  The beginning position and offset are specified
     as function arguments, and the new file position is returned.
     Regardless of the function arguments specified, the file pointer cannot
     be moved beyond the beginning or end of file boundaries.

     ^bWarning! ^b This function allows low-level access to DOS files and
     devices.  It should be used with extreme care and requires a thorough
     knowledge of the operating system.

 ^bExamples^b

     ^b^CFE^b  This example uses FSEEK() to determine the length of a file by
        seeking from the end of file.  Then, the file pointer is reset to the
        beginning of file:

        #include "Fileio.ch"
        //
        // Open the file read-only
        IF (nHandle := FOPEN("Temp.txt")) >= 0
           //
           // Get length of the file
           nLength := FSEEK(nHandle, 0, FS_END)
           //
           // Reset file position to beginning of file
           FSEEK(nHandle, 0)
           FCLOSE(nHandle)
        ELSE
           ? "File open error:", FERROR()
        ENDIF

     ^b^CFE^b  This pseudofunction positions the file pointer at the last
        byte in a binary file:

        #define FileBottom(nHandle);
              (FSEEK(nHandle, 0, FS_END))

     ^b^CFE^b  This pseudofunction positions the file pointer at the first
        byte in a binary file:

        #define FileTop(nHandle);
              (FSEEK(nHandle, 0))

     ^b^CFE^b  This pseudofunction reports the current position of the file
        pointer in a specified binary file:

        #define FilePos(nHandle);
              (FSEEK(nHandle, 0, FS_RELATIVE))

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Fileio.ch.
!seealso: "FCREATE()" "FERROR()" "FOPEN()" "FREAD()" "FREADSTR()" "FWRITE()" 
'------------------------------------------------------------------------------



!short: FWRITE()        Write to an open binary file
'------------------------------------------------------------------------------
 ^bFWRITE()^b
 Write to an open binary file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFWRITE(<nHandle>, <cBuffer>, [<nBytes>])
     ^b   --> nBytesWritten

 ^bArguments^b

     ^b<nHandle>^b is the file handle obtained from FOPEN(), FCREATE(), or
     predefined by DOS.

     ^b<cBuffer>^b is the character string to write to the specified file.

     ^b<nBytes>^b indicates the number of bytes to write beginning at the
     current file pointer position.  If omitted, the entire content of
     <cBuffer> is written.

 ^bReturns^b

     FWRITE() returns the number of bytes written as an integer numeric
     value.  If the value returned is equal to <nBytes>, the operation was
     successful.  If the return value is less than <nBytes> or zero, either
     the disk is full or another error has occurred.

 ^bDescription^b

     FWRITE() is a low-level file function that writes data to an open binary
     file from a character string buffer.  You can either write all or a
     portion of the buffer contents.  Writing begins at the current file
     position, and the function returns the actual number of bytes written.

     If FWRITE() results in an error condition, FERROR() can be used to
     determine the specific error.

     ^bWarning! ^b This function allows low-level access to DOS files and
     devices.  It should be used with extreme care and requires a thorough
     knowledge of the operating system

 ^bExamples^b

     ^b^CFE^b  This example copies the contents of one file to another:

        #include "Fileio.ch"
        #define F_BLOCK   512
        //
        cBuffer := SPACE(F_BLOCK)
        nInfile := FOPEN("Temp.txt", FO_READ)
        nOutfile := FCREATE("Newfile.txt", FC_NORMAL)
        lDone := .F.
        //
        DO WHILE !lDone

           nBytesRead := FREAD(nInfile, @cBuffer, F_BLOCK)
           IF FWRITE(nOutfile, cBuffer, nBytesRead) < ;
                       nBytesRead
              ? "Write fault: ", FERROR()
              lDone := .T.
           ELSE
              lDone := (nBytesRead == 0)
           ENDIF
        ENDDO
        //
        FCLOSE(nInfile)
        FCLOSE(nOutfile)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "FCLOSE()" "FCREATE()" "FERROR()" "FOPEN()" "I2BIN()" "L2BIN()" 
'------------------------------------------------------------------------------



!short: GETENV()        Retrieve the contents of a DOS environment variable
'------------------------------------------------------------------------------
 ^bGETENV()^b
 Retrieve the contents of a DOS environment variable
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bGETENV(<cEnvironmentVariable>) --> cString

 ^bArguments^b

     ^b<cEnvironmentVariable>^b is the name of the DOS environment variable.
     When specifying this argument, you can use any combination of upper and
     lowercase letters; GETENV() is not case-sensitive.

 ^bReturns^b

     GETENV() returns the contents of the specified DOS environment variable
     as a character string.  If the variable cannot be found, GETENV()
     returns a null string ("").

 ^bDescription^b

     GETENV() is an environment function that lets you retrieve information
     from the DOS environment into an application program.  Typically, this
     is configuration information, including path names, that give the
     location of files (database, index, label, or reports).  This function
     is particularly useful for network environments.

 ^bNotes^b

     ^b^CFE  Empty return value:^b If you are certain that an environment
        variable exists and yet GETENV() always returns a null string (""),
        be sure there are no spaces between the environment variable name and
        the first character of the string assigned to it in the DOS SET
        command.

     ^b^CFE  Compatibility:^b In previous releases of CA-Clipper, the
        function was called GETE().  This abbreviated form of GETENV() is
        still operational.

 ^bExamples^b

     ^b^CFE^b  This example retrieves the current DOS PATH setting, making it
        the current CA-Clipper PATH:

        cPath := GETENV("PATH")
        SET PATH TO (cPath)

     ^b^CFE^b  This example uses environment variables to configure the
        specific locations of files.  When you set up a system, define
        environment variables that contain the location of various file types
        as well as the CLIPPER environment variable (see The Runtime
        Environment chapter in the Programming and Utilities guide), like
        this:

        C>SET LOC_DBF=<database file path>
        C>SET LOC_NTX=<index file path>
        C>SET LOC_RPT=<report file path>

        In the configuration section of your application program, assign the
        contents of the environment variables to variables.  Then when you
        access a file, preface the reference with the path variable as
        follows:

        cDdfDirectory := GETENV("LOC_DBF")
        USE (cDdfDirectory + "Invoices")

 ^bFiles:^b  Library is CLIPPER.LIB.

!seealso: 
'------------------------------------------------------------------------------



!short: HARDCR()        Replace all soft carriage returns with hard carriage returns
'------------------------------------------------------------------------------
 ^bHARDCR()^b
 Replace all soft carriage returns in a character string with hard carriage
 returns
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bHARDCR(<cString>) --> cConvertedString

 ^bArguments^b

     ^b<cString>^b is the character string or memo field to convert.

 ^bReturns^b

     HARDCR() returns a character string up to 65,535 (64K) characters in
     length.

 ^bDescription^b

     HARDCR() is a memo function that replaces all soft carriage returns
     (CHR(141)) with hard carriage returns (CHR(13)).  It is used to display
     long character strings and memo fields containing soft carriage returns
     with console commands.  In CA-Clipper, console commands (including
     REPORT and LABEL FORM) do not automatically convert soft carriage
     returns to hard carriage returns, making it necessary for you to
     explicitly make the conversion.  Soft carriage returns are added by
     MEMOEDIT() when lines wrap.

 ^bNotes^b

     ^b^CFE  HARDCR() in REPORT and LABEL FORMs:^b If HARDCR() is used in a
        REPORT FORM or LABEL FORM contents expression and not used elsewhere,
        you must declare it EXTERNAL to assure that it is linked.

 ^bExamples^b

     ^b^CFE^b  To display a memo field formatted with the automatic word
        wrapping of MEMOEDIT():

        USE Sales NEW
        ? HARDCR(Sales->Notes)

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: c52g_002.ngo:"?|??" c52g_004.ngo:"EXTERNAL*" c52g_002.ngo:"LABEL FORM" "MEMOTRAN()" c52g_002.ngo:"REPORT FORM" "STRTRAN()" 
'------------------------------------------------------------------------------



!short: HEADER()        Return the current database file header length
'------------------------------------------------------------------------------
 ^bHEADER()^b
 Return the current database file header length
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bHEADER() --> nBytes

 ^bReturns^b

     HEADER() returns the number of bytes in the header of the current
     database file as an integer numeric value.  If no database file is in
     use, HEADER() returns a zero (0).

 ^bDescription^b

     HEADER() is a database function that is used with LASTREC(), RECSIZE(),
     and DISKSPACE() to create procedures for backing up files.

     By default, HEADER() operates on the currently selected work area.  It
     will operate on an unselected work area if you specify it as part of an
     aliased expression (see example below).

 ^bExamples^b

     ^b^CFE^b  This example determines the header size of the Sales.dbf:

        USE Sales NEW
        ? HEADER()            // Result: 258

     ^b^CFE^b  This example defines a pseudofunction, DbfSize(), that uses
        HEADER() with RECSIZE() and LASTREC() to calculate the size of the
        current database file in bytes:

        #define DbfSize()   ((RECSIZE() * LASTREC()) + ;
              HEADER() + 1)

        Later you can use DbfSize() as you would any function:

        USE Sales NEW
        USE Customer NEW
        ? DbfSize()
        ? Sales->(DbfSize())

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "DISKSPACE()" "LASTREC()" "RECSIZE()" 
'------------------------------------------------------------------------------



!short: I2BIN()         Convert a CA-Clipper numeric to a 16-bit binary integer
'------------------------------------------------------------------------------
 ^bI2BIN()^b
 Convert a CA-Clipper numeric to a 16-bit binary integer
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bI2BIN(<nInteger>) --> cBinaryInteger

 ^bArguments^b

     ^b<nInteger>^b is an integer numeric value to convert.  Decimal digits
     are truncated.

 ^bReturns^b

     I2BIN() returns a two-byte character string containing a 16-bit binary
     integer.

 ^bDescription^b

     I2BIN() is a low-level file function that converts an integer numeric
     value to a character string formatted as a binary integer--least
     significant byte first.  I2BIN() is used with FWRITE() to convert a
     CA-Clipper numeric to a standard binary form.  The inverse of I2BIN() is
     BIN2I().

 ^bExamples^b

     ^b^CFE^b  This example opens a database file using low-level file
        functions and writes a new date of the last update to bytes 1-3:

        #include "Fileio.ch"
        //
        nHandle = FOPEN("Sales.dbf", FO_READWRITE)
        //
        // Convert date of last update to int
        nYear = I2BIN(90)
        nMonth = I2BIN(12)
        nDay = I2BIN(15)
        //
        // Point to the date of last update
        FSEEK(nHandle, 1, FS_SET)
        //
        // Write the new update date using only the first byte
        FWRITE(nHandle, nYear, 1)
        FWRITE(nHandle, nMonth, 1)
        FWRITE(nHandle, nDay, 1)
        FCLOSE(nHandle)

 ^bFiles:^b  Library is EXTEND.LIB, source file is SOURCE\SAMPLE\EXAMPLEA.ASM.
!seealso: "BIN2I()" "BIN2L()" "BIN2W()" "CHR()" "FWRITE()" "L2BIN()" 
'------------------------------------------------------------------------------



!short: IF()            Return the result of an expression based on a condition
'------------------------------------------------------------------------------
 ^bIF()^b
 Return the result of an expression based on a condition
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^b[I]IF(<lCondition>, <expTrue>, <expFalse>) --> Value

 ^bArguments^b

     ^b<lCondition>^b is a logical expression to be evaluated.

     ^b<expTrue>^b is the value, a condition-expression, of any data type,
     returned if <lCondition> is true (.T.).

     ^b<expFalse>^b is the value, of any date type, returned if <lCondition>
     is false (.F.).  This argument need not be the same data type as
     <expTrue>.

 ^bReturns^b

     IF() returns the evaluation of <expTrue> if <lCondition> evaluates to
     true (.T.) and <expFalse> if it evaluates to false (.F.).  The value
     returned is the data type of the valid condition-expression.

 ^bDescription^b

     IF() is a logical conversion function.  It is one of the most powerful
     and versatile functions in CA-Clipper.  It provides a mechanism to
     evaluate a condition within an expression.  With this ability you can
     convert a logical expression to another data type.

 ^bExamples^b

     ^b^CFE^b  This example converts a logical data value to a numeric data
        value:

        lPaid = .T.
        ? IF(lPaid, 1, 0)               // Result: 1

     ^b^CFE^b  In this example a logical field is formatted depending on
        whether the Customer is past due or not:

        @ ROW() + 1, 25 SAY IF(lPaid, SPACE(10), "Go get 'em")

     ^b^CFE^b  If you are printing forms, you can print an indicating symbol
        in different columns depending on the value of a logical field:

        @ ROW(), IF(InHospital, 10, 12) SAY "X"

     ^b^CFE^b  You can also use IF() to force the LABEL FORM to print blank
        lines.  Enter the following expression when you create the label with
        RL.EXE:

        IF(EMPTY(Company), CHR(255), Company)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_004.ngo:"DO CASE" c52g_004.ngo:"IF" 
'------------------------------------------------------------------------------



!short: INDEXEXT()      Return default index extension based on the database driver
'------------------------------------------------------------------------------
 ^bINDEXEXT()^b
 Return the default index extension based on the database driver currently
 linked
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bINDEXEXT() --> cExtension

 ^bReturns^b

     Unless you have linked another database driver, INDEXEXT() returns
     ".NTX" to indicate that the default CA-Clipper driver is in effect.  If
     the dBASE III PLUS compatible database driver is linked, the function
     returns ".NDX".

 ^bDescription^b

     INDEXEXT() returns the default index file extension by determining which
     database driver is currently linked.

 ^bExamples^b

     ^b^CFE^b  In this example, INDEXEXT() creates an existence test for the
        Customer index file independent of the database driver linked into
        the current program:

        USE Customer NEW
        //
        IF .NOT. FILE("Customer" + INDEXEXT())
           INDEX ON CustName TO Customer
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "INDEXKEY()" "INDEXORD()" 
'------------------------------------------------------------------------------



!short: INDEXKEY()      Return the key expression of a specified index
'------------------------------------------------------------------------------
 ^bINDEXKEY()^b
 Return the key expression of a specified index
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bINDEXKEY(<nOrder>) --> cKeyExp

 ^bArguments^b

     ^b<nOrder>^b is the ordinal position of the index in the list of index
     files opened by the last USE...INDEX or SET INDEX TO command for the
     current work area.  A zero value specifies the controlling index,
     without regard to its actual position in the list.

 ^bReturns^b

     INDEXKEY() returns the key expression of the specified index as a
     character string.  If there is no corresponding index or if no database
     file is open, INDEXKEY() returns a null string ("").

 ^bDescription^b

     INDEXKEY() is a database function that determines the key expression of
     a specified index in the current work area and returns it as a character
     string.  To evaluate the key expression, specify INDEXKEY() as a macro
     expression like this: &(INDEXKEY(<nOrder>)).

     INDEXKEY() has a number of applications, but two specific instances are
     important.  Using INDEXKEY(), you can TOTAL on the key expression of the
     controlling index without having to specify the key expression in the
     source code.  The other instance occurs within a DBEDIT() user function.
     Here, you may want to determine whether or not to update the screen
     after the user has edited a record.  Generally, it is only necessary to
     update the screen if the key expression of the controlling index has
     changed for the current record.  Both of these examples are illustrated
     below.

     By default, INDEXKEY() operates on the currently selected work area.  It
     can be made to operate on an unselected work area by specifying it
     within an aliased expression (see example below).

 ^bExamples^b

     ^b^CFE^b  This example accesses the key expression of open indexes in
        the current work area:

        #define ORD_NATURAL   0
        #define ORD_NAME      1
        #define ORD_SERIAL    2
        //
        USE Customer INDEX Name, Serial NEW
        SET ORDER TO ORD_SERIAL
        ? INDEXKEY(ORD_NAME)        // Result: Name index exp
        ? INDEXKEY(ORD_SERIAL)      // Result: Serial index exp
        ? INDEXKEY(ORD_NATURAL)     // Result: Serial index exp

     ^b^CFE^b  This example accesses the key expression of the controlling
        index in an unselected work area:

        USE Customer INDEX Name, Serial NEW
        USE Sales INDEX Salesman NEW
        ? INDEXKEY(0), Customer->(INDEXKEY(0))

     ^b^CFE^b  This example uses INDEXKEY() as part of a TOTAL ON key
        expression.  Notice that INDEXKEY() is specified using a macro
        expression to force evaluation of the expression:

        USE Sales INDEX Salesman NEW
        TOTAL ON &(INDEXKEY(0)) FIELDS SaleAmount TO ;
              SalesSummary

     ^b^CFE^b  This example uses INDEXKEY() to determine whether the DBEDIT()
        screen should be updated after the user has edited the current field
        value.  Generally, you must update the DBEDIT() screen if the user
        changes a field that is part of the controlling index key.
        FieldEdit() is a user-defined function called from a DBEDIT() user
        function to edit the current field if the user has pressed an edit
        key:

        #include "Dbedit.ch"
        #define ORD_NATURAL   0
        FUNCTION FieldEdit()
           LOCAL indexVal
           // Save current key expression and value
           indexVal = &(INDEXKEY(ORD_NATURAL))
           .
           . <code to GET current field value>
           .
           // Refresh screen if key value has changed
           IF indexVal != &(INDEXKEY(ORD_NATURAL))
              nRequest = DE_REFRESH
           ELSE
              nRequest = DE_CONT
           ENDIF
           RETURN nRequest

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"INDEX" "INDEXEXT()" "INDEXORD()" c52g_002.ngo:"SET INDEX" c52g_002.ngo:"SET ORDER" c52g_002.ngo:"USE" 
'------------------------------------------------------------------------------



!short: INDEXORD()      Return the order position of the controlling index
'------------------------------------------------------------------------------
 ^bINDEXORD()^b
 Return the order position of the controlling index
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bINDEXORD() --> nOrder

 ^bReturns^b

     INDEXORD() returns an integer numeric value.  The value returned is
     equal to the position of the controlling index in the list of open
     indexes for the current work area.  A value of zero indicates that there
     is no controlling index and records are being accessed in natural order.
     If no database file is open, INDEXORD() will also return a zero.

 ^bDescription^b

     INDEXORD() is a database function that determines the position of the
     controlling index in the list of index files opened by the last
     USE...INDEX or SET INDEX TO in the current work area.  It is often
     useful to save the last controlling index so it can be restored later.

     By default, INDEXORD() operates on the currently selected work area.  It
     will operate on an unselected work area if you specify it as part of an
     aliased expression (see example below).

 ^bExamples^b

     ^b^CFE^b  This example uses INDEXORD() to save the current order.  After
        changing to a new order, it uses the saved value to restore the
        original order:

        USE Customer INDEX Name, Serial NEW
        nOrder := INDEXORD()                  // Result: 1
        SET ORDER TO 2
        ? INDEXORD()                          // Result: 2
        SET ORDER TO nOrder
        ? INDEXORD()                          // Result: 1

     ^b^CFE^b  This example uses an aliased expression to determine the order
        number of the controlling index in an unselected work area:

        USE Sales INDEX Salesman, CustNum NEW
        USE Customer INDEX Name, Serial NEW
        ? Sales->(INDEXORD())                 // Result: 1

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"INDEX" "INDEXKEY()" c52g_002.ngo:"SET INDEX" c52g_002.ngo:"SET ORDER" c52g_002.ngo:"USE" 
'------------------------------------------------------------------------------



!short: INKEY()         Extract a character from the keyboard buffer
'------------------------------------------------------------------------------
 ^bINKEY()^b
 Extract a character from the keyboard buffer
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bINKEY([<nSeconds>]) --> nInkeyCode

 ^bArguments^b

     ^b<nSeconds>^b specifies the number of seconds INKEY() waits for a
     keypress.  You can specify the value in increments as small as one-tenth
     of a second.  Specifying zero halts the program until a key is pressed.
     If <nSeconds> is omitted, INKEY() does not wait for a keypress.

 ^bReturns^b

     INKEY() returns an integer numeric value from -39 to 386, identifying
     the key extracted from the keyboard buffer.  If the keyboard buffer is
     empty, INKEY() returns zero.  INKEY() returns values for all ASCII
     characters, function, Alt-function, Ctrl-function, Alt-letter, and
     Ctrl-letter key combinations.

 ^bDescription^b

     INKEY() is a keyboard function that extracts the next key pending in the
     keyboard buffer and returns a value representing that key.  The value is
     also saved internally and can be accessed using LASTKEY().  If the
     <nSeconds> argument is specified and there are no pending keys in the
     buffer, program execution pauses until a key appears in the keyboard
     buffer, or <nSeconds> has elapsed.  The time INKEY() waits is based on
     the operating system clock and is not related to the microprocessor
     speed.  If <nSeconds> is zero, program execution pauses until a key is
     placed into the buffer.  Note that INKEY() is not a wait state and
     therefore SET KEYs are not active.

     INKEY() is similar to the NEXTKEY() function.  Unlike, INKEY(), however,
     NEXTKEY() reads but does not extract the key from the keyboard buffer.
     This is useful when you need to test for a key without processing it.

     INKEY() is the basic primitive of the CA-Clipper system for fetching
     keys from the keyboard buffer.  It is used for polling the keyboard or
     pausing program execution to wait for a keypress.  As an example, you
     can use INKEY() to terminate commands with a record scope such as LIST,
     LABEL FORM, and REPORT FORM by including it in a WHILE condition.  Refer
     to the example below.

     For a complete list of INKEY() codes and Inkey.ch constants, refer to
     the Error Messages and Appendices guide.

 ^bExamples^b

     ^b^CFE^b  This example gets a key from the keyboard then displays its
        character value followed by the INKEY() value:

        #include "Inkey.ch"
        //
        LOCAL nInkeyCode := 0
        DO WHILE LASTKEY() != K_ESC
           ? "Press any key: "
           nInkeyCode := INKEY(0)
           ?? "Character:", CHR(nInkeyCode),;
              "INKEY() code:", LTRIM(STR(nInkeyCode))
        ENDDO
        RETURN

     ^b^CFE^b  This example uses INKEY() to poll for a user interrupt
        keypress during a REPORT FORM.  If the user presses Esc during the
        printing process, the REPORT FORM terminates:

        #include "Inkey.ch"
        //
        USE Sales INDEX Salesman NEW
        REPORT FORM Monthly FOR MONTH(SalesDate) = ;
              MONTH(DATE());
           WHILE INKEY() != K_ESC

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Inkey.ch.
!seealso: "CHR()" "LASTKEY()" "NEXTKEY()" c52g_002.ngo:"SET KEY" c52g_009.ngo:"Inkey codes" 
'------------------------------------------------------------------------------



!short: INT()           Convert a numeric value to an integer
'------------------------------------------------------------------------------
 ^bINT()^b
 Convert a numeric value to an integer
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bINT(<nExp>) --> nInteger

 ^bArguments^b

     ^b<nExp>^b is a numeric expression to convert to an integer.

 ^bReturns^b

     INT() returns an integer numeric value.

 ^bDescription^b

     INT() is a numeric function that converts a numeric value to an integer
     by truncating--not rounding--all digits to the right of the decimal
     point.  INT() is useful in operations where the decimal portion of a
     number is not needed.

 ^bExamples^b

     ^b^CFE^b  These examples demonstrate the results of various invocations
        of the INT() function:

        ? INT(100.00)               // Result: 100
        ? INT(.5)                   // Result: 0
        ? INT(-100.75)              // Result: -100

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ROUND()" 
'------------------------------------------------------------------------------



!short: ISALPHA()       Determine if leftmost character in a string is alphabetic
'------------------------------------------------------------------------------
 ^bISALPHA()^b
 Determine if leftmost character in a string is alphabetic
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bISALPHA(<cString>) --> lBoolean

 ^bArguments^b

     ^b<cString>^b is the character string to examine.

 ^bReturns^b

     ISALPHA() returns true (.T.) if the first character in <cString> is
     alphabetic; otherwise, it returns false (.F.).

 ^bDescription^b

     ISALPHA() is a character function that determines if the specified
     string begins with an alphabetic character.  An alphabetic character
     consists of any uppercase or lowercase letter from A to Z.  ISALPHA()
     returns false (.F.) if the string begins with a digit or any other
     character.

 ^bExamples^b

     ^b^CFE^b  These examples demonstrate various results of ISALPHA():

        ? ISALPHA("AbcDe")               // Result: .T.
        ? ISALPHA("aBcDE")               // Result: .T.
        ? ISALPHA("1BCde")               // Result: .F.
        ? ISALPHA(".FRED")               // Result: .F.

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "ISDIGIT()" "ISLOWER()" "ISUPPER()" "LOWER()" "UPPER()" 
'------------------------------------------------------------------------------



!short: ISCOLOR()       Determine if the current computer has color capability
'------------------------------------------------------------------------------
 ^bISCOLOR()^b
 Determine if the current computer has color capability
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bISCOLOR() | ISCOLOUR() --> lBoolean

 ^bReturns^b

     ISCOLOR() returns true (.T.) if there is a color graphics card
     installed; otherwise, it returns false (.F.).

 ^bDescription^b

     ISCOLOR() is a screen function that allows you to make decisions about
     the type of screen attributes to assign (color or monochrome).  Note
     that some monochrome adapters with graphics capability return true
     (.T.).

 ^bExamples^b

     ^b^CFE^b  This example installs color attribute variables at runtime:

        IF ISCOLOR()
           cBox  = "BG+/B, W/N"
           cSays = "BG/B, W/N"
           cGets = "W/N, N/W"
        ELSE
           cBox  = "W+"
           cSays = "W/N, N+/W"
           cGets = "W/N, N/W"
        ENDIF
        .
        . <statements>
        .
        SETCOLOR(cSays)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "SETCOLOR()" 
'------------------------------------------------------------------------------



!short: ISDIGIT()       Determine if leftmost character in a string is a digit
'------------------------------------------------------------------------------
 ^bISDIGIT()^b
 Determine if leftmost character in a character string is a digit
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bISDIGIT(<cString>) --> lBoolean

 ^bArguments^b

     ^b<cString>^b is the character string to examine.

 ^bReturns^b

     ISDIGIT() returns true (.T.) if the first character of the character
     string is a digit between zero and nine; otherwise, it returns false
     (.F.).

 ^bDescription^b

     ISDIGIT() is a character function that determines whether the first
     character in a string is a numeric digit between zero and nine.  If any
     other character is the first character of the <cString>, ISDIGIT()
     returns false (.F.).

     ISDIGIT() is useful where you need to know if the current character
     string is a number before converting it to a numeric value with the
     VAL() function.

 ^bExamples^b

     ^b^CFE^b  These examples demonstrate various results of ISDIGIT():

        ? ISDIGIT("AbcDe")         // Result: .F.
        ? ISDIGIT("1abcd")         // Result: .T.
        ? ISDIGIT(".12345")        // Result: .F.

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "ISALPHA()" "ISLOWER()" "ISUPPER()" "LOWER()" "UPPER()" 
'------------------------------------------------------------------------------



!short: ISLOWER()       Determine if leftmost character is a lowercase letter
'------------------------------------------------------------------------------
 ^bISLOWER()^b
 Determine if leftmost character is a lowercase letter
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bISLOWER(<cString>) --> lBoolean

 ^bArguments^b

     ^b<cString>^b is the character string to examine.

 ^bReturns^b

     ISLOWER() returns true (.T.) if the first character of the character
     string is a lowercase letter; otherwise, it returns false (.F.).

 ^bDescription^b

     ISLOWER() is a character function that determines whether the first
     character of a character string is lowercase.  It is the inverse of
     ISUPPER() which determines whether a character begins with an uppercase
     character.

     Both ISLOWER() and ISUPPER() relate to the LOWER() and UPPER() functions
     which actually convert lowercase characters to uppercase, and vice
     versa.

 ^bExamples^b

     ^b^CFE^b  These examples demonstrate various results of ISLOWER():

        ? ISLOWER("aBcDe")         // Result: .T.
        ? ISLOWER("AbcDe")         // Result: .F.
        ? ISLOWER("1abcd")         // Result: .F.
        ? ISLOWER("abcd")          // Result: .T.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ISALPHA()" "ISDIGIT()" "ISUPPER()" "LOWER()" "UPPER()" 
'------------------------------------------------------------------------------



!short: ISPRINTER()     Determine whether the LPT1 is ready
'------------------------------------------------------------------------------
 ^bISPRINTER()^b
 Determine whether the LPT1 is ready
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bISPRINTER() --> lReady

 ^bReturns^b

     ISPRINTER() returns true (.T.) if LPT1 is ready; otherwise, it returns
     false (.F.).

 ^bDescription^b

     ISPRINTER() is a printer function that determines whether the parallel
     port (LPT1) is online and ready to print.  ISPRINTER() is
     hardware-dependent and, therefore, only works on IBM BIOS compatible
     systems.

     You can check ISPRINTER() to make sure the printer is ready before you
     begin a print operation; however, if an error occurs during the print
     operation, a runtime error is generated.

 ^bExamples^b

     ^b^CFE^b  This example tests the parallel port for readiness with up to
        25 retries.  If the parallel port is ready, the printer operation
        begins:

        LOCAL nCount := 0, nTimes := 25, lReady
        //
        DO WHILE nCount++ <= nTimes .AND. !(lReady := ;
              ISPRINTER())
        ENDDO
        //
        IF lReady
           REPORT FORM Sales TO PRINTER
        ELSE
           ? "Printer not ready..."
           BREAK
        ENDIF

 ^bFiles:^b  Library is EXTEND.LIB, source file is SOURCE\SAMPLE\EXAMPLEA.ASM.
!seealso: c52g_002.ngo:"SET DEVICE" c52g_002.ngo:"SET PRINTER" 
'------------------------------------------------------------------------------



!short: ISUPPER()       Determine if leftmost character in a string is uppercase
'------------------------------------------------------------------------------
 ^bISUPPER()^b
 Determine if leftmost character in a string is uppercase
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bISUPPER(<cString>) --> lBoolean

 ^bArguments^b

     ^b<cString>^b is the character string to examine.

 ^bReturns^b

     ISUPPER() returns true (.T.) if the first character is an uppercase
     letter; otherwise, it returns false (.F.).

 ^bDescription^b

     ISUPPER() is a character function that determines whether the first
     character of a string is uppercase.  It is the inverse of ISLOWER().
     Both ISUPPER() and ISLOWER() relate to the UPPER() and LOWER() functions
     which actually convert uppercase characters to lowercase, and vice
     versa.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate ISUPPER() applied to various values:

        ? ISUPPER("AbCdE")         // Result: .T.
        ? ISUPPER("aBCdE")         // Result: .F.
        ? ISUPPER("$abcd")         // Result: .F.
        ? ISUPPER("8ABCD")         // Result: .F.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ISALPHA()" "ISDIGIT()" "ISLOWER()" "LOWER()" "UPPER()" 
'------------------------------------------------------------------------------



!short: L2BIN()         Convert CA-Clipper numeric value to 32-bit binary integer
'------------------------------------------------------------------------------
 ^bL2BIN()^b
 Convert a CA-Clipper numeric value to a 32-bit binary integer
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bL2BIN(<nExp>) --> cBinaryInteger

 ^bArguments^b

     ^b<nExp>^b is the numeric value to convert.  Decimal digits are
     truncated.

 ^bReturns^b

     L2BIN() returns a four-byte character string formatted as a 32-bit
     binary integer.

 ^bDescription^b

     L2BIN() is a low-level file function used with FWRITE() to write
     CA-Clipper numeric values to a binary file.  This function is like
     I2BIN() which formats a CA-Clipper numeric to a 16-bit binary value.

     L2BIN() is the inverse function of BIN2L().

 ^bExamples^b

     ^b^CFE^b  This example creates a new binary file then writes a series of
        numbers to the files using L2BIN() to convert the numeric value to
        32-bit binary form:

        #include "Fileio.ch"
        //
        LOCAL nNumber, nHandle
        nHandle := FCREATE("MyFile", FC_NORMAL)
        FOR nNumber := 1 TO 100
           FWRITE(nHandle, L2BIN(nNumber) + CHR(0))
        NEXT
        FCLOSE(nHandle)

 ^bFiles:^b  Library is EXTEND.LIB, source file is SOURCE\SAMPLE\EXAMPLEA.ASM.
!seealso: "BIN2I()" "BIN2L()" "BIN2W()" "CHR()" "FWRITE()" "I2BIN()" 
'------------------------------------------------------------------------------



!short: LASTKEY()       Return the last key extracted from the keyboard buffer
'------------------------------------------------------------------------------
 ^bLASTKEY()^b
 Return the INKEY() value of the last key extracted from the keyboard buffer
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bLASTKEY() --> nInkeyCode

 ^bReturns^b

     LASTKEY() returns a number between -39 and 386, identifying the INKEY()
     value of the last key extracted from the keyboard buffer.

 ^bDescription^b

     LASTKEY() is a keyboard function that reports the INKEY() value of the
     last key fetched from the keyboard buffer by the INKEY() function, or a
     wait state such as ACCEPT, INPUT, READ, WAIT, ACHOICE(), DBEDIT(), or
     MEMOEDIT().  LASTKEY() retains its current value until another key is
     fetched from the keyboard buffer.

     LASTKEY() has a number of uses which include:

     ^b^CFE^b  Determining the key that terminates a READ

     ^b^CFE^b  Determining the key that exits the current Get object within a
        user-defined function, invoked by a VALID clause

     ^b^CFE^b  Identifying an exception key in the user function of
        ACHOICE(), DBEDIT(), or MEMOEDIT()

     LASTKEY() is also used with UPDATED() to determine if any Get object's
     buffer was changed during a READ.

     LASTKEY() is related to NEXTKEY() and READKEY().  NEXTKEY() reads the
     current key pending in the keyboard buffer without removing it.  Use
     NEXTKEY() instead of INKEY() when polling for a key.

     For a complete list of INKEY() codes and Inkey.ch constants for each
     key, refer to the Error Messages and Appendices guide.

 ^bExamples^b

     ^b^CFE^b  This example illustrates a typical application of LASTKEY() to
        test the key that exits a READ.  If the user exits with any key other
        than Esc and a GET was changed, the specified database file is
        updated:

        #include "Inkey.ch"
        //
        USE Customer NEW
        MEMVAR->balance = Customer->Balance
        @ 10, 10 SAY "Current Balance" GET MEMVAR->balance
        READ
        //
        IF (LASTKEY() != K_ESC) .AND. UPDATED()
           REPLACE Customer->Balance WITH MEMVAR->balance
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Inkey.ch.
!seealso: "CHR()" "INKEY()" c52g_002.ngo:"KEYBOARD" "NEXTKEY()" c52g_009.ngo:"Inkey codes" 
'------------------------------------------------------------------------------



!short: LASTREC()       Determine the number of records in the current (.dbf) file
'------------------------------------------------------------------------------
 ^bLASTREC()^b
 Determine the number of records in the current (.dbf) file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bLASTREC() | RECCOUNT()* --> nRecords

 ^bReturns^b

     LASTREC() returns the number of physical records in the current database
     file as an integer numeric value.  Filtering commands such as SET FILTER
     or SET DELETED have no effect on the return value.  LASTREC() returns
     zero if there is no database file in USE in the current work area.

 ^bDescription^b

     LASTREC() is a database function that determines the number of physical
     records in the current database file.  LASTREC() is identical to
     RECCOUNT() which is supplied as a compatibility function.

     By default, LASTREC() operates on the currently selected work area.  It
     will operate on an unselected work area if you specify it as part of an
     aliased expression (see example below).

 ^bExamples^b

     ^b^CFE^b  This example illustrates the relationship between LASTREC(),
        RECCOUNT(), and COUNT:

        USE Sales NEW
        ? LASTREC(), RECCOUNT()          // Result: 84 84
        //
        SET FILTER TO Salesman = "1001"
        COUNT TO nRecords
        ? nRecords, LASTREC()            // Result: 14 84

     ^b^CFE^b  This example uses an aliased expression to access the number
        of records in a open database file in an unselected work area:

        USE Sales NEW
        USE Customer NEW
        ? LASTREC(), Sales->(LASTREC())

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"COUNT" "EOF()" 
'------------------------------------------------------------------------------



!short: LEFT()          Extract a substring beginning with the leftmost character
'------------------------------------------------------------------------------
 ^bLEFT()^b
 Extract a substring beginning with the first character in a string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bLEFT(<cString>, <nCount>) --> cSubString

 ^bArguments^b

     ^b<cString>^b is a character string from which to extract characters.
     The maximum size of <cString> is 65,535 (64K) bytes.

     ^b<nCount>^b is the number of characters to extract.

 ^bReturns^b

     LEFT() returns the leftmost <nCount> characters of <cString> as a
     character string.  If <nCount> is negative or zero, LEFT() returns a
     null string ("").  If <nCount> is larger than the length of the
     character string, LEFT() returns the entire string.

 ^bDescription^b

     LEFT() is a character function that returns a substring of a specified
     character string.  It is the same as SUBSTR(<cString>, 1, <nCount>).
     LEFT() is also like RIGHT() which returns a substring beginning with the
     last character in a string.

     LEFT(), RIGHT(), and SUBSTR() are often used with both the AT() and
     RAT() functions to locate the first and/or the last position of a
     substring before extracting it.

 ^bExamples^b

     ^b^CFE^b  This example extracts the first three characters from the left
        of the target string:

        ? LEFT("ABCDEF", 3)                 // Result: ABC

     ^b^CFE^b  This example extracts a substring from the beginning of a
        string up to the first occurrence of a comma:

        LOCAL cName := "James, William"
        ? LEFT(cName, AT(",", cName) - 1)   // Result: James

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "AT()" "LTRIM()" "RAT()" "RIGHT()" "RTRIM()" "STUFF()" "SUBSTR()" 
'------------------------------------------------------------------------------



!short: LEN()           Return length of a string or number of array elements
'------------------------------------------------------------------------------
 ^bLEN()^b
 Return the length of a character string or the number of elements in an array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bLEN(<cString> | <aTarget>) --> nCount

 ^bArguments^b

     ^b<cString>^b is the character string to count.

     ^b<aTarget>^b is the array to count.

 ^bReturns^b

     LEN() returns the length of a character string or the number of elements
     in an array as an integer numeric value.  If the character string is a
     null string ("") or the array is empty, LEN() returns zero.

 ^bDescription^b

     LEN() is a character and array function that returns the length of a
     character string or the number of elements in an array.  With a
     character string, each byte counts as one, including an embedded null
     byte (CHR(0)).  By contrast, a null string (""), counts as zero.

     For an array, LEN() returns the number of elements.  If the array is
     multidimensional, subarrays count as one element.  This means that the
     LEN() of a nested or multidimensional array simply returns the length of
     the first dimension.  To determine the number of elements in other
     dimensions, use LEN() on the subarrays as shown in the example below.
     Note that nested arrays in CA-Clipper need not have uniform dimensions.

 ^bExamples^b

     ^b^CFE^b  These examples demonstrate LEN() with various arguments:

        ? LEN("string of characters")        // Result: 20
        ? LEN("")                            // Result: 0
        ? LEN(CHR(0))                        // Result: 1
        //
        LOCAL aTest[10]
        ? LEN(aTest)                         // Result: 10

     ^b^CFE^b  This example creates a literal two-dimensional array then
        returns the number of elements in the subarray contained in the first
        element of the original array:

        LOCAL aArray := { {1, 2}, {1, 2}, {1, 2} }
        ? LEN(aArray)                        // Result: 3
        ? LEN(aArray[1])                     // Result: 2

     ^b^CFE^b  This example navigates a multidimensional array using LEN():

        LOCAL aArray := { {1, 2}, {1, 2}, {1, 2} }
        LOCAL nRow, nColumn, nRowCount, nColumnCount
        //
        nRowCount = LEN(aArray)
        FOR nRow = 1 TO nRowCount
           nColumnCount = LEN(aArray[nRow])
           FOR nColumn = 1 TO nColumnCount
              ? nRow, nColumn, aArray[nRow][nColumn]
           NEXT
        NEXT

     ^b^CFE^b  In this example a function returns an array of numeric values
        that describe the dimensions of a nested or multidimensional array.
        The function assumes that the array has uniform dimensions:

        FUNCTION Dimensions( aArray )

           LOCAL aDims := {}
           DO WHILE ( VALTYPE(aArray) == "A" )
              AADD( aDims, LEN(aArray) )
              aArray := aArray[1]
           ENDDO
           RETURN (aDims)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "AADD()" "ASIZE()" "LTRIM()" "RTRIM()" 
'------------------------------------------------------------------------------



!short: LOG()           Calculate the natural logarithm of a numeric value
'------------------------------------------------------------------------------
 ^bLOG()^b
 Calculate the natural logarithm of a numeric value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bLOG(<nExp>) --> nNaturalLog

 ^bArguments^b

     ^b<nExp>^b is a numeric value greater than zero to convert to its
     natural logarithm.

 ^bReturns^b

     LOG() returns the natural logarithm as a numeric value.  If <nExp> is
     less than or equal to zero, LOG() returns a numeric overflow (displayed
     as a row of asterisks).

 ^bDescription^b

     LOG() is a numeric function that calculates the natural logarithm of a
     number and is the inverse of EXP().  The natural logarithm has a base of
     e which is approximately 2.7183.  The LOG() function returns x in the
     following equation:

     e**x = y

     where y is the numeric expression used as the LOG() argument (i.e.,
     LOG(y) = x).  Due to mathematical rounding, the values returned by LOG()
     and EXP() may not agree exactly (i.e., EXP(LOG(x)) may not always equal
     x).

 ^bExamples^b

     ^b^CFE^b  These examples demonstrate various results of LOG():

        ? LOG(10)                // Result: 2.30
        ? LOG(10 * 2)            // Result: 3.00
        ? EXP(LOG(1))            // Result: 1.00
        ? LOG(2.71)              // Result: 1.00

     ^b^CFE^b  This example is a user-defined function that returns the base
        10 logarithm:

        FUNCTION Log10( nNumber )
        IF nNumber > 0
           RETURN LOG(nNumber)/LOG(10)
        ELSE
           RETURN NIL
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "EXP()" c52g_002.ngo:"SET DECIMALS" c52g_002.ngo:"SET FIXED" 
'------------------------------------------------------------------------------



!short: LOWER()         Convert uppercase characters to lowercase
'------------------------------------------------------------------------------
 ^bLOWER()^b
 Convert uppercase characters to lowercase
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bLOWER(<cString>) --> cLowerString

 ^bArguments^b

     ^b<cString>^b is a character string to convert to lowercase.

 ^bReturns^b

     LOWER() returns a copy of <cString> with all alphabetic characters
     converted to lowercase.  All other characters remain the same as in the
     original string.

 ^bDescription^b

     LOWER() is a character function that converts upper and mixedcase
     strings to lowercase.  It is related to UPPER() which converts lower and
     mixedcase strings to uppercase.  LOWER() is related to the ISLOWER() and
     ISUPPER() functions which determine whether a string begins with a lower
     or uppercase letter.

     LOWER() is generally used to format character strings for display
     purposes.  It can, however, be used to normalize strings for
     case-independent comparison or INDEXing purposes.

 ^bExamples^b

     ^b^CFE^b  These examples demonstrate various results of LOWER():

        ? LOWER("STRING")             // Result: string
        ? LOWER("1234 CHARS = ")      // Result: 1234 chars =

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ISLOWER()" "ISUPPER()" "UPPER()" 
'------------------------------------------------------------------------------



!short: LTRIM()         Remove leading spaces from a character string
'------------------------------------------------------------------------------
 ^bLTRIM()^b
 Remove leading spaces from a character string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bLTRIM(<cString>) --> cTrimString

 ^bArguments^b

     ^b<cString>^b is the character string to copy without leading spaces.

 ^bReturns^b

     LTRIM() returns a copy of <cString> with the leading spaces removed.  If
     <cString> is a null string ("") or all spaces, LTRIM() returns a null
     string ("").

 ^bDescription^b

     LTRIM() is a character function that formats character strings with
     leading spaces.  These can be, for example, numbers converted to
     character strings using STR().

     LTRIM() is related to RTRIM() which removes trailing spaces, and
     ALLTRIM() which removes both leading and trailing spaces.  The inverse
     of ALLTRIM(), LTRIM(), and RTRIM() are the PADC(), PADR(), and PADL()
     functions which center, right-justify, or left-justify character strings
     by padding them with fill characters.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate LTRIM() used with several other
        functions:

        nNumber = 18
        ? STR(nNumber)                // Result:         18
        ? LEN(STR(nNumber))           // Result: 10
        ? LTRIM(STR(nNumber))         // Result: 18
        ? LEN(LTRIM(STR(nNumber)))    // Result: 2

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ALLTRIM()" "PAD()" "RTRIM()" "STR()" "SUBSTR()" 
'------------------------------------------------------------------------------



!short: LUPDATE()       Return the last modification date of a (.dbf) file
'------------------------------------------------------------------------------
 ^bLUPDATE()^b
 Return the last modification date of a (.dbf) file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bLUPDATE() --> dModification

 ^bReturns^b

     LUPDATE() returns the date of last change to the open database file in
     the current work area.  If there is no database file in USE, LUPDATE()
     returns a blank date.

 ^bDescription^b

     LUPDATE() is a database function that determines the date the database
     file in the current work area was last modified and CLOSEd.  By default,
     LUPDATE() operates on the currently selected work area.  It will operate
     on an unselected work area if you specify it as part of an aliased
     expression as shown in the example below.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates that the modification date of
        database file is not changed until the database file is closed:

        ? DATE()                  // Result: 09/01/90
        USE Sales NEW
        ? LUPDATE()               // Result: 08/31/90
        //
        APPEND BLANK
        ? LUPDATE()               // Result: 08/31/90
        CLOSE DATABASES
        //
        USE Sales NEW
        ? LUPDATE()               // Result: 09/01/90

     ^b^CFE^b  This example uses an aliased expression to access LUPDATE()
        for a database file open in an unselected work area:

        USE Sales NEW
        USE Customer NEW
        ? LUPDATE(), Sales->(LUPDATE())

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "FIELDNAME()" "LASTREC()" "RECSIZE()" 
'------------------------------------------------------------------------------



!short: MAX()           Return the larger of two numeric or date values
'------------------------------------------------------------------------------
 ^bMAX()^b
 Return the larger of two numeric or date values
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMAX(<nExp1>, <nExp2>) --> nLarger
     ^bMAX(<dExp1>, <dExp2>) --> dLarger

 ^bArguments^b

     ^b<nExp1>^b and ^b<nExp2>^b are the numeric values to compare.

     ^b<dExp1>^b and ^b<dExp2>^b are the date values to compare.

 ^bReturns^b

     MAX() returns the larger of the two arguments.  The value returned is
     the same type as the arguments.

 ^bDescription^b

     MAX() is a numeric and a date function that ensures the value of an
     expression is larger than a specified minimum.  The inverse of MAX() is
     MIN(), which returns the lesser of two numeric or date values.

 ^bExamples^b

     ^b^CFE^b  In these examples MAX() returns the greater of two numeric
        values:

        ? MAX(1, 2)                     // Result: 2
        ? MAX(2, 1)                     // Result: 2

     ^b^CFE^b  In these examples MAX() compares date values:

        ? DATE()                        // Result: 09/01/90
        ? MAX(DATE(), DATE() + 30)      // Result: 10/01/90
        ? MAX(DATE(), CTOD(""))         // Result: 09/01/90

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "MIN()" 
'------------------------------------------------------------------------------



!short: MAXCOL()        Determine the maximum visible screen column
'------------------------------------------------------------------------------
 ^bMAXCOL()^b
 Determine the maximum visible screen column
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMAXCOL() --> nColumn

 ^bReturns^b

     MAXCOL() returns the column number of the rightmost visible column for
     display purposes.

 ^bDescription^b

     MAXCOL() is a screen function that determines the maximum visible column
     of the screen.  Row and column numbers start at zero in CA-Clipper.

     If you use a C or other extended function to set the video mode, use the
     SETMODE() function so your CA-Clipper application returns the correct
     value for MAXCOL().

 ^bExamples^b

     ^b^CFE^b  This example uses MAXROW() and MAXCOL() to determine the area
        to draw a box then executes DBEDIT() within the box region:

        CLS
        @ 0, 0 TO MAXROW(), MAXCOL() DOUBLE
        DBEDIT(1, 1, MAXROW() + 1, MAXCOL() - 1)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "COL()" "MAXROW()" "ROW()" 
'------------------------------------------------------------------------------



!short: MAXROW()        Determine the maximum visible screen row
'------------------------------------------------------------------------------
 ^bMAXROW()^b
 Determine the maximum visible screen row
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMAXROW() --> nRow

 ^bReturns^b

     MAXROW() returns the row number of the bottommost visible row for
     display purposes.

 ^bDescription^b

     MAXROW() is a screen function that determines the maximum visible row of
     the screen.  Row and column numbers start at zero in CA-Clipper.

     If you use a C or other extended function to set the video mode, use the
     SETMODE() function so your CA-Clipper application returns the correct
     value for MAXCOL().

 ^bExamples^b

     ^b^CFE^b  This user-defined function, ScreenSize(), uses MAXROW() and
        MAXCOL() to return an array containing the current screen size:

        FUNCTION ScreenSize
           RETURN { MAXROW(), MAXCOL() }

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "COL()" "MAXCOL()" "ROW()" 
'------------------------------------------------------------------------------



!short: MEMOEDIT()      Display or edit character strings and memo fields           ^r^CE4^r
'------------------------------------------------------------------------------
 ^bMEMOEDIT()^b
 Display or edit character strings and memo fields
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMEMOEDIT([<cString>],
     ^b   [<nTop>], [<nLeft>],
     ^b   [<nBottom>], [<nRight>],
     ^b   [<lEditMode>],
     ^b   [<cUserFunction>],
     ^b   [<nLineLength>],
     ^b   [<nTabSize>],
     ^b   [<nTextBufferRow>],
     ^b   [<nTextBufferColumn>],
     ^b   [<nWindowRow>],
     ^b   [<nWindowColumn>]) --> cTextBuffer

 ^bArguments^b

     ^b<cString>^b is the character string or memo field to copy to the
     MEMOEDIT() text buffer.  If not specified, the text buffer is empty.

     ^b<nTop>^b, ^b<nLeft>^b, ^b<nBottom>^b, and ^b<nRight>^b are the upper
     left and lower right window coordinates.  Row values can range from zero
     to MAXROW(), and column positions can range from zero to MAXCOL().  If
     not specified, the default coordinates are 0, 0, MAXROW(), and MAXCOL().

     ^b<lEditMode>^b determines whether the text buffer can be edited or
     merely displayed.  Specifying true (.T.) allows the user to make changes
     to the text buffer, while specifying false (.F.) only allows the user to
     browse the text buffer.  If not specified, the default value is true
     (.T.).

     ^b<cUserFunction>^b is the name of a user-defined function that executes
     when the user presses a key not recognized by MEMOEDIT() and when no
     keys are pending in the keyboard buffer.  <cUserFunction> is specified
     as a character value without parentheses or arguments.  Specifying false
     (.F.) for this argument displays <cString> and causes MEMOEDIT() to
     immediately terminate.  If this argument is specified, the automatic
     behavior of MEMOEDIT() changes.  Refer to the discussion below.

     ^b<nLineLength>^b determines the length of lines displayed in the
     MEMOEDIT() window.  If a line is greater than <nLineLength>, it is word
     wrapped to the next line in the MEMOEDIT() window.  If <nLineLength> is
     greater than the number of columns in the MEMOEDIT() window, the window
     will scroll if the cursor moves past the window border.  If
     <nLineLength> is not specified, the default line length is (<nRight> -
     <nLeft>).

     ^b<nTabSize>^b determines the size of a tab character to insert when the
     user presses Tab.  If <nTabSize> is not specified, four spaces are
     inserted instead of a tab character.

     ^b<nTextBufferRow>^b and ^b<nTextBufferColumn>^b define the display
     position of the cursor within the text buffer when MEMOEDIT() is
     invoked.  <nTextBufferRow> begins with one and <nTextBufferColumn>
     begins with zero.  If these arguments are not specified, the cursor is
     placed at row one and column zero of the MEMOEDIT() window.

     ^b<nWindowRow>^b and ^b<nWindowColumn>^b define the initial position the
     cursor within the MEMOEDIT() window.  Row and column positions begin
     with zero.  If these arguments are not specified, the initial window
     position is row zero and the current cursor column position.

 ^bReturns^b

     MEMOEDIT() returns the text buffer if the user terminates editing with
     Ctrl-W or a copy of <cString> if user terminates with Esc.

 ^bDescription^b


     MEMOEDIT() is a user interface and general purpose text editing function
     that edits memo fields and long character strings.  Editing occurs
     within a specified window region placed anywhere on the screen.  Like
     the other user interface functions (ACHOICE() and DBEDIT()), MEMOEDIT()
     supports a number of different modes and includes a user function that
     allows key reconfiguration and other activities relevant to programming
     the current text editing task.

     ^b^CFE  The text buffer:^b When you invoke MEMOEDIT() and specify
        <cString>, it is copied to the text buffer.  The user actually edits
        the text buffer.  If the <cString> is not specified, the user is
        presented with an empty text buffer to edit.

        When the user exits MEMOEDIT() by pressing Ctrl-W, the contents of
        the text buffer are returned.  If the user exits by pressing Esc, the
        text buffer is discarded and the original <cString> value is
        returned.  In either case, the return value can then be assigned to a
        variable or memo field, or passed as an argument to another function.

     ^b^CFE  Editing modes:^b MEMOEDIT() supports two editing modes depending
        on the value of <lEditMode>.  When <lEditMode> is true (.T.),
        MEMOEDIT() enters edit mode and the user can change the contents of
        the MEMOEDIT() text buffer.  When <lEditMode> is false (.F.),
        MEMOEDIT() enters browse mode and the user can only navigate about
        the text buffer but cannot edit or insert new text.  To make browsing
        easier for the user, the scrolling is disabled so Uparrow and Dnarrow
        scroll the text buffer up or down one line within the MEMOEDIT()
        window.

     ^b^CFE  Entering and editing text:^b Within MEMOEDIT(), the user can
        enter and edit text by positioning the cursor, adding, or deleting
        characters.  To facilitate editing the text, there are a number of
        different navigation and editing keys:

        ^bMEMOEDIT() Navigation and Editing Keys^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bKey                      Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        Uparrow/Ctrl-E           Move up one line
        Dnarrow/Ctrl-X           Move down one line
        Leftarrow/Ctrl-S         Move left one character
        Rightarrow/Ctrl-D        Move right one character
        Ctrl-Leftarrow/Ctrl-A    Move left one word
        Ctrl-Rightarrow/Ctrl-F   Move right one word
        Home                     Move to beginning of current line
        End                      Move to end of current line
        Ctrl-Home                Move to beginning of current window
        Ctrl-End                 Move to end of current window
        PgUp                     Move to previous edit window
        PgDn                     Move to next edit window
        Ctrl-PgUp                Move to beginning of memo
        Ctrl-PgDn                Move to end of memo
        Return                   Move to beginning of next line
        Delete                   Delete character at cursor
        Backspace                Delete character to left of cursor
        Tab                      Insert tab character or spaces
        Printable characters     Insert character
        Ctrl-Y                   Delete the current line
        Ctrl-T                   Delete word right
        Ctrl-B                   Reform paragraph
        Ctrl-V/Ins               Toggle insert mode
        Ctrl-W                   Finish editing with save
        Esc                      Abort edit and return original
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

        When the user is entering text, there are two text entry modes,
        insert and overstrike.  When MEMOEDIT() is invoked, the default mode
        is overstrike.  Edit mode changes in MEMOEDIT() when the user presses
        Ins which toggles between the insert and overstrike.  It also changes
        in a user function using READINSERT() or RETURNing 22.  In insert
        mode, characters are entered into the text buffer at the current
        cursor position and the remainder of the text moves to the right.
        Insert mode is indicated in the scoreboard area.  In overstrike mode,
        characters are entered at the current cursor position overwriting
        existing characters while the rest of the text buffer remains in its
        current position.

        As the user enters text and the cursor reaches the edge of the
        MEMOEDIT() window, the current line wraps to the next line in the
        text buffer and a soft carriage return (CHR(141)) is inserted into
        the text.  If the <nLineLength> argument is specified, text wraps
        when the cursor position is the same as <nLineLength>.  If
        <nLineLength> is greater than the width of the MEMOEDIT() window, the
        window scrolls.  To explicitly start a new line or paragraph, the
        user must press Return.

     ^b^CFE  The edit screen:^b When MEMOEDIT() displays, it overwrites the
        specified area of the screen and does not save the underlying screen.
        Additionally, it does not display a border or a title.  To provide
        these facilities, you must create a procedure or user-defined
        function that performs these actions then calls MEMOEDIT().  See the
        example below.

     ^b^CFE  The user function:^b <cUserFunction>, a user-defined function
        specified as an argument, handles key exceptions and reconfigures
        special keys.  The user function is called at various times by
        MEMOEDIT(), most often in response to keys it does not recognize.
        Keys that instigate a key exception are all available control keys,
        function keys, and Alt keys.  Since these keys are not processed by
        MEMOEDIT(), they can be reconfigured.  Some of these keys have a
        default action assigned to them.  In the user function, you perform
        various actions, depending on the current MEMOEDIT() mode, then
        RETURN a value telling MEMOEDIT() what to do next.

        When the user function argument is specified, MEMOEDIT() defines two
        classes of keys: nonconfigurable and key exceptions.  When a
        nonconfigurable key is pressed, MEMOEDIT() executes it, otherwise a
        key exception is generated and the user function is called.  When
        there are no keys left in the keyboard buffer for MEMOEDIT() to
        process, the user function is called once again.

        When MEMOEDIT() calls the user function, it automatically passes
        three parameters indicating the MEMOEDIT() mode, the current text
        buffer line, and the current text buffer column.  The mode indicates
        the current state of MEMOEDIT() depending on the last key pressed or
        the last action taken prior to executing the user function.  The
        following modes are possible:

        ^bMEMOEDIT() Modes^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bMode    Memoedit.ch    Description^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0       ME_IDLE        Idle, all keys processed
        1       ME_UNKEY       Unknown key, memo unaltered
        2       ME_UNKEYX      Unknown key, memo altered
        3       ME_INIT        Initialization mode
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
!seealso: "MEMOEDIT()..." 
'------------------------------------------------------------------------------



!short: MEMOEDIT()...   continued
'------------------------------------------------------------------------------
        A mode value of 3 indicates that MEMOEDIT() is in initialization
        mode.  When you specify <cUserFunction>, MEMOEDIT() makes a call to
        the user function immediately after being invoked.  At this point,
        you RETURN a request to set MEMOEDIT()'s various text formatting
        modes: word wrap, scroll, or insert.  MEMOEDIT() calls the user
        function repeatedly, remaining in the initialization mode until you
        RETURN 0.  The text buffer is then displayed, and the user enters the
        edit mode set by <lEditMode>.  Note that if word wrap is on when
        MEMOEDIT() changes from initialization to edit mode, the entire text
        buffer is formatted with <nLineLength>.  To prevent this initial
        formatting, toggle word wrap off during initialization.  Note also
        that the toggles for scroll and word wrap are not assigned to any
        key, but can be assigned to a key from the user function.

        Modes 1 and 2 indicate that MEMOEDIT() has fetched an unrecognizable
        or configurable key from the keyboard buffer.  Configurable keys are
        processed by RETURNing 0 to execute the MEMOEDIT() default action.
        RETURNing a different value executes another key action, thereby
        redefining the key.  If the key is an unrecognizable key you can
        define an action for it by RETURNing a value requesting a key action
        or perform an action of your own definition.

        Mode 0 indicates that MEMOEDIT() is now idle with no more keys to
        process.  Whenever, MEMOEDIT() becomes idle, it always make a call to
        the user function.  At this point, you generally update line and
        column number displays.

        The other two parameters, current line and column, indicate the
        current cursor position in the text buffer when the user function is
        called.  The line parameter begins with position one, and column
        begins with position zero.

        When the mode is either 1, 2, or 3, you can return a value
        instructing MEMOEDIT() what action to perform next.  The following
        table summarizes the possible return values and their consequences:

        ^bMEMOEDIT() User Function Return Values^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bValue   Memoedit.ch         Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0       ME_DEFAULT          Perform default action
        1-31    ME_UNKEY            Process requested action corresponding to
                                    key value
        32      ME_IGNORE           Ignore unknown key
        33      ME_DATA             Treat unknown key as data
        34      ME_TOGGLEWRAP       Toggle word wrap mode
        35      ME_TOGGLESCROLL     Toggle scroll mode
        100     ME_WORDRIGHT        Perform word-right operation
        101     ME_BOTTOMRIGHT      Perform bottom-right operation
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^b^CFE  Header files:^b To make the mode and request values easier to
        remember and use, the header file Memoedit.ch is supplied in
        \CLIPPER5\INCLUDE.  Additionally Inkey.ch, which contains manifest
        constants for all the INKEY() values, is also located in the same
        directory.

 ^bNotes^b

     ^b^CFE  Configuring keys:^b If the <cUserFunction> is specified, the
        keys in the table below are configurable.

        ^bMEMOEDIT() Configurable Keys^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bKey            Default Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        Ctrl-Y         Delete the current line
        Ctrl-T         Delete word right
        Ctrl-B         Reform Paragraph
        Ctrl-V/Ins     Toggle insert mode
        Ctrl-W         Finish editing with save
        Esc            Abort edit and return original
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

        If the key is configurable, RETURNing 0 executes the MEMOEDIT()
        default action.  RETURNing a different value, however, executes
        another key action thereby redefining the key.  If the key is not a
        configurable key recognized by MEMOEDIT(), you can define an action
        for it also by RETURNing a value requesting a key action from the
        table above.

     ^b^CFE  Word wrap:^b Word wrap is a formatting mode you can toggle by
        RETURNing 34 from the user function.  When word wrap is on (the
        default), MEMOEDIT() inserts a soft carriage return/linefeed at the
        closest word break to the window border or line length, whichever
        occurs first.  When word wrap is off, MEMOEDIT() scrolls text buffer
        beyond the edge of the window until the cursor reaches the end of
        line.  At this point, the user must press Return (inserting a hard
        carriage return/linefeed) to advance to the next line.

     ^b^CFE  Reforming paragraphs:^b Pressing Ctrl-B or RETURNing a 2 from a
        user function reformats the text buffer until a hard carriage return
        (end of paragraph) or the end of the text buffer is reached.  This
        happens regardless of whether word wrap is on or off.

     ^b^CFE  Soft carriage returns:^b In CA-Clipper, the insertion of soft
        carriage return/linefeed characters is never allowed to change the
        significant content of the text.  That is, when a soft carriage
        return/linefeed is inserted between two words, the space characters
        between the two words are preserved.  When text is reformatted, any
        soft carriage return/linefeed characters are removed.  This leaves
        the text in its original form and properly handles the case where a
        soft carriage return/linefeed has been inserted in the middle of a
        word.

        In the Summer '87 version of MEMOEDIT(), when a soft carriage
        return/linefeed is inserted, a single space character is removed from
        the text at that point.  If the text is later reformatted using a
        different line width, each soft carriage return/linefeed is replaced
        by a single space.  However, if the text string is reformatted using
        any of the CA-Clipper text handling functions, words that were
        separated by a soft carriage return/linefeed will be run together
        because the soft carriage return/linefeed is not replaced with a
        space.

        To prevent this, text that was formatted using Summer '87 MEMOEDIT()
        should be processed to change any soft carriage return/linefeed pairs
        into space characters.  This can be accomplished using the STRTRAN()
        function as follows.

        STRTRAN( <text>, CHR(141)+CHR(10), " " )

        To convert memo values in an existing database, the following two
        line program can be used:

        USE <xcDatabase>
        REPLACE ALL <idMemo> WITH ;
           STRTRAN( <idMemo>, CHR(141)+CHR(10), " " )

        Because of the (.dbt) file format, replacing all occurrences of a
        memo field can cause the (.dbt) file to grow significantly.  The
        (.dbt) file can be reduced by copying the (.dbf) to a new file.

        For very large (.dbt) files, it may not be feasible to perform the
        above procedure.  The supplied utility program, DBT50.EXE located in
        \CLIPPER5\BIN, may be useful in these cases.  DBT50 scans an entire
        (.dbt) file, replacing any soft carriage return/linefeed pairs with
        two spaces.  Although this has the undesirable effect of causing
        certain words to be separated by two spaces instead of one, it allows
        the file to be processed in place without using additional disk
        space.  DBT50 modifies only soft carriage return/linefeed pairs in
        the target file.  Other text is unaffected.

     ^b^CFE  Editing text files:^b MEMOEDIT() edits text files if the text
        file can be read into a CA-Clipper character variable.  This can be
        done with the MEMOREAD() function.  After editing the contents of the
        text file held in the character variable, write it back to the file
        using MEMOWRIT().

 ^bExamples^b

     ^b^CFE^b  This example lets you browse a memo field but prevents any
        changes to the text buffer:

        USE Customer NEW
        SET CURSOR OFF
        MEMOEDIT(CustNotes, 5, 10, 20, 69, .F.)
        SET CURSOR ON

     ^b^CFE^b  This example allows editing of a memo field, assigning the
        changes back to the memo field:

        USE Customer NEW
        REPLACE CustNotes WITH ;
              MEMOEDIT(CustNotes, 5, 10, 20, 69)

     ^b^CFE^b  This example creates a character string using MEMOEDIT():

        LOCAL cNotes
        cNotes = MEMOEDIT()

     ^b^CFE^b  This example is a user-defined function that edits a character
        string in a boxed window displayed with a title:

        FUNCTION EditMemo( cString, cTitle,;
                 nTop, nLeft, nBottom, nRight )
           LOCAL cScreen := SAVESCREEN(nTop, nLeft,;

                 nBottom, nRight)
           @ nTop - 1, nLeft - 2 CLEAR TO nBottom + 1,;
                 nRight + 2
           @ nTop - 1, nLeft - 2 TO nBottom + 1, nRight + 2
           @ nTop - 1, nLeft SAY "[" + cTitle + "]"
           cString = MEMOEDIT(cString, nTop, nLeft,;
                 nBottom, nRight)
           RESTSCREEN(nTop, nLeft, nBottom, nRight, cScreen)
           RETURN (cString)

     ^b^CFE^b  This example reads the contents of a text file into a
        character variable, edits it, then writes it back to disk:

        LOCAL cString := MEMOREAD("Text.txt")
        cString := MEMOEDIT(cString)
        IF !MEMOWRIT("Text.txt", cString)
           ? "Write error"
           BREAK
        ENDIF
        RETURN

     ^b^CFE^b  This example contains a user-defined function that displays a
        message describing the current MEMOEDIT() mode.  Additionally, while
        in ME_UNKEY mode, the function will perform either a ME_WORDRIGHT or
        ME_BOTTOMRIGHT action depending on which associated function key is
        pressed:

        #include "memoedit.ch"
        #include "inkey.ch"

        PROCEDURE Main()
           USE Customer NEW
           REPLACE CustNotes WITH;
           MEMOEDIT( CustNotes, 5, 5, 15, 75, .T., "MemoUDF" )
        RETURN

        FUNCTION MemoUDF( nMode, nLine, nCol )
           LOCAL nKey := LASTKEY()
           LOCAL nRetVal := ME_DEFAULT         // Default return action

           DO CASE
           CASE nMode == ME_IDLE
              @ 20, 5 SAY "MemoMode is ME_IDLE  "
           CASE nMode == ME_UNKEY
              @ 20, 5 SAY "MemoMode is ME_UNKEY "
              DO CASE
              CASE nKey == K_F2
                 nRetVal := ME_WORDRIGHT
              CASE nKey == K_F3
                 nRetVal := ME_BOTTOMRIGHT
              ENDCASE
              CASE nMode == ME_UNKEYX
              @ 20, 5 SAY "MemoMode is ME_UNKEYX"
           OTHERWISE

              @ 20, 5 SAY "MemoMode is ME_INIT  "
           ENDCASE

        RETURN nRetVal

 ^bFiles:^b  Library is EXTEND.LIB, header files are Memoedit.ch and Inkey.ch.
!seealso: "LASTKEY()" "MEMOREAD()" "MEMOTRAN()" "MEMOWRIT()" 
'------------------------------------------------------------------------------



!short: MEMOLINE()      Extract a line of text from a character string or memo field
'------------------------------------------------------------------------------
 ^bMEMOLINE()^b
 Extract a line of text from a character string or memo field
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMEMOLINE(<cString>,
     ^b   [<nLineLength>],
     ^b   [<nLineNumber>],
     ^b   [<nTabSize>],
     ^b   [<lWrap>]) --> cLine

 ^bArguments^b

     ^b<cString>^b is the memo field or character string from which to
     extract a line of text.

     ^b<nLineLength>^b specifies the number of characters per line and can be
     between four and 254.  If not specified, the default line length is 79.

     ^b<nLineNumber>^b is the line number to extract.  If not specified, the
     default value is one.

     ^b<nTabSize>^b defines the tab size.  If not specified, the default
     value is four.  If <nTabSize> is greater than or equal to <nLineLength>,
     then the tab size is automatically converted to <nLineLength> - 1.

     ^b<lWrap>^b toggles word wrap on and off.  Specifying true (.T.) toggles
     word wrap on; false (.F.) toggles it off.  If not specified, the default
     value is true (.T.).

 ^bReturns^b

     MEMOLINE() returns the line of text specified by <nLineNumber> in
     <cString> as a character string.  If the line has fewer characters than
     the indicated length, the return value is padded with blanks.  If the
     line number is greater than the total number of lines in <cString>,
     MEMOLINE() returns a null string ("").

     If <lWrap> is true (.T.) and the indicated line length breaks the line
     in the middle of a word, that word is not included as part of the return
     value but shows up at the beginning of the next line extracted with
     MEMOLINE().

     If <lWrap> is false (.F.), MEMOLINE() returns only the number of
     characters specified by the line length.  The next line extracted by
     MEMOLINE() begins with the character following the next hard carriage
     return, and all intervening characters are not processed.

 ^bDescription^b

     MEMOLINE() is a memo function used with MLCOUNT() to extract lines of
     text from character strings and memo fields based on the number of
     characters per line.  It is the most basic facility provided by
     CA-Clipper to display memo fields and long strings.

     The basic method of operation is to determine the number of lines in the
     memo field or character string using MLCOUNT() with the same number of
     characters per line, tab size, and wrapping behavior as you intend to
     use with MEMOLINE().  Using this value as the upper boundary of a
     FOR...NEXT, each line of the memo field or character string can be
     extracted with MEMOLINE() and processed with any combination of output
     commands and functions required.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates the general method for displaying
        memo fields and long character strings using the combination of
        MLCOUNT() and MEMOLINE():

        LOCAL nLineLength := 40, nTabSize := 3, lWrap := .T.
        LOCAL nLines, nCurrentLine
        USE Customer INDEX CustName NEW
        //
        nLines := MLCOUNT(CustNotes, nLineLength,;
              nTabSize, lWrap)
        //
        SET PRINTER ON
        FOR nCurrentLine := 1 TO nLines
           ? MEMOLINE(CustNotes, nLineLength, nCurrentLine,;
                  nTabSize, lWrap)
        NEXT
        SET PRINTER OFF

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "MEMOEDIT()" "MLCOUNT()" "MLPOS()" 
'------------------------------------------------------------------------------



!short: MEMOREAD()      Return the contents of a disk file as a character string
'------------------------------------------------------------------------------
 ^bMEMOREAD()^b
 Return the contents of a disk file as a character string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMEMOREAD(<cFile>) --> cString

 ^bArguments^b

     ^b<cFile>^b is the name of the file to read from disk.  It must include
     an extension if there is one, and can optionally include a path.

 ^bReturns^b

     MEMOREAD() returns the contents of a text file as a character string.
     The maximum file size that can be read is 65,535 characters (64K)--the
     maximum size of a character string.  If <cFile> cannot be found,
     MEMOREAD() returns a null string ("").

 ^bDescription^b

     MEMOREAD() is a memo function that reads a disk file into memory where
     it can be manipulated as a character string or assigned to a memo field.
     MEMOREAD() is used with MEMOEDIT() and MEMOWRIT() to edit an imported
     disk file then write it back to disk.  MEMOREAD() searches for <cFile>
     beginning with the current DOS directory.  If the file is not found,
     MEMOREAD() searches the DOS path.  MEMOREAD() does not use the
     CA-Clipper DEFAULT or PATH to search for <cFile>.

     In a network environment, MEMOREAD() attempts to open the specified file
     shared and read-only.  If the file is opened exclusive by another
     process, MEMOREAD() returns a null string ("").

 ^bExamples^b

     ^b^CFE^b  This example uses MEMOREAD() to assign the contents of a text
        file to the Notes memo field and to a character variable:

        REPLACE Notes WITH MEMOREAD("Temp.txt")
        cString = MEMOREAD("Temp.txt")

     ^b^CFE^b  This example defines a function that edits a disk file:

        FUNCTION Editor( cFile )
           LOCAL cString
           IF (cString := MEMOREAD(cFile)) == ""
              ? "Error reading " + cFile
              RETURN .F.
           ELSE
              MEMOWRIT(cFile, MEMOEDIT(cString))
              RETURN .T.
           ENDIF

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "MEMOEDIT()" "MEMOWRIT()" c52g_002.ngo:"REPLACE" 
'------------------------------------------------------------------------------



!short: MEMORY()        Determine the amount of available free pool memory
'------------------------------------------------------------------------------
 ^bMEMORY()^b
 Determine the amount of available free pool memory
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMEMORY(<nExp>) --> nKbytes

 ^bArguments^b

     ^b<nExp>^b is a numeric value that determines the type of value MEMORY()
     returns as follows:

     ^bMEMORY() Argument Values^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bValue   Meaning^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     0       Estimated total space available for character values
     1       Largest contiguous block available for character values
     2       Area available for RUN commands
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bReturns^b

     MEMORY() returns an integer numeric value representing the amount of
     memory available, in one-kilobyte increments.

 ^bDescription^b

     MEMORY() is an environment function that reports various states of free
     pool memory.  (Free pool is the dynamic region of memory that stores
     character strings and executes RUN commands.)

 ^bExamples^b

     ^b^CFE^b  This example uses MEMORY() before a RUN command to determine
        if there is enough memory available to execute the external program:

        #define MEM_CHAR   0
        #define MEM_BLOCK  1
        #define MEM_RUN    2
        //
        IF MEMORY(MEM_RUN) >= 128
           RUN MYPROG
        ELSE
           ? "Not enough memory to RUN"
           BREAK
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.

!seealso: 
'------------------------------------------------------------------------------



!short: MEMOTRAN()      Replace carriage return/linefeeds in character strings
'------------------------------------------------------------------------------
 ^bMEMOTRAN()^b
 Replace carriage return/linefeeds in character strings
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMEMOTRAN(<cString>,
     ^b   [<cReplaceHardCR>],
     ^b   [<cReplaceSoftCR>]) --> cNewString

 ^bArguments^b

     ^b<cString>^b is the character string or memo field to search.

     ^b<cReplaceHardCR>^b is the character to replace a hard carriage
     return/linefeed pair with.  If not specified, the default value is a
     semicolon (;).

     ^b<cReplaceSoftCR>^b is the character to replace a soft carriage
     return/linefeed pair with.  If not specified, the default value is a
     space.

 ^bReturns^b

     MEMOTRAN() returns a copy of <cString> with the specified carriage
     return/linefeed pairs replaced.

 ^bDescription^b

     MEMOTRAN() is a memo function that converts a memo field or long
     character string containing hard and soft carriage return/linefeed
     characters into a form that can be displayed.  These two character
     combinations are end of line formatting indicators placed in the string
     by MEMOEDIT().  Soft carriage returns (CHR(141)) are inserted when a
     line longer than the width of the MEMOEDIT() window wraps.  Hard
     carriage returns (CHR(13)) are inserted when the user explicitly presses
     Return.

     MEMOTRAN() is particularly useful when displaying a memo field in a
     REPORT FORM which does not wrap when a soft carriage return is
     encountered.  MEMOTRAN() resolves this by converting soft carriage
     returns to spaces.  Note, however, that you must declare MEMOTRAN() as
     external using the REQUEST statement if it is used in a REPORT FORM and
     not specified anywhere else in the current program.

 ^bExamples^b

     ^b^CFE^b  This example strips all end of line characters from a memo
        field:

        REPLACE Notes WITH MEMOTRAN(Notes)

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: c52g_004.ngo:"EXTERNAL*" "HARDCR()" c52g_002.ngo:"REPORT FORM" c52g_004.ngo:"REQUEST" "STRTRAN()" 
'------------------------------------------------------------------------------



!short: MEMOWRIT()      Write a character string or memo field to a disk file
'------------------------------------------------------------------------------
 ^bMEMOWRIT()^b
 Write a character string or memo field to a disk file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMEMOWRIT(<cFile>, <cString>) --> lSuccess

 ^bArguments^b

     ^b<cFile>^b is the name of the target disk file including the file
     extension and optional path and drive designator.

     ^b<cString>^b is the character string or memo field to write to <cFile>.

 ^bReturns^b

     MEMOWRIT() returns true (.T.) if the writing operation is successful;
     otherwise, it returns false (.F.).

 ^bDescription^b

     MEMOWRIT() is a memo function that writes a character string or memo
     field to a disk file.  If a path is not specified, MEMOWRIT() writes
     <cFile> to the current DOS directory and not the current DEFAULT
     directory.  If <cFile> already exists, it is overwritten.

     MEMOWRIT() is generally used with MEMOREAD() to load text files into
     memory where they can be edited, displayed, and written back to disk.
     You can also use MEMOWRIT() as a quick way of exporting a memo field to
     a text file.

 ^bExamples^b

     ^b^CFE^b  This example uses MEMOWRIT() with MEMOREAD() to allow editing
        of memo fields with an external editor:

        LOCAL cEditor := "MYEDIT.EXE"
        USE Sales NEW
        IF MEMOWRIT("Cliptmp.txt", Notes)
           RUN (cEditor + " Cliptmp.txt")
           REPLACE Notes WITH MEMOREAD("Cliptmp.txt")
        ELSE
           ? "Error while writing Cliptmp.txt"
           BREAK
        ENDIF

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "MEMOEDIT()" "MEMOREAD()" 
'------------------------------------------------------------------------------



!short: MEMVARBLOCK()   Return a set-get code block for a given memory variable
'------------------------------------------------------------------------------
 ^bMEMVARBLOCK()^b
 Return a set-get code block for a given memory variable
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMEMVARBLOCK(<cMemvarName>) --> bMemvarBlock

 ^bArguments^b

     ^b<cMemvarName>^b is the name of the variable referred to by the set-get
     block, specified as a character string.

 ^bReturns^b

     MEMVARBLOCK() returns a code block that when evaluated sets (assigns) or
     gets (retrieves) the value of the given memory variable.  If
     <cMemvarName> does not exist, MEMVARBLOCK() returns NIL.

 ^bDescription^b

     The code block created by MEMVARBLOCK() has two operations depending on
     whether an argument is passed to the code block when it is evaluated.
     If evaluated with an argument, it assigns the value of the argument to
     <cMemvarName>.  If evaluated without an argument, the code block
     retrieves the value of <cMemvarName>.

 ^bNotes^b

     ^b^CFE^b  MEMVARBLOCK() creates set-get blocks only for variables whose
        names are known at runtime.  MEMVARBLOCK(), therefore, cannot be used
        to create set-get blocks for local or static variables.  The same
        restriction applies to creating blocks using the macro operator (&).

 ^bExamples^b

     ^b^CFE^b  This example compares MEMVARBLOCK() to a code block created
        using the macro operator (&).  Note that using MEMVARBLOCK() allows
        you to avoid the speed and size overhead of the macro operator:

        PRIVATE var := "This is a string"
        //
        // Set-Get block defined using macro operator
        bSetGet := &( "{ |setVal|;
              IF( setVal == NIL, var, var := setVal ) }" )
        // Set-Get block defined using MEMVARBLOCK()

        // bSetGet created here is the functional
        // equivalent of bSetGet above
        bSetGet := MEMVARBLOCK("var")

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "FIELDBLOCK()" "FIELDWBLOCK()" 
'------------------------------------------------------------------------------



!short: MIN()           Return the smaller of two numeric or date values
'------------------------------------------------------------------------------
 ^bMIN()^b
 Return the smaller of two numeric or date values
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMIN(<nExp1>, <nExp2>) --> nSmaller
     ^bMIN(<dExp1>, <dExp2>) --> dSmaller

 ^bArguments^b

     ^b<nExp1>^b and ^b<nExp2>^b are the numeric values to compare.

     ^b<dExp1>^b and ^b<dExp2>^b are the date values to compare.

 ^bReturns^b

     MIN() returns the smaller of the two arguments.  The value returned is
     the same data type as the arguments.

 ^bDescription^b

     MIN() is a numeric and a date function that ensures the value of an
     expression is smaller than a specified minimum.  The inverse of MIN() is
     MAX() which returns the greater of two numeric or date values.

 ^bExamples^b

     ^b^CFE^b  In these examples MIN() returns the smaller of two numeric
        values:

        ? MIN(99, 100)                  // Result: 99
        ? MIN(100, 99)                  // Result: 99

     ^b^CFE^b  In these examples MIN() compares date values:

        ? DATE()                        // Result: 09/01/90
        ? MIN(DATE(), DATE() + 30)      // Result: 09/01/90

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "MAX()" 
'------------------------------------------------------------------------------



!short: MLCOUNT()       Count number of lines in a character string or memo field
'------------------------------------------------------------------------------
 ^bMLCOUNT()^b
 Count the number of lines in a character string or memo field
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMLCOUNT(<cString>, [<nLineLength>],
     ^b   [<nTabSize>], [<lWrap>]) --> nLines

 ^bArguments^b

     ^b<cString>^b is the character string or memo field to count.

     ^b<nLineLength>^b specifies the number of characters per line and can
     range from four to 254.  If not specified, the default line length is
     79.

     ^b<nTabSize>^b defines the tab size.  If not specified, the default
     value is four.  If <nTabSize> is greater than or equal to <nLineLength>,
     then the tab size is automatically converted to <nLineLength> - 1.

     ^b<lWrap>^b toggles word wrap on and off.  Specifying true (.T.) toggles
     word wrap on; false (.F.) toggles it off.  If not specified, the default
     value is true (.T.).

 ^bReturns^b

     MLCOUNT() returns the number of lines in <cString> depending on the
     <nLineLength>, the <nTabSize>, and whether word wrapping is on or off.

 ^bDescription^b

     MLCOUNT() is a memo function used with MEMOLINE() to print character
     strings and memo fields based on the number of characters per line.  In
     the basic operation, use MLCOUNT() to return the number of lines in the
     character string or memo field.  Then, using MEMOLINE() to extract each
     line, loop through the memo field until there are no lines left.

     If <lWrap> is true (.T.) and an end of line position breaks a word, it
     is word wrapped to the next line and the next line begins with that
     word.  If <lWrap> is false (.F.), MLCOUNT() counts the number of
     characters specified by <nLineLength> as the current line.  The next
     line begins with the character following the next hard or soft carriage
     return.  Intervening characters are ignored.

 ^bExamples^b

     ^b^CFE^b  This example displays the contents of each Notes memo field in
        the Sales database file, one line at a time:

        USE Sales NEW
        nLineLength = 65
        //
        DO WHILE !EOF()
           nLines = MLCOUNT(Sales->Notes, nLineLength)
           FOR nCurrLine = 1 TO nLines
              ? MEMOLINE(Sales->Notes, nLineLength, nCurrLine)
           NEXT
           SKIP
           ?
        ENDDO

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "MEMOLINE()" "MEMOTRAN()" "MLPOS()" 
'------------------------------------------------------------------------------



!short: MLCTOPOS()      Return byte position based on line and column position
'------------------------------------------------------------------------------
 ^bMLCTOPOS()^b
 Return byte position of a formatted string based on line and column position
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMLCTOPOS(<cText>, <nWidth>, <nLine>,
     ^b   <nCol>, [<nTabSize>], [<lWrap>]) --> nPosition

 ^bArguments^b

     ^b<cText>^b is the text string to scan.

     ^b<nWidth>^b is the line length formatting width.

     ^b<nLine>^b is the line number counting from 1.

     ^b<nCol>^b is the column number counting from 0.

     ^b<nTabSize>^b is the number of columns between tab stops.  If not
     specified, the default is 4.

     ^b<lWrap>^b is the word wrap flag.  If not specified, the default is
     true (.T.).

 ^bReturns^b

     MLCTOPOS() returns the byte position within <cText> counting from 1.

 ^bDescription^b

     MLCTOPOS() is a memo function that determines the byte position that
     corresponds to a particular line and column within the formatted text.
     Note that the line number is one-relative, the column number is
     zero-relative.  This is compatible with MEMOEDIT().  The return value is
     one-relative, making it suitable for use in SUBSTR() or other string
     functions.

     MLCTOPOS() is used with MPOSTOLC() to create search routines or other
     text processing for MEMOEDIT().  Refer to the source code for the
     program editor (PE) found in \CLIPPER5\SOURCE\PE directory.

 ^bExamples^b

     ^b^CFE^b  This example determines the byte position of line 5, column 3
        in the cText string:

        cText := "Note the side on which the bread ;
                    is buttered."
        //
        ? MLCTOPOS(cText, 5, 3, 0)         // Result: 10

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "MEMOEDIT()" "MLPOS()" "MPOSTOLC()" 
'------------------------------------------------------------------------------



!short: MLPOS()         Determine the position of a line in a string or memo field
'------------------------------------------------------------------------------
 ^bMLPOS()^b
 Determine the position of a line in a character string or memo field
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMLPOS(<cString>, <nLineLength>,
     ^b   <nLine>, [<nTabSize>], [<lWrap>]) --> nPosition

 ^bArguments^b

     ^b<cString>^b is a character string or memo field.

     ^b<nLineLength>^b specifies the number of characters per line.

     ^b<nLine>^b specifies the line number.

     ^b<nTabSize>^b defines the tab size.  The default is four.  If
     <nTabSize> is greater than or equal to <nLineLength>, then the tab size
     is adjusted to <nLineLength> - 1.

     ^b<lWrap>^b toggles word wrap on and off.  Specifying true (.T.) toggles
     word wrap on, and false (.F.) toggles it off.  The default is true
     (.T.).

 ^bReturns^b

     MLPOS() returns the character position of <nLine> in <cString> as an
     integer numeric value.  If <nLine> is greater than the number of lines
     in <cString>, MLPOS() returns the length of <cString>.

 ^bExamples^b

     ^b^CFE^b  This example uses MLPOS() to find the position of a specific
        line, given a line length:

        cString = MEMOREAD("Temp.txt")
        nLineLength = 40
        nLine = 5
        nPosition = MLPOS(cString, nLineLength, nLine)
        ? SUBSTR(cString, nPosition, 12)

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "MEMOLINE()" "MEMOTRAN()" "MLCOUNT()" 
'------------------------------------------------------------------------------



!short: MOD()*          Return dBASE III PLUS modulus of two numbers
'------------------------------------------------------------------------------
 ^bMOD()*^b
 Return dBASE III PLUS modulus of two numbers
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMOD(<nDividend>, <nDivisor>) --> nRemainder

 ^bArguments^b

     ^b<nDividend>^b is the dividend of the division operation.

     ^b<nDivisor>^b is the divisor of the division operation.

 ^bReturns^b

     MOD() returns a number representing the remainder of <nDividend> divided
     by <nDivisor>.

 ^bDescription^b

     MOD() is a numeric function that emulates the dBASE III PLUS MOD()
     function.  It is implemented using the CA-Clipper modulus operator (%).
     Note that there are differences between the dBASE III PLUS MOD()
     function and the CA-Clipper modulus operator which are described in the
     following table:

     ^bDifferences Between dBASE III PLUS MOD() Function
     ^band the CA-Clipper Modulus Operator
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bDividend   Divisor   Modulus Operator   MOD()   dBASE III PLUS
     ^b                                                MOD() function
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
      3            0            Error        Error          3
      3           -2              1           -1           -1
     -3            2             -1            1            1
     -3            0            Error        Error         -3
     -1            3             -1            2            2
     -2            3             -2            1            1
      2           -3              2           -1           -1
      1           -3              1           -2           -2
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     MOD() is supplied as a compatibility function and therefore not
     recommended.  It is superseded entirely by the modulus operator (%).

 ^bNotes^b

     ^b^CFE  Zero divisor in dBASE III PLUS:^b In dBASE III PLUS, a zero
        divisor returns the dividend for every value of the dividend.  In
        CA-Clipper, by contrast, the modulus of any dividend using a zero
        divisor causes a runtime error.

     ^b^CFE  Zero divisor in earlier versions:^b In versions of CA-Clipper
        prior to Summer '87, a modulus operation with a zero divisor returned
        zero for all dividends.  In Summer '87 and later versions, it returns
        a runtime error.

 ^bFiles:^b  Library is EXTEND.LIB, source file is SOURCE\SAMPLE\MOD.PRG.
!seealso: c52g_005.ngo:"%" 
'------------------------------------------------------------------------------



!short: MONTH()         Convert a date value to the number of the month
'------------------------------------------------------------------------------
 ^bMONTH()^b
 Convert a date value to the number of the month
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMONTH(<dDate>) --> nMonth

 ^bArguments^b

     ^b<dDate>^b is the date value to convert.

 ^bReturns^b

     MONTH() returns an integer numeric value in the range of zero to 12.
     Specifying a null date (CTOD("")) returns zero.

 ^bDescription^b

     MONTH() is a date conversion function that is useful when you require a
     numeric month value during calculations for such things as periodic
     reports.  MONTH() is a member of a group of functions that return
     components of a date value as numeric values.  The group includes DAY()
     and YEAR() to return the day and year values as numerics.  CMONTH() is a
     related function that allows you to return the name of the month from a
     date value.

 ^bExamples^b

     ^b^CFE^b  These examples return the month of the system date:

        ? DATE()                      // Result: 09/01/90
        ? MONTH(DATE())               // Result: 9
        ? MONTH(DATE()) + 1           // Result: 10

     ^b^CFE^b  This example demonstrates MONTH() acting on a null date:

        #define NULL_DATE   (CTOD(""))
        ? MONTH(NULL_DATE)            // Result: 0

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CMONTH()" "DAY()" "DOW()" "YEAR()" 
'------------------------------------------------------------------------------



!short: MPOSTOLC()      Return line and column position based on byte position
'------------------------------------------------------------------------------
 ^bMPOSTOLC()^b
 Return line and column position of a formatted string based on a specified
 byte position
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMPOSTOLC(<cText>, <nWidth>, <nPos>,
     ^b   [<nTabSize>], [<lWrap>]) --> aLineColumn

 ^bArguments^b

     ^b<cText>^b is a text string.

     ^b<nWidth>^b is the length of the formatted line.

     ^b<nPos>^b is the byte position within text counting from one.

     ^b<nTabSize>^b is the number of columns between tab stops.  If not
     specified, the default is four.

     ^b<lWrap>^b is the word wrap flag.  If not specified, the default is
     true (.T.).

 ^bReturns^b

     MPOSTOLC() returns an array containing the line and the column values
     for the specified byte position, <nPos>.

 ^bDescription^b

     MPOSTOLC() is a memo function that determines the formatted line and
     column corresponding to a particular byte position within <cText>.  Note
     that the line number returned is one-relative, the column number is
     zero-relative.  This is compatible with MEMOEDIT().  <nPos> is
     one-relative, compatible with AT(), RAT(), and other string functions.

     MPOSTOLC(), used with MLCTOPOS(), can create search routines or other
     text processing for MEMOEDIT().  Refer to the source code for the
     program editor (PE) found in \CLIPPER5\SOURCE\PE directory.

 ^bExamples^b

     ^b^CFE^b  This example determines, for the text string shown, the line
        and column corresponding to the tenth character of the text, assuming
        a formatting width of five columns.  A formatting width of five would
        cause each of the first three words to be placed on a line by itself.
        The tenth character of the text is the "s" in "side."  The word
        "side" would be at the leftmost column of the third line of the
        formatted text, so the return value is {3, 0}:

        cText := "Note the side on which the bread ;
              is buttered."
        //
        aLC := MPOSTOLC(cText, 5, 10)         // Result: {3, 0}

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "MEMOEDIT()" "MLCTOPOS()" "MLPOS()" 
'------------------------------------------------------------------------------



!short: NETERR()        Determine if a network command has failed
'------------------------------------------------------------------------------
 ^bNETERR()^b
 Determine if a network command has failed
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bNETERR([<lNewError>]) --> lError

 ^bArguments^b

     ^b<lNewError>^b if specified sets the value returned by NETERR() to the
     specified status.  <lNewError> can be either true (.T.) or false (.F.).
     Setting NETERR() to a specified value allows the runtime error handler
     to control the way certain file errors are handled.  For more
     information, refer to Errorsys.prg.

 ^bReturns^b

     NETERR() returns true (.T.) if a USE or APPEND BLANK fails.  The initial
     value of NETERR() is false (.F.).  If the current process is not running
     under a network operating system, NETERR() always returns false (.F.).

 ^bDescription^b

     NETERR() is a network function.  It is a global flag set by USE,
     USE...EXCLUSIVE, and APPEND BLANK in a network environment.  It is used
     to test whether any of these commands have failed by returning true
     (.T.) in the following situations:

     ^bNETERR() Causes^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bCommand             Cause^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     USE                 USE EXCLUSIVE by another process
     USE...EXCLUSIVE     USE EXCLUSIVE or USE by another process
     APPEND BLANK        FLOCK() or RLOCK() of LASTREC() + 1 by another user
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     NETERR() is generally applied in a program by testing it following a USE
     or APPEND BLANK command.  If it returns false (.F.), you can perform the
     next operation.  If the command is USE, you can open index files.  If it
     is APPEND BLANK, you can assign values to the new record with a REPLACE
     or @...GET command.  Otherwise, you must handle the error by either
     retrying the USE or APPEND BLANK, or terminating the current operation
     with a BREAK or RETURN.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates typical usage of NETERR().  If the
        USE succeeds, the index files are opened and processing continues.
        If the USE fails, a message displays and control returns to the
        nearest BEGIN SEQUENCE construct:

        USE Customer SHARED NEW
        IF !NETERR()
           SET INDEX TO CustNum, CustOrders, CustZip
        ELSE
           ? "File is in use by another"
           BREAK
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"APPEND BLANK" "FLOCK()" "RLOCK()" c52g_002.ngo:"USE" 
'------------------------------------------------------------------------------



!short: NETNAME()       Return the current workstation identification
'------------------------------------------------------------------------------
 ^bNETNAME()^b
 Return the current workstation identification
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bNETNAME() --> cWorkstationName

 ^bReturns^b

     NETNAME() returns the workstation identification as a character string
     up to 15 characters in length.  If the workstation identification was
     never set or the application is not operating under the IBM PC Network,
     it returns a null string ("").

 ^bExamples^b

     ^b^CFE^b  This example demonstrates the NETNAME() result when a
        workstation is started as a network node with a station identifier of
        "STATION 1":

        ? NETNAME()               // Result: STATION 1

     ^b^CFE^b  This example demonstrates the NETNAME() result when a
        workstation is started as a stand-alone unit:

        ? NETNAME()               // Result: ""

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: 
'------------------------------------------------------------------------------



!short: NEXTKEY()       Read the pending key in the keyboard buffer
'------------------------------------------------------------------------------
 ^bNEXTKEY()^b
 Read the pending key in the keyboard buffer
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bNEXTKEY() --> nInkeyCode

 ^bReturns^b

     NEXTKEY() returns an integer numeric value ranging from -39 to 386.  If
     the keyboard buffer is empty, NEXTKEY() returns zero.  If SET TYPEAHEAD
     is zero, NEXTKEY() always returns zero.

 ^bDescription^b

     NEXTKEY() is a keyboard function that reads the keystroke pending in the
     keyboard buffer without removing it.  The value returned is the INKEY()
     code of the key pressed--the same value as returned by INKEY() and
     LASTKEY().  NEXTKEY() returns values for all ASCII characters as well as
     function, Alt-function, Ctrl-function, Alt-letter, and Ctrl-letter key
     combinations.

     NEXTKEY() is like the INKEY() function, but differs in one fundamental
     respect.  INKEY() removes the pending key from the keyboard buffer and
     updates LASTKEY() with the value of the key.  NEXTKEY(), by contrast,
     reads, but does not remove the key from the keyboard buffer and does not
     update LASTKEY().

     Since NEXTKEY() does not remove the key from the keyboard buffer, it can
     be used to poll the keyboard then pass control to a routine that uses a
     wait state or INKEY() to actually fetch the key from the buffer.

     For a complete list of INKEY() codes and Inkey.ch constants, refer to
     the CA-Clipper Inkey Codes Appendix in the Error Messages and Appendices
     guide.

 ^bExamples^b

     ^b^CFE^b  This example places an Esc key in the keyboard buffer then
        shows the differences between INKEY(), LASTKEY(), and NEXTKEY():

        #include "Inkey.ch"
        //
        CLEAR TYPEAHEAD
        KEYBOARD CHR(K_ESC)
        //
        ? NEXTKEY(), LASTKEY()            // Result: 27 0
        ? INKEY(), LASTKEY()              // Result: 27 27
        ? NEXTKEY()                       // Result: 0

 ^bFiles:^b  Library is EXTEND.LIB, header file is Inkey.ch.
!seealso: "INKEY()" c52g_002.ngo:"KEYBOARD" "LASTKEY()" c52g_002.ngo:"SET TYPEAHEAD" c52g_009.ngo:"Inkey codes" 
'------------------------------------------------------------------------------



!short: NOSNOW()        Toggle snow suppression
'------------------------------------------------------------------------------
 ^bNOSNOW()^b
 Toggle snow suppression
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bNOSNOW(<lToggle>) --> NIL

 ^bArguments^b

     ^b<lToggle>^b is a logical value that toggles the current state of snow
     suppression.  A value of true (.T.) enables the snow suppression on,
     while a value of false (.F.) disables snow suppression.

 ^bDescription^b

     NOSNOW() is used to suppress snow on CGA monitors.  Typically, use
     NOSNOW() in the configuration section of your application to give the
     user the option to suppress snow.

 ^bFiles:^b  Library is CLIPPER.LIB
!seealso: 
'------------------------------------------------------------------------------



!short: OS()            Return the operating system name
'------------------------------------------------------------------------------
 ^bOS()^b
 Return the operating system name
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bOS() --> cOsName

 ^bReturns^b

     OS() returns the operating system name as a character string.

 ^bDescription^b

     OS() is an environment function that returns the name of the disk
     operating system under which the current workstation is operating.  The
     name is returned in the form of the operating system name followed by
     the version number.

 ^bExamples^b

     ^b^CFE^b  This example uses OS() to report the operating system the
        current workstation is running:

        ? OS()                  // Result: DOS 3.3

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "GETENV()" "VERSION()" 
'------------------------------------------------------------------------------



!short: OUTERR()        Write a list of values to the standard error device
'------------------------------------------------------------------------------
 ^bOUTERR()^b
 Write a list of values to the standard error device
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bOUTERR(<exp list>) --> NIL

 ^bArguments^b

     ^b<exp list>^b is a list of values to display and can consist of any
     combination of data types including memo.

 ^bReturns^b

     OUTERR() always returns NIL.

 ^bDescription^b

     OUTERR() is identical to OUTSTD() except that it writes to the standard
     error device rather than the standard output device.  Output sent to the
     standard error device bypasses the CA-Clipper console and output devices
     as well as any DOS redirection.  It is typically used to log error
     messages in a manner that will not interfere with the standard screen or
     printer output.

 ^bExamples^b

     ^b^CFE^b  This example displays an error message along with the date and
        time of occurrence to the screen:

        OUTERR("File lock failure", DATE(), TIME())

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DISPOUT()" "OUTSTD()" 
'------------------------------------------------------------------------------



!short: OUTSTD()        Write a list of values to the standard output device
'------------------------------------------------------------------------------
 ^bOUTSTD()^b
 Write a list of values to the standard output device
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bOUTSTD(<exp list>) --> NIL

 ^bArguments^b

     ^b<exp list>^b is a list of values to display and can consist of any
     combination of data types including memo.

 ^bReturns^b

     OUTSTD() always returns NIL.

 ^bDescription^b

     OUTSTD() is a simple output function similar to QOUT(), except that it
     writes to the STDOUT device (instead of to the CA-Clipper console output
     stream).  Programs with very simple output requirements (i.e., that
     perform no full-screen input or output) can use this function to avoid
     loading the terminal output subsystems.  The header file Simpleio.ch
     redefines the ? and ?? commands to use the OUTSTD() function.

     Since OUTSTD() sends its output to the standard output device, the
     output can be redirected using the DOS redirection symbols (>, >, |).
     This lets you redirect output from a CA-Clipper program to a file or
     pipe.  Refer to your PC/MS-DOS documentation for more information on
     this operating system facility.

 ^bExamples^b

     ^b^CFE^b  This example uses OUTSTD() to display a list of expressions:

        OUTSTD(Name, PADR(RTRIM(City) + "," + ;
              State, 20), ZipCode)

     ^b^CFE^b  This example redirects the output of a CA-Clipper program to a
        new file using the DOS redirection operator (>):

        C>MYPROG > FILE.TXT

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Simpleio.ch.
!seealso: "DISPOUT()" "OUTERR()" "QOUT()" 
'------------------------------------------------------------------------------



!short: PAD()           Pad character, date, or numeric value with a fill character
'------------------------------------------------------------------------------
 ^bPAD()^b
 Pad character, date, and numeric values with a fill character
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b


     ^bPADL(<exp>, <nLength>, [<cFillChar>])
     ^b   --> cPaddedString
     ^bPADC(<exp>, <nLength>, [<cFillChar>])
     ^b   --> cPaddedString
     ^bPADR(<exp>, <nLength>, [<cFillChar>])
     ^b   --> cPaddedString

 ^bArguments^b

     ^b<exp>^b is a character, numeric, or date value to pad with a fill
     character.

     ^b<nLength>^b is the length of the character string to return.

     ^b<cFillChar>^b is the character to pad <exp> with.  If not specified,
     the default is a space character.

 ^bReturns^b

     PADC(), PADL(), and PADR() return the result of <exp> as a character
     string padded with <cFillChar> to a total length of <nLength>.

 ^bDescription^b

     PADC(), PADL(), and PADR() are character functions that pad character,
     date, and numeric values with a fill character to create a new character
     string of a specified length.  PADC() centers <exp> within <nLength>
     adding fill characters to the left and right sides; PADL() adds fill
     characters on the left side; and PADR() adds fill characters on the
     right side.  If the length of <exp> exceeds <nLength>, all of the PAD()
     functions truncate cPaddedString to <nLength>.

     PADC(), PADL(), and PADR() display variable length strings within a
     fixed length area.  They can be used, for instance, to assure alignment
     with consecutive ?? commands.  Another use is to display text to a
     fixed-width screen area assuring that previous text is completely
     overwritten.

     PADC(), PADL(), and PADR() are the inverse of the ALLTRIM(), RTRIM(),
     and LTRIM() functions which trim leading and trailing space from
     character strings.

 ^bExamples^b

     ^b^CFE^b  This example uses PADR() to format a record number display on
        a status line filling the allocated space:

        IF EOF()
           @ 23, 45 PADR("EOF/" + LTRIM(STR(LASTREC())), 20)
        ELSEIF BOF()
           @ 23, 45 PADR("BOF/" + LTRIM(STR(LASTREC())), 20)
        ELSE
           @ 23, 45 SAY PADR("Record " + LTRIM(STR(RECNO()) ;
                 + "/" + LTRIM(STR(LASTREC())), 20)
        ENDIF

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "ALLTRIM()" "LTRIM()" "RTRIM()" 
'------------------------------------------------------------------------------



!short: PCOL()          Return the current column position of the printhead
'------------------------------------------------------------------------------
 ^bPCOL()^b
 Return the current column position of the printhead
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bPCOL() --> nColumn

 ^bReturns^b

     PCOL() returns an integer numeric value representing the last printed
     column position, plus one.  The beginning column position is zero.

 ^bDescription^b

     PCOL() is a printer function that reports the column position of the
     printhead after the last print operation.  PCOL() is updated only if
     either SET DEVICE TO PRINTER or SET PRINTER ON is in effect.  PCOL() is
     the same as COL() except that it relates to the printer rather than the
     screen.  PCOL() is updated in the following ways:

     ^b^CFE^b  Application startup sets PCOL() to zero

     ^b^CFE^b  EJECT resets PCOL() to zero

     ^b^CFE^b  A print operation sets PCOL() to the last column print
        position plus one

     ^b^CFE^b  SETPRC() sets PCOL() to the specified column position

     PCOL(), used with PROW(), prints a value relative to the last value
     printed on the same line.  This makes it easier to align columns when
     printing a columnar report.  A value is printed in the next column by
     specifying its position as PCOL() + <column offset>.  Note that PCOL()
     is effective for alignment only if the column values are fixed-width.
     To guarantee fixed-width column values, format the output using
     TRANSFORM(), the PICTURE clause of @...SAY, or any of the PAD()
     functions.

 ^bNotes^b

     ^b^CFE  Printer control codes:^b Sending control codes to the printer
        causes PCOL() to become out of sync with the printhead position.
        Although control codes do not print, this discrepancy happens because
        CA-Clipper counts all characters sent to the printer regardless of
        how the printer treats them.  To make the necessary adjustment, save
        the current PROW() and PCOL() values, send the control codes, then
        use SETPRC() to restore the original PROW() and PCOL() values.

     ^b^CFE  SET MARGIN:^b PCOL() cannot reliably be used with SET MARGIN to
        print with @...SAY.  When printing with @...SAY, the current MARGIN
        value is always added to the specified column position before output
        is sent to the printer.  This effectively adds the MARGIN value to
        PCOL() for each invocation of @...SAY to the same print line.

 ^bExamples^b

     ^b^CFE^b  In this example, PCOL() creates a simple report that prints a
        listing of Customer names, addresses, and phone numbers:

        LOCAL nLine := 99, nPage := 1
        USE Customer INDEX CustName NEW
        SET DEVICE TO PRINTER
        DO WHILE !EOF()
           IF nLine > 55
              PageTop(nPage)
              nLine := 1
              nPage++
           ENDIF
           @ nLine, 10 SAY CustName
           @ nLine, PCOL() + 2;
              SAY RTRIM(City) + ", " + RTRIM(State) + ZipCode;
                    PICTURE REPLICATE("X", 35)
           @ nLine, PCOL() + 2;
              SAY Phone;
                    PICTURE "@R (999) 999-9999"
           nLine++
           SKIP
        ENDDO
        SET DEVICE TO SCREEN
        CLOSE

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "COL()" "PAD()" "PROW()" "ROW()" c52g_002.ngo:"SET DEVICE" "SETPRC()" 
'------------------------------------------------------------------------------



!short: PCOUNT()        Determine the position of the last actual parameter passed
'------------------------------------------------------------------------------
 ^bPCOUNT()^b
 Determine the position of the last actual parameter passed
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bPCOUNT() --> nLastArgumentPos

 ^bReturns^b

     PCOUNT() returns, as an integer numeric value, the position of the last
     argument passed.  If no arguments are passed, PCOUNT() returns zero.

 ^bDescription^b

     PCOUNT() reports the position of the last argument in the list of
     arguments passed when a procedure or user-defined function is invoked.
     This information is useful when determining whether arguments were left
     off the end of the argument list.  Arguments skipped in the middle of
     the list are still included in the value returned.

     To determine if a parameter did not receive a value, test it for NIL.
     Skipped parameters are uninitialized and, therefore, return NIL when
     accessed.  Another method is to test parameters with the VALTYPE()
     function.  This can establish whether the argument was passed and
     enforce the correct type at the same time.  If a parameter was not
     supplied, a default value can be assigned.

     For more information on passing parameters, refer to the Basic Concepts
     chapter in the Programming and Utilities guide.

 ^bExamples^b

     ^b^CFE^b  This example is a user-defined function that opens a database
        file and uses PCOUNT() to determine whether the calling procedure
        passed the name of the database file to open.  If the name was not
        passed, OpenFile() asks for the name:

        FUNCTION OpenFile( cFile )
           IF PCOUNT() = 0
              ACCEPT "File to use: " TO cFile
           ENDIF
           USE (cFile)
           RETURN (NETERR())

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_004.ngo:"DO*" c52g_004.ngo:"FUNCTION" c52g_004.ngo:"PARAMETERS" c52g_004.ngo:"PROCEDURE" "VALTYPE()" 
'------------------------------------------------------------------------------



!short: PROCLINE()      Return source line number of current or previous activation
'------------------------------------------------------------------------------
 ^bPROCLINE()^b
 Return the source line number of the current or previous activation
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bPROCLINE([<nActivation>]) --> nSourceLine

 ^bArguments^b

     ^b<nActivation>^b is a numeric value that specifies which activation to
     query.  Zero refers to the current activation, one refers to the
     previous activation, etc.  If not specified, the default value is zero.

 ^bReturns^b

     PROCLINE() returns the line number of the last line executed in a
     currently executing procedure, function, or code block as an integer
     numeric value.  If the /L compiler option suppresses line number
     information, PROCLINE() always returns zero.

 ^bDescription^b

     PROCLINE() queries the CA-Clipper activation stack to determine the last
     line executed in a currently executing procedure, user-defined function,
     or code block.  The activation stack is an internal structure that
     maintains a record of each procedure, function, or code block
     invocation.  A line number is relative to the beginning of the original source
     file.  A line includes a comment, blank line, preprocessor directive,
     and a continued line.  A multistatement line is counted as a single
     line.

     For the current activation, PROCLINE() returns the number of the current
     line.  For a previous activation, PROCLINE() returns the number of the
     line that invoked the procedure, or a user-defined function in which
     PROCLINE() is invoked.

     If the activation being queried is a code block evaluation, PROCLINE()
     returns the line number of the procedure in which the code block was
     originally defined.

     PROCLINE() is used with PROCNAME() to report debugging information.

 ^bExamples^b

     ^b^CFE^b  In this example, PROCLINE() returns the line number for the
        current activation, followed by the line number of the previous
        activation:

        // First line of source file
        MyFunction()
           RETURN

        FUNCTION MyFunction
           ? PROCLINE()      // Result: 6 (current activation)
           ? PROCLINE(1)     // Result: 2 (previous activation)
           RETURN NIL

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "PROCNAME()" 
'------------------------------------------------------------------------------



!short: PROCNAME()      Return name of current or previous procedure or function
'------------------------------------------------------------------------------
 ^bPROCNAME()^b
 Return the name of the current or previous procedure or user-defined function
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bPROCNAME([<nActivation>]) --> cProcedureName

 ^bArguments^b

     ^b<nActivation>^b specifies which activation to query.  A value of zero
     refers to the current activation, a value of one refers to the previous
     activation, etc.  If unspecified, the default value is zero.

 ^bReturns^b

     PROCNAME() returns the name of a currently executing procedure,
     function, or code block, as a character string.

 ^bDescription^b

     PROCNAME() queries the CA-Clipper activation stack to determine the name
     of a currently executing procedure, user-defined function, or code
     block.  The activation stack is an internal structure that maintains a
     record of each procedure, function, or code block invocation.

     For the current activation, PROCNAME() returns the name of the current
     procedure or user-defined function.  For a previous activation,
     PROCNAME() returns the name of the procedure or user-defined function
     that invoked the current procedure.

     If the activation being queried is a code block evaluation, PROCNAME()
     returns the name of the procedure or user-defined function that defined
     the code block, preceded by (b).  If the activation being queried is a
     memvar, PROCNAME() returns the name preceded by M->.

     PROCNAME() is used with PROCLINE() to report debugging information.

 ^bExamples^b

     ^b^CFE^b  This example is a user-defined function you can call during a
        debugging phase of program development to display the activation
        stack with line numbers:

        FUNCTION ListStack( cMessage )
           LOCAL nActivation := 1
           ? cMessage
           DO WHILE !(PROCNAME(nActivation) == "")
              ? "Called from:", PROCNAME(nActivation),;
                 "(" + LTRIM(STR(PROCLINE(nActivation))) + ")"
              nActivation++
           ENDDO
           QUIT
           RETURN NIL

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "PROCLINE()" 
'------------------------------------------------------------------------------



!short: PROW()          Return the current row position of the printhead
'------------------------------------------------------------------------------
 ^bPROW()^b
 Return the current row position of the printhead
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bPROW() --> nRow

 ^bReturns^b

     PROW() returns an integer numeric value that represents the number of
     the current line sent to the printer.  The beginning row position is
     zero.

 ^bDescription^b

     PROW() is a printer function that reports the row position of the
     printhead after the last print operation.  PROW() is updated only if
     either SET DEVICE TO PRINTER or SET PRINTER ON is in effect.  PROW() is
     like ROW() except that it relates to the printer rather than the screen.
     PROW() is updated in the following ways:

     ^b^CFE^b  Application startup sets PROW() to zero

     ^b^CFE^b  EJECT resets PROW() to zero

     ^b^CFE^b  A print operation sets PROW() to the last row print position

     ^b^CFE^b  SETPRC() sets PROW() to the specified row position

     PROW(), used with PCOL() prints a value to a new row relative to the
     last row printed.  If the printhead is positioned to a new row with a
     control code, a linefeed (CHR(10)), or formfeed (CHR(12)), PROW() is not
     updated and, therefore, will not return the expected value.  To prevent
     this discrepancy, reset PROW() to the correct value with SETPRC() after
     sending any of these characters to the printer.

 ^bExamples^b

     ^b^CFE^b  This example uses PROW() and SETPRC() to create a simple
        one-across label program that prints with @...SAY instead of ?:

        USE Customer INDEX CustName NEW
        SET DEVICE TO PRINTER
        SETPRC(2, 0)
        DO WHILE !EOF()
           @ PROW(), 3 SAY CustName
           @ PROW() + 1, 3 SAY RTRIM(City) + ",;
                  " + RTRIM(State) + ZipCode
           @ PROW() + 1, 3 SAY Phone PICTURE "@R ;
                 (999) 999-9999"
           SETPRC(2, 0)
           SKIP
        ENDDO
        SET DEVICE TO SCREEN
        CLOSE

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "COL()" c52g_002.ngo:"EJECT" "PCOL()" "ROW()" c52g_002.ngo:"SET DEVICE" "SETPRC()" 
'------------------------------------------------------------------------------



!short: QOUT()          Display a list of expressions to the console
'------------------------------------------------------------------------------
 ^bQOUT()^b
 Display a list of expressions to the console
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bQOUT([<exp list>]) --> NIL
     ^bQQOUT([<exp list>]) --> NIL

 ^bArguments^b

     ^b<exp list>^b is a comma-separated list of expressions (of any data
     type other than array or block) to display to the console.  If no
     argument is specified and QOUT() is specified, a carriage
     return/linefeed pair is displayed.  If QQOUT() is specified without
     arguments, nothing displays.

 ^bReturns^b

     QOUT() and QQOUT() always return NIL.

 ^bDescription^b

     QOUT() and QQOUT() are console functions.  These are the functional
     primitives that create the ? and ?? commands, respectively.  Like the ?
     and ?? commands, they display the results of one or more expressions to
     the console.  QOUT() outputs carriage return and linefeed characters
     before displaying the results of <exp list>.  QQOUT() displays the
     results of <exp list> at the current ROW() and COL() position.  When
     QOUT() and QQOUT() display to the console, ROW() and COL() are updated.
     If SET PRINTER is ON, PROW() and PCOL() are updated instead.  If <exp
     list> is specified, both QOUT() and QQOUT() display a space between the
     results of each expression.

     You can use QOUT() and QQOUT() for console display within an expression.
     This is particularly useful for blocks, iteration functions such as
     AEVAL() and DBEVAL(), and in a list of statements in the output pattern
     of a user-defined command definition.

 ^bExamples^b

     ^b^CFE^b  This example uses QOUT() with AEVAL() to list the contents of
        a literal array to the console:

        LOCAL aElements := { 1, 2, 3, 4, 5 }
        AEVAL(aElements, { |element| QOUT(element) })

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"?|??" c52g_002.ngo:"@...SAY" c52g_002.ngo:"SET ALTERNATE" c52g_002.ngo:"SET CONSOLE" c52g_002.ngo:"SET PRINTER" 
'------------------------------------------------------------------------------



!short: RAT()           Return the position of the last occurrence of a substring
'------------------------------------------------------------------------------
 ^bRAT()^b
 Return the position of the last occurrence of a substring
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bRAT(<cSearch>, <cTarget>) --> nPosition

 ^bArguments^b

     ^b<cSearch>^b is the character string to locate.

     ^b<cTarget>^b is the character string to search.

 ^bReturns^b

     RAT() returns the position of <cSearch> within <cTarget> as an integer
     numeric value.  If <cSearch> is not found, RAT() returns zero.

 ^bDescription^b

     RAT() is a character function that returns the position of the last
     occurrence of a character substring within another character string.  It
     does this by searching the target string from the right.  RAT() is like
     the AT() function which returns the position of the first occurrence of
     a substring within another string.  RAT() is also like the $ operator
     which determines whether a substring is contained within a string.

     Both the RAT() and AT() functions are used with SUBSTR(), LEFT(), and
     RIGHT() to extract substrings.

 ^bExamples^b

     ^b^CFE^b  This example uses RAT() to create a user-defined function,
        FilePath(), that extracts the path from a file specification.  If the
        path is unspecified, FilePath() returns a null string (""):

        ? FilePath("C:\DBF\Sales.dbf")      // Result: C:\DBF\

        FUNCTION FilePath( cFile )
           LOCAL nPos, cFilePath
           IF (nPos := RAT("\", cFile)) != 0
              cFilePath = SUBSTR(cFile, 1, nPos)
           ELSE
              cFilePath = ""
           ENDIF
           RETURN cFilePath

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "AT()" "LEFT()" "RIGHT()" "STRTRAN()" "SUBSTR()" 
'------------------------------------------------------------------------------



!short: READEXIT()      Toggle Uparrow and Dnarrow as READ exit keys
'------------------------------------------------------------------------------
 ^bREADEXIT()^b
 Toggle Uparrow and Dnarrow as READ exit keys
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bREADEXIT([<lToggle>]) --> lCurrentState

 ^bArguments^b

     ^b<lToggle>^b toggles the use of Uparrow and Dnarrow as READ exit keys.
     Specifying true (.T.) enables them as exit keys, and false (.F.)
     disables them.

 ^bReturns^b

     READEXIT() returns the current setting as a logical value.

 ^bDescription^b

     READEXIT() is an environment function that reports the current state of
     Uparrow and Dnarrow as keys the user can press to exit a READ from the
     first or last Get object in a GetList.  If the optional <lToggle>
     argument is specified, Uparrow and Dnarrow are either enabled or
     disabled as READ exit keys.  At program startup, Uparrow and Dnarrow are
     not enabled as READ exit keys.  Normally, READ exit keys include only
     PgUp, PgDn, Esc, or Return from the last GET.

 ^bExamples^b

     ^b^CFE^b  This example shows READEXIT() enabling Uparrow and Dnarrow
        exit keys before a READ then resetting them after the READ
        terminates:

        cMyvar = SPACE(10)
        lLastExit = READEXIT(.T.)   // Result: Turn on exit keys
        //
        @ 10, 10 SAY "Enter: " GET cMyvar
        READ
        READEXIT(lLastExit)         // Result: Restore previous setting

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"@...GET" c52g_002.ngo:"READ" "READINSERT()" 
'------------------------------------------------------------------------------



!short: READINSERT()    Toggle the current insert mode for READ and MEMOEDIT()
'------------------------------------------------------------------------------
 ^bREADINSERT()^b
 Toggle the current insert mode for READ and MEMOEDIT()
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bREADINSERT([<lToggle>]) --> lCurrentMode

 ^bArguments^b

     ^b<lToggle>^b toggles the insert mode on or off.  True (.T.) turns
     insert on, while false (.F.) turns insert off.  The default is false
     (.F.) or the last user-selected mode in READ or MEMOEDIT().

 ^bReturns^b

     READINSERT() returns the current insert mode state as a logical value.

 ^bDescription^b

     READINSERT() is an environment function that reports the current state
     of the insert mode for READ and MEMOEDIT(), and optionally sets the
     insert mode on or off depending on the value of <lToggle>.  When
     READINSERT() returns false (.F.), and the user enters characters into a
     Get object's buffer during a READ or a MEMOEDIT(), characters are
     overwritten.  When READINSERT() returns true (.T.), entered characters
     are inserted instead.  The insert mode is a global setting belonging to
     the system and not any specific object.

     You can execute READINSERT() prior to or during a READ or MEMOEDIT().
     If used with READ, READINSERT() can be invoked within a WHEN or VALID
     clause of @...GET or within a SET KEY procedure.  If used with
     MEMOEDIT(), it can be invoked with the user function as well as a SET
     KEY procedure.

 ^bExamples^b

     ^b^CFE^b  This example sets the insert mode prior to entering MEMOEDIT()
        and resets the mode when MEMOEDIT() terminates:

        USE Sales NEW

        // Turn on insert mode
        lInsMode = READINSERT(.T.)
        Sales->Notes := MEMOEDIT(Sales->Notes)
        //
        // Restore previous insert mode
        READINSERT(lInsMode)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "MEMOEDIT()" c52g_002.ngo:"READ" "READEXIT()" 
'------------------------------------------------------------------------------



!short: READKEY()*      Determine what key terminated a READ
'------------------------------------------------------------------------------
 ^bREADKEY()*^b
 Determine what key terminated a READ
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bREADKEY() --> nReadkeyCode

 ^bReturns^b

     READKEY() returns a code representing the key pressed to exit a READ.
     In CA-Clipper, the following keys are the standard READ exit keys and
     their READKEY() return codes:

     ^bREADKEY() Return Codes^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bExit Key             Return Code^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Uparrow              5
     Dnarrow              2
     PgUp                 6
     PgDn                 7
     Ctrl-PgUp           31
     Ctrl-PgDn           30
     Esc                 12
     Ctrl-End, Ctrl-W    14
     Type past end       15
     Return              15
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bDescription^b

     READKEY() is a keyboard function that emulates the READKEY() function in
     dBASE III PLUS.  Its purpose is to determine what key the user pressed
     to terminate a READ.  If UPDATED() is true (.T.), READKEY() returns the
     code plus 256.  Uparrow and Dnarrow exit a READ only if READEXIT()
     returns true (.T.).  The default value is false (.F.).  To provide
     complete compatibility for these keys, execute a READEXIT (.T.) at the
     beginning of your main procedure.

     READKEY() is supplied as a compatibility function and therefore its use
     is strongly discouraged.  It is superseded entirely by LASTKEY() which
     determines the last keystroke fetched from the keyboard buffer.  If the
     keystroke was a READ exit key, LASTKEY() will return the INKEY() code
     for that key.  To determine whether any Get object's buffer was modified
     during a READ, it is superseded by the UPDATED() function.

 ^bFiles:^b  Library is EXTEND.LIB, source file is SOURCE\SAMPLE\READKEY.PRG.
!seealso: c52g_002.ngo:"@...GET" "LASTKEY()" c52g_002.ngo:"READ" "READEXIT()" "UPDATED()" c52g_009.ngo:"Inkey codes" 
'------------------------------------------------------------------------------



!short: READMODAL()     Activate a full-screen editing mode for a GetList
'------------------------------------------------------------------------------
 ^bREADMODAL()^b
 Activate a full-screen editing mode for a GetList
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bREADMODAL(<aGetList>) --> NIL

 ^bArguments^b

     ^b<aGetList>^b is an array containing a list of Get objects to edit.

 ^bReturns^b

     READMODAL() always returns NIL.

 ^bDescription^b

     READMODAL() is a user interface function that implements the full-screen
     editing mode for GETs, and is part of the open architecture Get system
     of CA-Clipper.  READMODAL() is like the READ command, but takes a
     GetList array as an argument and does not reinitialize the GetList array
     when it terminates.  Because of this, you can maintain multiple lists of
     Get objects and activate them any time in a program's execution as long
     as the array to activate is visible.

     In order to retain compatibility with previous versions of CA-Clipper,
     the GET system in CA-Clipper is implemented using a public array called
     GetList.  Each time an @...GET command executes, it creates a Get object
     and adds to the currently visible GetList array.  The standard READ
     command is preprocessed into a call to READMODAL() using the GetList
     array as its argument.  If the SAVE clause is not specified, the
     variable GetList is assigned an empty array after the READMODAL()
     function terminates.

     Some of the functions in the Getsys.prg have been made public so that they
     can be used when implementing customized Get readers.  These functions
     are listed in the table below.

     ^bGet System functions^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bFunction            Description^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     GETACTIVE()         Return the currently active Get object
     GETAPPLYKEY()       Apply a key to a Get object from within a Get reader
     GETDOSETKEY()       Process SET KEY during Get editing
     GETPOSTVALIDATE()   Postvalidate the current Get object
     GETPREVALIDATE()    Prevalidate a Get object
     GETREADER()         Execute standard READ behavior for a Get object
     GETPREVALIDATE()    Prevalidate a Get object
     READFORMAT()        Return, and optionally set the code block that
                         implements a format (.fmt) file
     READKILL()          Return, and optionally set whether the current Read
                         should be exited
     READUPDATED()       Return, and optionally set whether a Get has changed
                         during a Read
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     For reference information on the Get objects and functions listed above,
     refer to the Get System chapter in the Programming and Utilities guide.

     For more information on the supported keys in the default READMODAL()
     function, refer to the READ command reference in this chapter.

 ^bFiles:^b  Library is CLIPPER.LIB, source file is SOURCE\SYS\GETSYS.PRG.
!seealso: c52g_002.ngo:"@...GET" c52g_002.ngo:"READ" 
'------------------------------------------------------------------------------



!short: READVAR()       Return the current GET/MENU variable name
'------------------------------------------------------------------------------
 ^bREADVAR()^b
 Return the current GET/MENU variable name
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bREADVAR() --> cVarName

 ^bReturns^b

     READVAR() returns the name of the variable associated with the current
     Get object or the variable being assigned by the current MENU TO command
     as an uppercase character string.

 ^bDescription^b

     READVAR() is an environment function that, primarily, implements
     context-sensitive help for Get objects and lightbar menus.  READVAR()
     only works during a READ or MENU TO command.  If used during any other
     wait states such as ACCEPT, INPUT, WAIT, ACHOICE(), DBEDIT(), or
     MEMOEDIT(), it returns a null string ("").  Access it within a SET KEY
     procedure, or within a user-defined function invoked from a WHEN or
     VALID clause of a Get object.

 ^bExamples^b

     ^b^CFE^b  This example implements a simple help system for Get objects
        using a database file to store the help text.  When the user presses
        F1, the help database file is searched using READVAR() as the key
        value.  If there is help text available, it is displayed in a window:

        #include "Inkey.ch"
        //
        SET KEY K_F1 TO HelpLookup
        cString = SPACE(10)
        @ 5, 5 SAY "Enter:" GET cString
        READ
        RETURN

        FUNCTION HelpLookup
           USE Help INDEX Help NEW
           SEEK READVAR()
           IF FOUND()
              DisplayHelp(Help->Topic)
           ELSE
              DisplayHelp("No help for " + READVAR())
           ENDIF
           CLOSE Help
           RETURN NIL

        FUNCTION DisplayHelp( cTopic )
           LOCAL cScreen := SAVESCREEN(5,5,15,70),;
                  cColor := SETCOLOR("BG+/B")
           //
           SET CURSOR OFF
           @ 5, 5 CLEAR TO 15, 70
           @ 5, 5 TO 15, 70 DOUBLE
           @ 5, 30 SAY " Help for " + READVAR() + " "
           MEMOEDIT(cTopic, 6, 7, 14, 68, .F.)
           //
           RESTSCREEN(5, 5, 15, 70, cScreen)
           SETCOLOR(cColor)
           SET CURSOR ON
           //
           RETURN NIL

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"@...GET" c52g_002.ngo:"MENU TO" c52g_002.ngo:"READ" c52g_002.ngo:"SET KEY" 
'------------------------------------------------------------------------------



!short: RECCOUNT()*     Determine the number of records in the current (.dbf) file
'------------------------------------------------------------------------------
 ^bRECCOUNT()*^b
 Determine the number of records in the current (.dbf) file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bRECCOUNT()* | LASTREC() --> nRecords

 ^bReturns^b

     RECCOUNT() returns the number of physical records in the current
     database file as an integer numeric value.  Filtering commands such as
     SET FILTER or SET DELETED have no effect on the return value.
     RECCOUNT() returns zero if there is no database file open in the current
     work area.

 ^bDescription^b

     RECCOUNT() is a database function that is a synonym for LASTREC().  By
     default, RECCOUNT() operates on the currently selected work area.  It
     will operate on an unselected work area if you specify it as part of an
     aliased expression (see example below).

 ^bExamples^b

     ^b^CFE^b  This example illustrates the relationship between COUNT and
        RECCOUNT():

        USE Sales NEW
        ? RECCOUNT()                      // Result: 84
        //
        SET FILTER TO Salesman = "1001"
        COUNT TO nRecords
        ? nRecords                        // Result: 14
        ? RECCOUNT()                      // Result: 84

     ^b^CFE^b  This example uses an aliased expression to access the number
        of records in an unselected work area:

        USE Sales NEW
        USE Customer NEW
        ? RECCOUNT(), Sales->(RECCOUNT())

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"COUNT" "EOF()" "LASTREC()" 
'------------------------------------------------------------------------------



!short: RECNO()         Return the current record number of a work area
'------------------------------------------------------------------------------
 ^bRECNO()^b
 Return the current record number of a work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bRECNO() --> nRecord

 ^bReturns^b

     RECNO() returns the current record number as an integer numeric value.
     If the work area contains a database file with zero records, RECNO()
     returns one, BOF() and EOF() both return true (.T.), and LASTREC()
     returns zero.

     If the record pointer is moved past the last record, RECNO() returns
     LASTREC() + 1 and EOF() returns true (.T.).  If an attempt is made to
     move before the first record, RECNO() returns the record number of the
     first logical record in the database file and BOF() returns true (.T.).
     If no database file is open, RECNO() will return a zero.

 ^bDescription^b

     RECNO() is a database function that returns the current record number in
     a work area.  In the CA-Clipper database file scheme, each database file
     is physically ordered by record number.  Each work area in turn
     maintains a pointer to the current record in its open database file.
     That record number is reported by RECNO().  The record numbering
     facility allows direct access to a record without sequentially scanning
     the database file to reach the specified record position.

     RECNO(), typically, generalizes routines that process records by record
     number.  This includes SET RELATION...TO RECNO() which links database
     files by record number.  GO RECNO() also refreshes the current record
     data from disk.

     By default, RECNO() operates on the currently selected work area.  It
     operates on an unselected work area if you specify it as part of an
     aliased expression (see example below).

 ^bExamples^b

     ^b^CFE^b  This example queries RECNO() after deliberately moving the
        record pointer:

        USE Customers NEW
        GO 3
        ? RECNO()                       // Result: 3
        GO TOP
        ? RECNO()                       // Result: 1
        nRecord := 3
        GO nRecord
        ? RECNO()                       // Result: 3
        GO BOTTOM
        SKIP
        ? RECNO(), LASTREC()            // Result: 11 10

     ^b^CFE^b  This example uses aliased expressions to query the value of
        RECNO() in unselected work areas:

        USE Sales NEW
        USE Customer NEW
        //
        ? Sales->(RECNO())
        ? Customer->(RECNO())

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "BOF()" "EOF()" c52g_002.ngo:"GO" "LASTREC()" c52g_002.ngo:"SKIP" 
'------------------------------------------------------------------------------



!short: RECSIZE()       Determine the record length of a database (.dbf) file
'------------------------------------------------------------------------------
 ^bRECSIZE()^b
 Determine the record length of a database (.dbf) file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bRECSIZE() --> nBytes

 ^bReturns^b

     RECSIZE() returns, as a numeric value, the record length, in bytes, of
     the database file open in the current work area.  RECSIZE() returns zero
     if no database file is open.

 ^bDescription^b

     RECSIZE() is a database function that determines the length of a record
     by summing the lengths of each field then adding one for the DELETED()
     status flag.  When this value is multiplied by LASTREC(), the product is
     the amount of space occupied by the file's records.

     RECSIZE() is useful in programs that perform automatic file backup.
     When used in conjunction with DISKSPACE(), the RECSIZE() function can
     assist in ensuring that sufficient free space exists on the disk before a
     file is stored.

     By default, RECSIZE() operates on the currently selected work area.  It
     will operate on an unselected work area if you specify it as part of an
     aliased expression (see example below).

 ^bExamples^b

     ^b^CFE^b  The following user-defined function, DbfSize(), uses RECSIZE()
        to calculate the size of the current database file:

        FUNCTION DbfSize
           RETURN ((RECSIZE() * LASTREC()) + HEADER() + 1)

     ^b^CFE^b  This example illustrates the use of RECSIZE() to determine the
        record length of database files open in unselected work areas:

        USE Customer NEW
        USE Sales NEW
        //
        ? RECSIZE(), Customer->(RECSIZE())
        ? DbfSize(), Customer->(DbfSize())

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "DISKSPACE()" "FIELDNAME()" "HEADER()" "LASTREC()" 
'------------------------------------------------------------------------------



!short: REPLICATE()     Return a string repeated a specified number of times
'------------------------------------------------------------------------------
 ^bREPLICATE()^b
 Return a string repeated a specified number of times
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bREPLICATE(<cString>, <nCount>) --> cRepeatedString

 ^bArguments^b

     ^b<cString>^b is the character string to repeat.

     ^b<nCount>^b is the number of times to repeat <cString>.

 ^bReturns^b

     REPLICATE() returns a character string up to a maximum of 65,535 (64K)
     bytes in length.  Specifying a zero as the <nCount> argument returns a
     null string ("").

 ^bDescription^b

     REPLICATE() is a character function that repeatedly displays, prints, or
     stuffs the keyboard with one or more characters.  REPLICATE() is like
     the SPACE() function which returns a specified number of space
     characters.

 ^bExamples^b

     ^b^CFE^b  These examples demonstrate REPLICATE() repeating strings:

        ? REPLICATE("*", 5)           // Result: *****
        ? REPLICATE("Hi ", 2)         // Result: Hi Hi
        ? REPLICATE(CHR(42), 5)       // Result: *****

     ^b^CFE^b  This example uses REPLICATE() to stuff the keyboard with
        several Dnarrow keys:

        #include "Inkey.ch"
        KEYBOARD REPLICATE(CHR(K_DN), 25)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "SPACE()" 
'------------------------------------------------------------------------------



!short: RESTSCREEN()    Display a saved screen region to a specified location
'------------------------------------------------------------------------------
 ^bRESTSCREEN()^b
 Display a saved screen region to a specified location
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bRESTSCREEN([<nTop>], [<nLeft>],
     ^b   [<nBottom>], [<nRight>], <cScreen>) --> NIL

 ^bArguments^b

     ^b<nTop>^b, ^b<nLeft>^b, ^b<nBottom>^b, and ^b<nRight>^b define the
     coordinates of the screen information contained in <cScreen>.  If the
     <cScreen> was saved without coordinates to preserve the entire screen,
     no screen coordinates are necessary with RESTSCREEN().

     ^b<cScreen>^b is a character string containing the saved screen region.

 ^bReturns^b

     RESTSCREEN() always returns NIL.

 ^bDescription^b

     RESTSCREEN() is a screen function that redisplays a screen region saved
     with SAVESCREEN().  The target screen location may be the same as or
     different than the original location when the screen region was saved.
     If you specify a new screen location, the new screen region must be the
     same size or you will get ambiguous results.  To use RESTSCREEN() to
     restore screen regions saved with SAVE SCREEN, specify the region
     coordinates as 0, 0, MAXROW(), MAXCOL().

     ^bWarning! ^b SAVE SCREEN, RESTORE SCREEN, SAVESCREEN(), and
     RESTSCREEN() are supported when using the default (IBM PC memory mapped)
     screen driver.  Other screen drivers may not support saving and
     restoring screens.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates RESTSCREEN() as part of a general
        purpose popup menu function, PopMenu():

        ? PopMenu({1, 1, 3, 10, {"ItemOne", "ItemTwo"}, ;
              "BG+/B"})

        FUNCTION PopMenu( aList )
           LOCAL cScreen, nChoice, cOldColor := ;
                    SETCOLOR(aList[6])
           cScreen := SAVESCREEN(aList[1], aList[2],;
               aList[3], aList[4])
           @ aList[1], aList[2], TO aList[3], aList[4] DOUBLE
           nChoice := ACHOICE(++aList[1], ++aList[2],;
              --aList[3], --aList[4], aList[5])
           SETCOLOR(cOldColor)
           RESTSCREEN(--aList[1], --aList[2], ++aList[3],;
               ++aList[4], cScreen)
           RETURN nChoice

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "SAVESCREEN()" 
'------------------------------------------------------------------------------



!short: RIGHT()         Return a substring beginning with the rightmost character
'------------------------------------------------------------------------------
 ^bRIGHT()^b
 Return a substring beginning with the rightmost character
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bRIGHT(<cString>, <nCount>) --> cSubString

 ^bArguments^b

     ^b<cString>^b is the character string from which to extract characters.

     ^b<nCount>^b is the number of characters to extract.

 ^bReturns^b

     RIGHT() returns the rightmost <nCount> characters of <cString>.  If
     <nCount> is zero, RIGHT() returns a null string ("").  If <nCount> is
     negative or larger than the length of the character string, RIGHT()
     returns <cString>.  The maximum string size is 65,535 (64K) bytes.

 ^bDescription^b

     RIGHT() is a character function that extracts a substring beginning with
     the rightmost character in <cString>.  It is the same as the character
     expression, SUBSTR(<cString>, -<nCount>).  For example, RIGHT("ABC", 1)
     is the same as SUBSTR("ABC", -1).  RIGHT() is related to LEFT() which
     extracts a substring beginning with the leftmost character in <cString>.

     The RIGHT(), LEFT(), and SUBSTR() functions are often used with both the
     AT() and RAT() functions to locate either the first and/or the last
     position of a substring before extracting it.

 ^bExamples^b

     ^b^CFE^b  This example shows the relationship between RIGHT() and
        SUBSTR():

        ? RIGHT("ABCDEF", 3)                   // Result: DEF
        ? SUBSTR("ABCDEF", -3)                 // Result: DEF

     ^b^CFE^b  This example extracts a substring from the end of another
        string up to the last occurrence of a comma:

        LOCAL cName := "James,William"
        ? RIGHT(cName,;
        LEN(cName) - RAT(",", cName) - 1)      // Result: William

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "LEFT()" "LTRIM()" "RTRIM()" "STUFF()" "SUBSTR()" 
'------------------------------------------------------------------------------



!short: RLOCK()         Lock the current record in the active work area
'------------------------------------------------------------------------------
 ^bRLOCK()^b
 Lock the current record in the active work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bRLOCK() --> lSuccess

 ^bReturns^b

     RLOCK() returns true (.T.) if the record lock is obtained; otherwise, it
     returns false (.F.).

 ^bDescription^b

     RLOCK() is a network function that locks the current record, preventing
     other users from updating the record until the lock is released.
     RLOCK() provides a shared lock, allowing other users read-only access to
     the locked record while allowing only the current user to modify it.  A
     record lock remains until another record is locked, an UNLOCK is
     executed, the current database file is closed, or an FLOCK() is obtained
     on the current database file.

     For each invocation of RLOCK(), there is one attempt to lock the current
     record, and the result is returned as a logical value.  An attempt to
     obtain a record lock fails if another user currently has a file or
     record lock, or EXCLUSIVE USE of the database file.  An attempt to
     RLOCK() in an empty database returns true (.T.).

     By default, RLOCK() operates on the currently selected work area.  It
     will operate on an unselected work area if you specify it as part of an
     aliased expression (see example below).  This feature is useful since
     RLOCK() does not automatically attempt a record lock for related files.

     As a general rule, RLOCK() operates solely on the current record.  This
     includes the following commands:

     ^b^CFE^b  @...GET

     ^b^CFE^b  DELETE (single record)

     ^b^CFE^b  RECALL (single record)

     ^b^CFE^b  REPLACE (single record)

     Refer to the Network Programming chapter in the Programming and
     Utilities guide for more information.

 ^bNotes^b

     ^b^CFE  SET RELATION:^b CA-Clipper does not automatically lock all
        records in the relation chain when you lock the current work area
        record.  Also, an UNLOCK has no effect on related work areas.

 ^bExamples^b

     ^b^CFE^b  This example deletes a record in a network environment, using
        RLOCK():

        USE Customer INDEX CustName SHARED NEW
        SEEK "Smith"
        IF FOUND()
           IF RLOCK()
              DELETE
              ? "Smith deleted"
           ELSE
              ? "Record in use by another"
           ENDIF
        ELSE
           ? "Smith not in Customer file"
        ENDIF
        CLOSE

     ^b^CFE^b  This example specifies RLOCK() as an aliased expression to
        lock a record in an unselected work area:

        USE Sales SHARED NEW
        USE Customer SHARED NEW
        //
        IF !Sales->(RLOCK())
           ? "The current Sales record is in use by another"
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"APPEND BLANK" "FLOCK()" c52g_002.ngo:"SET EXCLUSIVE*" c52g_002.ngo:"UNLOCK" c52g_002.ngo:"USE" 
'------------------------------------------------------------------------------



!short: ROUND()         Return numeric value rounded to a specified number of digits
'------------------------------------------------------------------------------
 ^bROUND()^b
 Return a numeric value rounded to a specified number of digits
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bROUND(<nNumber>, <nDecimals>) --> nRounded

 ^bArguments^b

     ^b<nNumber>^b is the numeric value to round.

     ^b<nDecimals>^b defines the number of decimal places to retain.
     Specifying a negative <nDecimals> value rounds whole number digits.

 ^bReturns^b

     ROUND() returns a numeric value.

 ^bDescription^b

     ROUND() is a numeric function that rounds <nNumber> to the number of
     places specified by <nDecimals>.  Specifying a zero or negative value
     for <nDecimals> allows rounding of whole numbers.  A negative
     <nDecimals> indicates the number of digits to the left of the decimal
     point to round.  Digits between five to nine, inclusive, are rounded up.
     Digits below five are rounded down.

     The display of the return value does not obey the DECIMALS setting
     unless SET FIXED is ON.  With SET FIXED OFF, the display of the return
     value contains as many decimal digits as you specify for <nDecimals>, or
     zero, if <nDecimals> is less than one.

 ^bExamples^b

     ^b^CFE^b  These examples round values with decimal digits:

        SET DECIMALS TO 2
        SET FIXED ON
        //
        ? ROUND(10.4, 0)                     // Result: 10.00
        ? ROUND(10.5, 0)                     // Result: 11.00
        ? ROUND(10.51, 0)                    // Result: 11.00
        ? ROUND(10.49999999999999, 2)        // Result: 10.50

     ^b^CFE^b  These examples use a negative <nDecimals> argument to round
        numeric values to whole number values:

        ? ROUND(101.99, -1)                  // Result: 100.00
        ? ROUND(109.99, -1)                  // Result: 110.00
        ? ROUND(109.99, -2)                  // Result: 100.00

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "INT()" c52g_002.ngo:"SET DECIMALS" c52g_002.ngo:"SET FIXED" "STR()" "VAL()" 
'------------------------------------------------------------------------------



!short: ROW()           Return the screen row position of the cursor
'------------------------------------------------------------------------------
 ^bROW()^b
 Return the screen row position of the cursor
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bROW() --> nRow

 ^bReturns^b

     ROW() returns the cursor row position as an integer numeric value.  The
     range of the return value is zero to MAXROW().

 ^bDescription^b

     ROW() is a screen function that returns the current row or line position
     of the screen cursor.  The value of ROW() is updated by both console and
     full-screen commands and functions.  @...SAY only updates ROW() when the
     current DEVICE is the SCREEN.

     ROW() is used with COL() and all variations of the @ command to position
     the cursor to a new line relative to the current line.  In particular,
     you can use ROW() and COL() to create screen position-independent
     procedures or functions where you pass the upper left row and column as
     parameters.

     ROW() is related to PROW() and PCOL() which track the current printhead
     position instead of the screen cursor position.

 ^bExamples^b

     ^b^CFE^b  In this example, ROW() simulates the LIST command, displaying
        text on the same line but in different columns:

        LOCAL nRow
        USE Customer INDEX CustName NEW
        DO WHILE .NOT. EOF()
           CLS
           @ 1, 1 SAY PADR("Name", LEN(CustName))
           @ ROW(), COL() + 2 SAY PADR("Address", ;
                 LEN(Address))
           @ ROW(), COL() + 2 SAY PADR("Phone", LEN(Phone))
           nRow = 0
           DO WHILE nRow++ <= 15 .AND. (!EOF())
              @ ROW() + 1, 1 SAY CustName
              @ ROW(), COL() + 2 SAY Address
              @ ROW(), COL() + 2 SAY Phone
              SKIP
           ENDDO
           WAIT
        ENDDO
        CLOSE Customer

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"?|??" c52g_002.ngo:"@...SAY" "COL()" "MAXROW()" "PROW()" c52g_002.ngo:"SET DEVICE" 
'------------------------------------------------------------------------------



!short: RTRIM()         Remove trailing spaces from a character string
'------------------------------------------------------------------------------
 ^bRTRIM()^b
 Remove trailing spaces from a character string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^b[R]TRIM(<cString>) --> cTrimString

 ^bArguments^b

     ^b<cString>^b is the character string to copy without trailing spaces.

 ^bReturns^b

     RTRIM() returns a copy of <cString> with the trailing spaces removed.
     If <cString> is a null string ("") or all spaces, RTRIM() returns a null
     string ("").

 ^bDescription^b

     RTRIM() is a character function that formats character strings.  It is
     useful when you want to delete trailing spaces while concatenating
     strings.  This is typically the case with database fields which are
     stored in fixed-width format.  For example, you can use RTRIM() to
     concatenate first and last name fields to form a name string.

     RTRIM() is related to LTRIM() which removes leading spaces, and
     ALLTRIM() which removes both leading and trailing spaces.  The inverse
     of ALLTRIM(), LTRIM(), and RTRIM() are the PADC(), PADR(), and PADL()
     functions which center, right-justify, or left-justify character strings
     by padding them with fill characters.

 ^bExamples^b

     ^b^CFE^b  This is a user-defined function in which RTRIM() formats city,
        state, and zip code fields for labels or form letters:

        FUNCTION CityState(cCity, cState, cZip)
           RETURN RTRIM(cCity) + ", " ;
            + RTRIM(cState) + "  " + cZip

     ^b^CFE^b  In this example the user-defined function, CityState(),
        displays a record from Customer.dbf:

        USE Customer INDEX CustName NEW
        SEEK "Kate"
        ? CityState(City, State, ZipCode)
        // Result: Athens, GA 10066

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ALLTRIM()" "LTRIM()" "PAD()" "SUBSTR()" 
'------------------------------------------------------------------------------



!short: SAVESCREEN()    Save a screen region for later display
'------------------------------------------------------------------------------
 ^bSAVESCREEN()^b
 Save a screen region for later display
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSAVESCREEN([<nTop>], [<nLeft>],
     ^b   [<nBottom>], [<nRight>]) --> cScreen

 ^bArguments^b

     ^b<nTop>^b, ^b<nLeft>^b, ^b<nBottom>^b, and ^b<nRight>^b define the
     coordinates of the screen region to save.  If either <nBottom> or
     <nRight> is greater than MAXROW() or MAXCOL(), the screen is clipped.
     If you specify no coordinates, the entire screen (i.e., from 0,0 to
     MAXROW(), MAXCOL()) is saved.

 ^bReturns^b

     SAVESCREEN() returns the specified screen region as a character string.

 ^bDescription^b

     SAVESCREEN() is a screen function that saves a screen region to a
     variable of any storage class including a field variable.  Later, you
     can redisplay the saved screen image to the same or a new location using
     RESTSCREEN().  Screen regions are usually saved and restored when using
     a popup menu routine or dragging a screen object.

     ^bWarning! ^b SAVE SCREEN, RESTORE SCREEN, SAVESCREEN(), and
     RESTSCREEN() are supported when using the default (IBM PC memory mapped)
     screen driver.  Other screen drivers may not support saving and
     restoring screens.

 ^bExamples^b

     ^b^CFE^b  The following user-defined function creates a popup menu using
        ACHOICE() with SAVESCREEN() and RESTSCREEN(), returning the selection
        in the array of choices:

        FUNCTION PopMenu( nTop, nLeft, nBottom, nRight, ;
                             aItems, cColor )
           LOCAL cScreen, nChoice, cLastColor := ;
                 SETCOLOR(cColor)
           //
           cScreen:= SAVESCREEN(nTop, nLeft, nBottom, nRight)
           @ nTop, nLeft TO nBottom, nRight DOUBLE
           //
           nChoice:= ACHOICE(++nTop, ++nLeft, ;
                        --nBottom, --nRight, aItems)
           //
           RESTSCREEN(--nTop, --nLeft, ++nBottom, ++nRight, ;
                          cScreen)
           SETCOLOR(cLastColor)
           RETURN nChoice

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "RESTSCREEN()" 
'------------------------------------------------------------------------------



!short: SCROLL()        Scroll a screen region up or down, right or left            ^r^CE4^r
'------------------------------------------------------------------------------
 ^bSCROLL()^b
 Scroll a screen region up or down, right or left
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSCROLL([<nTop>], [<nLeft>],
     ^b   [<nBottom>], [<nRight>], [<nVert>] [<nHoriz>])
     ^b   --> NIL

 ^bArguments^b

     ^b<nTop>^b, ^b<nLeft>^b, ^b<nBottom>^b, and ^b<nRight>^b define the
     scroll region coordinates.  Row and columns values can range from 0, 0
     to MAXROW(), MAXCOL().  If you do not specify coordinate arguments, the
     dimensions of the visible display are used.

     ^b<nVert>^b defines the number of rows to scroll, vertically.  A
     positive value scrolls up the specified number of rows.  A negative
     value scrolls down the specified number of rows.  A value of zero
     disables vertical scrolling.  If <nVert> is not specified, zero is
     assumed.

     ^b<nHoriz>^b defines the number of rows to scroll horizontally.  A
     positive value scrolls left the specified number of columns.  A negative
     value scrolls right the specified number of columns.  A value of zero
     disables horizontal scrolling.  If <nHoriz> is not specified, zero is
     assumed.

     If you supply neither <nVert> or <nHoriz> parameters to SCROLL(), the
     area specified by the first four parameters will be blanked.

     ^bWarning!^b  Horizontal scrolling is not supported on all of the
     alternate terminal drivers (i.e. ANSITERM, NOVTERM, PCBIOS).

 ^bReturns^b

     SCROLL() always returns NIL.

 ^bDescription^b

     SCROLL() is a screen function that scrolls a screen region up or down a
     specified number of rows.  When a screen scrolls up, the first line of
     the region is erased, all other lines are moved up, and a blank line is
     displayed in the current standard color on the bottom line of the
     specified region.  If the region scrolls down, the operation is
     reversed.  If the screen region is scrolled more than one line, this
     process is repeated.

     SCROLL() is used primarily to display status information into a defined
     screen region.  Each time a new message is displayed, the screen region
     scrolls up one line and a new line displays at the bottom.

 ^bExamples^b

     ^b^CFE^b  This user-defined function displays a message string at the
        bottom of a screen region after scrolling the region up one line:

        FUNCTION ScrollUp( nTop, nLeft, nBottom, nRight, ;
                             expDisplay )
           //
           SCROLL(nTop, nLeft, nBottom, nRight, 1)
           @ nBottom, nLeft SAY expDisplay
           //
           RETURN NIL

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"@...BOX" c52g_002.ngo:"@...CLEAR" c52g_002.ngo:"@...TO" c52g_002.ngo:"CLEAR SCREEN" 
'------------------------------------------------------------------------------



!short: SECONDS()       Return the number of seconds elapsed since midnight
'------------------------------------------------------------------------------
 ^bSECONDS()^b
 Return the number of seconds elapsed since midnight
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSECONDS() --> nSeconds

 ^bReturns^b

     SECONDS() returns the system time as a numeric value in the form
     seconds.hundredths.  The numeric value returned is the number of seconds
     elapsed since midnight, and is based on a twenty-four hour clock in a
     range from zero to 86399.

 ^bDescription^b

     SECONDS() is a time function that provides a simple method of
     calculating elapsed time during program execution, based on the system
     clock.  It is related to the TIME() function which returns the system
     time as a string in the form hh:mm:ss.

 ^bExamples^b

     ^b^CFE^b  This example contrasts the value of TIME() with SECONDS():

        ? TIME()               // Result: 10:00:00
        ? SECONDS()            // Result: 36000.00

     ^b^CFE^b  This example uses SECONDS() to track elapsed time in seconds:

        LOCAL nStart, nElapsed
        nStart:= SECONDS()
        .
        . <statements>
        .
        nElapsed:= SECONDS() - nStart
        ? "Elapsed: " + LTRIM(STR(nElapsed)) + " seconds"

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "TIME()" 
'------------------------------------------------------------------------------



!short: SELECT()        Determine the work area number of a specified alias
'------------------------------------------------------------------------------
 ^bSELECT()^b
 Determine the work area number of a specified alias
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSELECT([<cAlias>]) --> nWorkArea

 ^bArguments^b

     ^b<cAlias>^b is the target work area alias name.

 ^bReturns^b

     SELECT() returns the work area of the specified alias as a integer
     numeric value.

 ^bDescription^b

     SELECT() is a database function that determines the work area number of
     an alias.  The number returned can range from zero to 250.  If <cAlias>
     is not specified, the current work area number is returned.  If <cAlias>
     is specified and the alias does not exist, SELECT() returns zero.

     ^bNote: ^b The SELECT() function and SELECT command specified with an
     extended expression argument look somewhat alike.  This shouldn't be a
     problem since the SELECT() function is not very useful on a line by
     itself

 ^bExamples^b

     ^b^CFE^b  This example uses SELECT() to determine which work area
        USE...NEW selected:

        USE Sales NEW
        SELECT 1
        ? SELECT("Sales")            // Result: 4

     ^b^CFE^b  To reselect the value returned from the SELECT() function, use
        the SELECT command with the syntax, SELECT (<idMemvar>), like this:

        USE Sales NEW
        nWorkArea:= SELECT()
        USE Customer NEW
        SELECT (nWorkArea)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ALIAS()" c52g_002.ngo:"SELECT" c52g_002.ngo:"USE" "USED()" 
'------------------------------------------------------------------------------



!short: SET()           Inspect or change a system setting
'------------------------------------------------------------------------------
 ^bSET()^b
 Inspect or change a system setting
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET(<nSpecifier>, [<expNewSetting>], [<lOpenMode>])
     ^b    --> CurrentSetting

 ^bArguments^b

     ^b<nSpecifier>^b is a numeric value that identifies the setting to be
     inspected or changed.  <nSpecifier> should be supplied as a manifest
     constant (see below).

     ^b<expNewSetting>^b is an optional argument that specifies a new value
     for the <nSpecifier>.  The type of <expNewSetting> depends on
     <nSpecifier>.

     ^b<lOpenMode>^b is a logical value that indicates whether or not files
     are opened for the following settings:

     _SET_ALTFILE, _SET_PRINTFILE, _SET_EXTRAFILE

     should be truncated or opened in append mode.  A value of false (.F.)
     means the file should be truncated.  A value of true (.T.) means the
     file should be opened in append mode.  In either case, if the file does
     not exist, it is created.

     If this argument is not specified, the default is append mode.

 ^bReturns^b

     SET() returns the current value of the specified setting.

 ^bDescription^b

     SET() is a system function that lets you inspect or change the values of
     the CA-Clipper system settings.  For information on the meaning and
     legal values for a particular setting, refer to the associated command
     or function.

     Use a manifest constant to specify the setting to be inspected or
     changed.  These constants are defined in a header file called Set.ch.
     This header file should be included at the top of any source file which
     uses SET().

     Set.ch also defines a constant called _SET_COUNT.  This constant is
     equal to the number of settings that can be changed or inspected with
     SET(), allowing the construction of a generic function that preserves
     all settings (see example below).

     ^bNote: ^b The numeric values of the manifest constants in Set.ch are
     version-dependent and should never be used directly; the manifest
     constants should always be used.

     If <nSpecifier> or <expNewSetting> is invalid, the call to SET() is
     ignored.

     ^bSet Values Defined in Set.ch^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bConstant            Value Type     Associated Command or Function^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     _SET_EXACT          Logical        SET EXACT
     _SET_FIXED          Logical        SET FIXED
     _SET_DECIMALS       Numeric        SET DECIMALS
     _SET_DATEFORMAT     Character      SET DATE
     _SET_EPOCH          Numeric        SET EPOCH
     _SET_PATH           Character      SET PATH
     _SET_DEFAULT        Character      SET DEFAULT
     _SET_EXCLUSIVE      Logical        SET EXCLUSIVE
     _SET_SOFTSEEK       Logical        SET SOFTSEEK
     _SET_UNIQUE         Logical        SET UNIQUE
     _SET_DELETED        Logical        SET DELETED
     _SET_CANCEL         Logical        SETCANCEL()
     _SET_DEBUG          Logical        ALTD()
     _SET_COLOR          Character      SETCOLOR()
     _SET_CURSOR         Numeric        SETCURSOR()
     _SET_CONSOLE        Logical        SET CONSOLE
     _SET_ALTERNATE      Logical        SET ALTERNATE
     _SET_ALTFILE        Character      SET ALTERNATE TO
     _SET_DEVICE         Character      SET DEVICE
     _SET_PRINTER        Logical        SET PRINTER
     _SET_PRINTFILE      Character      SET PRINTER TO
     _SET_MARGIN         Numeric        SET MARGIN
     _SET_BELL           Logical        SET BELL
     _SET_CONFIRM        Logical        SET CONFIRM
     _SET_ESCAPE         Logical        SET ESCAPE
     _SET_INSERT         Logical        READINSERT()
     _SET_EXIT           Logical        READEXIT()
     _SET_INTENSITY      Logical        SET INTENSITY
     _SET_SCOREBOARD     Logical        SET SCOREBOARD
     _SET_DELIMITERS     Logical        SET DELIMITERS
     _SET_DELIMCHARS     Character      SET DELIMITERS TO
     _SET_WRAP           Logical        SET WRAP
     _SET_MESSAGE        Numeric        SET MESSAGE
     _SET_MCENTER        Logical        SET MESSAGE
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^bNote: ^b _SET_EXTRAFILE and _SET_SCROLLBREAK have no corresponding
     commands.  _SET_EXTRAFILE lets you specify an additional alternate file,
     and _SET_SCROLLBREAK lets you toggle the interpretation of Ctrl-S.

 ^bExamples^b

     ^b^CFE^b  In this example a user-defined function preserves or restores
        all global settings.  This function might be used on entry to a
        subsystem to ensure the subsystem does not affect the state of the
        program that called it:

        #include "Set.ch"
        //

        FUNCTION SetAll( aNewSets )
           LOCAL aCurrentSets[_SET_COUNT], nCurrent
           IF ( aNewSets != NIL )   // Set new and return current
              FOR nCurrent := 1 TO _SET_COUNT
                 aCurrentSets[nCurrent] := ;
                    SET(nCurrent, aNewSets[nCurrent])
              NEXT
           ELSE                     // Just return current
              FOR nCurrent := 1 TO _SET_COUNT
                 aCurrentSets[nCurrent] := SET(nCurrent)
              NEXT
           ENDIF
           RETURN (aCurrentSets)

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Set.ch.
!seealso: 
'------------------------------------------------------------------------------



!short: SETBLINK()      Toggle asterisk (*) interpretation in SETCOLOR()
'------------------------------------------------------------------------------
 ^bSETBLINK()^b
 Toggle asterisk (*) interpretation in SETCOLOR() string between blinking and
 background intensity
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSETBLINK([<lToggle>]) --> lCurrentSetting

 ^bArguments^b

     ^b<lToggle>^b changes the meaning of the asterisk (*) character when it
     is encountered in a SETCOLOR() string.  Specifying true (.T.) sets
     character blinking on and false (.F.) sets background intensity.  The
     default is true (.T.).

 ^bReturns^b

     SETBLINK() returns the current setting as a logical value.

 ^bDescription^b

     SETBLINK() is an environment function that toggles the
     blinking/background intensity attribute and reports the current state of
     SETBLINK().  When SETBLINK() is on, characters written to the screen can
     be made to blink by including an asterisk (*) in a color string passed
     to SETCOLOR().  When SETBLINK() is off, the asterisk (*) causes the
     background color to be intensified instead.  Thus, blinking and
     background intensity attributes are not available at the same time.

     ^bNote: ^b This function is meaningful only on the IBM PC or compatible
     computers with CGA, EGA, or VGA display hardware.

 ^bExamples^b

     ^b^CFE^b  This example saves the current SETBLINK() state before passing
        control to a user-defined function.  Upon return, SETBLINK() is
        restored to its original value:

        lOldBlink := SETBLINK()
        MyFunc()
        SETBLINK(lOldBlink)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "SETCOLOR()" c52g_002.ngo:"SET COLOR*" 
'------------------------------------------------------------------------------



!short: SETCANCEL()     Toggle Alt-C and Ctrl-Break as program termination keys
'------------------------------------------------------------------------------
 ^bSETCANCEL()^b
 Toggle Alt-C and Ctrl-Break as program termination keys
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSETCANCEL([<lToggle>]) --> lCurrentSetting

 ^bArguments^b

     ^b<lToggle>^b changes the availability of Alt-C and Ctrl-Break as
     termination keys.  Specifying true (.T.) allows either of these keys to
     terminate an application and false (.F.) disables both keys.  The
     default is true (.T.).

 ^bReturns^b

     SETCANCEL() returns the current setting as a logical value.

 ^bDescription^b

     SETCANCEL() is a keyboard function that toggles the state of the
     termination keys, Alt-C and Ctrl-Break, and reports the current state of
     SETCANCEL().  Use SETCANCEL() when you want to suppress a user's ability
     to terminate a program without using the specified method.

     Note that if Alt-C or Ctrl-Break is redefined with SET KEY, the SET KEY
     definition takes precedence even if SETCANCEL() returns true (.T.).

     ^bWarning! ^b When SETCANCEL() has been set false (.F.), the user cannot
     terminate a runaway program unless you provide an alternative escape
     mechanism.

 ^bExamples^b

     ^b^CFE^b  This example provides an escape route from a wait state with
        SETCANCEL() set off:

        #define K_ALTC   302
        //
        SETCANCEL(.F.)              // Disable termination keys
        SET KEY K_ALTC TO AltC      // Redefine Alt-C
        .
        . <statements>
        .
        RETURN

        FUNCTION AltC
           LOCAL cScreen, nChoice, cLastColor := ;
                 SETCOLOR("W/B, N/G")
           //
           SAVE SCREEN TO cScreen
           @ 6, 20 CLEAR TO 9, 58
           @ 6, 20 TO 9, 58 DOUBLE
           @ 7, 26 SAY "Alt-C: Do you want to quit?"
           @ 8, 35 PROMPT " Yes "
           @ 8, 41 PROMPT " No "
           MENU TO nChoice
           SETCOLOR(cLastColor)
           RESTORE SCREEN FROM cScreen
           //
           IF nChoice = 1
              QUIT
           ENDIF
           //
           RETURN NIL

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ALTD()" c52g_002.ngo:"SET ESCAPE" c52g_002.ngo:"SET KEY" "SETKEY()" 
'------------------------------------------------------------------------------



!short: SETCOLOR()      Return the current colors and optionally set new colors
'------------------------------------------------------------------------------
 ^bSETCOLOR()^b
 Return the current colors and optionally set new colors
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSETCOLOR([<cColorString>]) --> cColorString

 ^bArguments^b

     ^b<cColorString>^b is a character string containing a list of color
     attribute settings for subsequent screen painting.  The following is a
     list of settings and related scopes:

     ^bColor Settings^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bSetting        Scope^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Standard       All screen output commands and functions
     Enhanced       GETs and selection highlights
     Border         Border around screen, not supported on EGA and VGA
     Background     Not supported
     Unselected     Unselected GETs
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     Each setting is a foreground and background color pair separated by the
     slash (/) character and followed by a comma.  All settings are optional.  If a
     setting is skipped, its previous value is retained with only new values
     set.  Settings may be skipped within the list or left off the end as
     illustrated in the examples below.

 ^bReturns^b

     SETCOLOR() returns the current color settings as a character string.

 ^bDescription^b

     SETCOLOR() is a screen function that saves the current color setting or
     sets new colors for subsequent screen painting.  A color string is made
     from several color settings, each color corresponding to different
     regions of the screen.  As stated above, each setting is made up of a
     foreground and background color.  Foreground defines the color of
     characters displayed on the screen.  Background defines the color
     displayed behind the character.  Spaces and nondisplay characters
     display as background.

     In CA-Clipper, the settings that define color behavior are:

     ^bStandard:^b The standard setting governs all console, full-screen, and
     interface commands and functions when displaying to the screen.  This
     includes commands such as @...PROMPT, @...SAY, and ?, and functions such
     as ACHOICE(), DBEDIT(), and MEMOEDIT().

     ^bEnhanced:^b The enhanced setting governs highlighted displays.  This
     includes GETs with INTENSITY ON, and the MENU TO, DBEDIT(), and
     ACHOICE() selection highlight.

     ^bBorder:^b The border is an area around the screen that cannot be
     written to.

     ^bBackground:^b The background is not supported.

     ^bUnselected:^b The unselected setting indicates input focus by
     displaying the current GET in the enhanced color while other GETs are
     displayed in the unselected color.

     In addition to colors, foreground settings can have high intensity
     and/or blinking attributes.  With a monochrome display, high intensity
     enhances brightness of painted text.  With a color display, high
     intensity changes the hue of the specified color.  For example, "N"
     displays foreground text as black where "N+" displays the same text as
     gray.  High intensity is denoted by "+".  The blinking attribute causes
     the foreground text to flash on and off at rapid intervals.  Blinking is
     denoted with "*".  The attribute character can occur anywhere in the
     setting string, but is always applied to the foreground color regardless
     of where it occurs.

     The following colors are supported:

     ^bList of Colors^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bColor          Letter    Monochrome^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Black          N, Space  Black
     Blue           B         Underline
     Green          G         White
     Cyan           BG        White
     Red            R         White
     Magenta        RB        White
     Brown          GR        White
     White          W         White
     Gray           N+        White
     Bright Blue    B+        Bright Underline
     Bright Green   G+        Bright White
     Bright Cyan    BG+       Bright White
     Bright Red     R+        Bright White
     Bright Magenta RB+       Bright White
     Yellow         GR+       Bright White
     Bright White   W+        Bright White
     Black          U         Underline
     Inverse Video  I         Inverse Video
     Blank          X         Blank
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bNotes^b

     ^b^CFE  Arguments are not specified:^b Unlike SET COLOR TO, SETCOLOR()
        with no argument does not restore colors to their default values.

     ^b^CFE  Color numbers:^b SETCOLOR() supports color letter combinations,
        but not color number combinations.

 ^bExamples^b

     ^b^CFE^b  This example assigns the current color setting to the
        variable, cColor:

        cColor:= SETCOLOR()

     ^b^CFE^b  This example uses SETCOLOR() to save the current color setting
        and set a new one.

        cNewColor:= "BR+/N, R+/N"
        cOldColor:= SETCOLOR(cNewColor)

     ^b^CFE^b  This example uses SET COLOR TO to reset the default colors:

        SET COLOR TO
        ? SETCOLOR()            // Result: W/N, N/W, N, N, N/W

     ^b^CFE^b  These two examples specify SETCOLOR() with missing settings:

        // Settings left off the end
        SETCOLOR("W/N, BG+/B")
        //
        // Settings skipped within the list
        SETCOLOR("W/N, BG+/B,,,W/N")

     ^b^CFE^b  This example uses SETCOLOR() with ISCOLOR() to set the colors,
        depending on the screen type:

        FUNCTION DefaultColors
           IF ISCOLOR()
              cForm := "W+/N, BG+/B,,,W/N"
              cDialog := "N/N+, BG+/B,,,N/N+"
              cAlert := "W+/R, BG+/B,,,W+/R"
           ELSE
              cForm := "W+/N, N/W,,,W/N"
              cDialog := "W+/N, N/W,,,W/N"
              cAlert := "W+/N, N/W,,,W/N"
           ENDIF
           RETURN NIL

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ISCOLOR()" c52g_002.ngo:"SET COLOR*" c52g_002.ngo:"SET INTENSITY" c52g_010.ngo:"Colors" 
'------------------------------------------------------------------------------



!short: SETCURSOR()     Set the cursor shape
'------------------------------------------------------------------------------
 ^bSETCURSOR()^b
 Set the cursor shape
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSETCURSOR([<nCursorShape>]) --> nCurrentSetting

 ^bArguments^b

     ^b<nCursorShape>^b is a number indicating the shape of the cursor.  For
     simpler coding, the header file Setcurs.ch provides descriptive names
     for the various cursor shapes as shown in the table below:

     ^bCursor Shapes^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bShape              Value     Setcurs.ch^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     None                0        SC_NONE
     Underline           1        SC_NORMAL
     Lower half block    2        SC_INSERT
     Full block          3        SC_SPECIAL1
     Upper half block    4        SC_SPECIAL2
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bReturns^b

     SETCURSOR() returns the current cursor shape as a numeric value.

 ^bDescription^b

     SETCURSOR() is an environment function that controls the shape of the
     screen cursor.  The actual shape is dependent on the current screen
     driver.  The specified shapes appear on IBM PC and compatible computers.
     On other computers, the appearance may differ for each value specified.

     SETCURSOR(0) is the same as SET CURSOR OFF, and any positive integer
     value of <nCursorShape> less than 5 is the same as SET CURSOR ON.  The
     cursor will display as the selected shape.

 ^bExamples^b

     ^b^CFE^b  This example uses SETCURSOR() to turn on a full block cursor
        for the subsequent READ.  When the READ terminates SETCURSOR() turns
        off the cursor:

        #include "Setcurs.ch"
        //
        USE Customer NEW
        @ 10, 10 GET Customer->Name
        @ 11, 10 GET Customer->Phone
        //
        SETCURSOR(SC_SPECIAL1)        // Change cursor to a block
        READ
        SETCURSOR(SC_NONE)            // Turn off cursor

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Setcurs.ch.
!seealso: c52g_002.ngo:"SET CONSOLE" c52g_002.ngo:"SET CURSOR" "SETPOS()" 
'------------------------------------------------------------------------------



!short: SETKEY()        Assign an action block to a key
'------------------------------------------------------------------------------
 ^bSETKEY()^b
 Assign an action block to a key
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSETKEY(<nInkeyCode>, [<bAction>]) --> bCurrentAction

 ^bArguments^b

     ^b<nInkeyCode>^b is the INKEY() value of the key to be associated or
     queried.

     ^b<bAction>^b specifies a code block that is automatically executed
     whenever the specified key is pressed during a wait state.

 ^bReturns^b

     SETKEY() returns the action block currently associated with the
     specified key, or NIL if the specified key is not currently associated
     with a block.

 ^bDescription^b

     SETKEY() is a keyboard function that sets or queries the automatic
     action associated with a particular key during a wait state.  A wait
     state is any mode that extracts keys from the keyboard except for
     INKEY(), but including ACHOICE(), DBEDIT(), MEMOEDIT(), ACCEPT, INPUT,
     READ and WAIT.  Up to 32 keys may be assigned at any one time.  At
     startup, the system automatically assigns the F1 key to execute a
     procedure or user-defined function named Help.

     When an assigned key is pressed during a wait state, the EVAL() function
     evaluates the associated <bAction> and the parameters, PROCNAME(),
     PROCLINE(), and READVAR().  It is, however, not necessary to list
     arguments when specifying <bAction> if you do not plan to use them
     within the action block.

     SETKEY() is like the SET KEY command which associates a procedure
     invocation with a key.

 ^bExamples^b

     ^b^CFE^b  This code fragment associates an action block with a key,
        then, after getting a key using INKEY(), executes it with the EVAL()
        function:

        #include "Inkey.ch"
        SETKEY(K_DN, {|cProc, nLine, cVar| MyProc(cProc, ;
                          nLine, cVar)})
        .
        . <statements>
        .
        DO WHILE .T.
           nKey := INKEY(0)
           DO CASE
           CASE (bAction := SETKEY(nKey)) != NIL
              EVAL(bAction, PROCNAME(), PROCLINE(), READVAR())
           CASE nKey = K_PGUP
              Previous()
           CASE nKey = K_PGDN
              Next()
           CASE nKey = K_ESC
              EXIT
           ENDCASE
        ENDDO

 ^bFiles:^b  Library is CLIPPER.LIB, header is Inkey.ch.
!seealso: "EVAL()" "INKEY()" c52g_002.ngo:"SET KEY" c52g_009.ngo:"Inkey codes" 
'------------------------------------------------------------------------------



!short: SETMODE()       Change display mode to a specified number of rows, columns
'------------------------------------------------------------------------------
 ^bSETMODE()^b
 Change display mode to a specified number of rows and columns
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSETMODE(<nRows>, <nCols>) --> lSuccess

 ^bArguments^b

     ^b<nRows>^b is the number of rows in the desired display mode.

     ^b<nCols>^b is the number of columns in the desired display mode.

 ^bReturns^b

     SETMODE() returns true (.T.) if the mode change was successful;
     otherwise, it returns false (.F.).

 ^bDescription^b

     SETMODE() is an environment function that attempts to change the mode of
     the display hardware to match the number of rows and columns specified.
     The change in screen size is reflected in the values returned by
     MAXROW() and MAXCOL().

 ^bExamples^b

     ^b^CFE^b  This example switches to a 43-line display mode:

        IF SETMODE(43, 80)
           ? "43-line mode successfully set"
        ELSE
           ? "43-line mode not available"
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "MAXCOL()" "MAXROW()" 
'------------------------------------------------------------------------------



!short: SETPOS()        Move the cursor to a new position
'------------------------------------------------------------------------------
 ^bSETPOS()^b
 Move the cursor to a new position
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSETPOS(<nRow>, <nCol>) --> NIL

 ^bArguments^b

     ^b<nRow>^b and ^b<nCol>^b define the new screen position of the cursor.
     These values may range from 0, 0 to MAXROW(), MAXCOL().

 ^bReturns^b

     SETPOS() always returns NIL.

 ^bDescription^b

     SETPOS() is an environment function that moves the cursor to a new
     position on the screen.  After the cursor is positioned, ROW() and COL()
     are updated accordingly.  To control the shape and visibility of the
     cursor, use the SETCURSOR() function.

 ^bExamples^b

     ^b^CFE^b  This example moves the cursor to a new position then displays
        a string to the screen using a console command, ??:

        SETPOS(1, 1)
        ?? "Hello world"

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "COL()" "ROW()" c52g_002.ngo:"SET CURSOR" "SETCURSOR()" 
'------------------------------------------------------------------------------



!short: SETPRC()        Set PROW() and PCOL() values
'------------------------------------------------------------------------------
 ^bSETPRC()^b
 Set PROW() and PCOL() values
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSETPRC(<nRow>, <nCol>) --> NIL

 ^bArguments^b

     ^b<nRow>^b is the new PROW() value.

     ^b<nCol>^b is the new PCOL() value.

 ^bReturns^b

     SETPRC() always returns NIL.

 ^bDescription^b

     SETPRC() is a printer function that sends control codes to the printer
     without changing the tracking of the printhead position.  When
     CA-Clipper prints, it updates the PCOL() value with the number of
     characters sent to the printer.  There is no discrimination between
     printable or nonprintable characters.  If, for example, a string of ten
     characters sent to the printer contains two characters interpreted by
     the printer as a control code, the CA-Clipper PCOL() value is
     incremented by ten, while the true printhead position is moved only by
     eight.  This can lead to alignment problems.  Using SETPRC(), you can
     compensate for control codes by resetting PCOL() as shown in the example
     below.

     SETPRC() also suppresses page ejects when printing with @...SAY.  This
     is important when the next row position is smaller than the current row
     and an EJECT has not been issued.  In this situation, CA-Clipper issues
     an automatic page eject if the next row print position is less than the
     current PROW() value.  Using SETPRC(), you can set PROW() to a number
     less than the current row, thus suppressing the automatic EJECT.

 ^bExamples^b

     ^b^CFE^b  This user-defined function, PrintCodes(), uses SETPRC() to
        send control codes to the printer without affecting PROW() and PCOL()
        values:

        #include "Set.ch"
        #define ITALICS_ON   CHR(27) + "I"
        #define ITALICS_OFF  CHR(27) + "E"
        //
        SET DEVICE TO PRINTER
        @ 12, 10 SAY "This is an"
        @ PROW(), PCOL() + 2 SAY PrintCodes(ITALICS_ON) + ;
                 "important"
        @ PROW(), PCOL() + 2 SAY PrintCodes(ITALICS_OFF) + ;
                 "meeting"
        SET DEVICE TO SCREEN
        RETURN

        FUNCTION PrintCodes( cCtrlCode )
           LOCAL nRow, nCol, lPrinter
           lPrinter := SET(_SET_PRINTER, .T.) // SET PRINTER ON
           nRow:= PROW()                      // Save printhead position
           nCol:= PCOL()
           //
           ?? cCtrlCode                       // Send control code
           //
           SETPRC(nRow, nCol)
           SET(_SET_PRINTER, lPrinter)        // Restore printer setting
           RETURN ""                          // Return a null string

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "PCOL()" "PROW()" c52g_002.ngo:"SET DEVICE" "SET()" 
'------------------------------------------------------------------------------



!short: SOUNDEX()       Convert a character string to soundex form
'------------------------------------------------------------------------------
 ^bSOUNDEX()^b
 Convert a character string to soundex form
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSOUNDEX(<cString>) --> cSoundexString

 ^bArguments^b

     ^b<cString>^b is the character string to convert.

 ^bReturns^b

     SOUNDEX() returns a four-digit character string in the form A999.

 ^bDescription^b

     SOUNDEX() is a character function that indexes and searches for
     sound-alike or phonetic matches.  It is used in applications where the
     precise spelling of character keys is not known or where there is a high
     probability of misspelled names.  Misspelling is common in real-time
     transaction systems where the data entry operator is receiving
     information over the telephone.  SOUNDEX() works by bringing
     sound-alikes together under the same key value.  Note, however, the
     soundex method is not absolute.  Keys that are quite different can
     result in the same soundex value.

 ^bExamples^b

     ^b^CFE^b  This example builds an index using SOUNDEX() to create the key
        values.  It then searches for a value found in the Salesman field:

        USE Sales
        INDEX ON SOUNDEX(Salesman) TO Salesman
        SEEK SOUNDEX("Smith")
        ? FOUND(), Salesman            // Result: .T. Smith

     ^b^CFE^b  Here, a search is made for the same key as above but with a
        different spelling:

        SEEK SOUNDEX("Smythe")
        ? FOUND(), Salesman            // Result: .T. Smith

 ^bFiles:^b  Library is EXTEND.LIB, source file is SOURCE\SAMPLE\SOUNDEX.C.
!seealso: c52g_002.ngo:"INDEX" c52g_002.ngo:"LOCATE" c52g_002.ngo:"SEEK" c52g_002.ngo:"SET SOFTSEEK" 
'------------------------------------------------------------------------------



!short: SPACE()         Return a string of spaces
'------------------------------------------------------------------------------
 ^bSPACE()^b
 Return a string of spaces
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSPACE(<nCount>) --> cSpaces

 ^bArguments^b

     ^b<nCount>^b is the number of spaces to return, up to a maximum of
     65,535 (64K).

 ^bReturns^b

     SPACE() returns a character string.  If <nCount> is zero, SPACE()
     returns a null string ("").

 ^bDescription^b

     SPACE() is a character function that returns a specified number of
     spaces.  It is the same as REPLICATE(" ", <nCount>).  SPACE() can
     initialize a character variable before associating it with a GET.
     SPACE() can also pad strings with leading or trailing spaces.  Note,
     however, that the PADC(), PADL(), and PADR() functions are more
     effective for this purpose.

 ^bExamples^b

     ^b^CFE^b  This example uses SPACE() to initialize a variable for data
        input:

        USE Customer NEW
        MEMVAR->Name = SPACE(LEN(Customer->Name))
        @ 10,10 SAY "Customer Name" GET MEMVAR->Name
        READ

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "PAD()" "REPLICATE()" 
'------------------------------------------------------------------------------



!short: SQRT()          Return the square root of a positive number
'------------------------------------------------------------------------------
 ^bSQRT()^b
 Return the square root of a positive number
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSQRT(<nNumber>) --> nRoot

 ^bArguments^b

     ^b<nNumber>^b is a positive number to take the square root of.

 ^bReturns^b

     SQRT() returns a numeric value calculated to double precision.  The
     number of decimal places displayed is determined solely by SET DECIMALS
     regardless of SET FIXED.  A negative <nNumber> returns zero.

 ^bDescription^b

     SQRT() is a numeric function used anywhere in a numeric calculation to
     compute a square root (e.g., in an expression that calculates standard
     deviation).

 ^bExamples^b

     ^b^CFE^b  These examples show various results of SQRT():

        SET DECIMALS TO 5
        //
        ? SQRT(2)                 // Result: 1.41421
        ? SQRT(4)                 // Result: 2.00000
        ? SQRT(4) ** 2            // Result: 4.00000
        ? SQRT(2) ** 2            // Result: 2.00000

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"SET DECIMALS" c52g_002.ngo:"SET FIXED" 
'------------------------------------------------------------------------------



!short: STR()           Convert a numeric expression to a character string
'------------------------------------------------------------------------------
 ^bSTR()^b
 Convert a numeric expression to a character string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSTR(<nNumber>, [<nLength>], [<nDecimals>]) --> cNumber

 ^bArguments^b

     ^b<nNumber>^b is the numeric expression to convert to a character
     string.

     ^b<nLength>^b is the length of the character string to return, including
     decimal digits, decimal point, and sign.

     ^b<nDecimals>^b is the number of decimal places to return.

 ^bReturns^b

     STR() returns <nNumber> formatted as a character string.  If the
     optional length and decimal arguments are not specified, STR() returns
     the character string according to the following rules:

     ^bResults of STR() with No Optional Arguments^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bExpression               Return Value Length^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Field Variable           Field length plus decimals
     Expressions/constants    Minimum of 10 digits plus decimals
     VAL()                    Minimum of 3 digits
     MONTH()/DAY()            3 digits
     YEAR()                   5 digits
     RECNO()                  7 digits
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bDescription^b

     STR() is a numeric conversion function that converts numeric values to
     character strings.  It is commonly used to concatenate numeric values to
     character strings.  STR() has applications displaying numbers, creating
     codes such as part numbers from numeric values, and creating index keys
     that combine numeric and character data.

     STR() is like TRANSFORM() which formats numeric values as character
     strings using a mask instead of length and decimal specifications.

     The inverse of STR() is VAL() which converts character numbers to
     numerics.

 ^bNotes^b

     ^b^CFE^b  If <nLength> is less than the number of whole number digits in
        <nNumber>, STR() returns asterisks instead of the number.

     ^b^CFE^b  If <nLength> is less than the number of decimal digits
        required for the decimal portion of the returned string, CA-Clipper
        rounds the number to the available number of decimal places.

     ^b^CFE^b  If <nLength> is specified, but <nDecimals> is omitted (no
        decimal places), the return value is rounded to an integer.

 ^bExamples^b

     ^b^CFE^b  These examples demonstrate the range of values returned by
        STR(), depending on the arguments specified:

        nNumber:= 123.45
        ? STR(nNumber)                // Result:        123.45
        ? STR(nNumber, 4)             // Result:  123
        ? STR(nNumber, 2)             // Result: **
        ? STR(nNumber * 10, 7, 2)     // Result: 1234.50
        ? STR(nNumber * 10, 12, 4)    // Result:    1234.5000
        ? STR(nNumber, 10, 1)         // Result:    1234.5

     ^b^CFE^b  This example uses STR() to create an index with a compound key
        of order numbers and customer names:

        USE Customer NEW
        INDEX ON STR(NumOrders, 9) + CustName TO CustOrd

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "TRANSFORM()" "VAL()" 
'------------------------------------------------------------------------------



!short: STRTRAN()       Search and replace characters within a string or memo field
'------------------------------------------------------------------------------
 ^bSTRTRAN()^b
 Search and replace characters within a character string or memo field
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSTRTRAN(<cString>, <cSearch>,
     ^b   [<cReplace>], [<nStart>], [<nCount>]) --> cNewString

 ^bArguments^b

     ^b<cString>^b is the character string or memo field to search.

     ^b<cSearch>^b is the sequence of characters to locate.

     ^b<cReplace>^b is the sequence of characters with which to replace
     <cSearch>.  If this argument is not specified, the specified instances
     of the search argument are replaced with a null string ("").

     ^b<nStart>^b is the first occurrence that will be replaced.  If this
     argument is omitted, the default is one.

     ^b<nCount>^b is the number of occurrences to replace.  If this argument
     is not specified, the default is all.

 ^bReturns^b

     STRTRAN() returns a new character string with the specified instances of
     <cSearch> replaced with <cReplace>.

 ^bDescription^b

     STRTRAN() is a character function that performs a standard substring
     search within a character string.  When it finds a match, it replaces
     the search string with the specified replacement string.  All instances
     of <cSearch> are replaced unless <nStart> or <nCount> is specified.
     Note that STRTRAN() replaces substrings and, therefore, does not account
     for whole words.

 ^bExamples^b

     ^b^CFE^b  This example uses STRTRAN() to establish a postmodern analog
        to a famous quotation:

        cString:= "To compute, or not to compute?"
        ? STRTRAN(cString, "compute", "be")
        // Result: To be, or not to be?

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "AT()" "HARDCR()" "MEMOTRAN()" "RAT()" "STUFF()" "SUBSTR()" 
'------------------------------------------------------------------------------



!short: STUFF()         Delete and insert characters in a string
'------------------------------------------------------------------------------
 ^bSTUFF()^b
 Delete and insert characters in a string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSTUFF(<cString>, <nStart>,
     ^b   <nDelete>, <cInsert>) --> cNewString

 ^bArguments^b

     ^b<cString>^b is the target character string into which characters are
     inserted and deleted.

     ^b<nStart>^b is the starting position in the target string where the
     insertion/deletion occurs.

     ^b<nDelete>^b is the number of characters to delete.

     ^b<cInsert>^b is the string to insert.

 ^bReturns^b

     STUFF() returns a copy of <cString> with the specified characters
     deleted and with <cInsert> inserted.

 ^bDescription^b

     STUFF() is a character function that deletes <nDelete> characters from
     <cString> beginning at the <nStart> position.  Then, it inserts
     <cInsert> into the resulting string beginning at <nStart> to form the
     return string.  With this, STUFF() can perform the following six
     operations:

     ^b^CFE  Insert:^b If <nDelete> is zero, no characters are removed from
        <cString>.  <cInsert> is then inserted at <nStart>, and the entire
        string is returned.  For example, STUFF("My dog has fleas.", 12, 0,
        "no ") returns "My dog has no fleas."

     ^b^CFE  Replace:^b If <cInsert> is the same length as <nDelete>,
        <cInsert> replaces characters beginning at <nStart>.  The same number
        of characters are deleted as are inserted, and the resulting string
        is the same length as the original.  For example, STUFF("My dog has
        fleas.", 12, 5, "bones") returns "My dog has bones."

     ^b^CFE  Delete:^b If <cInsert> is a null string (""), the number of
        characters specified by <nDelete> are removed from <cString>, and the
        string is returned without any added characters.  For example,
        STUFF("My dog has fleas.", 1, 3, "") returns "dog has fleas."

     ^b^CFE  Replace and insert:^b If <cInsert> is longer than <nDelete>, all
        characters from <nStart> up to <nDelete> are replaced and the rest of
        <cInsert> is inserted.  Since more characters are inserted than are
        deleted, the resulting string is always longer than the original.
        For example, STUFF("My dog has fleas.", 8, 3, "does not have")
        returns "My dog does not have fleas."

     ^b^CFE  Replace and delete:^b If the length of <cInsert> is less than
        <nDelete>, more characters are deleted than inserted.  The resulting
        string, therefore, is shorter than the original.  For example,
        STUFF("My dog has fleas.", 8, 3, "is") returns "My dog is fleas."

     ^b^CFE  Replace and delete rest:^b If <nDelete> is greater than or equal
        to the number of characters remaining in <cString> beginning with
        <nStart>, all remaining characters are deleted before <cInsert> is
        inserted.  For example, STUFF("My dog has fleas.", 8, 10, "is.")
        returns "My dog is."

 ^bExamples^b

     ^b^CFE^b  These examples demonstrate the six basic operations of
        STUFF():

        // Insert
        ? STUFF("ABCDEF", 2, 0, "xyz")      // Result: AxyzBCDEF
        // Replace
        ? STUFF("ABCDEF", 2, 3, "xyz")      // Result: AxyzEF
        // Delete
        ? STUFF("ABCDEF", 2, 2, "")         // Result: ADEF
        // Replace and insert
        ? STUFF("ABCDEF", 2, 1, "xyz")      // Result: AxyzCDEF
        // Replace and delete
        ? STUFF("ABCDEF", 2, 4, "xyz")      // Result: AxyzF
        // Replace and delete rest
        ? STUFF("ABCDEF", 2, 10, "xyz")     // Result: Axyz

 ^bFiles:^b  Library is EXTEND.LIB, source file is SOURCE\SAMPLE\STUFF.C.
!seealso: "AT()" "LEFT()" "RAT()" "RIGHT()" "STRTRAN()" "SUBSTR()" 
'------------------------------------------------------------------------------



!short: SUBSTR()        Extract a substring from a character string
'------------------------------------------------------------------------------
 ^bSUBSTR()^b
 Extract a substring from a character string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSUBSTR(<cString>, <nStart>, [<nCount>]) --> cSubstring

 ^bArguments^b

     ^b<cString>^b is the character string from which to extract a substring.
     It can be up to 65,535 (64K) bytes, the maximum character string size in
     CA-Clipper.

     ^b<nStart>^b is the starting position in <cString>.  If <nStart> is
     positive, it is relative to the leftmost character in <cString>.  If
     <nStart> is negative, it is relative to the rightmost character in the
     <cString>.

     ^b<nCount>^b is the number of characters to extract.  If omitted, the
     substring begins at <nStart> and continues to the end of the string.  If
     <nCount> is greater than the number of characters from <nStart> to the
     end of <cString>, the extra is ignored.

 ^bReturns^b

     SUBSTR() returns a character string.

 ^bDescription^b

     SUBSTR() is a character function that extracts a substring from another
     character string or memo field.  SUBSTR() is related to the LEFT() and
     RIGHT() functions which extract substrings beginning with leftmost and
     rightmost characters in <cString>, respectively.

     The SUBSTR(), RIGHT(), and LEFT() functions are often used with both the
     AT() and RAT() functions to locate either the first and/or the last
     position of a substring before extracting it.  They are also used to
     display or print only a portion of a character string.

 ^bExamples^b

     ^b^CFE^b  These examples extract the first and last name from a
        variable:

        cName:= "Biff Styvesent"
        ? SUBSTR(cName, 1, 4)               // Result: Biff
        ? SUBSTR(cName, 6)                  // Result: Styvesent
        ? SUBSTR(cName, LEN(cName) + 2)     // Result: null string
        ? SUBSTR(cName, -9)                 // Result: Styvesent
        ? SUBSTR(cName, -9, 3)              // Result: Sty

     ^b^CFE^b  This example uses SUBSTR() with AT() and RAT() to create a
        user-defined function to extract a filename from a file
        specification:

        ? FileBase("C:\PRG\MYFILE.OBJ")      // Result: MYFILE.OBJ

        FUNCTION FileBase( cFile )
           LOCAL nPos
           IF (nPos := RAT("\", cFile)) != 0
              RETURN SUBSTR(cFile, nPos + 1)
           ELSEIF (nPos := AT(":", cFile)) != 0
              RETURN SUBSTR(cFile, nPos + 1)
           ELSE
              RETURN cFile
           ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "AT()" "LEFT()" "RAT()" "RIGHT()" "STR()" 
'------------------------------------------------------------------------------



!short: TIME()          Return the system time
'------------------------------------------------------------------------------
 ^bTIME()^b
 Return the system time
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bTIME() --> cTimeString

 ^bReturns^b

     TIME() returns the system time as a character string in the form
     hh:mm:ss.  hh is hours in 24-hour format, mm is minutes, and ss is
     seconds.

 ^bDescription^b

     TIME() is a time function that displays the system time on the screen or
     prints it on a report.  TIME() is related to SECONDS() which returns the
     integer value representing the number of seconds since midnight.
     SECONDS() is generally used in place of TIME() for time calculations.

 ^bExamples^b

     ^b^CFE^b  These examples show the results of TIME() used with SUBSTR()
        to extract the hour, minutes, and seconds digits:

        ? TIME()                       // Result: 10:37:17
        ? SUBSTR(TIME(), 1, 2)         // Result: 10
        ? SUBSTR(TIME(), 4, 2)         // Result: 37
        ? SUBSTR(TIME(), 7, 2)         // Result: 17

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DATE()" "SECONDS()" "SUBSTR()" 
'------------------------------------------------------------------------------



!short: TONE()          Sound a speaker tone for a specified frequency and duration
'------------------------------------------------------------------------------
 ^bTONE()^b
 Sound a speaker tone for a specified frequency and duration
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bTONE(<nFrequency>, <nDuration>) --> NIL

 ^bArguments^b

     ^b<nFrequency>^b is a positive numeric value indicating the frequency of
     the tone to sound.

     ^b<nDuration>^b is a positive numeric value indicating the duration of
     the tone measured in increments of 1/18 of a second.  For example, an
     <nDuration> value of 18 represents one second.

     For both arguments, noninteger values are truncated--not rounded--to
     their integer portion.

 ^bReturns^b

     TONE() always returns NIL.

 ^bDescription^b

     TONE() is a sound function that indicates various program states to the
     user.  These can be error states, boundary conditions, or the end of a
     time-consuming process.  For example, an error state would sound an
     error tone before alerting the user with a message or interactive dialog
     box.  A boundary condition might indicate that the user is attempting to
     cursor past the top or bottom of a column in a TBrowse object.  A batch
     process also might indicate its completion with a sound to alert the
     user, in case the user has turned away from the screen.

     TONE() works by sounding the speaker at the specified frequency for the
     specified duration.  The duration is measured in increments of 1/18 of a
     second.  The frequency is measured in hertz (cycles per second).
     Frequencies of less than 20 are inaudible.  The table below shows the
     frequencies of standard musical notes.

     ^bNote: ^b TONE() works only on IBM PC and 100% compatible computers

     ^bTable of Musical Notes^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bPitch   Frequency    Pitch     Frequency^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     C       130.80       mid C     261.70
     C#      138.60       C#        277.20
     D       146.80       D         293.70
     D#      155.60       D#        311.10
     E       164.80       E         329.60
     F       174.60       F         349.20
     F#      185.00       F#        370.00
     G       196.00       G         392.00
     G#      207.70       G#        415.30
     A       220.00       A         440.00
     A#      233.10       A#        466.20
     B       246.90       B         493.90
                          C         523.30
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bExamples^b

     ^b^CFE^b  This example is a beep function that indicates that a batch
        operation has completed:

        FUNCTION DoneBeep
           TONE(300, 1)
           TONE(100, 1)
           TONE(300, 1)
           TONE(100, 1)
           RETURN NIL

     ^b^CFE^b  This example is a tone sequence that indicates invalid
        keystrokes or boundary conditions:

        FUNCTION ErrorBeep
           TONE(100, 3)
           RETURN NIL

 ^bFiles:^b  Library is EXTEND.LIB, source file is SOURCE\SAMPLE\EXAMPLEA.ASM.
!seealso: "CHR()" c52g_002.ngo:"SET BELL" 
'------------------------------------------------------------------------------



!short: TRANSFORM()     Convert any value into a formatted character string
'------------------------------------------------------------------------------
 ^bTRANSFORM()^b
 Convert any value into a formatted character string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bTRANSFORM(<exp>, <cSayPicture>) --> cFormatString

 ^bArguments^b

     ^b<exp>^b is the value to format.  This expression can be any valid
     CA-Clipper data type except array, code block, and NIL.

     ^b<cSayPicture>^b is a string of picture and template characters that
     describes the format of the returned character string.

 ^bReturns^b

     TRANSFORM() converts <exp> to a formatted character string as defined by
     <cSayPicture>.

 ^bDescription^b

     TRANSFORM() is a conversion function that formats character, date,
     logical, and numeric values according to a specified picture string that
     includes a combination of picture function and template strings.
     TRANSFORM() formats data for output to the screen or the printer in the
     same manner as the PICTURE clause of the @...SAY command.

     ^b^CFE  Function string:^b A picture function string specifies
        formatting rules that apply to the TRANSFORM() return value as a
        whole, rather than to particular character positions within <exp>.
        The function string consists of the @ character, followed by one or
        more additional characters, each of which has a particular meaning
        (see table below).  If a function string is present, the @ character
        must be the leftmost character of the picture string, and the
        function string must not contain spaces.  A function string may be
        specified alone or with a template string.  If both are present, the
        function string must precede the template string, and the two must be
        separated by a single space.

        ^bTRANSFORM() Functions^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bFunction     Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        B            Displays numbers left-justified
        C            Displays CR after positive numbers
        D            Displays date in SET DATE format
        E            Displays date in British format
        R            Nontemplate characters are inserted
        X            Displays DB after negative numbers
        Z            Displays zeros as blanks
        (            Encloses negative numbers in parentheses
        !            Converts alphabetic characters to uppercase
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^b^CFE  Template string:^b A picture template string specifies
        formatting rules on a character by character basis.  The template
        string consists of a series of characters, some of which have special
        meanings (see table below).  Each position in the template string
        corresponds to a position in the value of the <exp> argument.
        Because TRANSFORM() uses a template, it can insert formatting
        characters such commas, dollar signs, and parentheses.

        Characters in the template string that have no assigned meanings are
        copied literally into the return value.  If the @R picture function
        is used, these characters are inserted between characters of the
        return value; otherwise, they overwrite the corresponding characters
        of the return value.  A template string may be specified alone or
        with a function string.  If both are present, the function string
        must precede the template string, and the two must be separated by a
        single space.

        ^bTRANSFORM() Templates^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bTemplate       Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        A,N,X,9,#      Displays digits for any data type
        L              Displays logicals as "T" or "F"
        Y              Displays logicals as "Y" or "N"
        !              Converts an alphabetic character to uppercase
        $              Displays a dollar sign in place of a leading space in
                       a numeric
        *              Displays an asterisk in place of a leading space in a
                       numeric
        .              Specifies a decimal point position
        ,              Specifies a comma position
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bExamples^b

     ^b^CFE^b  This example formats a number into a currency format using a
        template:

        ? TRANSFORM(123456, "$999,999")   // Result: $123,456

     ^b^CFE^b  This example formats a character string using a function:

        ? TRANSFORM("to upper", "@!")     // Result: TO UPPER

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"@...SAY" "LOWER()" "PAD()" "STR()" "UPPER()" c52g_011.ngo:"Picture codes" 
'------------------------------------------------------------------------------



!short: TYPE()          Determine the type of an expression
'------------------------------------------------------------------------------
 ^bTYPE()^b
 Determine the type of an expression
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bTYPE(<cExp>) --> cType

 ^bArguments^b

     ^b<cExp>^b is a character expression whose type is to be determined.
     <cExp> can be a field, with or without the alias, a private or public
     variable, or an expression of any type.

 ^bReturns^b

     TYPE() returns one of the following characters:

     ^bTYPE() Return Values^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bReturns    Meaning^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     A          Array
     B          Block
     C          Character
     D          Date
     L          Logical
     M          Memo
     N          Numeric
     O          Object
     U          NIL, local, or static
     UE         Error syntactical
     UI         Error indeterminate
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bDescription^b

     TYPE() is a system function that returns the type of the specified
     expression.  It can test expression validity as long as the expression
     uses CLIPPER.LIB functions and does not reference local or static
     variables, user-defined functions, or built-in functions supplied in
     EXTEND.LIB.

     TYPE() is like VALTYPE() but uses the macro operator (&) to determine
     the type of the argument.  This precludes the use of TYPE() to determine
     the type of local and static variables.  VALTYPE(), by contrast,
     evaluates an expression and determines the data type of the return
     value.  This lets you determine the type of user-defined functions as
     well as local and static variables.

 ^bNotes^b

     ^b^CFE  Array references:^b References to private and public arrays
        return "A."  References to array elements return the type of the
        element.

     ^b^CFE  IF():^b To return the appropriate data type for an IF()
        expression, TYPE() evaluates the condition then returns the type of
        the evaluated path.  If either the IF() condition or the evaluated
        path are invalid, TYPE() returns "UE."

     ^b^CFE  Testing parameters:^b TYPE() can only test the validity of
        parameters received using the PARAMETERS statement.  Testing a
        parameter declared as part of a FUNCTION or PROCEDURE declaration
        always returns "U." because local parameters do not have a symbol in
        the symbol table.  To determine whether an argument was skipped or
        left off the end of the argument list, compare the parameter to NIL
        or use VALTYPE().

     ^b^CFE  User-defined and EXTEND.LIB functions:^b If a reference is made
        anywhere in an expression to a function not found in CLIPPER.LIB (a
        user-defined or EXTEND.LIB function), TYPE() returns "UI."  If the
        user-defined function is not linked into the current program, TYPE()
        returns "U."

 ^bExamples^b

     ^b^CFE^b  These examples demonstrate various results from invocations of
        TYPE():

        ? TYPE('SUBSTR("Hi There", 4, 5)')      // Result: C
        ? TYPE("UDF()")                         // Result: UI
        ? TYPE('IF(.T., "true", 12)')           // Result: C

     ^b^CFE^b  This example shows two methods for testing for the existence
        and type of declared parameters:

        FUNCTION TestParams
           PARAMETERS cParam1, nParam2
           IF cParam1 = NIL
              ? "First parameter was not passed"
              cParam1 := "Default value"
           ENDIF
           //
           IF TYPE(nParam2) == "U"
              ? "Second parameter was not passed"
           ENDIF
           .
           . <statements>
           .
           RETURN NIL

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "VALTYPE()" 
'------------------------------------------------------------------------------



!short: UPDATED()       Determine whether a GET changed during a READ
'------------------------------------------------------------------------------
 ^bUPDATED()^b
 Determine whether a GET changed during a READ
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bUPDATED() --> lChange

 ^bReturns^b

     UPDATED() returns true (.T.) if data in a GET is added or changed;
     otherwise, it returns false (.F.).

 ^bDescription^b

     UPDATED() determines whether characters were successfully entered into a
     GET from the keyboard during the most current READ.  Each time READ
     executes, UPDATED() is set to false (.F.).  Then, any change to a GET
     entered from the keyboard sets UPDATED() to true (.T.) after the user
     successfully exits the GET.  If the user presses Esc before exiting the
     first GET edited, UPDATED() remains false (.F.).  Once UPDATED() is set
     to true (.T.), it retains this value until the next READ is executed.

     Within a SET KEY or VALID procedure, you can change the current GET
     variable using the KEYBOARD command or by assigning a new value with one
     of the many assignment operators.  Changing the variable with KEYBOARD
     is the same as if the user had entered the change directly from the
     keyboard, and UPDATED() is set accordingly.  However, since UPDATED()
     reflects only those changes made from the keyboard, an assignment to the
     GET variable does not affect UPDATED().

 ^bExamples^b

     ^b^CFE^b  This example assigns field values from Customer.dbf to
        variables and edits them.  If the user changes any of the values, the
        field variables for the current record are updated with the new
        values:

        USE Customer NEW
        CLEAR
        MEMVAR->Customer = Customer->Customer
        MEMVAR->Address = Customer->Address
        @ 1, 1 SAY "Name:" GET MEMVAR->Customer
        @ 2, 1 SAY "Address:" GET MEMVAR->Address
        READ
        //
        IF UPDATED()
           Customer->Customer := MEMVAR->Customer
           Customer->Address := MEMVAR->Address
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_002.ngo:"@...GET" c52g_002.ngo:"READ" c52g_002.ngo:"SET KEY" 
'------------------------------------------------------------------------------



!short: UPPER()         Convert lowercase characters to uppercase
'------------------------------------------------------------------------------
 ^bUPPER()^b
 Convert lowercase characters to uppercase
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bUPPER(<cString>) --> cUpperString

 ^bArguments^b

     ^b<cString>^b is the character string to convert.

 ^bReturns^b

     UPPER() returns a copy of <cString> with all alphabetical characters
     converted to uppercase.  All other characters remain the same as in the
     original string.

 ^bDescription^b

     UPPER() is a character function that converts lower and mixedcase
     strings to uppercase.  It is related to LOWER() which converts upper and
     mixedcase strings to lowercase.  UPPER() is related to the ISUPPER() and
     ISLOWER() functions which determine whether a string begins with an
     uppercase or lowercase letter.

     UPPER() is generally used to format character strings for display
     purposes.  It can, however, be used to normalize strings for
     case-independent comparison or INDEXing purposes.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate the effects of UPPER():

        ? UPPER("a string")           // Result: A STRING
        ? UPPER("123 char = <>")      // Result: 123 CHAR = <>

     ^b^CFE^b  This example uses UPPER() as part of a case-independent
        condition:

        USE Customer INDEX CustName NEW
        LIST CustName FOR "KATE" $ UPPER(Customer)

     ^b^CFE^b  UPPER() is also useful for creating case-independent index key
        expressions:

        USE Customer NEW
        INDEX ON UPPER(Last) TO CustLast

     ^b^CFE^b  Later, use the same expression to look up Customers:

        MEMVAR->Last = SPACE(15)
        @ 10, 10 GET MEMVAR->Last
        READ

        SEEK UPPER(MEMVAR->Last)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ISLOWER()" "ISUPPER()" "LOWER()" 
'------------------------------------------------------------------------------



!short: USED()          Determine whether a database file is in USE
'------------------------------------------------------------------------------
 ^bUSED()^b
 Determine whether a database file is in USE
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bUSED() --> lDbfOpen

 ^bReturns^b

     USED() returns true (.T.) if there is a database file in USE; otherwise,
     it returns false (.F.).


 ^bDescription^b

     USED() is a database function that determines whether there is a
     database file in USE in a particular work area.  By default, USED()
     operates on the currently selected work area.  It will operate on an
     unselected work area if you specify it as part of an aliased expression.

 ^bExamples^b

     ^b^CFE^b  This example determines whether a database file is in USE in
        the current work area:

        USE Customer NEW
        ? USED()               // Result: .T.
        CLOSE
        ? USED()               // Result: .F.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ALIAS()" c52g_002.ngo:"SELECT" "SELECT()" c52g_002.ngo:"USE" 
'------------------------------------------------------------------------------



!short: VAL()           Convert a character number to numeric type
'------------------------------------------------------------------------------
 ^bVAL()^b
 Convert a character number to numeric type
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bVAL(<cNumber>) --> nNumber

 ^bArguments^b

     ^b<cNumber>^b is the character expression to convert.

 ^bReturns^b

     VAL() returns <cNumber> converted to a numeric value including decimal
     digits.

 ^bDescription^b

     VAL() is a character conversion function that converts a character
     string containing numeric digits to a numeric value.  When VAL() is
     executed, it evaluates <cNumber> until a second decimal point, the first
     non-numeric character, or the end of the expression is encountered.
     Leading spaces are ignored.  When SET FIXED is ON, VAL() returns the
     number of decimal places specified by SET DECIMALS, rounding <cNumber>
     if it is specified with more digits than the current DECIMALS value.  As
     with all other functions that round, digits between zero and four are
     rounded down, and digits between five and nine are rounded up.  When SET
     FIXED is OFF, VAL() returns the number of decimal places specified in
     <cNumber>.

     VAL() is the opposite of STR() and TRANSFORM() which convert numeric
     values to character strings.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate VAL() with SET FIXED ON and SET
        DECIMALS TO 2:

        SET DECIMALS TO 2
        SET FIXED ON
        //
        ? VAL("12.1234")         // Result:   12.12
        ? VAL("12.1256")         // Result:   12.13
        ? VAL("12A12")           // Result:   12
        ? VAL("A1212")           // Result:      0
        ? VAL(SPACE(0))          // Result:      0
        ? VAL(SPACE(1))          // Result:      0
        ? VAL(" 12.12")          // Result:   12.12
        ? VAL("12 .12")          // Result:   12.00

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ROUND()" c52g_002.ngo:"SET DECIMALS" c52g_002.ngo:"SET FIXED" "STR()" "TRANSFORM()" 
'------------------------------------------------------------------------------



!short: VALTYPE()       Determine the data type returned by an expression
'------------------------------------------------------------------------------
 ^bVALTYPE()^b
 Determine the data type returned by an expression
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bVALTYPE(<exp>) --> cType

 ^bArguments^b

     ^b<exp>^b is an expression of any type.

 ^bReturns^b

     VALTYPE() returns a single character representing the data type returned
     by <exp>.  VALTYPE() returns one of the following characters:

     ^bVALTYPE() Return Values^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bReturns    Meaning^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     A          Array
     B          Block
     C          Character
     D          Date
     L          Logical
     M          Memo
     N          Numeric
     O          Object
     U          NIL
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bDescription^b

     VALTYPE() is a system function that takes a single argument, evaluates
     it, and returns a one character string describing the data type of the
     return value.  It is similar to TYPE(), but differs by actually
     evaluating the specified argument and determining the type of the return
     value.  For this reason, you can determine the type of local and static
     variables, user-defined functions, and EXTEND.LIB functions.  TYPE(), by
     contrast, uses the macro operator (&) to evaluate the type of its
     argument.  Note that if the argument does not exist an error ("undefined
     error") will occur, unlike TYPE which will return "U."

 ^bExamples^b

     ^b^CFE^b  These examples show the return values for several data types:

        ? VALTYPE(1)                // Result: N
        ? VALTYPE("GOOB")           // Result: C
        ? VALTYPE(NIL)              // Result: U
        ? VALTYPE(array)            // Result: A
        ? VALTYPE(block)            // Result: B

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "TYPE()" 
'------------------------------------------------------------------------------



!short: VERSION()       Returns CA-Clipper version
'------------------------------------------------------------------------------
 ^bVERSION()^b
 Returns CA-Clipper version
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bVERSION() --> cVersion

 ^bReturns^b

     VERSION() returns the version number of the CA-Clipper library,
     EXTEND.LIB, as a character value.

 ^bDescription^b

     VERSION() is an environment function that returns the version of the
     CA-Clipper library, EXTEND.LIB.

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: 
'------------------------------------------------------------------------------



!short: WORD()*         Convert CALL command numeric parameters from double to int
'------------------------------------------------------------------------------
 ^bWORD()*^b
 Convert CALL command numeric parameters from double to int
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b


     ^bWORD(<nNumber>) --> NIL

 ^bArguments^b

     ^b<nNumber>^b is the numeric value to convert to int specified in the
     range of plus or minus 32,767, inclusive.

 ^bReturns^b

     Used as an argument for the CALL command, WORD() returns an integer.  In
     all other contexts, it returns NIL.

 ^bDescription^b

     WORD() is a numeric conversion function that converts numeric parameters
     of the CALL command from double to integer values.  WORD() is a
     compatibility command and therefore not recommended.  Both the CALL
     command and the WORD() function are superseded by facilities provided by
     the Extend System.  Refer to the Using the Extend System chapter in the
     Technical Reference guide for more information.

 ^bExamples^b

     ^b^CFE^b  This example uses WORD() as an argument of the CALL command:

        CALL Cproc WITH WORD(30000), "Some text"

 ^bFiles:^b  Library is CLIPPER.LIB.

!seealso: 
'------------------------------------------------------------------------------



!short: YEAR()          Convert a date value to the year as a numeric value
'------------------------------------------------------------------------------
 ^bYEAR()^b
 Convert a date value to the year as a numeric value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bYEAR(<dDate>) --> nYear

 ^bArguments^b

     ^b<dDate>^b is the date value to convert.

 ^bReturns^b

     YEAR() returns the year of the specified date value including the
     century digits as a four-digit numeric value.  The value returned is not
     affected by the current DATE or CENTURY format.  Specifying a null date
     (CTOD("")) returns zero.

 ^bDescription^b

     YEAR() is a date conversion function that converts a date value to a
     numeric year value.  Use it in calculations for things like periodic
     reports or for formatting date displays.

     YEAR() is a member of a group of functions that return components of a
     date value as numeric values.  The group includes DAY() and MONTH()
     which return the day and month values as numeric values.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate YEAR() using the system date:

        ? DATE()                    // Result: 09/20/90
        ? YEAR(DATE())              // Result: 1990
        ? YEAR(DATE()) + 11         // Result: 2001

     ^b^CFE^b  This example creates a user-defined function using YEAR() to
        format a date value in the form: month day, year:

        ? Mdy(DATE())               // Result: September 20, 1990

        FUNCTION Mdy( dDate )
           RETURN CMONTH(dDate) + " " + ;
                 LTRIM(STR(DAY(dDate)));
              + "," + STR(YEAR(dDate))

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DAY()" "MONTH()" 
'------------------------------------------------------------------------------



