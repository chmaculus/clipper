!short: ?|??            Display one or more values to the console
'------------------------------------------------------------------------------
 ^b?|??^b
 Display one or more values to the console
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^b? | ?? [<exp list>]

 ^bArguments^b

     ^b<exp list>^b is a list of values to display and can be any combination
     of data types, including memo.

     If you specify no argument and use the ? command, a carriage
     return/linefeed is sent to the console.  If you use the ?? command
     without arguments, nothing happens.

 ^bDescription^b

     ? and ?? are console commands that display the results of one or more
     expressions, separated by a space, to the console.  These commands are
     also command synonyms for the QOUT() and QQOUT() functions,
     respectively.

     Although functionally similar, ? and ?? differ slightly.  ? sends a
     carriage return/linefeed to the console before displaying the results of
     the expression list.  ?? displays output at the current screen cursor or
     printhead position.  This lets you use successive ?? commands to display
     output to the same line.

     A ? or ?? command locates the cursor or printhead one position to the
     right of the last character displayed.  If SET PRINTER is OFF, ROW() and
     COL() are updated to reflect the new cursor position.  If SET PRINTER is
     ON, PROW() and PCOL() are updated with the new printhead position.

     If output from a ? or ?? command reaches the edge of the screen as
     reported by MAXCOL(), it wraps to the next line.  If the output reaches
     the bottom of the screen as reported by MAXROW(), the screen scrolls up
     one line.

     You can echo output from the ? or ?? commands to the printer by
     specifying a SET PRINTER ON command before beginning output.  You can
     echo output from both of these commands to a text file using SET
     ALTERNATE TO <xcFile> to create the file, and SET ALTERNATE ON to begin
     echoing to the file.  Like other console commands, SET CONSOLE OFF
     suppresses the display to the screen without affecting output to the
     printer or text file.

     To format any expression specified, use TRANSFORM() or a user-defined
     function.  If you need to pad a variable length value for column
     alignment, use any of the PAD() functions to left-justify,
     right-justify, or center the value. See the examples below.

 ^bExamples^b

     ^b^CFE^b  This example prints a record from a database file using ? and
        ?? commands with PADR() to assure column alignment:

        LOCAL nPage := 0, nLine := 99
        USE Salesman INDEX Salesman NEW
        SET PRINTER ON
        SET CONSOLE OFF
        DO WHILE !EOF()
           IF nLine > 55
              IF nPage != 0
                 EJECT
              ENDIF
              ? PADR("Page", LTRIM(STR(nPage++)), 72)
              ?? DTOC(DATE())
              ?
              ?
              ? PADC("Sales Listing", 79)
              ?
              nLine := 5
           ENDIF
           ? Name, Address, PADR(RTRIM(City) + "," ;
                 + State, 20), ZipCode
           nLine++
           SKIP
        ENDDO
        SET CONSOLE ON
        SET PRINTER OFF
        CLOSE Salesman

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...SAY" c52g_001.ngo:"PAD()" "SET CONSOLE" "SET PRINTER" c52g_001.ngo:"TRANSFORM()" 
'------------------------------------------------------------------------------



!short: @...BOX         Draw a box on the screen
'------------------------------------------------------------------------------
 ^b@...BOX^b
 Draw a box on the screen
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^b@ <nTop>, <nLeft>, <nBottom>, <nRight>
     ^b   BOX <cBoxString> [COLOR <cColorString>]

 ^bArguments^b

     ^b<nTop>, <nLeft>, <nBottom>, <nRight>^b define the coordinates of the
     box.  @...BOX draws a box using row values from zero to MAXROW(), and
     column values from zero to MAXCOL(). If <nBottom> and <nRight> are
     larger than MAXROW() and MAXCOL(), the bottom-right corner is drawn off
     the screen.

     ^bBOX <cBoxString>^b defines a string of eight border characters and a
     fill character.  If <cBoxString> is specified as a single character,
     that character draws the whole box.

     ^bCOLOR <cColorString>^b defines the display color of the drawn box.  If
     not specified, the box is drawn using the standard color setting of the
     current system color as defined by SETCOLOR().  Note that <cColorString>
     is a character expression containing the standard color setting.  If you
     want to specify a literal color setting, enclose it within quote marks.

 ^bDescription^b

     @...BOX draws a box on the screen using configurable border and fill
     characters.  @...BOX draws the box using <cBoxString> starting from the
     upper lefthand corner, proceeding clockwise and filling the screen
     region with the ninth character.  If the ninth character is not
     specified, the screen region within the box is not painted.  Existing
     text and color remain unchanged.

     After @...BOX executes, the cursor is located in the upper corner of the
     boxed region at <nTop> + 1 and  <nLeft> + 1.  ROW() and COL() are also
     updated to reflect the new cursor position.

 ^bExamples^b

     ^b^CFE^b  These examples draw two boxes using box manifest constants
        defined in the supplied header file, Box.ch.  The first example draws
        a box using the specified characters for the border, but leaves all
        other areas of the screen intact.  The second example draws the same
        box filling the box region with space characters:

        #include "Box.ch"
        // Draw a box with a double-line top with a
        // single-line side
        @ 1, 1, 22, 79 BOX B_DOUBLE_SINGLE
        // Draw the same box filling the box region with
        // spaces
        @ 1, 1, 22, 79 BOX B_DOUBLE_SINGLE + SPACE(1)

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Box.ch.
!seealso: "@...CLEAR" "@...TO" c52g_001.ngo:"DISPBOX()" c52g_001.ngo:"SCROLL()" c52g_013.ngo:"Box characters" c52g_010.ngo:"Colors" 
'------------------------------------------------------------------------------



!short: @...CLEAR       Clear a rectangular region of the screen
'------------------------------------------------------------------------------
 ^b@...CLEAR^b
 Clear a rectangular region of the screen
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^b@ <nTop>, <nLeft> [CLEAR
     ^b   [TO <nBottom>, <nRight>]]

 ^bArguments^b

     ^b<nTop>^b and ^b<nLeft>^b define the upper left corner coordinate.

     ^bTO <nBottom>, <nRight>^b defines the lower right corner coordinates of
     the screen region to CLEAR.  If the TO clause is not specified, these
     coordinates default to MAXROW() and MAXCOL().

 ^bDescription^b

     @...CLEAR erases a rectangular region of the screen by filling the
     specified region with space characters using the current standard color
     setting.  After @...CLEAR erases the designated region, the cursor is
     located in the upper corner of the region at <nTop> + 1 and <nLeft> + 1.
     ROW() and COL() are also updated to reflect the new cursor position.

 ^bExamples^b

     ^b^CFE^b  This example erases the screen from 10, 10 to 20, 40, painting
        the region blue then displaying a box bright cyan on blue:

        SETCOLOR("BG+/B")
        @ 10, 10 CLEAR TO 20, 40
        @ 10, 10 TO 20, 40

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...BOX" "CLEAR SCREEN" c52g_001.ngo:"SCROLL()" c52g_001.ngo:"SETCOLOR()" 
'------------------------------------------------------------------------------



!short: @...GET         Create a new Get object and display it to the screen
'------------------------------------------------------------------------------
 ^b@...GET^b
 Create a new Get object and display it to the screen
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^b@ <nRow>, <nCol>
     ^b   [SAY <exp>
     ^b      [PICTURE <cSayPicture>]
     ^b      [COLOR <cColorString>]]
     ^b   GET <idVar>
     ^b      [PICTURE <cGetPicture>]
     ^b      [COLOR <cColorString>]
     ^b      [WHEN <lPreExpression>]
     ^b      [RANGE* <dnLower>, <dnUpper>] |
     ^b      [VALID <lPostExpression>]

 ^bArguments^b

     ^b<nRow>^b and ^b<nCol>^b specify the row and column coordinates for the
     operation.  If the SAY clause is present, <nRow> and <nCol> specify the
     coordinates for the SAY, and the GET is displayed to the right of the
     SAY output.  If the SAY clause is not present, <nRow> and <nCol>
     directly specify the coordinates for the GET.  In either case, output
     which extends beyond the visible extent of the display is clipped and
     does not appear.

     ^bSAY <exp>^b displays the value of <exp> at the specified coordinates.
     If you specify the PICTURE <cSayPicture> clause, <exp> is formatted
     according to the rules of SAY pictures.

     ^bGET <idVar>^b specifies the name of the variable associated with the
     GET.  <idVar> may be of any storage class (if the storage class is
     ambiguous, FIELD is assumed).  If <idVar> contains an array value, you
     must supply one or more subscripts.  The current value of <idVar> is
     displayed at the GET coordinates.  The value must be character, date,
     numeric, or logical type.  Array, NIL, code block, and null string values
     are not permitted.

     ^bPICTURE <cGetPicture>^b specifies the display format and editing rules
     for the GET.

     ^bCOLOR <cColorString>^b defines the color settings for the current Get
     object.  <cColorString> is a character expression containing one or more
     color settings.  You must specify literal color settings enclosed in
     quote marks.

     If you specify two color settings, the first determines the unselected
     color (the display color for the Get object) and the second determines
     the selected color (the color when the Get object has focus).  If you
     only specify one color, it determines both the unselected and selected
     colors for the Get object.

     On a combined @...SAY...GET command, two COLOR clauses are required to
     specify colors for both the SAY and the GET: one for the SAY, and one
     for the GET.

     ^bWHEN <lPreExpression>^b specifies an expression that must be satisfied
     before the cursor can enter the GET during a READ.  The expression can
     optionally be a code block.  The GET object is passed as a parameter to
     the code block.

     ^bVALID <lPostExpression>^b specifies an expression that must be
     satisfied before the cursor can leave the GET during a READ.  The
     expression can optionally be a code block.  The GET object is passed as
     a parameter to the code block.

     ^bRANGE* <dnLower>^b, ^b<dnUpper>^b specifies a range of allowable
     values for input to the GET.  During a READ command, if you enter a new
     GET value that does not fall within the specified range, the cursor
     cannot leave the GET.

 ^bDescription^b

     The @...GET command creates a new Get object, displays its value, and
     adds it to the array referred to by the variable GetList.  If no
     variable called GetList has been declared or created in the current
     procedure, and no PRIVATE variable called GetList exists from a previous
     procedure, the system uses the predefined PUBLIC variable GetList.  A
     subsequent READ command activates the GETs contained in the GetList
     array and allows the user to edit their contents.

     Each Get object has an associated variable, <idVar>.  The variable may
     be of any storage class, including a database field, private, public,
     local, or static variable.  If <idVar> is followed by one or more
     subscripts, the specified array element is associated with the GET.
     When the Get object is created, the <idVar> name is stored in the Get
     object, along with a code block which allows the value of <idVar> to be
     retrieved or assigned during the READ.

     The READ command performs a full-screen edit of the GETs in the GetList
     array.  As the user moves the cursor into each GET, the value of the
     associated <idVar> is retrieved by evaluating the code block saved in
     the Get object.  The value is converted to textual form and placed in a
     buffer within the Get object.  This buffer is displayed on the screen,
     and the user is allowed to edit the text from the keyboard.  When the
     user moves the cursor out of the GET, the updated buffer is converted
     back to the appropriate data type and assigned to <idVar>.

     ^bAutomatic formatting and validation:^b During a READ, some formatting
     and edit validation is automatically performed for numeric, date, and
     logical values.  As the user is typing, an automatic data type test is
     performed on each key pressed, preventing the user from entering an
     invalid character.

     ^bPrevalidation:^b The WHEN clause specifies a condition which must be
     satisfied before the cursor can enter the GET.  During a READ,
     <lPreExpression> is evaluated whenever the user attempts to move the
     cursor into the GET.  If it evaluates to true (.T.), the cursor can
     enter; otherwise, the GET is skipped.

     ^bPostvalidation:^b You may perform postvalidation using either the
     VALID or RANGE* clauses.  VALID specifies a condition which must be
     satisfied before the cursor can leave the GET.  During a READ,
     <lPostExpression> is evaluated whenever the user attempts to move the
     cursor out of the GET.  If it evaluates to true (.T.), the cursor can
     leave; otherwise, the cursor remains in the GET.  RANGE* specifies a
     range of acceptable values for numeric or date values.  If the value
     entered by the user is not within the specified range, the cursor cannot
     leave the GET.

     ^bPICTURE:^b When you specify the PICTURE clause for a GET, the
     character string specified by <cGetPicture> controls formatting and edit
     validation.  The picture string controls the display format like a SAY
     picture.  It also controls the way the user can edit the buffer.  A
     picture string consists of two distinct parts, a function string and a
     template string, either or both of which may be present.

     ^b^CFE  Function string:^b A PICTURE function string specifies
        formatting or validation rules which apply to the GET's display value
        as a whole, rather than to particular character positions within it.
        The function string consists of the @ character, followed by one or
        more additional characters, each of which has a particular meaning
        (see table below).  The function string must be the first element of
        a PICTURE clause and cannot contain spaces.  A function string may be
        specified alone or with a template string.  If both are present, the
        function string must precede the template string, and the two must be
        separated by a single space.

        ^bGET PICTURE Format Functions^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bFunc    Type Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        A       C    Allows only alphabetic characters
        B       N    Displays numbers left-justified
        C       N    Displays CR after positive numbers
        D       D,N  Displays dates in SET DATE format
        E       D,N  Displays dates with day and month inverted independent
                     of the current DATE SETting, numerics with comma and
                     period reverse (European style)
        K       ALL  Deletes default text if first key is not a cursor key
        R       C    Nontemplate characters are inserted in the display but
                     not saved in the variable
        S<n>    C    Allows horizontal scrolling within a GET.  <n> is an
                     integer that specifies the width of the region.
        X       N    Displays DB after negative numbers
        Z       N    Displays zero as blanks
        (       N    Displays negative numbers in parentheses with leading
                     spaces
        )       N    Displays negative numbers in parentheses without leading
                     spaces
        !       C    Converts alphabetic character to uppercase
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^b^CFE  Template string:^b A PICTURE template string specifies
        formatting or validation rules on a character by character basis.
        The template string consists of a series of characters, some of which
        have special meanings (see table below).  Each position in the
        template string corresponds to a position in the displayed GET value.
        Characters in the template string which do not have assigned meanings
        are copied verbatim into the displayed GET value.  If you use the @R
        picture function, these characters are inserted between characters of
        the display value, and are automatically removed when the display
        value is reassigned to <idVar>; otherwise, they overwrite the
        corresponding characters of the display value and also affect the
        value assigned to <idVar>.  You may specify a template string alone
        or with a function string.  If you use both, the function string must
        precede the template string, and the two must be separated by a
        single space.

        ^bGET PICTURE Template Symbols^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bTemplate     Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        A            Allows only alphabetic characters
        N            Allows only alphabetic and numeric characters
        X            Allows any character
        9            Allows digits for any data type including sign for
                     numerics
        #            Allows digits, signs and spaces for any data type
        L            Allows only T, F, Y or N
        Y            Allows only Y or N
        !            Converts an alphabetic character to uppercase
        $            Displays a dollar sign in place of a leading space in a
                     numeric
        *            Displays an asterisk in place of a leading space in a
                     numeric
        .            Displays a decimal point
        ,            Displays a comma
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^bSCOREBOARD:^b If a new value is rejected because it fails the RANGE*
     test or because it is a malformed date value, a message appears on the
     screen.  The message displays in the SCOREBOARD area, which you can
     enable or disable using the SET SCOREBOARD command.

     ^bExit with Esc:^b If the user exits a GET by pressing Esc, the GET
     variable is restored to the value it had on entry to the GET, and the
     READ is terminated.  No postvalidation is performed.  You can enable or
     suppress this behavior with the SET ESCAPE command.

     ^bSET KEY procedures:^b The SET KEY command lets you specify a procedure
     to be executed whenever a specific key is pressed during a READ.  After
     a SET KEY procedure terminates, the GET is reactivated with the cursor
     restored to its previous position.

     ^bLifetime of a Get object:^b Get objects, like arrays, exist as long as
     there are active references to them somewhere in the current program.
     Normally, only the array in the GetList variable maintains a reference
     to the Get object; the GET is released when GetList is released or
     reassigned.  The CLEAR and CLEAR GETS commands assign an empty array to
     GetList, as does the READ command unless you specify the SAVE clause.

     ^bAssignment:^b Each GET is associated with a variable, <idVar>, in the
     @...GET command.  At various times during the editing process, <idVar>
     may be assigned the current value of the Get object's buffer.  This
     occurs in the following instances:

     ^b^CFE^b  After the user presses an exit key and before the validation
        expression is executed

     ^b^CFE^b  After the user presses a SET KEY

     Also, the current Get object's buffer is refreshed from <idVar> and
     redisplayed at various intervals:

     ^b^CFE^b  After a SET KEY procedure terminates

     ^b^CFE^b  After a WHEN expression is evaluated

     ^b^CFE^b  After a VALID expression is evaluated

     This lets you explicitly assign <idVar> within any of these operations.
     See the note below for more information.

     ^bGET coordinates and display:^b When you create a Get object using the
     @...GET command, the row and column coordinates at which the GET is
     initially displayed are stored into the Get object.  When the @...GET
     command executes, the new GET displays at <nRow> and <nCol>, unless you
     specify the SAY clause which positions the GET so there is one display
     column between the last character of the SAY output and the first
     character of the GET (or of the DELIMITERS, see below).

     If SET DELIMITERS is ON when the @...GET command executes , the current
     DELIMITER characters display on either side of the initial GET display,
     and the column coordinate of the GET is adjusted accordingly.  Note that
     the delimiters are not attributes of the GET object, but simply display
     as the SAY clause does.

     If INTENSITY is ON, GETs initially display in the current unselected
     color (or the enhanced color, if no unselected color has been
     specified).  During a READ, the active GET displays in the enhanced
     color, while the remaining GETs display in the unselected color.  With
     INTENSITY OFF, all GETs display in the standard color.

     When a GET displays, the width of the displayed value is determined by
     the length of the value in <idVar> or, if you specify the PICTURE
     clause, by the number of positions in <cGetPicture>.  If you specify the
     @S function as a part of <cGetPicture>, the @S argument controls the
     width of the displayed value.
!seealso: "@...GET..." 
'------------------------------------------------------------------------------



!short: @...GET...      continued
'------------------------------------------------------------------------------
 ^bNotes^b

     ^b^CFE  WHEN and VALID:^b The expressions specified in the WHEN and
        VALID clauses may be of arbitrary complexity and may include calls to
        user-defined functions.  This is useful for attaching automatic
        actions to the activation or deactivation of a GET.

     ^b^CFE  Assigning <idVar>:^b Because of the automatic refresh and
        display properties of a Get object while it is being READ, you can
        make an explicit assignment to the Get object's <idVar> within a WHEN
        or VALID expression.  You can directly assign the variable by name in
        the validation expression or, for private, public, local, or static
        variables, by passing a reference to <idVar> to a function; the
        function can then assign <idVar> by assigning the corresponding
        formal parameter.  If <idVar> is a field, it is globally visible and
        can be assigned by name in a function called by the validation
        expression.

        When including a Get in a called function, do not include an <idVar>
        with the same name as a field <idVar>.  Field references have
        precedence over public variables so the public <idVar> will be
        ignored.

     ^b^CFE  GET specific help:^b You can use a SET KEY procedure to display
        help text associated with a Get object.  Within the SET KEY
        procedure, use the READVAR() function to determine the <idVar>
        associated with the current Get object.  Use this information to
        display the appropriate help text.  Remember that when a
        CA-Clipper-compiled program loads, the F1 KEY is automatically
        SET TO a procedure or user-defined function named Help.

     ^b^CFE  SET DEVICE TO PRINTER:^b SET DEVICE TO PRINTER does not direct
        display of a Get object under the @...GET command to the printer or
        file.

 ^bExamples^b

     ^b^CFE^b  This  example uses the VALID clause to validate input into a
        GET:

        LOCAL nNumber := 0
        @ 10, 10 SAY "Enter a number:" ;
           GET nNumber VALID nNumber > 0

     ^b^CFE^b  This example demostrates passing a code block with the VALID
        clause.  The parameter oGet is the current get object.  Udf() changes
        the value of the GET:

        LOCAL GetList := {}, cVar := SPACE(10)
        CLS
        @ 10, 10 GET cVar  VALID { |oGet| Udf1( oGet ) }
        READ
        .
        .
        .
        * Udf( <oGet> ) --> .T.

        FUNCTION Udf1( oGet )

        IF "test" $ oGet:BUFFER          // Compare buffer contents
        oGet:varPut( "new value " )      // Change contents
        ENDIF

        RETURN .T.

     ^b^CFE^b  This example uses the WHEN clause to prohibit entry into GETs
        based on the value of another GET.  In this example, entering Y in
        the Insured field indicates the client has insurance and the user is
        allowed to enter insurance information.  If the client does not have
        insurance, the cursor moves to the Accident field:

        @ 10, 10 GET Insured PICTURE "Y"
        @ 11, 10 GET InsNumber WHEN Insured
        @ 12, 10 GET InsCompany WHEN Insured
        @ 13, 10 GET Accident PICTURE "Y"
        READ

     ^b^CFE^b  This is an example of a GET in a secondary work area:

        USE Invoice NEW
        APPEND BLANK
        USE Inventory NEW
        @ 1, 1 GET Invoice->CustNo
        READ

     ^b^CFE^b  This example uses the @K function to suggest a default input
        value, but deletes it if the first key pressed is not a cursor key or
        Return:

        LOCAL cFile := "Accounts"
        @ 1, 1 SAY "Enter file" GET cFile PICTURE "@K"
        READ

     ^b^CFE^b  This is an example of a nested READ using GetList and lexical
        scoping:

        #include "inkey.ch"
        //
        // Local to this function only
        LOCAL GetList := {}
        LOCAL cName   := SPACE( 10 )
        //
        CLS
        SETKEY( K_F2, { || MiscInfo() } )   // Hot key to special READ
        //
        // Get object added to Getlist
        // works on local getlist
        @ 10, 10 SAY "Name" GET cName
        READ
        //
        RETURN NIL

        /***
        *  MiscInfo() ---> NIL
        */
        FUNCTION MiscInfo()
        //
        LOCAL GetList    := {}               // Local to this
        LOCAL cExtraInfo := SPACE( 30 )      // function only
        //
        // Get object added to getlist
        // works on local getlist
        @ 12, 10 SAY "Note: " GET cExtraInfo
        READ
        //
        RETURN NIL

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...SAY" c52g_001.ngo:"COL()" "READ" c52g_001.ngo:"SETCOLOR()" c52g_011.ngo:"Picture codes" c52g_010.ngo:"Colors" 
'------------------------------------------------------------------------------



!short: @...PROMPT      Paint a menu item and define a message
'------------------------------------------------------------------------------
 ^b@...PROMPT^b
 Paint a menu item and define a message
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^b@ <nRow>, <nCol> PROMPT <cMenuItem>
     ^b   [MESSAGE <cExpression>]

 ^bArguments^b

     ^b<nRow>^b and ^b<nCol>^b are the row and column coordinates of the menu
     item display.  Row values can range from zero to MAXROW(), and column
     values can range from zero to MAXCOL().

     ^bPROMPT <cMenuItem>^b is the menu item string to display.

     ^bMESSAGE <cExpression>^b defines the message to display each time the
     current menu item is highlighted.  A code block evaluating to a
     character expression may optionally be used.

 ^bDescription^b

     @...PROMPT is the display portion of the CA-Clipper lightbar menu
     system.  Each @...PROMPT command paints a menu item in the current
     standard color and defines an associated MESSAGE to be displayed on the
     line specified by SET MESSAGE.  The lightbar menu is then invoked with
     MENU TO.  You can specify menu items in any order and configuration of
     row and column position.  MENU TO, however, navigates the current list
     of menu items in the order they were defined. You can define up to 4096
     menu items for each menu.

     After each @...PROMPT command, the cursor is located one column position
     to the right of the last menu item character and ROW() and COL() are
     updated to reflect the new cursor position.  This lets you use ROW() and
     COL() to specify consecutive menu item positions relative to the first
     one painted.  See the example below.

 ^bExamples^b

     ^b^CFE^b  This example displays a lightbar menu with the associated
        messages displayed on the next line.  When the user presses Return,
        the position of the item in the list of menu items is assigned to
        nChoice:

        LOCAL nChoice := 1
        SET WRAP ON
        SET MESSAGE TO 2
        @ 1, 3 PROMPT "File" MESSAGE "Access data files"
        @ ROW(), COL() + 2 PROMPT "Edit" ;
           MESSAGE "Edit current record"
        MENU TO nChoice

     ^b^CFE^b  This example shows how to pass the MESSAGE clause a code block
        which calls a user-defined function that displays a message in a
        different color:

        SET COLOR TO gr+/b,r+/n
        SET MESSAGE TO 23       // This is necessary.
        CLEAR SCREEN

        @ 3,4 PROMPT "one "  MESSAGE {||UDF("Message One  ")}
        @ 4,4 PROMPT "two "  MESSAGE {||UDF("Message Two  ")}
        @ 5,4 PROMPT "three" MESSAGE {||UDF("Message Three")}

        MENU TO test

        FUNCTION UDF(cParm)
        cOldColor := SETCOLOR("w+/n")
        @ 22,1 SAY cParm        // Must be different row than the
                                // SET MESSAGE TO nRow
        SETCOLOR(cOldColor)
        RETURN ""               // Character string must be returned

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"ACHOICE()" "MENU TO" "SET MESSAGE" "SET WRAP" c52g_001.ngo:"SETCOLOR()" 
'------------------------------------------------------------------------------



!short: @...SAY         Display data at a specified screen or printer row and column
'------------------------------------------------------------------------------
 ^b@...SAY^b
 Display data at a specified screen or printer row and column
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^b@ <nRow>, <nCol>
     ^b   SAY <exp> [PICTURE <cSayPicture>]
     ^b   [COLOR <cColorString>]

 ^bArguments^b

     ^b<nRow>^b and ^b<nCol>^b are the row and column coordinates of the
     display.  Row values can range from zero to a maximum of MAXROW() if the
     current DEVICE is the SCREEN or 32,766 if the current DEVICE is the
     PRINTER.  Also, column values can range from zero to a maximum of
     MAXCOL() or 32,766 if the current DEVICE is the PRINTER.

     ^bSAY <exp>^b displays the result of a character, date, logical, or
     numeric expression to the current DEVICE.

     ^bPICTURE <cSayPicture>^b defines the formatting control for the display
     of <exp>.  CA-Clipper provides two mechanisms, functions and templates,
     to control formatting.  Functions apply to an entire SAY, while
     templates format characters position by position.

     ^bCOLOR <cColorString>^b defines the display color of <exp>.  If not
     specified, <exp> displays in the standard color as defined by
     SETCOLOR().  <cColorString> is a character expression containing the
     standard color setting.  If you specify a literal color setting, it must
     be enclosed in quote marks.

     On a combined @...SAY...GET command, two COLOR clauses are required to
     specify colors for both the SAY and the GET: one for the SAY and one for
     the GET.

 ^bDescription^b

     @...SAY is a full-screen command that outputs the results of <exp> to
     either the screen or the printer at the specified row and column
     coordinates.  It can optionally format output using the PICTURE clause.
     @...SAY creates data entry screens or reports that can be sent to the
     screen or printer.

     When an @...SAY command executes , the output from <exp> is sent to the
     current device defined with SET DEVICE.  The current DEVICE can be the
     SCREEN or PRINTER.  Unlike console commands, @...SAY output to the
     printer is not echoed to the screen and SET CONSOLE has no effect on
     @...SAY output to the screen.

     If the current DEVICE is the SCREEN (the system default), @...SAY
     displays output to the screen leaving the cursor one column position to
     the right of the last character displayed.  ROW() and COL() are then
     updated with this position.  Output that displays off the screen, as
     defined by MAXROW() and MAXCOL(), is clipped and the cursor is
     positioned beyond the visible screen.  All @...SAY output displays are
     in standard color.  Refer to the SETCOLOR() reference in this chapter
     for more information on color.

     If the current DEVICE is set to PRINTER, the display is directed to the
     printer at the specified <nRow> and <nCol> position.  If current MARGIN
     value is greater than zero, it is added to <nCol> first.  The printhead
     is then advanced one column position to the right of the last character
     output and PROW() and PCOL() are updated.  @...SAY commands to the
     printer behave differently than to the screen if output is addressed to
     a printer row or column position less than the current PROW() and PCOL()
     values.

     ^b^CFE^b  If <nRow> is less than PROW(), an automatic EJECT (CHR(12)) is
        sent to the printer followed by the number of linefeed characters
        (CHR(10)) required to position the printhead on <nRow> on the
        following page.

     ^b^CFE^b  If <nCol> including the SET MARGIN value is less than PCOL(),
        a carriage return character (CHR(13)) and the number of spaces
        required to position <exp> at <nCol> are sent to the printer.

     To override this behavior and send control codes to the printer, or for
     any other reason, you can use SETPRC() to reset PROW() and PCOL() to new
     values.  See the SETPRC() function reference  for more information.

     If the current DEVICE is the PRINTER, redirect output from @...SAY
     commands to a file using the SET PRINTER TO <xcFile> command.

     @...SAY command output can be formatted using the PICTURE clause with a
     <cSayPicture>.  This performs the same action as the TRANSFORM()
     function.  A <cSayPicture> may consist of a function and/or a template.
     A PICTURE function imposes a rule on the entire @...SAY output.  A
     PICTURE template defines the length of the @...SAY output and the
     formatting rule for each position within the output.

     ^b^CFE  Function string^b: A PICTURE function string specifies
        formatting rules which apply to the SAY's entire display value,
        rather than to particular character positions within it.  The
        function string consists of the @ character, followed by one or more
        additional characters, each of which has a particular meaning (see
        table below).  The function string must not contain spaces.  A
        function string may be specified alone or with a template string.  If
        both are present, the function string must precede the template
        string, and the two must be separated by a single space.

        ^bSAY and TRANSFORM() PICTURE Format Functions^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bFunction     Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        B            Displays numbers left-justified
        C            Displays CR after positive numbers
        D            Displays dates in SET DATE format
        E            Displays dates and numbers in British format
        R            Nontemplate characters are inserted
        X            Displays DB after negative numbers
        Z            Displays zeros as blanks
        (            Encloses negative numbers in parentheses
        !            Converts alphabetic characters to uppercase
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^b^CFE  Template string:^b A PICTURE template string specifies
        formatting rules on a character-by-character basis. The template
        string consists of a series of characters, some of which have special
        meanings (see table below).  Each position in the template string
        corresponds to a position in the displayed SAY value.  Characters in
        the template string which do not have assigned meanings are copied
        verbatim into the displayed SAY value.  If you use the @R picture
        function, characters without special PICTURE template string meaning
        are inserted between characters of the display value; otherwise, they
        overwrite the corresponding characters of the display value.  You may
        specify a template string alone or with a function string.  If both
        are present, the function string must precede the template string,
        and the two must be separated by a single space.

        ^bSAY and TRANSFORM() Template Symbols^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bTemplate     Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        A,N,X,9,#    Displays digits for any data type
        L            Displays logicals as "T" or "F"
        Y            Displays logicals as "Y" or "N"
        !            Converts alphabetic characters to uppercase
        $            Display a dollar sign in place of a leading space in a
                     number
        *            Display an asterisk in place of a leading space in a
                     number
        .            Specifies a decimal point position
        ,            Specifies a comma position
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bExamples^b

     ^b^CFE^b  This example uses an @...SAY with a PICTURE clause to display
        formatted output:

        nNetIncome = 7125.50
        nNetLoss = -125.50
        cPhone = "2134567890"
        cName = "Kate Mystic"
        //
        @ 1, 1 SAY nNetIncome PICTURE "@E 9,999.99"
        // Result: .125,50

        @ 2, 1 SAY nNetLoss PICTURE "@)"
        // Result: (125.50)

        @ 3, 1 SAY cPhone PICTURE "@R (999)999-9999"
        // Result: (213)456-7890

        @ 4, 1 SAY cName PICTURE "@!"
        // Result: KATE MYSTIC

     ^b^CFE^b  This example is a small label printing program that uses SET
        DEVICE to direct output to the printer and SETPRC() to suppress
        automatic EJECTs:

        USE Salesman INDEX Salesman NEW
        SET DEVICE TO PRINTER
        DO WHILE !EOF()                  // Print all records
           @ 2, 5 SAY RTRIM(FirstName) + ", " + LastName
           @ 3, 5 SAY Street
           @ 4, 5 SAY RTRIM(City) + ", " + State + "  " + ;
                    PostalCode
           @ 6, 0 SAY SPACE(1)           // Move to label bottom
           SETPRC(0, 0)                  // Suppress page eject
           SKIP                          // Next record
        ENDDO
        SET DEVICE TO SCREEN
        CLOSE Salesman

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...GET" c52g_001.ngo:"COL()" "SET DEVICE" c52g_011.ngo:"Picture codes" c52g_010.ngo:"Colors" 
'------------------------------------------------------------------------------



!short: @...TO          Draw a single or double-line box
'------------------------------------------------------------------------------
 ^b@...TO^b
 Draw a single or double-line box
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^b@ <nTop>, <nLeft>
     ^b   TO <nBottom>, <nRight> [DOUBLE] [COLOR
     ^b      <cColorString>]

 ^bArguments^b

     ^b<nTop>, <nLeft>, <nBottom>^b, and ^b<nRight>^b define the coordinates
     of the box.  @...TO draws the box using row values from zero to MAXROW()
     and column values from zero to MAXCOL(). <nBottom> and <nRight> can be
     larger than the screen size but output is clipped at MAXROW() and
     MAXCOL().

     ^bDOUBLE^b draws the box with a double line.  If not specified, the box
     is drawn with a single line.

     ^bCOLOR <cColorString>^b defines the display color of the drawn box.  If
     not specified, the box is drawn using the standard color setting of the
     current system color as defined by SETCOLOR(). Note that <cColorString>
     is a character expression containing the standard color setting.  If you
     specify a literal color setting, enclose it within quote marks.

 ^bDescription^b

     @...TO draws a single or double-line box on the screen.  If <nTop> and
     <nBottom> are the same, a horizontal line is drawn. If <nLeft> and
     <nRight> are the same, a vertical line is drawn.

     After @...TO finishes drawing, the cursor is located in the upper left
     corner of the boxed region at <nTop> + 1 and <nLeft> + 1.  ROW() and
     COL() are also updated to reflect the new cursor position.

     @...TO is like @...BOX except that @...BOX lets you define the
     characters of the box and supports a fill character.  @...TO, however,
     is recommended for portability since it does not require the
     specification of hardware-dependent graphics characters.

 ^bExamples^b

     ^b^CFE^b  This example erases a region of the screen, then draws a box
        of the same size:

        @ 10, 10 CLEAR TO 20, 40
        @ 10, 10 TO 20, 40 DOUBLE COLOR "BG+/B"

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...BOX" "@...CLEAR" c52g_001.ngo:"DISPBOX()" c52g_010.ngo:"Colors" 
'------------------------------------------------------------------------------



!short: ACCEPT          Place keyboard input into a memory variable
'------------------------------------------------------------------------------
 ^bACCEPT^b
 Place keyboard input into a memory variable
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bACCEPT [<expPrompt>] TO <idVar>

 ^bArguments^b

     ^b<expPrompt>^b is an optional prompt displayed before the input area.
     The prompt can be an expression of any data type.

     ^b<idVar>^b is the variable that will hold input from the keyboard.  If
     the specified <idVar> does not exist or is not visible, a private
     variable is created.

 ^bDescription^b

     ACCEPT is a console command and wait state that takes input from the
     keyboard and assigns it as a character string to the specified variable.
     When ACCEPT is executed, it first performs a carriage return/linefeed,
     displays the prompt, and then begins taking characters from the keyboard
     at the first character position following the prompt.  You may input up
     to 255 characters.  When input reaches the edge of the screen, as
     defined by MAXCOL(), the cursor moves to the next line.

     ACCEPT supports only two editing keys: Backspace and Return.  Esc is not
     supported.  Backspace deletes the last character typed.  Return confirms
     entry and is the only key that can terminate an ACCEPT.  If Return is
     the only key pressed, ACCEPT assigns a null value ("") to <idVar>.

 ^bExamples^b

     ^b^CFE^b  This example uses ACCEPT to get keyboard input from the user:

        LOCAL cVar
        ACCEPT "Enter a value: " TO cVar
        IF cVar == ""
           ? "User pressed Return"
        ELSE
           ? "User input:", cVar
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...GET" "@...SAY" c52g_001.ngo:"INKEY()" "INPUT" "KEYBOARD" "WAIT*" 
'------------------------------------------------------------------------------



!short: APPEND BLANK    Add a new record to the current database file
'------------------------------------------------------------------------------
 ^bAPPEND BLANK^b
 Add a new record to the current database file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bAPPEND BLANK

 ^bDescription^b

     APPEND BLANK is a database command that adds a new record to the end of
     the current database file and then makes it the current record.  The new
     field values are initialized to the empty values for each data type:
     character fields are assigned with spaces; numeric fields are assigned
     zero; logical fields are assigned false (.F.); date fields are assigned
     CTOD(""); and memo fields are left empty.

     If operating under a network with the current database file shared,
     APPEND BLANK attempts to add and then lock a new record.  If another
     user has locked the database file with FLOCK() or locked LASTREC() + 1
     with RLOCK(), NETERR() returns true (.T.).  Note that a newly APPENDed
     record remains locked until you lock another record or perform an
     UNLOCK.  APPEND BLANK does not release an FLOCK() set by the current
     user.

 ^bExamples^b

     ^b^CFE^b  This example attempts to add a record to a shared database
        file and uses NETERR() to test whether the operation succeeded:

        USE Sales SHARED NEW
        .
        . <statements>
        .
        APPEND BLANK
        IF !NETERR()
           <update empty record>...
        ELSE
           ? "Append operation failed"
           BREAK
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "APPEND FROM" c52g_001.ngo:"FLOCK()" c52g_001.ngo:"NETERR()" c52g_001.ngo:"RLOCK()" 
'------------------------------------------------------------------------------



!short: APPEND FROM     Import records from a (.dbf) or ASCII file
'------------------------------------------------------------------------------
 ^bAPPEND FROM^b
 Import records from a (.dbf) or ASCII file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bAPPEND FROM <xcFile>
     ^b   [FIELDS <idField list>]
     ^b   [<scope>] [WHILE <lCondition>] [FOR <lCondition>]
     ^b   [SDF | DELIMITED [WITH BLANK | <xcDelimiter>]]

 ^bArguments^b

     ^bFROM <xcFile>^b specifies the name of the source file.  You can
     specify <xcFile> either as a literal filename or as a character
     expression enclosed in parentheses.  If a file extension  is not
     specified, (.dbf) is the default input file type.  If SDF or DELIMITED
     is specified, the file extension is assumed to be (.txt) unless
     otherwise specified.

     ^bFIELDS <idField list>^b specifies the list of fields to copy from
     <xcFile>.  The default is all fields.

     ^b<scope>^b is the portion of the source database file to APPEND FROM.
     NEXT <n> APPENDs the first <n> records.  RECORD <n> APPENDs only record
     number <n> from <xcFile>.  The default scope is ALL records in <xcFile>.

     ^bWHILE <lCondition>^b specifies the set of records meeting the
     condition from the first record in the source file until the condition
     fails.

     ^bFOR <lCondition>^b specifies the conditional set of records to APPEND
     FROM within the given scope.

     ^bSDF^b identifies a System Data Format ASCII file.  Records and fields
     are fixed length.

     ^bDELIMITED^b identifies an ASCII text file, where character fields are
     enclosed in double quote marks (the default delimiter).  Note that
     delimiters are not required and CA-Clipper correctly APPENDs character
     fields not enclosed in them.  Fields and records are variable length.

     ^bDELIMITED WITH BLANK^b identifies an ASCII text file in which fields
     are separated by one space and character fields are not enclosed in
     delimiters.

     ^bDELIMITED WITH <xcDelimiter>^b identifies a delimited ASCII text file,
     where character fields are enclosed using the specified delimiter.  you
     can specify <xcDelimiter> as a literal character or as a character
     expression enclosed in parentheses.

     See the tables below for more information regarding the format
     specification requirements for ASCII text files that you want to APPEND
     using these arguments.

     ^bWarning! ^b If the DELIMITED WITH clause is specified on a COPY TO or
     APPEND FROM command line, it must be the last clause specified.

 ^bDescription^b

     APPEND FROM adds records to the current database file from an ASCII text
     file or another database file.  Only fields with the same names and
     types are APPENDed.  Fields with the same name from both the current
     database file and <xcFile> must be the same data type.  If they are not,
     a runtime error occurs when the APPEND FROM command is invoked.

     Any date information in <xcFile> must be in the format yyyymmdd to be
     properly APPENDed.

     In a network environment, APPEND FROM does not require that the current
     database file be USEed EXCLUSIVEly or locked with FLOCK() to perform its
     operation.  As each record is added, CA-Clipper automatically arbitrates
     contention for the new record.

     When you invoke APPEND FROM, CA-Clipper attempts to open <xcFile> shared
     and read-only.  If access is denied, APPEND FROM terminates with a
     runtime error.  Refer to the Network Programming chapter in the
     Programming and Utilities guide for more information.  No error is
     raised if you attempt to open a (.dbf) file that is already open.

     This table shows the format specifications for SDF text files.

     ^bSDF Text File Format Specifications^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bFile Element        Format^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Character fields    Padded with trailing blanks
     Date fields         yyyymmdd
     Logical fields      T or F
     Memo fields         Ignored
     Numeric fields      Padded with leading blanks or zeros
     Field separator     None
     Record separator    Carriage return/linefeed
     End of file marker  1A hex or CHR(26)
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     This table shows the format specifications for DELIMITED and DELIMITED
     WITH <xcDelimiter> ASCII text files.

     ^bDELIMITED Text File Format Specifications^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bFile Element        Format^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Character fields    May be delimited, with trailing blanks truncated
     Date fields         yyyymmdd
     Logical fields      T or F
     Memo fields         Ignored
     Numeric fields      Leading zeros may be truncated
     Field separator     Comma
     Record separator    Carriage return/linefeed
     End of file marker  1A hex or CHR(26)
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     This table shows the format specifications for DELIMITED WITH BLANK
     ASCII text files.

     ^bDELIMITED WITH BLANK Text File Format Specifications^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bFile Element        Format^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Character fields    Not delimited, trailing blanks may be truncated
     Date fields         yyyymmdd
     Logical fields      T or F
     Memo fields         Ignored
     Numeric fields      Leading zeros may be truncated
     Field separator     Single blank space
     Record separator    Carriage return/linefeed
     End of file marker  1A hex or CHR(26)
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bNotes^b

     ^b^CFE  Deleted records:^b If DELETED is OFF, deleted records in
        <xcFile> are APPENDed to  the current database file and retain their
        deleted status.  If DELETED is ON, however, none of the deleted
        <xcFile> records is APPENDed.

     ^b^CFE  Unmatched field widths:^b If a field in the current database
        file is character type and has a field length greater than the
        incoming <xcFile> data, CA-Clipper pads the <xcFile> data with
        blanks.  If the current field is character data type and its field
        length is less than the incoming <xcFile> data, the <xcFile> data is
        truncated to fit.  If the current field is numeric type and the
        incoming <xcFile> data has more digits than the current field length,
        a runtime error occurs.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates an APPEND FROM command using a
        fields list and a condition:

        USE Sales NEW
        APPEND FROM BranchFile FIELDS Branch, Salesman, Amount;
           FOR Branch = 100

     ^b^CFE^b  This example demonstrates how a <scope> can be specified to
        import a particular record from another database file:

        APPEND RECORD 5 FROM Temp

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "COPY TO" 
'------------------------------------------------------------------------------



!short: AVERAGE         Average numeric expressions in the current work area
'------------------------------------------------------------------------------
 ^bAVERAGE^b
 Average numeric expressions in the current work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bAVERAGE <nExp list> TO <idVar list>
     ^b   [<scope>] [WHILE <lCondition>] [FOR <lCondition>]

 ^bArguments^b

     ^b<nExp list>^b is a list of the numeric values to AVERAGE for each
     record processed.

     ^bTO <idVar list>^b identifies a list of receiving variables which will
     contain the average results.  Variables that either do not exist or are
     not visible are created as private variables.  <idVar list> must contain
     the same number of elements as <nExp list>.

     ^b<scope>^b defines the portion of the current database file to AVERAGE.
     The default scope is ALL.

     ^bWHILE <lCondition>^b specifies the set of records meeting the
     condition from the current record until the condition fails.

     ^bFOR <lCondition>^b specifies the conditional set of records to AVERAGE
     within the given scope.

 ^bDescription^b

     AVERAGE calculates the average of one or more numeric expressions to
     variables for a range of records in the current database file.  Zero
     values are counted in the AVERAGE unless explicitly ruled out with a FOR
     condition.

 ^bExamples^b

     ^b^CFE^b  This example averages a single numeric field using a condition
        to select a subset of records from the database file:

        USE Sales NEW
        AVERAGE Amount TO nAvgAmount FOR Branch = "100"

     ^b^CFE^b  This example finds the average date for a range of dates:

        AVERAGE (SaleDate - CTOD("00/00/00")) ;
           TO nAvgDays FOR !EMPTY(SaleDate)
           dAvgDate := CTOD("00/00/00") + nAvgDays

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"DBEVAL()" "SUM" "TOTAL" 
'------------------------------------------------------------------------------



!short: CALL*           Execute a C or Assembler procedure
'------------------------------------------------------------------------------
 ^bCALL*^b
 Execute a C or Assembler procedure
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCALL <idProcedure> [WITH <exp list>]

 ^bArguments^b

     ^b<idProcedure>^b is the name of the external procedure to CALL.

     ^bWITH <exp list>^b is an optional list of up to seven expressions of
     any data type to pass to the external procedure.

 ^bDescription^b

     CALL executes a separately compiled or assembled procedure.  The
     procedure must be defined as FAR and end with a FAR return instruction.
     Place parameters on the stack using the C parameter passing convention.
     Each parameter consists of a FAR (four-byte) pointer to the actual
     parameter value.  When necessary you may use the WORD() function to pass
     a two-byte binary value in the WITH expression.  The DX:BX and ES:BX
     registers also contain a copy of the first four bytes of parameter
     information.

     The procedure must preserve the BP, SS, SI, DI, ES, and DS registers as
     well as clear the direction flag.

     CALL is a compatibility command and therefore not recommended.  It is
     superseded by the Extend System which provides functions for passing
     data to and from CA-Clipper.

 ^bNotes^b

     ^b^CFE  Character strings:^b Pass a character argument as a FAR pointer
        to a null-terminated string (a string with a 00 hex byte at the end).

     ^b^CFE  Numeric values:^b Pass each numeric argument as a FAR pointer to
        an eight-byte IEEE floating point value.  To pass a parameter as an
        integer, use the WORD() function.  The WORD() function converts the
        numeric value to a two-byte binary integer, and passes the integer
        value directly rather than through a pointer.  Note that WORD() will
        not work for values outside of the 32,767 range since these values
        cannot be accurately represented as two-byte integers.

     ^b^CFE  Date values:^b Pass each date argument as a FAR pointer to a
        four-byte (long) integer containing a Julian day number.

     ^b^CFE  Logical values:^b Pass each logical argument as a FAR pointer to
        a two-byte binary integer containing either zero or one for true
        (.T.) or false (.F.), respectively.

     ^b^CFE  Compiling and linking:^b CALLed programs must conform to the
        following rules:

        ^b-^b  Procedures must be in INTEL 8086 relocatable object file
           format with the .OBJ file extension.

        ^b-^b  Procedures must follow the C calling and parameter passing
           conventions.

        ^b-^b  Procedures must be available to the linker at link time, along
           with the library of the source compiler.  You will need runtime
           support for any language other than assembly language.  See your
           compiler manual for further information.

     ^b^CFE  Microsoft C:^b Microsoft C versions 5.0 and above place a
        leading underscore on function names when they are compiled.  To call
        them, therefore, you must CALL _<function>.

     ^b^CFE  dBASE III PLUS:^b To convert a dBASE III PLUS load module to a
        CA-Clipper-compatible module, add the following statements to your
        .ASM file:

        PUBLIC <proc>

        and

        push ds
        mov ds, dx

     ^bWarning! ^b Modifying the parameter values may produce incorrect or
     unexpected results and, therefore, is strongly discouraged.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"WORD()*" 
'------------------------------------------------------------------------------



!short: CANCEL*         Terminate program processing
'------------------------------------------------------------------------------
 ^bCANCEL*^b
 Terminate program processing
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCANCEL* | QUIT

 ^bDescription^b

     CANCEL and QUIT both terminate the current program, closing all open
     files, and returning control to the operating system.  You can use
     either command from anywhere in a CA-Clipper program system.  A RETURN
     executed at the highest level procedure, performs the same action.

 ^bNotes^b

     ^b^CFE  Return code:^b When a CA-Clipper program terminates, the return
        code is set to 1 if the process ends with a fatal error.  If the
        process ends normally, the return code is set to 0 or the last
        ERRORLEVEL() set in the program.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"ERRORLEVEL()" "QUIT" c52g_004.ngo:"RETURN" 
'------------------------------------------------------------------------------



!short: CLEAR ALL*      Close files and release public and private variables
'------------------------------------------------------------------------------
 ^bCLEAR ALL*^b
 Close files and release public and private variables
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCLEAR ALL

 ^bDescription^b

     CLEAR ALL releases all public and private variables, closes all open
     databases and related files in all active work areas, and SELECTs work
     area 1.  Related files are index, alternate, and memo files.  CLEAR ALL,
     however, does not release local or static variables.

     CLEAR ALL is a compatibility command and not recommended.  Its usage in
     CA-Clipper is superseded by the command or function that performs the
     specific action you need.  You can close files associated with work
     areas with one of the various forms of the CLOSE command.  You can
     release private and public variables using the RELEASE command although
     explicitly releasing variables is discouraged in most instances.  For
     more information on the scope and lifetime of variables, refer to the
     Basic Concepts chapter in the Programming and Utilities guide.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CLEAR GETS" "CLEAR MEMORY" "CLOSE" "RELEASE" 
'------------------------------------------------------------------------------



!short: CLEAR GETS      Release Get objects from the current GetList array
'------------------------------------------------------------------------------
 ^bCLEAR GETS^b
 Release Get objects from the current GetList array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCLEAR GETS

 ^bDescription^b

     CLEAR GETS explicitly releases all Get objects in the current and
     visible GetList array, and terminates the calling READ, releasing any
     remaining objects in the calling READ, if executed within a SET KEY
     procedure or a user-defined function invoked by a VALID clause.  CLEAR
     GETS releases Get objects by assigning an empty array to the variable
     GetList.  GetList is the name of the variable used to hold an array of
     Get objects for subsequent READ commands.  There are two other
     mechanisms that automatically release Get objects: CLEAR specified
     without the SCREEN clause, and READ specified without the SAVE clause.

     CLEAR GETS has two basic uses.  First, it can be used to terminate a
     READ from a SET KEY procedure or VALID user-defined function.  Second,
     it can be used to delete Get objects from the GetList array when you
     haven't executed a READ or you have saved the Get objects by using READ
     SAVE.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...CLEAR" "@...GET" "CLOSE" "READ" "RELEASE" "SET TYPEAHEAD" 
'------------------------------------------------------------------------------



!short: CLEAR MEMORY    Release all public and private variables
'------------------------------------------------------------------------------
 ^bCLEAR MEMORY^b
 Release all public and private variables
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCLEAR MEMORY

 ^bDescription^b

     CLEAR MEMORY deletes both public and private memory variables from the
     memory variable table.  It operates in contrast to RELEASE ALL which
     does not actually delete public and private memory variables, but
     assigns NIL to those whose scope is the current procedure.  CLEAR MEMORY
     is the only way to delete all public memory variables from current
     memory.  Local and static variables, however, are unaffected by CLEAR
     MEMORY.

     For more information on variables, refer to the Variables section of the
     Basic Concepts chapter in the Programming and Utilities guide.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "RELEASE" 
'------------------------------------------------------------------------------



!short: CLEAR SCREEN    Clear the screen and home the cursor
'------------------------------------------------------------------------------
 ^bCLEAR SCREEN^b
 Clear the screen and home the cursor
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCLEAR [SCREEN] | CLS

 ^bArguments^b

     ^bSCREEN^b suppresses the automatic releasing of Get objects from the
     current and visible GetList array when the screen is CLEARed.

 ^bDescription^b

     CLEAR is a full-screen command that erases the screen, releases pending
     GETs, and positions the cursor at row and column zero.  If the SCREEN
     clause is specified, Get objects are not released.

     CLS is a synonym for CLEAR SCREEN.

 ^bNotes^b

     ^b^CFE  SET KEY and VALID:^b If you are editing GETs, executing a CLEAR
        within a SET KEY procedure or within a VALID user-defined function
        will abort the active READ when control returns.  To clear the screen
        without CLEARing GETs, use either the CLEAR SCREEN or CLS commands.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...CLEAR" "CLEAR GETS" c52g_001.ngo:"SCROLL()" 
'------------------------------------------------------------------------------



!short: CLEAR TYPEAHEAD Empty the keyboard buffer
'------------------------------------------------------------------------------
 ^bCLEAR TYPEAHEAD^b
 Empty the keyboard buffer
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCLEAR TYPEAHEAD

 ^bDescription^b

     CLEAR TYPEAHEAD is a keyboard command that clears all pending keys from
     the CA-Clipper keyboard buffer.  This is useful in user interface
     procedures or user-defined functions to guarantee that keys processed
     from the keyboard buffer are appropriate to the current activity and not
     pending from a previous activity.  User functions called by ACHOICE()
     and DBEDIT() are especially sensitive to such keys.

     Note that both the SET TYPEAHEAD and KEYBOARD commands also clear the
     keyboard buffer.

 ^bExamples^b

     ^b^CFE^b  This example empties the keyboard buffer before invoking
        DBEDIT(), guaranteeing that any pending keys will not be executed:

        CLEAR TYPEAHEAD
        DBEDIT()

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "KEYBOARD" "SET TYPEAHEAD" 
'------------------------------------------------------------------------------



!short: CLOSE           Close a specific set of files
'------------------------------------------------------------------------------
 ^bCLOSE^b
 Close a specific set of files
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCLOSE [<idAlias> | ALL | ALTERNATE | DATABASES |
     ^b   FORMAT |INDEXES]

 ^bArguments^b

     ^b<idAlias>^b specifies the work area where all files are CLOSEd.

     ^bALL^b CLOSEs alternate, database, and index files in all work areas,
     releasing all active filters, relations, and format definitions.

     ^bALTERNATE^b CLOSEs the currently open alternate file, performing the
     same action as SET ALTERNATE TO with no argument.

     ^bDATABASES^b CLOSEs all open databases, memo and associated index files
     in all work areas, and releases all active filters and relations.  It
     does not, however, have any effect on the active format.

     ^bFORMAT^b releases the current format, performing the same action as
     SET FORMAT TO with no argument.

     ^bINDEXES^b CLOSEs all index files open in the current work area.

 ^bDescription^b

     CLOSE is a general purpose command that closes various types of
     CA-Clipper files depending on the specified option.  CLOSE with no
     option closes the current database and associated files, the same as USE
     with no arguments.

     In CA-Clipper, a number of other commands also CLOSE files including:

     ^b^CFE^b  QUIT

     ^b^CFE^b  CANCEL*

     ^b^CFE^b  RETURN from the highest level procedure

     ^b^CFE^b  CLEAR ALL*

     ^b^CFE^b  USE with no argument

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "QUIT" c52g_004.ngo:"RETURN" "SET ALTERNATE" "SET INDEX" "USE" 
'------------------------------------------------------------------------------



!short: COMMIT          Perform a solid-disk write for all active work areas
'------------------------------------------------------------------------------
 ^bCOMMIT^b
 Perform a solid-disk write for all active work areas
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCOMMIT

 ^bDescription^b

     COMMIT is a database command that flushes CA-Clipper buffers and
     performs a solid-disk write for all work areas with open database and
     index files.  The solid-disk write capability is available under DOS
     version 3.3 and above.  Under DOS 3.2 or less, COMMIT flushes CA-Clipper
     buffers to DOS.

     In a network environment, issuing a GO TO RECNO() or a SKIP0 will flush
     CA-Clipper's database and index buffers, but only a COMMIT will flush
     the buffers and perform a solid-disk write.  Thus to insure updates are
     visible to other processes, you must issue a COMMIT after all database
     update commands (e.g., APPEND, REPLACE).  To insure data integrity,
     COMMIT should be issued before an UNLOCK operation.  Refer to the
     Network Programming chapter in the Programming and Utilities guide for
     more information on update visibility.

 ^bNotes^b

     ^b^CFE^b  COMMIT uses DOS interrupt 21h function 68h to perform the
        solid-disk write.  It is up to the network operating system to
        properly implement this request.  Check with the network vendor to
        see if this is supported.

 ^bExamples^b

     ^b^CFE^b  In this example, COMMIT forces a write to disk after a series
        of memory variables are assigned to field variables:

        USE Sales EXCLUSIVE NEW
        MEMVAR->Name := Sales->Name
        MEMVAR->Amount := Sales->Amount
        //
        @ 10, 10 GET MEMVAR->Name
        @ 11, 10 GET MEMVAR->Amount
        READ
        //
        IF UPDATED()
           APPEND BLANK
           REPLACE Sales->Name WITH MEMVAR->Name
           REPLACE Sales->Amount WITH MEMVAR->Amount
           COMMIT
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"DBCOMMIT()" c52g_001.ngo:"DBCOMMITALL()" "GO" "SKIP" 
'------------------------------------------------------------------------------



!short: CONTINUE        Resume a pending LOCATE
'------------------------------------------------------------------------------
 ^bCONTINUE^b
 Resume a pending LOCATE
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCONTINUE

 ^bDescription^b

     CONTINUE is a database command that searches from the current record
     position for the next record meeting the most recent LOCATE condition
     executed in the current work area.  It terminates when a match is found
     or end of file is encountered.  If CONTINUE is successful, the matching
     record becomes the current record and FOUND() returns true (.T.); if
     unsuccessful, FOUND() returns false (.F.).

     Each work area may have an active LOCATE condition.  In CA-Clipper, a
     LOCATE condition remains pending until a new LOCATE condition is
     specified.  No other commands release the condition.

 ^bNotes^b

     ^b^CFE  Scope and WHILE condition:^b Note that the scope and WHILE
        condition of the initial LOCATE are ignored; only the FOR condition
        is used with CONTINUE.  If you are using a LOCATE with a WHILE
        condition and want to continue the search for a matching record, use
        SKIP and then repeat the original LOCATE statement adding REST as the
        scope.

 ^bExamples^b

     ^b^CFE^b  This example scans records in Sales.dbf for a particular
        salesman and displays a running total sales amounts:

        LOCAL nRunTotal := 0
        USE Sales NEW
        LOCATE FOR Sales->Salesman = "1002"
        DO WHILE FOUND()
           ? Sales->Salesname, nRunTotal += Sales->Amount
           CONTINUE
        ENDDO

     ^b^CFE^b  This example demonstrates how to continue if the pending
        LOCATE scope contains a WHILE condition:

        LOCAL nRunTotal := 0
        USE Sales INDEX Salesman NEW
        SEEK "1002"
        LOCATE REST WHILE Sales->Salesman = "1002";
              FOR Sales->Amount > 5000
        DO WHILE FOUND()
           ? Sales->Salesname, nRunTotal += Sales->Amount
           SKIP
           LOCATE REST WHILE Sales->Salesman = "1002";
              FOR Sales->Amount > 5000
        ENDDO

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"EOF()" c52g_001.ngo:"FOUND()" "LOCATE" "SEEK" 
'------------------------------------------------------------------------------



!short: COPY FILE       Copy a file to a new file or to a device                    ^r^CE4^r
'------------------------------------------------------------------------------
 ^bCOPY FILE^b
 Copy a file to a new file or to a device
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCOPY FILE <xcSourceFile> TO <xcTargetFile>|<xcDevice>

 ^bArguments^b

     ^b<xcSourceFile>^b is the name of the source file to COPY including the
     extension.

     ^b<xcTargetFile>^b is the name of the target file including the
     extension.

     Both arguments can be specified as literal filenames or as character
     expressions enclosed in parentheses.  COPY FILE supplies no default
     extensions.

     ^b<xcDevice>^b is the name of the device where all subsequent output
     will be sent.  You can specify a device name as a literal character
     string or a character expression enclosed in parentheses.  Additionally,
     a device can be either local or network.  If you COPY TO a non-existing
     device you create a file with the name of the device.  When specifying
     device names, do not use a trailing colon.

 ^bDescription^b

     COPY FILE is a file command that copies files to and from the CA-Clipper
     default drive and directory unless you specify a drive and/or path.  If
     the <xcTargetFile> exists, it is overwritten without warning or error.

 ^bExamples^b

     ^b^CFE^b  This example copies a file to a new file and then tests for
        the existence of the new file:

        COPY FILE Test.prg TO Real.prg
        ? FILE("Real.prg")                  // Result: .T.

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "COPY TO" "RENAME" "SET DEFAULT" 
'------------------------------------------------------------------------------



!short: COPY STRUCTURE  Copy the current (.dbf) structure to a new (.dbf) file
'------------------------------------------------------------------------------
 ^bCOPY STRUCTURE^b
 Copy the current (.dbf) structure to a new (.dbf) file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCOPY STRUCTURE [FIELDS <idField list>]
     ^b   TO <xcDatabase>

 ^bArguments^b

     ^bFIELDS <idField list>^b defines the set of fields to COPY to the new
     database structure in the order specified.  The default is all fields.

     ^bTO <xcDatabase>^b is the name of the target database file and can be
     specified either as a literal database filename or as a character
     expression enclosed in parentheses.  The default extension is (.dbf)
     unless another is specified.

 ^bDescription^b

     COPY STRUCTURE is a database command that creates an empty database file
     with field definitions from the current database file.  If <xcDatabase>
     exists, it is overwritten.

     COPY STRUCTURE creates empty structures that can be used to archive
     records from the current database file or to create a temporary database
     file for data entry.

 ^bExamples^b

     ^b^CFE^b  In this example, COPY STRUCTURE creates a temporary file.
        After the user enters data into the temporary file, the master
        database file is updated with the new information:

        USE Sales NEW
        COPY STRUCTURE TO Temp
        USE Temp NEW
        lMore := .T.
        DO WHILE lMore
           APPEND BLANK
           @ 10, 10 GET Temp->Salesman
           @ 11, 11 GET Temp->Amount
           READ
           IF UPDATED()
              SELECT Sales
              APPEND BLANK
              REPLACE Sales->Salesman WITH Temp->Salesman
              REPLACE Sales->Amount WITH Temp->Amount
              SELECT Temp
              ZAP
           ELSE
              lMore := .F.
           ENDIF
        ENDDO
        CLOSE DATABASES

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "COPY STRU EXTE" "CREATE" 
'------------------------------------------------------------------------------



!short: COPY STRU EXTE  Copy field definitions to a (.dbf) file
'------------------------------------------------------------------------------
 ^bCOPY STRUCTURE EXTENDED^b
 Copy field definitions to a (.dbf) file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCOPY STRUCTURE EXTENDED
     ^b   TO <xcExtendedDatabase>

 ^bArguments^b

     ^bTO <xcExtendedDatabase>^b is the name of the target structure extended
     database file.  This argument can be specified either as a literal
     database filename or as a character expression enclosed in parentheses.

 ^bDescription^b

     COPY STRUCTURE EXTENDED creates a database file whose contents is the
     structure of the current database file with a record for the definition
     of each field.  The structure extended database file has the following
     structure:

     ^bStructure of an Extended File^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bField   Name           Type        Length  Decimals^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     1       Field_name     Character   10
     2       Field_type     Character   1
     3       Field_len      Numeric     3       0
     4       Field_dec      Numeric     4       0
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     Used in application programs, COPY STRUCTURE EXTENDED permits you to
     create or modify the structure of a database file programmatically.  To
     create a new database file from the structure extended file, use CREATE
     FROM.  If you need an empty structure extended file, use CREATE.

 ^bNotes^b

     ^b^CFE  Character field lengths greater than 255:^b In CA-Clipper, the
        maximum character field length is 64K.  For compatibility reasons,
        field lengths greater than 255 are represented as a combination of
        the Field_dec and Field_len fields.  After COPYing STRUCTURE
        EXTENDED, you can use the following formula to determine the length
        of any character field:

        nFieldLen := IF(Field_type = "C" .AND. ;
              Field_dec != 0, Field_dec * 256) + ;
              Field_len, Field_len)

 ^bExamples^b

     ^b^CFE^b  This example creates Struc.dbf from Sales.dbf as a structure
        extended file then lists the contents of Struc.dbf to illustrate the
        typical layout of field definitions:

        USE Sales NEW
        COPY STRUCTURE EXTENDED TO Struc
        USE Struc NEW
        LIST Field_name, Field_type, Field_len, Field_dec

        Result:

        1 BRANCH        C      3      0
        2 SALESMAN      C      4      0
        3 CUSTOMER      C      4      0
        4 PRODUCT       C     25      0
        5 AMOUNT        N      8      2
        6 NOTES         C      0    125
        // Field length is 32,000 characters

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "COPY STRUCTURE" "CREATE" "CREATE FROM" c52g_001.ngo:"FIELDNAME()" c52g_001.ngo:"TYPE()" 
'------------------------------------------------------------------------------



!short: COPY TO         Export records to a new (.dbf) or ASCII file
'------------------------------------------------------------------------------
 ^bCOPY TO^b
 Export records to a new (.dbf) or ASCII file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCOPY [FIELDS <idField list>] TO <xcFile>
     ^b   [<scope>] [WHILE <lCondition>] [FOR <lCondition>]
     ^b   [SDF | DELIMITED [WITH BLANK | <xcDelimiter>]]

 ^bArguments^b

     ^bFIELDS <idField list>^b specifies the list of fields to copy to the
     target file.  The default is all fields.

     ^bTO <xcFile>^b specifies the name of the target file.  The filename can
     be specified either as a literal filename or as a character expression
     enclosed in parentheses.  If SDF or DELIMITED is specified, (.txt) is
     the default extension.  Otherwise, (.dbf) is the default extension.

     ^b<scope>^b defines the portion of the current database file to COPY.
     The default is ALL records.

     ^bWHILE <lCondition>^b specifies the set of records meeting the
     condition from the current record until the condition fails.

     ^bFOR <lCondition>^b specifies the conditional set of records to COPY
     within the given scope.

     ^bSDF^b specifies the output file type as a System Data Format ASCII
     text file.  Records and fields are fixed length.

     ^bDELIMITED^b specifies the output file type as a delimited ASCII text
     file where character fields are enclosed in double quote marks (the
     default delimiter).  Records and fields are variable length.

     ^bDELIMITED WITH BLANK^b identifies an ASCII text file in which fields
     are separated by one space and character fields have no delimiters.

     ^bDELIMITED WITH <xcDelimiter>^b identifies a delimited ASCII text file
     where character fields are enclosed using the specified delimiter.
     <xcDelimiter> can be specified either as a literal character or as a
     character expression enclosed in parentheses.

     See the tables below for more information regarding the format
     specifications for ASCII text files created using these arguments.

     ^bNote: ^b If the DELIMITED WITH clause is specified on a COPY or APPEND
     command, it must be the last clause specified.

 ^bDescription^b

     COPY TO is a database command that copies all or part of the current
     database file to a new file.  Records contained in the active database
     file are copied unless limited by a <scope>, a FOR|WHILE clause, or a
     filter.

     If DELETED is OFF, deleted records in the source file are copied to
     <xcFile> where they retain their deleted status.  If DELETED is ON,
     however, no deleted records are copied.  Similarly, if a FILTER has been
     SET invisible records are not copied.

     Records are copied in controlling index order if there is an index open
     in the current work area and SET ORDER is not zero.  Otherwise, records
     are copied in natural order.

     In a network environment, CA-Clipper opens the target database file
     EXCLUSIVEly before the COPY TO operation begins.  Refer to the Network
     Programming chapter in the Programming and Utilities guide for more
     information.

     This table shows the format specifications for SDF text files.

     ^bSDF Text File Format Specifications^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bFile Element        Format^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Character fields    Padded with trailing blanks
     Date fields         yyyymmdd
     Logical fields      T or F
     Memo fields         Ignored
     Numeric fields      Padded with leading blanks for zeros
     Field separator     None
     Record separator    Carriage return/linefeed
     End of file marker  1A hex or CHR(26)
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     This table shows the format specifications for DELIMITED and DELIMITED
     WITH <xcDelimiter> ASCII text files.

     ^bDELIMITED Text File Format Specifications^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bFile Element        Format^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Character fields    Delimited, with trailing blanks truncated
     Date fields         yyyymmdd
     Logical fields      T or F
     Memo fields         Ignored
     Numeric fields      Leading zeros truncated
     Field separator     Comma
     Record separator    Carriage return/linefeed
     End of file marker  1A hex or CHR(26)
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     This table shows the format specifications for DELIMITED WITH BLANK
     ASCII text files.

     ^bDELIMITED WITH BLANK Text File Format Specifications^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bFile Element        Format^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Character fields    Not delimited, trailing blanks truncated
     Date fields         yyyymmdd
     Logical fields      T or F
     Memo fields         Ignored
     Numeric fields      Leading zeros truncated
     Field separator     Single blank space
     Record separator    Carriage return/linefeed
     End of file marker  1A hex or CHR(26)
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bExamples^b

     ^b^CFE^b  This example demonstrates COPYing to another database file:

        USE Sales NEW
        COPY TO Temp

     ^b^CFE^b  This example demonstrates the layout of an SDF file with four
        fields, one for each data type:

        USE Testdata NEW
        COPY NEXT 1 TO Temp SDF
        TYPE Temp.txt

        Result:

        Character     12.0019890801T

     ^b^CFE^b  This example demonstrates the layout of a DELIMITED file:

        COPY NEXT 1 TO Temp DELIMITED
        TYPE Temp.txt

        Result:

        "Character",12.00,19890801,T

     ^b^CFE^b  This example demonstrates the layout of a DELIMITED file WITH
        a different delimiter:

        COPY NEXT 1 TO Temp DELIMITED WITH '
        TYPE Temp.txt

        Result:

        'Character',12.00,19890801,T

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "APPEND FROM" "COPY FILE" "COPY STRUCTURE" "SET DELETED" 
'------------------------------------------------------------------------------



!short: COUNT           Tally records to a variable
'------------------------------------------------------------------------------
 ^bCOUNT^b
 Tally records to a variable
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCOUNT TO <idVar>
     ^b   [<scope>] [WHILE <lCondition>] [FOR <lCondition>]

 ^bArguments^b

     ^bTO <idVar>^b identifies the variable that holds the COUNT result.  A
     variable that either does not exist or is invisible is created as a
     private variable whose scope is the current procedure.

     ^b<scope>^b is the portion of the current database file to COUNT.  The
     default is ALL records.

     ^bWHILE <lCondition>^b specifies the set of records meeting the
     condition from the current record until the condition fails.

     ^bFOR <lCondition>^b specifies the conditional set of records to COUNT
     within the given scope.

 ^bDescription^b

     COUNT tallies the number of records from the current work area that
     match the specified record scope and conditions.  The result is then
     placed in the specified variable.  <idVar> can be a variable of any
     storage class including a field.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a COUNT of Branches in Sales.dbf:

        USE Sales NEW
        COUNT TO nBranchCnt FOR Branch = 100
        ? nBranchCnt                           // Result: 4

     ^b^CFE^b  This example tallies the number of records in Sales.dbf whose
        Branch has the value of 100 and assigns the result to the Count field
        in Branch.dbf for branch 100:

        USE Branch INDEX Branch NEW
        SEEK 100
        USE Sales INDEX SalesBranch NEW
        SEEK 100
        COUNT TO Branch->Count WHILE Branch = 100

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "AVERAGE" c52g_001.ngo:"DBEVAL()" "SUM" "TOTAL" 
'------------------------------------------------------------------------------



!short: CREATE          Create an empty structure extended (.dbf) file
'------------------------------------------------------------------------------
 ^bCREATE^b
 Create an empty structure extended (.dbf) file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCREATE <xcExtendedDatabase>

 ^bArguments^b

     ^b<xcExtendedDatabase>^b is the name of the empty structure extended
     database file.  This argument can be specified either as a literal
     database filename or as a character expression enclosed in parentheses.
     If no extension is specified, (.dbf) is the default extension.

 ^bDescription^b

     CREATE produces an empty structure extended database file with the
     following structure:

     ^bStructure of an Extended File^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bField   Name           Type        Length  Decimals^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     1       Field_name     Character   10
     2       Field_type     Character   1
     3       Field_len      Numeric     3       0
     4       Field_dec      Numeric     4       0
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     Like COPY STRUCTURE EXTENDED, CREATE can be used in conjunction with
     CREATE FROM to form a new database file.  Unlike COPY STRUCTURE
     EXTENDED, CREATE produces an empty database file and does not require
     the presence of another database file to create it.

     <xcExtendedDatabase> is automatically opened in the current work area
     after it is CREATEd.

 ^bExamples^b

     ^b^CFE^b  This example creates a new structure extended file, places the
        definition of one field into it, and then CREATEs a new database file
        FROM the extended structure:

        CREATE TempStru
        APPEND BLANK
        REPLACE Field_name WITH "Name",;
           Field_type WITH "C",;
           Field_len WITH 25,;
           Field_dec WITH 0
        CLOSE
        CREATE NewFile FROM TempStru

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "COPY STRU EXTE" "CREATE FROM" 
'------------------------------------------------------------------------------



!short: CREATE FROM     Create a new (.dbf) file from a structure extended file     ^r^CE4^r
'------------------------------------------------------------------------------
 ^bCREATE FROM^b
 Create a new (.dbf) file from a structure extended file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCREATE <xcDatabase> FROM <xcExtendedDatabase> [NEW]
     ^b   [ALIAS <xcAlias>] [VIA <cDriver>]

 ^bArguments^b

     ^b<xcDatabase>^b is the name of the new database file to create from the
     structure extended file.

     ^b<xcExtendedDatabase>^b is the name of a structure extended file to use
     as the structure definition for the new database file.

     Both of these arguments can be specified either as literal database
     filenames or as character expressions enclosed in parentheses.  If an
     extension is not specified, the default is (.dbf).

     ^bNEW^b opens <xcDatabase> in the next available work area making it
     the current work area.  If this clause is not specified, <xcDatabase> is
     opened in the current work area.

     ^bALIAS <xcAlias>^b is the name to associate with the work area when
     <xcDatabase> is opened.  You may specify the alias name as a literal
     name or as a character expression enclosed in parentheses.  A valid
     <xcAlias> may be any legal identifier (i.e., it must begin with an
     alphabetic character and may contain numeric or alphabetic characters
     and the underscore).  Within a single application, CA-Clipper will not
     accept duplicate aliases.  If this clause is not specified, the alias
     defaults to the database filename.

     ^bVIA <cDriver>^b  specifies the replaceable database driver (RDD) to
     use to process the current work area.  <cDriver> is name of the RDD
     specified as a character expression.  If you specify <cDriver> as a
     literal value, you must enclose it in quotes.

 ^bDescription^b

     CREATE FROM produces a new database file with the field definitions
     taken from the contents of a structure extended file.  To qualify as a
     structure extended file, a database file must contain the following four
     fields:

     ^bStructure of an Extended File^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bField   Name           Type        Length  Decimals^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     1       Field_name     Character   10
     2       Field_type     Character   1
     3       Field_len      Numeric     3       0
     4       Field_dec      Numeric     4       0
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     <xcDatabase> is automatically opened in the current work area after it
     is CREATEd.

 ^bNotes^b

     ^b^CFE  Data dictionaries:^b For data dictionary applications, you can
        have any number of other fields within the structure extended file to
        describe the extended field attributes.  You may, for example, want
        to have fields to describe such field attributes as a description,
        key flag, label, color, picture, and a validation expression for the
        VALID clause.  When you CREATE FROM, CA-Clipper creates the new
        database file from the required fields only, ignoring all other
        fields in the extended structure.  Moreover, CA-Clipper is not
        sensitive to the order of the required fields.

     ^b^CFE  Character field lengths greater than 255:^b There are two
        methods for creating a character field with a length greater than 255
        digits:

        ^b-^b  Specify the field length using both the Field_len and
           Field_dec fields according to the following formulation:

           FIELD->Field_len := <nFieldLength> % 256
           FIELD->Field_dec := INT(<nFieldLength> / 256)

        ^b-^b  Modify the structure of the extended structure changing the
           length of Field_len to 5 then specify the actual field length.
           This can be accomplished in DBU.EXE.  Refer to the Database
           Utility chapter in the Programming and Utilities guide for more
           information.

 ^bExamples^b

     ^b^CFE^b  This example is a procedure that simulates an interactive
        CREATE utility:

        CreateDatabase("NewFile")
        RETURN

        FUNCTION CreateDatabase( cNewDbf )
           CREATE TmpExt         // Create empty structure extended
           USE TmpExt
           lMore := .T.
           DO WHILE lMore        // Input new field definitions
              APPEND BLANK
              CLEAR
              @ 5, 0 SAY "Name.....: " GET Field_name
              @ 6, 0 SAY "Type.....: " GET Field_type
              @ 7, 0 SAY "Length...: " GET Field_len
              @ 8, 0 SAY "Decimals.: " GET Field_dec
              READ
              lMore := (!EMPTY(Field_name))
           ENDDO

           // Remove all blank records
           DELETE ALL FOR EMPTY(Field_name)   PACK
           CLOSE

        // Create new database file
           CREATE (cNewDbf) FROM TmpExt
           ERASE TmpExt.dbf
           RETURN NIL

     ^b^CFE^b  This example creates a new definition in a structure extended
        file for a character field with a length of 4000 characters:

        APPEND BLANK
        REPLACE Field_name WITH "Notes",;
           Field_type WITH "C",;
           Field_len  WITH 4000 % 256,;
           Field_dec  WITH INT(4000 / 256)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "COPY STRUCTURE" "COPY STRU EXTE" "CREATE" 
'------------------------------------------------------------------------------



!short: DELETE          Mark records for deletion
'------------------------------------------------------------------------------
 ^bDELETE^b
 Mark records for deletion
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDELETE [<scope>] [WHILE <lCondition>]
     ^b   [FOR <lCondition>]

 ^bArguments^b

     ^b<scope>^b is the portion of the current database file to DELETE.  If a
     scope is not specified, DELETE acts only on the current record.  If a
     conditional clause is specified, the default becomes ALL records.

     ^bWHILE <lCondition>^b specifies the set of records meeting the
     condition from the current record until the condition fails.

     ^bFOR <lCondition>^b specifies the conditional set of records to DELETE
     within the given scope.

 ^bDescription^b

     DELETE is a database command that tags records so they can be filtered
     with SET DELETED ON, queried with DELETED(), or physically removed from
     the database file with PACK.  In addition, display commands such as LIST
     and DISPLAY identify deleted records with an asterisk (*) character.
     Once records are deleted, you can reinstate them by using RECALL.  If
     you want to remove all records from a database file, use ZAP instead of
     DELETE ALL and PACK.

     In a network environment, DELETE requires the current record be locked
     with RLOCK() if you are DELETEing a single record.  If you are DELETEing
     several records, the current database file must be locked with FLOCK()
     or USEed EXCLUSIVEly.  Refer to the Network Programming chapter in the
     Programming and Utilities guide for more information.

 ^bNotes^b

     ^b^CFE  DELETE with SET DELETED ON:^b If the current record is deleted
        with SET DELETED ON, it will be visible until the record pointer is
        moved.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates use of the FOR clause to mark a set
        of records for deletion:

        USE Sales INDEX Salesman NEW
        DELETE ALL FOR Inactive

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"DBEVAL()" c52g_001.ngo:"DELETED()" "PACK" "RECALL" "SET DELETED" "ZAP" 
'------------------------------------------------------------------------------



!short: DELETE FILE     Remove a file from disk
'------------------------------------------------------------------------------
 ^bDELETE FILE^b
 Remove a file from disk
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDELETE FILE | ERASE <xcFile>

 ^bArguments^b

     ^b<xcFile>^b is the name of the file to be deleted from disk and can be
     specified either as a literal filename or as a character expression
     enclosed in parentheses.  You must specify the filename, including the
     extension, and it may optionally be preceded by a drive and/or path
     specification.

 ^bDescription^b

     DELETE FILE, a synonym for ERASE, is a file command that removes the
     specified file from disk.  SET DEFAULT and SET PATH do not affect DELETE
     FILE.  The file is deleted from disk only if found in the current DOS
     directory or in the directory explicitly specified as part of the
     filename.

     ^bWarning! ^b Files must be CLOSEd before deleting them.

 ^bExamples^b

     ^b^CFE^b  This example removes a specified file from disk then tests to
        see if the file was in fact removed:

        ? FILE("Temp.dbf")               // Result: .T.
        DELETE FILE Temp.dbf
        ? FILE("Temp.dbf")               // Result: .F.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CLOSE" c52g_001.ngo:"CURDIR()" c52g_001.ngo:"FILE()" "USE" 
'------------------------------------------------------------------------------



!short: DIR*            Display a listing of files from a specified path
'------------------------------------------------------------------------------
 ^bDIR*^b
 Display a listing of files from a specified path
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDIR [<xcFileSpec>]

 ^bArguments^b

     ^b<xcFileSpec>^b is a template that must be matched by displayed files
     and can include standard wildcard (* and ?) characters.  You can specify
     <xcFileSpec> as a literal file specification string or as a character
     expression enclosed in parentheses.

 ^bDescription^b

     DIR is a file command that displays a listing of files from the
     specified path in one of two formats depending on whether you specify
     the <xcFileSpec> argument.  If you do not specify a path, DIR displays a
     standard listing of database files from the current or specified
     directory.  The list includes the database filename, date of last
     update, and number of records.  Including the option <xcFileSpec>
     displays a list of all files in the specified directory.  This list
     includes the filename, extension, number of bytes, and date of last
     update.

     If no path is specified, DIR displays files from the current DOS drive
     and directory unless SET DEFAULT has been used to specify a new default
     directory.

     DIR is a compatibility command and therefore not recommended.  It is
     superseded by the DIRECTORY() function which returns an array of file
     information from a wildcard pattern.  Using this array, you can display
     file information to screen.

 ^bNotes^b

     ^b^CFE  Directory picklists:^b To present directory information to the
        user, use ADIR() to return one or more arrays of directory
        information, and ACHOICE() to present a picklist to the user.

 ^bExamples^b

     ^b^CFE^b  These examples display DOS and database files in the current
        directory:

        cFilespec := "*.*"
        DIR (cFilespec)            // Display all files
        DIR                        // Display all (.dbf) files
        DIR *.prg                  // Display all program files

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: c52g_001.ngo:"DIRECTORY()" "SET DEFAULT" 
'------------------------------------------------------------------------------



!short: DISPLAY         Display records to the console
'------------------------------------------------------------------------------
 ^bDISPLAY^b
 Display records to the console
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDISPLAY <exp list>
     ^b   [TO PRINTER] [TO FILE <xcFile>]
     ^b   [<scope>] [WHILE <lCondition>]
     ^b   [FOR <lCondition>] [OFF]

 ^bArguments^b

     ^b<exp list>^b is the list of values to display for each record
     processed.

     ^bTO PRINTER^b echoes output to the printer.

     ^bTO FILE <xcFile>^b echoes output to the indicated file which can be
     specified either as a literal filename or as a character expression
     enclosed in parentheses.  If an extension is not specified, (.txt) is
     added.

     ^b<scope>^b is the portion of the current database file to DISPLAY.  The
     default is the current record, or NEXT 1.  If a condition is specified,
     the scope becomes ALL.

     ^bWHILE <lCondition>^b specifies the set of records meeting the
     condition from the current record until the condition fails.

     ^bFOR <lCondition>^b specifies the conditional set of records to DISPLAY
     within the given scope.

     ^bOFF^b suppresses the display of the record number.

 ^bDescription^b

     DISPLAY is a database command that sequentially accesses records in the
     current work area sending the results of the <exp list> to the console
     in a tabular format with each column separated by a space.  The command
     does not display column headers or pause at predetermined intervals.
     DISPLAY is identical to LIST with the exception that its default scope
     is NEXT 1 rather than ALL.

     When invoked, output is sent to the screen and optionally to the printer
     and/or a file.  To suppress output to the screen while printing or
     echoing output to a file, SET CONSOLE OFF before the DISPLAY command
     line.

 ^bNotes^b

     ^b^CFE  Interrupting output:^b To let the user interrupt the processing
        of a DISPLAY command, using the INKEY() function, add a test for the
        interrupt key press to the FOR condition.  See the example below.

     ^b^CFE  Printer margin:^b Since DISPLAY is a console command, it honors
        the current SET MARGIN for output echoed to the printer.

 ^bExamples^b

     ^b^CFE^b  This example illustrates a simple DISPLAY, and a conditional
        DISPLAY to the printer:

        USE Sales NEW
        DISPLAY DATE(), TIME(), Branch
        DISPLAY Branch, Salesman FOR Amount > 500 TO PRINTER

     ^b^CFE^b  This example interrupts a DISPLAY using INKEY() to test
        whether the user pressed the Esc key:

        #define K_ESC  27
        USE Sales INDEX SalesMan NEW
        DISPLAY Branch, Salesman, Amount WHILE ;
           INKEY() != K_ESC

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"DBEVAL()" c52g_001.ngo:"INKEY()" "LIST" "SET MARGIN" 
'------------------------------------------------------------------------------



!short: EJECT           Advance the printhead to top of form
'------------------------------------------------------------------------------
 ^bEJECT^b
 Advance the printhead to top of form
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bEJECT

 ^bDescription^b

     EJECT is a printing command that sends a formfeed character (CHR(12)) to
     the printer and sets the PCOL() and PROW() values to zero.  If you
     address a printer row less than the last row position since an EJECT or
     SETPRC() was executed, CA-Clipper automatically performs an EJECT.
     Because of this, your printing logic must proceed sequentially from left
     to right down the page.  If you need to reset the internal printer row
     and column values to zero without sending a formfeed, use SETPRC().

 ^bExamples^b

     ^b^CFE^b  This example prints a simple list report and uses EJECT to
        advance to a new page when the line counter reaches the maximum
        number of lines to print per page:

        LOCAL nLine := 99, nPage := 0
        USE Sales NEW
        SET PRINTER ON
        SET CONSOLE OFF
        DO WHILE !EOF()
           IF nLine > 55
              EJECT
              ? "Page " + LTRIM(STR(++nPage, 3))
              ? "Date " + CTOD(DATE())
              ?
              ? "Salesman", "Amount"
              ?
              nLine := 6
           ENDIF
           ? Sales->Salesman, Sales->Amount
           nLine++
           SKIP
        ENDDO
        SET PRINTER OFF
        SET CONSOLE ON
        CLOSE

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "SET CONSOLE" "SET DEVICE" "SET PRINTER" c52g_001.ngo:"SETPRC()" 
'------------------------------------------------------------------------------



!short: ERASE           Remove a file from disk
'------------------------------------------------------------------------------
 ^bERASE^b
 Remove a file from disk
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bERASE | DELETE FILE <xcFile>

 ^bArguments^b

     ^b<xcFile>^b is the name of the file to be deleted from disk and can be
     specified either as a literal filename or as a character expression
     enclosed in parentheses.  The filename must be fully specified including
     the extension, and it may optionally be preceded by a drive and/or path
     specification.

 ^bDescription^b

     ERASE is a file command that removes a specified file from disk.  SET
     DEFAULT and SET PATH do not affect ERASE.  The file is deleted from disk
     only if found in the current DOS directory or in the directory
     explicitly specified as part of the filename.

     ^bWarning! ^b Files must be CLOSEd before being ERASEd.

 ^bExamples^b

     ^b^CFE^b  This example removes a specified file from disk then tests to
        see if the file was in fact removed:

        ? FILE("Temp.dbf")         // Result: .T.
        ERASE Temp.dbf
        ? FILE("Temp.dbf")         // Result: .F.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CLOSE" c52g_001.ngo:"CURDIR()" c52g_001.ngo:"FERASE()" c52g_001.ngo:"FILE()" c52g_001.ngo:"FRENAME()" "RENAME" "USE" 
'------------------------------------------------------------------------------



!short: FIND*           Search an index for a specified key value
'------------------------------------------------------------------------------
 ^bFIND*^b
 Search an index for a specified key value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFIND <xcSearchString>

 ^bArguments^b

     ^b<xcSearchString>^b is part or all of the index key of a record to
     search for and can be specified either as a literal string or as a
     character expression enclosed in parentheses.  If an expression is
     specified instead of a literal string, FIND operates the same as SEEK.

 ^bDescription^b

     FIND is a database command that searches an index for the first key
     matching the specified character string and positions the record pointer
     to the corresponding record.

     If SOFTSEEK is OFF and FIND does not find a record, the record pointer
     is positioned to LASTREC() + 1, EOF() returns true (.T.), and FOUND()
     returns false (.F.).

     If SOFTSEEK is ON, the record pointer is positioned to the record with
     the first key value greater than the search argument and FOUND() returns
     false (.F.).  In this case, EOF() returns true (.T.) only if there are
     no keys in the index greater than the search argument.

     FIND is a compatibility command and not recommended.  Its usage is
     superseded entirely by the SEEK command.

 ^bExamples^b

     ^b^CFE^b  These examples show simple FIND results:

        USE Sales INDEX Branch NEW
        FIND ("500")
        ? FOUND(), EOF(), RECNO()         // Result: .F. .T. 85
        FIND 200
        ? FOUND(), EOF(), RECNO()         // Result: .T. .F. 5
        FIND "100"
        ? FOUND(), EOF(), RECNO()         // Result: .T. .F. 1

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"EOF()" c52g_001.ngo:"FOUND()" "SEEK" "SET ORDER" "SET SOFTSEEK" 
'------------------------------------------------------------------------------



!short: GO              Move the record pointer to a specific record
'------------------------------------------------------------------------------
 ^bGO^b
 Move the record pointer to a specific record
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bGO[TO] <nRecord> | BOTTOM | TOP

 ^bArguments^b

     ^b<nRecord>^b specifies the target record number.

     ^bBOTTOM^b specifies the last logical record in the current work area.

     ^bTOP^b specifies the first logical record in the current work area.

 ^bDescription^b

     GO is a database command that positions the record pointer in the
     current work area to a specified record.  You can specify the record by
     number or as top or bottom of file.  If the new position is TOP and
     there is an active index, the record pointer moves to the first record
     in the index, otherwise it moves to record 1.  If the new position is
     BOTTOM and there is an active index, the record pointer moves to the
     last record in the index, otherwise it moves to LASTREC().

     The GO <nRecord> form of the command is the same as the RECORD clause of
     any database command that supports a scope.

 ^bNotes^b

     ^b^CFE  Accessing filtered records:^b You can access records filtered by
        SET DELETED ON or SET FILTER TO with GO <nRecord>.  If DELETED is ON
        or there is an active FILTER, GO BOTTOM moves to the last logical
        record that is not deleted and/or that matches the filter condition.
        If DELETED is ON or there is an active FILTER, GO TOP moves to the
        first logical record that is not deleted and/or that matches the
        filter condition.

     ^b^CFE  Unique indexes:^b You can access records not present in an index
        created with SET UNIQUE ON or INDEX...UNIQUE with GO <nRecord>.

     ^b^CFE  Record out of range:^b In CA-Clipper, a GO that positions the
        pointer to a record out of range of the database file does not
        generate a runtime error.  Instead, EOF() and BOF() are set to true
        (.T.) and the record pointer is set to LASTREC() + 1.

     ^b^CFE  Refreshing database and index buffers:^b In a network
        environment, you can refresh database and index buffers without
        moving the record pointer by using GO RECNO().  Refer to the Network
        Programming chapter in the Programming and Utilities guide for more
        information.

 ^bExamples^b

     ^b^CFE^b  These examples show simple GO results:

        USE Sales NEW
        ? LASTREC()            // Result: 84
        //
        GO TOP
        ? RECNO()              // Result: 1
        //
        GO BOTTOM
        ? RECNO()              // Result: 84
        //
        GO 5
        ? RECNO()              // Result: 5
        //
        GO 5 + 15
        ? RECNO()              // Result: 20

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"LASTREC()" c52g_001.ngo:"RECNO()" "SET FILTER" "SET RELATION" "SKIP" 
'------------------------------------------------------------------------------



!short: INDEX           Create an index file                                        ^r^CE4^r
'------------------------------------------------------------------------------
 ^bINDEX^b
 Create an index file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bINDEX ON <expKey> TO <xcIndex> [UNIQUE]
     ^b   [<scope>]
     ^b   [FOR <lCondition>]
     ^b   [WHILE <lCondition>]
     ^b   [[EVAL <lCondition>][EVERY <nRecords>]]
     ^b   [ASCENDING | DESCENDING]

 ^bArguments^b

     ^b<expKey>^b is an expression that returns the key value to place in the
     index for each record in the current work area.  <expKey> can be
     character, date, logical, or numeric type.  The maximum length of the
     index key expression is 250 characters.

     ^bTO <xcIndex>^b specifies the name of the index file to create.  You
     can specify the filename either as a literal filename or as a character
     expression enclosed in parentheses.  If the specified name does not
     include a file extension, a default extension is used.  For standard
     CA-Clipper indexes the default extension is (.ntx).  For dBASE III PLUS
     compatible indexes, the default extension is (.ndx).

     ^bUNIQUE^b specifies that <xcIndex> includes only unique key values.

     ^b<scope>^b is the portion of the current database to INDEX.  The
     default is ALL records.  All other valid scope clauses (i.e., NEXT
     <nRecords>, REST, and RECORD <nRecord>) are permitted.  If you specify a
     scope, the database is processed in the controlling index order.  The
     scope is transient (i.e., is not stored in the (.ntx) file and not used
     for REINDEXing purposes).

     ^bFOR <lCondition>^b specifies the conditional set of records on which
     to index.  Only those records that meet the condition are included in
     the resulting index (.ntx) file.  The maximum length of the FOR
     expression is 250 characters.  The FOR condition is stored as part of
     the (.ntx) file and therefore used when updating or recreating the index
     using the REINDEX command.

     ^bWHILE <lCondition>^b specifies another condition that each record
     processed must meet; as soon as a record is encountered that causes the
     condition to fail, the INDEX command terminates.  If a WHILE clause is
     specified, the database file is processed in the controlling index
     order.  The WHILE condition is transient (i.e., is not stored in the
     (.ntx) file and not used for index updates and REINDEXing purposes).

     ^bEVAL <lCondition>^b specifies a condition that is evaluated either for
     each record processed or at the interval specified by the EVERY clause.
     This clause provides a flexible way to monitor the progress of the
     indexing operation.  <lCondition> may be any logical expression,
     including a user-defined function that displays status information and
     then returns a logical value.  The value of <lCondition> is transient
     which means that it is discarded after the index is created (i.e., it is
     not retained for REINDEXing purposes).  Indexing stops if the EVAL
     condition returns false (.F.)

     ^bEVERY <nRecords>^b specifies a numeric expression that modifies how
     often EVAL is evaluated.  When using EVAL, the EVERY option offers a
     performance enhancement by evaluating the condition for every nth record
     instead of for each record indexed.  The EVERY keyword is ignored if no
     EVAL condition is specified.

     ^bNote: ^b Since <scope>, WHILE, EVAL, and EVERY are transient, they
     will not be available when the database is REINDEXed.  Although the
     REINDEX command does provide for EVAL and EVERY clauses, <scope> and
     WHILE are not allowed as part of the REINDEX operation.  Thus, scoping
     is useful only for immediate queries.

     ^bASCENDING^b specifies that the index keys be sorted in increasing
     order of value.  If neither ASCENDING nor DESCENDING is specified,
     ASCENDING is assumed.  Although not stored as an explicit part of the
     (.ntx) file, ASCENDING is an implicit (.ntx) file attribute that is
     understood by the REINDEX command.

     ^bDESCENDING^b specifies that the index keys be sorted in decreasing
     order of value.  Using this keyword is the same as specifying the
     DESCEND() function within <expKey>, but without the performance penalty
     during index updates.  If you create a DESCENDING index, you won't need
     to use the DESCEND() function during a SEEK.  DESCENDING is an attribute
     of the (.ntx) file, where it is stored and used for REINDEXing purposes.

 ^bDescription^b

     INDEX is a database command that creates a file containing an index of
     records in the current database file, based on <expKey>.  When the index
     file is used, the database file records appear in key expression order
     although the index does not alter the physical order of records within
     the database file.  INDEX orders character keys in accordance with the
     ASCII value of each character within the string, numeric values in
     numeric order, date values chronological order with blank dates treated
     as low values, and logical values sorted with true (.T.) treated as high
     values.  Memo fields cannot be INDEXed.

     When INDEX ON is invoked, all open index files in the current work area
     are closed and the new index file is created.  When the indexing
     operation finishes, the new index remains open becoming the controlling
     index and the record pointer is positioned to the first record in the
     index.

     INDEX is like SORT but does not make a physical copy of the database
     file and is updated each time a new key value is entered in the current
     database file.  SORT is primarily used to copy an ordered subset of
     records to another database file.

     In a network environment, INDEX opens <xcIndex> exclusive.  Failure to
     open the file raises , a runtime error.  Refer to the Network
     Programming chapter in the Programming and Utilities guide for more
     information.

 ^bNotes^b

     ^b^CFE  Date indexes:^b CA-Clipper supports date indexes for both (.ntx)
        and (.ndx) index types.  For a key expression that includes a date as
        a subset of the key, create the expression as character data type and
        use DTOS() to convert the date to character.

     ^b^CFE  Declared variables:^b You cannot use local and static variables
        in index key expressions.  This is because index expressions are
        saved as text in the index files and are later compiled and run using
        the macro operator (&) to produce the actual key values.  Since
        locals and statics are invisible within macro variables and
        expressions, references to them within index key expressions are not
        resolved properly.

        For similar reasons, a variable declared with any of the other
        compile-time declarations such as MEMVAR or FIELD, are not valid
        within an index key expression.  If you need aliasing or variable
        qualification in an index key expression, implement it explicitly in
        the expression rather than through compiler declarations.  Refer to
        the discussion on variables in the Basic Concepts chapter of the
        Programming and Utilities guide.

     ^b^CFE  Deleted and filtered records:^b Records that are filtered or
        marked for deletion are included in the index.

     ^b^CFE  Dictionary order indexes:^b To create a dictionary order index
        of character keys, use UPPER(<expKey>) as the index expression.
        Dictionary order is an order where capitalization is ignored.

     ^b^CFE  Compatible index files:^b CA-Clipper supports dBASE III PLUS
        compatible index files using a special database driver.  Refer to the
        CA-Clipper Linker chapter in the Programming and Utilities guide for
        instructions on linking drivers.

     ^bWarning! ^b The dBASE III PLUS database driver supports the CA-Clipper
     locking mechanism in place of the dBASE III PLUS mechanism.  This means
     you cannot have both a CA-Clipper program and dBASE III PLUS
     concurrently accessing the same index files on a network without
     compromising integrity.  With two CA-Clipper programs, however, the
     dBASE III PLUS database driver works the same as the standard CA-Clipper
     database driver.

     ^b^CFE  Unique indexes:^b When you INDEX...UNIQUE or SET UNIQUE ON,
        CA-Clipper creates an index with uniqueness as an attribute.  As
        indexing proceeds and two or more records have the same key value,
        CA-Clipper includes only the first record in the index.  Whenever the
        unique index is updated, REINDEXed, or PACKed, only unique records
        are added.  Note that a unique index retains the uniqueness attribute
        and is unaffected by subsequent invocations of SET UNIQUE.

     ^b^CFE  Trimming key values:^b In CA-Clipper, an <expKey> that changes the
        key length may create an inoperable index.  This happens because
        CA-Clipper stores index key values in fixed increments and index key
        sizes are calculated by evaluating <expKey> on a blank record.  A
        trimmed <expKey>, therefore, always evaluates to a null string ("")
        leading to a size mismatch between the target and the defined key
        length.  To use any of the TRIM() functions within a key expression,
        use PADR() to guarantee a fixed length like this:

        USE Customer NEW
        INDEX ON PADR(RTRIM(Last) + First, 40) TO CustName

 ^bExamples^b

     ^b^CFE^b  This example creates a simple index:

        USE Customer NEW
        INDEX ON Name TO Customer

     ^b^CFE^b  This example creates a unique index:

        USE Customer NEW
        INDEX ON Name TO Customer UNIQUE

     ^b^CFE^b  This example creates a simple descending index:

        USE Customer NEW
        INDEX ON Name TO Customer DESCENDING

     ^b^CFE^b  This example creates an index with a progress indicator which
        displays the percentage of the database indexed every 10 records:

        USE Customer NEW
        INDEX ON Name TO Customer EVAL NtxProgress();
                 EVERY LASTREC()/10

        FUNCTION NtxProgress
        LOCAL cComplete := LTRIM(STR((RECNO()/LASTREC()) * 100))
        @ 23, 00 SAY "Indexing..." + cComplete + "%"
        RETURN .T.

     ^b^CFE^b  This example creates a simple conditional index using a FOR
        condition:

        USE Customer NEW
        INDEX ON Name TO Customer FOR PostalCode = "95605"

     ^b^CFE^b  This example creates a subindex using an existing order:

        USE Customer INDEX Customer NEW
        SEEK "SMITH"
        IF FOUND()
           INDEX ON PostalCode TO PostCode WHILE Name = "SMITH"
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"DESCEND()" c52g_001.ngo:"DTOS()" "REINDEX" "SET INDEX" "SET ORDER" 
'------------------------------------------------------------------------------



!short: INPUT           Enter the result of an expression into a variable
'------------------------------------------------------------------------------
 ^bINPUT^b
 Enter the result of an expression into a variable
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bINPUT [<expPrompt>] TO <idVar>

 ^bArguments^b

     ^b<expPrompt>^b is an optional prompt displayed before the input area.
     The prompt can be an expression of any data type.

     ^bTO <idVar>^b specifies the name of the variable to assign the
     evaluation result.  If <idVar> is not visible or does not exist, a
     private variable is created and assigned the result.

 ^bDescription^b

     INPUT is a console command and wait state that takes entry from the
     keyboard in the form of a valid expression of up to 255 characters and
     any data type.  When invoked, INPUT sends a carriage return/linefeed to
     the screen, displays the prompt, and begins accepting keyboard input at
     the first character position following the prompt.  Input greater than
     MAXCOL() wraps to the next line.

     Pressing Return terminates entry of the expression.  The expression is
     then compiled and evaluated using the macro operator (&), and the result
     assigned to <idVar>.  If the variable is not visible or does not exist,
     it is created as a private.  If no expression is entered, no action is
     taken.

     INPUT supports only two special keys: Backspace and Return.  Esc is not
     supported.  Backspace deletes the last character typed.  Return confirms
     entry and is the only key that can terminate an INPUT.

 ^bExamples^b

     ^b^CFE^b  In this example INPUT assigns a keyboard entry to an existing
        local variable:

        LOCAL exp
        INPUT "Expression: " TO exp
        IF exp != NIL
           ? exp
        ELSE
           ? "No expression entered"
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "ACCEPT" 
'------------------------------------------------------------------------------



!short: JOIN            Merge two (.dbf) files to create a new (.dbf) file
'------------------------------------------------------------------------------
 ^bJOIN^b
 Create a new database file by merging records/fields from two work areas
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bJOIN WITH <xcAlias> TO <xcDatabase>
     ^b   FOR <lCondition> [FIELDS <idField list>]

 ^bArguments^b

     ^bWITH <xcAlias>^b is the name of the work area to merge with records
     from the current work area.  You can specify it either as a literal
     alias or as a character expression enclosed in parentheses.

     ^bTO <xcDatabase>^b is the name of the target database file specified
     either as a literal filename or as a character expression enclosed in
     parentheses.

     ^bFOR <lCondition>^b selects only records meeting the specified
     condition.

     ^bFIELDS <idField list>^b is the projection of fields from both work
     areas into the new database file.  To specify any fields in the
     secondary work area, reference them with the alias.  If the FIELDS
     clause is not specified, all fields from the primary work area are
     included in the target database file.

 ^bDescription^b

     JOIN creates a new database file by merging selected records and fields
     from two work areas based on a general condition.  JOIN works by making
     a complete pass through the secondary work area for each record in the
     primary work area, evaluating the condition for each record in the
     secondary work area.  When the <lCondition> is true (.T.), a new record
     is created in the target database file using the FIELDS specified from
     both work areas.

     If SET DELETED is OFF, deleted records in both source files (i.e., the
     two files being JOINed) are processed.  However, their deleted status is
     not retained in the target <xcDatabase>.  No record in the target file
     is marked for deletion regardless of its deleted status in either of the
     source files.

     If SET DELETED is ON, no deleted records are processed in either of the
     source files.  Thus, deleted records do not become part of the target
     <xcDatabase>.  Similarly, filtered records are not processed and do not
     become part of the target file.

     ^bWarning! ^b The number of records processed will be the LASTREC() of
     the primary work area multiplied by the LASTREC() of the secondary work
     area.  For example, if you have two database files with 100 records
     each, the number of records JOIN processes is the equivalent of
     sequentially processing a single database file of 10,000 records.
     Therefore, use this command carefully.

 ^bExamples^b

     ^b^CFE^b  This example JOINs the Customer.dbf to the Invoices.dbf to
        produce Purchases.dbf:

        USE Invoices NEW
        USE Customers NEW
        JOIN WITH Invoices TO Purchases;
           FOR Last = Invoices->Last;
           FIELDS First, Last, Invoices->Number, ;
              Invoices->Amount

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "SET RELATION" 
'------------------------------------------------------------------------------



!short: KEYBOARD        Stuff a string into the keyboard buffer
'------------------------------------------------------------------------------
 ^bKEYBOARD^b
 Stuff a string into the keyboard buffer
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bKEYBOARD <cString>

 ^bArguments^b

     ^b<cString>^b is the string to stuff into the keyboard buffer.

 ^bDescription^b

     KEYBOARD is a keyboard command that stuffs <cString> into the keyboard
     buffer after clearing any pending keystrokes.  The characters remain in
     the keyboard buffer until fetched by a wait state such as ACCEPT, INPUT,
     READ, ACHOICE(), MEMOEDIT(), and DBEDIT(), or INKEY().  In addition to
     display characters, <cString> may include control characters.

     Generally, to convert an INKEY() code of a control key to a character
     value, use CHR().  There are, however, some limitations.  You can only
     stuff characters with INKEY() codes between zero and 255, inclusive,
     into the keyboard buffer.

     Typically, KEYBOARD is used in a SET KEY procedure to reassign keys in a
     wait state.  Another use within the ACHOICE() user function is to input
     the keys you want ACHOICE() to execute before returning control to it.
     The same concept applies to DBEDIT().

 ^bExamples^b

     ^b^CFE^b  This example uses KEYBOARD to stuff a GET with an item
        selected from a picklist each time the GET is entered:

        #include "Inkey.ch"
        LOCAL cVar1 := SPACE(10), nVar := 2500, ;
              cVar2 := SPACE(10)
        CLEAR
        @ 09, 10 GET cVar1
        @ 10, 10 GET cVar2 WHEN PickList()
        @ 11, 10 GET nVar
        READ
        RETURN

        FUNCTION PickList
           STATIC aList := { "First", "Second", ;
              "Three", "Four" }
           LOCAL cScreen, nChoice, nKey := LASTKEY()
           cScreen := SAVESCREEN(10, 10, 14, 20)
           @ 10, 10 TO 14, 20 DOUBLE
           IF (nChoice := ACHOICE(11, 11, 13, 19, aList)) != 0
              KEYBOARD CHR(K_CTL_Y) + aList[nChoice] + ;
                    CHR(nKey)

           ENDIF
           RESTSCREEN(10, 10, 14, 20, cScreen)
           RETURN .T.

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Inkey.ch.
!seealso: c52g_001.ngo:"CHR()" c52g_001.ngo:"INKEY()" c52g_001.ngo:"LASTKEY()" c52g_001.ngo:"NEXTKEY()" "SET KEY" 
'------------------------------------------------------------------------------



!short: LABEL FORM      Display labels to the console                               ^r^CE4^r
'------------------------------------------------------------------------------
 ^bLABEL FORM^b
 Display labels to the console
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bLABEL FORM <xcLabel>
     ^b   [TO PRINTER] [TO FILE <xcFile>] [NOCONSOLE]
     ^b   [<scope>] [WHILE <lCondition>] [FOR <lCondition>]
     ^b   [SAMPLE]

 ^bArguments^b

     ^b<xcLabel>^b is the name of the label (.lbl) file that contains the
     FORM definition of the LABEL and can be specified either as a literal
     filename or as a character expression enclosed in parentheses.  If an
     extension is not specified (.lbl) is assumed.

     ^bTO PRINTER^b echoes output to the printer.

     ^bTO FILE <xcFile>^b echoes output to <xcFile>.  Specify <xcFile> as a
     literal filename or as a character expression enclosed in parentheses.
     If an extension is not specified, (.txt) is added.

     ^bNOCONSOLE^b suppresses all LABEL FORM output to the console.  If not
     specified, output automatically displays to the console unless SET
     CONSOLE is OFF.

     ^b<scope>^b is the portion of the current database file to display
     labels.  The default is ALL records.

     ^bWHILE <lCondition>^b specifies the set of records meeting the
     condition from the current record until the condition fails.

     ^bFOR <lCondition>^b specifies to LABEL FORM, the conditional set of
     records within the given scope.

     ^bSAMPLE^b displays test labels as rows of asterisks.  Each test label
     has the same number of columns and rows as the label definition.  Then,
     following each test label display, is the query, "Do you want more
     samples?"  Answering "Y" forces another test label display.  Answering
     "N" causes LABEL FORM to display the actual labels for the specified
     scope and condition.

 ^bDescription^b

     LABEL FORM is a console command that sequentially accesses records in
     the current work area, displaying labels using a definition stored in a
     (.lbl) file.  Create the (.lbl) using RL.EXE or by dBASE III PLUS.
     Refer to the Report and Label Utility chapter in the Programming and
     Utilities guide for more information about creating label definitions.

     When invoked, output is sent to the screen, and optionally, to the
     printer and/or a file.  To suppress output to the screen while printing
     or echoing output to a file, SET CONSOLE OFF before invocation of LABEL
     FORM.

     When invoked, LABEL FORM searches the current SET PATH drive and
     directory, if the <xcLabel> file is not found in the current directory,
     and the path is not specified.

 ^bNotes^b

     ^b^CFE  Interrupting LABEL FORM:^b To interrupt a LABEL FORM, use
        INKEY() as a part of the FOR condition, to test for an interrupt key
        press.  See the example below.

     ^b^CFE  Printer margin:^b LABEL FORM obeys the current SET MARGIN for
        output echoed to the printer.

 ^bExamples^b

     ^b^CFE^b  This example prints a set of labels and writes them to a file
        with a single command.  Two forms of the command are shown:

        LOCAL cLabel := "Sales", cFile := "Sales"
        USE Sales INDEX Sales NEW
        LABEL FORM Sales TO PRINTER TO FILE Sales
        LABEL FORM (cLabel) TO PRINTER TO FILE (cFile)

     ^b^CFE^b  This example interrupts LABEL FORM using INKEY() to test if
        the user pressed the Esc key:

        #define K_ESC  27
        USE Sales INDEX Sales NEW
        LABEL FORM Sales WHILE INKEY() != K_ESC

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "REPORT FORM" "SET PRINTER" 
'------------------------------------------------------------------------------



!short: LIST            List records to the console
'------------------------------------------------------------------------------
 ^bLIST^b
 List records to the console
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bLIST <exp list>
     ^b   [TO PRINTER] [TO FILE <xcFile>]
     ^b   [<scope>] [WHILE <lCondition>]
     ^b   [FOR <lCondition>] [OFF]

 ^bArguments^b

     ^b<exp list>^b is the list of expressions to be evaluated and displayed
     for each record processed.

     ^bTO PRINTER^b echoes output to the printer.

     ^bTO FILE <xcFile>^b echoes output to the specified filename and can be
     specified either as a literal filename or as a character expression
     enclosed in parentheses.  If an extension is not specified, (.txt) is
     added.

     ^b<scope>^b is the portion of the current database file to LIST.  The
     default is ALL records.

     ^bWHILE <lCondition>^b specifies the set of records meeting the
     condition from the current record until the condition fails.

     ^bFOR <lCondition>^b specifies the conditional set of records to LIST
     within the given scope.

     ^bOFF^b suppresses the display of record numbers.

 ^bDescription^b

     LIST is a console command that sequentially accesses records in the
     current work area, displaying the results of one or more expressions for
     each record accessed.  The output is in tabular format with each column
     separated by a space.  LIST is identical to DISPLAY with the exception
     that its default scope is ALL rather than NEXT 1.

     When invoked, output is sent to the screen and, optionally, to the
     printer and/or a file.  To suppress output to the screen while printing
     or echoing output to a file, SET CONSOLE OFF before the LIST invocation.

 ^bNotes^b

     ^b^CFE  Interrupting LIST:^b So the user may interrupt a LIST, use
        INKEY() as part of the FOR condition to test for an interrupt key
        press.  See the example below.

     ^b^CFE  Printer margin:^b LIST honors the current SET MARGIN for output
        echoed to the printer.

 ^bExamples^b

     ^b^CFE^b  In this example, a simple list is followed by a conditional
        list to the printer:

        USE Sales
        LIST DATE(), TIME(), Branch
        LIST Branch, Salesman FOR Amount > 500 TO PRINTER

     ^b^CFE^b  This example interrupts LIST using INKEY() to test whether the
        user pressed the Esc key:

        #define K_ESC     27
        USE Sales INDEX Salesman NEW
        LIST Branch, Salesman, Amount WHILE INKEY() != K_ESC

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "?|??" "DISPLAY" 
'------------------------------------------------------------------------------



!short: LOCATE          Search sequentially for a record matching a condition
'------------------------------------------------------------------------------
 ^bLOCATE^b
 Search sequentially for a record matching a condition
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bLOCATE [<scope>] FOR <lCondition>
     ^b   [WHILE <lCondition>]

 ^bArguments^b

     ^b<scope>^b is the portion of the current database file in which to
     perform the LOCATE.  The default scope is ALL records.

     ^bFOR <lCondition>^b specifies the next record to LOCATE within the
     given scope.

     ^bWHILE <lCondition>^b specifies the set of records meeting the
     condition from the current record until the condition fails.

 ^bDescription^b

     LOCATE is a database command that searches for the first record in the
     current work area that matches the specified conditions and scope.  When
     you first execute a LOCATE, it searches from the beginning record of the
     scope for the first matching record in the current work area.  It
     terminates when a match is found or the end of the LOCATE scope is
     reached.  If it is successful, the matching record becomes the current
     record and FOUND() returns true (.T.).  If it is unsuccessful, FOUND()
     returns false (.F.) and the positioning of the record pointer depends on
     the controlling scope of the LOCATE.

     Each work area can have its own LOCATE condition.  The condition remains
     active until you execute another LOCATE command in that work area or the
     application terminates.

     LOCATE works with CONTINUE.  Once a LOCATE has been issued, you can
     resume the search from the current record pointer position with
     CONTINUE.  There are, however, some exceptions.  See note below.

 ^bNotes^b

     ^b^CFE  CONTINUE:^b Both the <scope> and the WHILE condition apply only
        to the initial LOCATE and are not operational for any subsequent
        CONTINUE commands.  To continue a pending LOCATE with a scope or
        WHILE condition, use SKIP then LOCATE REST WHILE <lCondition> instead
        of CONTINUE.

 ^bExamples^b

     ^b^CFE^b  These examples show typical LOCATEs:

        USE Sales INDEX Salesman
        LOCATE FOR Branch = "200"
        ? FOUND(), EOF(), RECNO()         // Result: .T. .F. 5
        LOCATE FOR Branch = "5000"
        ? FOUND(), EOF(), RECNO()         // Result: .F. .T. 85

     ^b^CFE^b  This example shows a LOCATE with a WHILE condition that is
        continued by using LOCATE REST:

        SEEK "Bill"
        LOCATE FOR Branch = "200" WHILE Salesman = "Bill"
        DO WHILE FOUND()
           ? Branch, Salesman
           SKIP
           LOCATE REST FOR Branch = "200" WHILE ;
                    Salesman = "Bill"
        ENDDO

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CONTINUE" c52g_001.ngo:"EOF()" c52g_001.ngo:"FOUND()" "SEEK" "SET FILTER" 
'------------------------------------------------------------------------------



!short: MENU TO         Execute a lightbar menu for defined PROMPTs                 ^r^CE4^r
'------------------------------------------------------------------------------
 ^bMENU TO^b
 Execute a lightbar menu for defined PROMPTs
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bMENU TO <idVar>

 ^bArguments^b

     ^b<idVar>^b is the name of the variable to assign the result of the menu
     selection.  If the specified variable is not visible or does not exist,
     a private variable is created and assigned the result.

 ^bDescription^b

     MENU TO is the selection mechanism for the CA-Clipper lightbar menu
     system.  Before invoking MENU TO, first define the menu items and
     associated MESSAGEs with a series of @...PROMPT commands.  Then,
     activate the menu with MENU TO <idVar>.  If <idVar> does not exist or is
     not visible, MENU TO creates it as a private variable and places the
     highlight on the first menu item.  If <idVar> does exist, its initial
     value determines the first menu item highlighted.

 ^bNotes^b

     ^b^CFE  Color:^b Menu items are painted in the current standard color
        with the highlighted menu item appearing in the current enhanced
        color.

     ^b^CFE  Navigation and selection:^b Pressing the arrow keys moves the
        highlight to the next or previous menu item.  As each menu item is
        highlighted the associated MESSAGE displays on the row specified with
        SET MESSAGE.  If WRAP is ON, an Uparrow from the first menu item
        moves the highlight to the last menu item.  Also, a Dnarrow from the
        last menu item moves the highlight to the first.

        To make a selection, press Return or the first character of a menu
        item.  MENU TO then returns the position of the selected menu item as
        a numeric value into the specified memory variable.  Pressing Esc
        aborts the menu selection and returns zero.  The table below
        summarizes the active keys within MENU TO.

     ^b^CFE  SET KEY procedures:^b A MENU TO command can be nested within a
        SET KEY procedure invoked within a menu without clearing the pending
        PROMPTs.

        ^bMENU TO Active Keys^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bKey            Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        Uparrow        Move to previous menu item
        Dnarrow        Move to next menu item
        Home           Move to first menu item
        End            Move to last item menu item
        Leftarrow      Move to previous menu item
        Rightarrow     Move to next menu item
        PgUp           Select menu item, returning position
        PgDn           Select menu item, returning position
        Return         Select menu item, returning position
        Esc            Abort selection, returning zero
        First letter   Select first menu item with same first letter,
                       returning position
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bExamples^b

     ^b^CFE^b  This example creates a simple vertical lightbar menu with
        messages appearing centered on line 23.  When invoked, the highlight
        defaults to the second menu item based on the initial value of
        nChoice:

        LOCAL nChoice := 2
        SET WRAP ON
        SET MESSAGE TO 23 CENTER
        @ 6, 10 PROMPT "Add"  MESSAGE "New Acct"
        @ 7, 10 PROMPT "Edit" MESSAGE "Change Acct"
        @ 9, 10 PROMPT "Quit" MESSAGE "Return to DOS"
        MENU TO nChoice
        //
        DO CASE
        CASE nChoice = 0
           QUIT
        CASE nChoice = 1
           NewAccount()
        CASE nChoice = 2
           ChangeAccount()
        CASE nChoice = 3
           QUIT
        ENDCASE
        RETURN

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...PROMPT" c52g_001.ngo:"ACHOICE()" "SET MESSAGE" "SET WRAP" 
'------------------------------------------------------------------------------



!short: NOTE*           Place a single-line comment in a program file
'------------------------------------------------------------------------------
 ^bNOTE*^b
 Place a single-line comment in a program file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bNOTE [<commentText>]

 ^bArguments^b

     ^b<commentText>^b is a string of characters placed after the comment
     indicator.

 ^bDescription^b

     NOTE is command synonym for the single-line comment indicator (*).  All
     characters after NOTE are ignored until the CA-Clipper compiler
     encounters an end of line (carriage return/linefeed).  This means a
     single-line comment cannot be continued with the semicolon onto a new
     line.

     If you need a multiline comment, begin the comment block with a
     slash-asterisk (/*) symbol and end the comment block with an
     asterisk-slash (*/) symbol.  If you need to comment out a block of
     code, use the conditional compilation directives #ifdef...#endif
     instead of multiline comments.  This is important since nested comments
     are illegal.

     NOTE is a compatibility command and therefore not recommended.  It is
     superseded by the C-style comment symbols slash-asterisk (/*) and
     asterisk-slash (*/), as well as the double-slash (//).  It is also
     superseded by the dBASE-style comment symbols, asterisk (*) and the
     double-ampersand (&&).

     For a complete discussion on comment indicators, refer to the Basic
     Concepts chapter in the Programming and Utilities guide.

 ^bExamples^b

     ^b^CFE^b  These examples show the various comment symbols supported by
        CA-Clipper:

        // This is a comment
        /* This is a comment */
        * This is a comment
        && This is a comment
        NOTE This is a comment

!seealso: 
'------------------------------------------------------------------------------



!short: PACK            Remove deleted records from a database file
'------------------------------------------------------------------------------
 ^bPACK^b
 Remove deleted records from a database file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bPACK

 ^bDescription^b

     PACK is a database command that removes all records marked for deletion
     from the current database file, REINDEXes all active indexes in the
     current work area, and recovers all the physical space occupied by the
     deleted records.  During its operation, PACK does not create any backup
     files, although the associated REINDEX operation may.  After the PACK
     command terminates, the record pointer is reset to the first logical
     record in the current work area.

     In a network environment, PACK requires the current database be USEd
     EXCLUSIVEly.  If this condition is not met when PACK is invoked,
     CA-Clipper generates a runtime error.

     Note that PACKing large database files can be a time-consuming process
     and may not be feasible in a high-volume transaction system on a
     network.  By modifying the system design, you can remove the necessity
     of physically removing records from the database file altogether.  See
     the Network Programming chapter in the Programming and Utilities guide
     for more information.

 ^bExamples^b

     ^b^CFE^b  The following shows the result of a simple PACK:

        USE Sales NEW
        ? LASTREC()                  // Result: 84
        //
        DELETE RECORD 4
        PACK
        ? LASTREC()                  // Result: 83

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DELETE" c52g_001.ngo:"DELETED()" c52g_001.ngo:"FLOCK()" "RECALL" "REINDEX" "ZAP" 
'------------------------------------------------------------------------------



!short: QUIT            Terminate program processing
'------------------------------------------------------------------------------
 ^bQUIT^b
 Terminate program processing
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bQUIT | CANCEL*

 ^bDescription^b

     QUIT and CANCEL both terminate program processing, close all open files,
     and return control to the operating system.  Each of these commands can
     be used from anywhere in a program system.  A RETURN executed at the
     highest level procedure or a BREAK, with no pending SEQUENCE, also QUITs
     the program.

 ^bNotes^b

     ^b^CFE  Return code:^b When a CA-Clipper program terminates, the return
        code is set to 1 if the process ends with a fatal error.  If the
        process ends normally the return code is set to zero or the last
        ERRORLEVEL() set in the program.

 ^bExamples^b

     ^b^CFE^b  This example uses QUIT in a dialog box:

        IF DialogYesNo(10, 10, "Quit to DOS", "BG+/B,B/W", 2)
           QUIT
        ENDIF
        RETURN

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_004.ngo:"BEGIN SEQUENCE" c52g_001.ngo:"ERRORLEVEL()" c52g_004.ngo:"RETURN" 
'------------------------------------------------------------------------------



!short: READ            Activate full-screen editing mode using Get objects
'------------------------------------------------------------------------------
 ^bREAD^b
 Activate full-screen editing mode using Get objects
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bREAD [SAVE]

 ^bArguments^b

     ^bSAVE^b retains the contents of the current GetList after the READ
     terminates.  Later, you can edit the same Get objects by issuing another
     READ.  If not specified, the current GetList is assigned an empty array
     deleting all of the previous Get objects when the READ terminates.

 ^bDescription^b

     READ executes a full-screen editing mode using all Get objects created
     and added to the current GetList since the most recent CLEAR, CLEAR
     GETS, CLEAR ALL or READ commands.  If there is a format procedure
     active, READ executes that procedure before entering the full-screen
     editing mode.

     Within a READ, the user can edit the buffer of each Get object as well
     as move from one Get object to another.  Before the user can enter a Get
     object, control passes to the associated WHEN <lPreCondition> if one has
     been assigned to that Get object.  If <lPreCondition> returns true
     (.T.), the user is allowed to edit the buffer of the Get object.
     Otherwise control passes to the next Get object in the GetList.  Within
     a GET buffer, the user can edit using the full complement of editing and
     navigation keys.  See the tables below.

     When the user presses a GET exit key, control passes to the associated
     RANGE or VALID postcondition if one has been specified.  If either
     condition returns true (.T.) editing of the Get object is terminated and
     control passes to the next Get object.  Otherwise, control remains
     within the current Get object until a valid value is entered or the user
     presses the Esc key.

     When the user successfully enters a value into a Get object, the
     associated variable is assigned the value of the Get object's buffer.

     The following tables list active keys within a READ:

     ^bREAD Navigation Keys^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bKey                                     Action^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Leftarrow, Ctrl-S                       Character left.  Does not move
                                             cursor to previous GET
     Rightarrow, Ctrl-D                      Character right.  Does not move
                                             cursor to next GET
     Ctrl-Leftarrow, Ctrl-A                  Word left
     Ctrl-Rightarrow, Ctrl-F                 Word right
     Uparrow, Shift-Tab, Ctrl-E              Previous GET
     Dnarrow, Tab, Ctrl-X, Return, Ctrl-M    Next GET
     Home                                    First character of GET
     End                                     Last character of GET
     Ctrl-Home                               Beginning of first GET
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^bREAD Editing Keys^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bKey                 Action^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Del, Ctrl-G         Delete character at cursor position
     Backspace, Ctrl-H   Destructive backspace
     Ctrl-T              Delete word right
     Ctrl-Y              Delete from cursor position to end of GET
     Ctrl-U              Restore current GET to original value
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^bREAD Toggle Keys^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bKey                 Action^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Ins, Ctrl-V         Toggle insert mode
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^bREAD Exit Keys^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bKey                           Action^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Ctrl-W, Ctrl-C, PgUp, PgDn    Terminate READ saving current GET
     Return, Ctrl-M                Terminate READ from last GET
     Esc                           Terminate READ without saving current GET
     Uparrow                       Terminate READ from first GET if
                                   READEXIT()=.T.
     Dnarrow                       Terminate READ from last GET if
                                   READEXIT()=.T.
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bNotes^b

     ^b^CFE  Nested READs:^b To perform a nested READ within a SET KEY,
        VALID, or WHEN procedure or user-defined function, declare or create
        a new GetList, perform a series of @...GET statements, then READ.
        When the procedure terminates, the new GetList is released and the
        previous GetList becomes visible again.  See the example below.

     ^b^CFE  Quick keys:^b Pressing Home or End in quick succession goes to
        the first or last nonblank character in a Get object's buffer.

     ^b^CFE  Terminating a READ:^b A READ is terminated by executing a BREAK,
        CLEAR, CLEAR GETS, or CLEAR ALL from within a SET KEY procedure or a
        user-defined function initiated by VALID.

     ^b^CFE  UPDATED():^b If any Get object buffer was changed during the
        current READ, UPDATED() is set to true (.T.).

 ^bExamples^b

     ^b^CFE^b  This example defines several GETs then READs them:

        CLEAR
        cVar1 := cVar2 := cVar3 := SPACE(10)
        @ 10, 10 SAY "Variable one:" GET cVar1 VALID ;
              !EMPTY(cVar1)
        @ 11, 10 SAY "Variable two:" GET cVar2 ;
                 WHEN RTRIM(cVar1) !=  "One"
        @ 12, 10 SAY "Variable three:" GET cVar3 VALID ;
                 !EMPTY(cVar3)
        READ

     ^b^CFE^b  This example performs a nested READ within a SET KEY, WHEN, or
        VALID procedure or user-defined function:

        LOCAL cName := SPACE(10)
        @ 10, 10 GET cName VALID SubForm( cName )
        READ
        RETURN

        FUNCTION SubForm( cLookup )
           LOCAL GetList := {}        // Create new GetList
           USE Sales INDEX Salesman NEW
           SEEK cLookup
           IF FOUND()
              @ 15, 10 GET Salesman   // Add Get objects to
              @ 16, 10 GET Amount     // new GetList
              READ                    // READ from new GetList
           ENDIF
           CLOSE Sales
           RETURN .T.                 // Release new GetList

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...GET" "CLEAR GETS" c52g_001.ngo:"LASTKEY()" c52g_001.ngo:"READEXIT()" c52g_001.ngo:"READMODAL()" 
'------------------------------------------------------------------------------



!short: RECALL          Restore records marked for deletion
'------------------------------------------------------------------------------
 ^bRECALL^b
 Restore records marked for deletion
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bRECALL [<scope>] [WHILE <lCondition>]
     ^b   [FOR <lCondition>]

 ^bArguments^b

     ^b<scope>^b is the portion of the current database file to RECALL.  The
     default scope is the current record, or NEXT 1.  If a condition is
     specified, the default scope becomes ALL.

     ^bWHILE <lCondition>^b specifies the set of records meeting the
     condition from the current record until the condition fails.

     ^bFOR <lCondition>^b specifies the conditional set of records to RECALL
     within the given scope.

 ^bDescription^b

     RECALL is a database command that restores records marked for deletion
     in the current work area.  This is the inverse of the DELETE command.
     If DELETED is ON, RECALL can restore the current record or a specific
     record, if you specify a RECORD scope.  Note that once you PACK a
     database file, all marked records have been physically removed from the
     file and cannot be recovered.

     In a network environment, RECALLing the current record requires an
     RLOCK().  RECALLing several records requires an FLOCK() or EXCLUSIVE USE
     of the current database file.  Refer to the Network Programming chapter
     in the Programming and Utilities guide for more information.

 ^bExamples^b

     ^b^CFE^b  This examples show the results of RECALL:

        USE Sales NEW
        //
        DELETE RECORD 4
        ? DELETED()               // Result: .T.
        //
        RECALL
        ? DELETED()               // Result: .F.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DELETE" c52g_001.ngo:"DELETED()" c52g_001.ngo:"FLOCK()" "PACK" c52g_001.ngo:"RLOCK()" "SET DELETED" 
'------------------------------------------------------------------------------



!short: REINDEX         Rebuild open indexes in the current work area               ^r^CE4^r
'------------------------------------------------------------------------------
 ^bREINDEX^b
 Rebuild open indexes in the current work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bREINDEX
     ^b[EVAL <lCondition>]
     ^b[EVERY <nRecords>]]

 ^bArguments^b

     ^bEVAL <lCondition>^b specifies a condition that is evaluated either for
     each record processed or at the interval specified by the EVERY clause.
     This clause is identical to the EVAL clause of the INDEX command, but
     must be respecified in order for the reindexing operation to be
     monitored since the value of <lCondition> is transient.

     ^bEVERY <nRecords>^b specifies a numeric expression that modifies how
     often EVAL is evaluated.  When using EVAL, the EVERY option offers a
     performance enhancement by evaluating the condition for every nth record
     instead of for each record reindexed.  The EVERY keyword is ignored if
     no EVAL condition is specified.

 ^bDescription^b

     REINDEX is a database command that rebuilds all open indexes in the
     current work area.  When the reindexing operation finishes, all rebuilt
     indexes remain open, order is reset to one, and the record pointer is
     positioned to the first record in the controlling index.  If any of the
     indexes were created with SET UNIQUE ON, REINDEX adds only unique keys
     to the index.  If any of the indexes were created using a FOR condition,
     only those key values from records matching the condition are added to
     the index.

     In a network environment, REINDEX requires EXCLUSIVE USE of the current
     database file.  Refer to the Network Programming chapter in the
     Programming and Utilities guide for more information.

     ^bCaution! ^b REINDEX does not recreate the header of the index file
     when it recreates the index.  Because of this, REINDEX does not help if
     there is corruption of the file header.  To guarantee a valid index,
     always use INDEX ON in place of REINDEX to rebuild damaged indexes

 ^bNotes^b

     Index key order, UNIQUE status, and the FOR condition are known to the
     (.ntx) file and are, therefore, respected and maintained by REINDEX.

 ^bExamples^b

     ^b^CFE^b  This example REINDEXes the index open in the current work
        area:

        USE Sales INDEX Salesman, Territory NEW
        REINDEX

     ^b^CFE^b  This example REINDEXes using a progress indicator:

        USE Sales INDEX Salesman, Territory NEW
        REINDEX EVAL NtxProgress() EVERY 10

        FUNCTION NtxProgress
        LOCAL cComplete := LTRIM(STR((RECNO()/LASTREC()) * 100))
        @ 23, 00 SAY "Indexing..." + cComplete + "%"
        RETURN .T.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "INDEX" "PACK" "SET INDEX" "USE" 
'------------------------------------------------------------------------------



!short: RELEASE         Delete public and private memory variables
'------------------------------------------------------------------------------
 ^bRELEASE^b
 Delete public and private memory variables
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bRELEASE <idMemvar list>
     ^bRELEASE ALL [LIKE | EXCEPT <skeleton>]

 ^bArguments^b

     ^b<idMemvar list>^b is a list of private or public variables or arrays
     to delete.

     ^bALL [LIKE|EXCEPT <skeleton>]^b defines the set of visible private
     memory variables to assign, or to exclude from assignment of, a NIL
     value.  <skeleton> is the wildcard mask to specify a group of memory
     variables to delete.  The wildcard characters supported are * and ?.

 ^bDescription^b

     RELEASE is a memory variable command that performs one of two actions
     depending on how it is specified.  If RELEASE is specified with
     <idMemvar list>, the specified public and private memory variables
     and/or arrays are deleted from memory.  Previous hidden instances
     (public or private variables defined in higher-level procedures) become
     accessible upon termination of the procedure where the variable was
     originally created.

     If RELEASE is specified with any form of the ALL clause, private memory
     variables created at the current procedure level are assigned a NIL and
     not deleted until the current procedure or user-defined function
     terminates.  Public variables are unaffected by this form of the RELEASE
     command.  To release public variables, you must RELEASE them explicitly
     or use CLEAR MEMORY.

     Local or static variables are not affected by the RELEASE command.
     Local variables are released automatically when the procedure or
     user-defined function where the variables were declared terminates.
     Static variables cannot be released since they exist for the duration
     of the program.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CLEAR MEMORY" c52g_004.ngo:"LOCAL" c52g_004.ngo:"PRIVATE" c52g_004.ngo:"PUBLIC" "QUIT" 
'------------------------------------------------------------------------------



!short: RENAME          Change the name of a file
'------------------------------------------------------------------------------
 ^bRENAME^b
 Change the name of a file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bRENAME <xcOldFile> TO <xcNewFile>

 ^bArguments^b

     ^b<xcOldFile>^b is the name of the file to rename including an extension
     and optionally preceded by a drive and/or path designator.  <xcOldFile>
     can be specified as a literal string or a character expression enclosed
     in parentheses.

     ^bTO <xcNewFile>^b specifies the new filename including extension and
     optionally prefaced by a drive and/or path designator.  <xcNewFile> can
     be specified as a literal string or a character expression enclosed in
     parentheses.

 ^bDescription^b

     RENAME is a file command that changes the name of a specified file to a
     new name.  If the source directory is different from the target
     directory, the file moves to the new directory.  RENAME does not use SET
     DEFAULT and SET PATH to locate <xcOldFile>.  Instead, the <xcOldFile> is
     renamed only if it is located in the current DOS directory or in the
     specified path.

     In the instance that either <xcNewFile> exists or is currently open,
     RENAME does nothing.  To trap this condition as an error, use the FILE()
     function before executing the command.  See the example below.

     ^bWarning! ^b Files must be CLOSEd before renaming.  Attempting to
     rename an open file will produce unpredictable results.  When a database
     file is RENAMEd, remember that any associated memo (.dbt) file must also
     be RENAMEd.  Failure to do so may compromise the integrity of your
     program.

 ^bExamples^b

     ^b^CFE^b  This example renames a file, checking for the existence of the
        target file before beginning the RENAME operation:

        xcOldFile := "OldFile.txt"
        xcNewFile := "NewFile.txt"
        IF !FILE(xcNewFile)
           RENAME (xcOldFile) TO (xcNewFile)
           ELSE
        ? "File already exists"
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "COPY FILE" c52g_001.ngo:"CURDIR()" "ERASE" c52g_001.ngo:"FILE()" c52g_001.ngo:"FERASE()" c52g_001.ngo:"FRENAME()" "RUN" 
'------------------------------------------------------------------------------



!short: REPLACE         Assign new values to field variables
'------------------------------------------------------------------------------
 ^bREPLACE^b
 Assign new values to field variables
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bREPLACE <idField> WITH <exp>
     ^b   [, <idField2> WITH <exp2>...]
     ^b   [<scope>] [WHILE <lCondition>] [FOR <lCondition>]

 ^bArguments^b

     ^b<idField>^b is the name of the field variable to assign a new value.
     If <idField> is prefaced with an alias, the assignment takes place in
     the designated work area.

     ^bWITH <exp>^b defines the value to assign to <idField>.

     ^b<scope>^b is the portion of the current database file to REPLACE.  The
     default is the current record, or NEXT 1.  Specifying a condition
     changes the default to ALL records in the current work area.

     ^bWHILE <lCondition>^b specifies the set of records meeting the
     condition from the current record until the condition fails.

     ^bFOR <lCondition>^b specifies the conditional set of records to REPLACE
     within the given scope.

 ^bDescription^b

     REPLACE is a database command that assigns new values to the contents of
     one or more field variables in the current record in the specified work
     areas.  The target field variables can be character, date, logical,
     memo, or numeric.  REPLACE performs the same function as the assignment
     operator (:=) except that it assumes that an unaliased reference is to a
     field variable.  This means that you can assign new values to field
     variables using assignment statements provided that the field variable
     references are prefaced with an alias, the FIELD alias, or declared
     using the FIELD declaration statement.

     The default scope of REPLACE is the current record unless a scope or
     condition is specified.  If a scope or condition is specified, the
     replace operation is performed on each record matching the scope and/or
     condition.

     ^bWarning!^b  When you REPLACE a key field, the index is updated and the
     relative position of the record pointer within the index is changed.
     This means that REPLACEing a key field with a scope or a condition may
     yield an erroneous result.  To update a key field, SET ORDER TO 0 before
     the REPLACE.  This insures that the record pointer moves sequentially in
     natural order.  All open indexes, however, are updated if the key field
     is REPLACEd.

     In a network environment, REPLACEing the current record requires an
     RLOCK().  REPLACEing with a scope and/or condition requires an FLOCK()
     or EXCLUSIVE USE of the current database file.  If a field is being
     REPLACEd in another work area by specifying its alias, that record must
     also be locked with an RLOCK().  Refer to the Network Programming
     chapter in the Programming and Utilities guide for more information.

 ^bExamples^b

     ^b^CFE^b  This example shows a simple use of REPLACE:

        USE Customer NEW
        APPEND BLANK
        USE Invoices NEW
        APPEND BLANK

        //
        REPLACE Charges WITH Customer->Markup * Cost,;
           Custid WITH Customer->Custid,;
           Customer->TranDate WITH DATE()

     ^b^CFE^b  Using assignment statements in place of the REPLACE command
        looks like this:

        FIELD->Charges := Customer->Markup * FIELD->Cost
        FIELD->Custid := Customer->Custid
        Customer->TranDate := DATE()

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "COMMIT" c52g_001.ngo:"FLOCK()" c52g_001.ngo:"RLOCK()" 
'------------------------------------------------------------------------------



!short: REPORT FORM     Display a report to the console
'------------------------------------------------------------------------------
 ^bREPORT FORM^b
 Display a report to the console
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bREPORT FORM <xcReport>
     ^b   [TO PRINTER] [TO FILE <xcFile>] [NOCONSOLE]
     ^b   [<scope>] [WHILE <lCondition>] [FOR <lCondition>]
     ^b   [PLAIN | HEADING <cHeading>] [NOEJECT] [SUMMARY]

 ^bArguments^b

     ^b<xcReport>^b is the name of the report form (.frm) file that contains
     the definition of the REPORT.  If an extension is not specified, (.frm)
     is assumed.  <xcReport> can be specified as a literal string or as a
     character expression enclosed in parentheses.

     ^bTO PRINTER^b echoes output to the printer.

     ^bTO FILE <xcFile>^b echoes output, without formfeed characters (ASCII
     12), to a file.  If a file extension is not specified, a (.txt) is
     added.  You can specify <xcFile> as a literal string or as a character
     expression enclosed in parentheses.

     ^bNOCONSOLE^b suppresses all REPORT FORM output to the console.  If not
     specified, output automatically displays to the console unless SET
     CONSOLE is OFF.

     ^b<scope>^b is the portion of the current database file to report.  The
     default scope is ALL.

     ^bWHILE <lCondition>^b specifies the set of records meeting the
     condition from the current record until the condition fails.

     ^bFOR <lCondition>^b specifies the conditional set of records to report
     within the given scope.

     ^bPLAIN^b suppresses the display of the date and page number, and causes
     the report to print without page breaks.  In addition, the report title
     and column headings display only at the top of the report.

     ^bHEADING^b places the result of <cHeading> on the first line of each
     page.  <cHeading> is evaluated only once at the beginning of the report,
     before the record pointer is moved.  If both PLAIN and HEADING are
     specified, PLAIN takes precedence.

     ^bNOEJECT^b suppresses the initial page eject when the TO PRINTER clause
     is used.

     ^bSUMMARY^b causes the REPORT FORM to display only group, subgroup, and
     grand total lines.  Detail lines are suppressed.

 ^bDescription^b

     REPORT FORM is a console command that sequentially accesses records in
     the current work area displaying a tabular, and optionally grouped
     report with page and column headings from a definition held in a (.frm)
     file.  The actual REPORT FORM file (.frm) is created using RL.EXE or
     dBASE III PLUS.  Refer to the Report and Label Utility chapter in the
     Programming and Utilities guide for more information about creating
     report definitions.

     When invoked, REPORT FORM sends output to the screen and, optionally, to
     the printer and/or a file.  To suppress output to the screen while
     printing or echoing output to a file, SET CONSOLE OFF before the REPORT
     FORM invocation.

     When invoked, REPORT FORM searches the current SET PATH drive and
     directory if the <xcReport> file is not found in the current directory
     and the path is not specified.

 ^bNotes^b

     ^b^CFE  Interrupting REPORT FORM:^b To allow the user to interrupt a
        REPORT FORM, use INKEY(), to test for an interrupt key press, as a
        part of the FOR condition .  See the example below.

     ^b^CFE  Printer margin:^b REPORT FORM obeys the current SET MARGIN value
        for output echoed to the printer.

     ^b^CFE  Forcing formfeed characters into an output file:^b To include
        formfeed characters when sending a REPORT FORM TO FILE, redirect
        printer output to a file using SET PRINTER like this:

        SET PRINTER TO <xcFile>
        REPORT FORM <xcReport> TO PRINTER
        SET PRINTER TO

     ^b^CFE  Reporting in a network environment:^b REPORT FORM commands
        executed in a network environment can be affected by changes made to
        database files by other users while the report is in progress.  For
        example, if a user changes a key value from "A" to "Z" while the
        report is printing, the same record could appear twice.

 ^bExamples^b

     ^b^CFE^b  This example uses both a literal and an extended expression to
        execute a REPORT FORM:

        LOCAL xcReport := "Sales"
        USE Sales INDEX Sales NEW
        REPORT FORM Sales TO PRINTER FOR Branch = "100";
                  HEADING "Branch 100"
        REPORT FORM (xcReport) TO PRINTER FOR Branch != "100"

     ^b^CFE^b  This example interrupts a REPORT FORM using INKEY() to test
        whether the user has pressed the Esc key:

        #define K_ESC  27
        USE Sales INDEX Sales NEW
        REPORT FORM Sales WHILE INKEY() != K_ESC

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "LABEL FORM" "LIST" 
'------------------------------------------------------------------------------



!short: RESTORE         Retrieve memory variables from a memory (.mem) file         ^r^CE4^r
'------------------------------------------------------------------------------
 ^bRESTORE^b
 Retrieve memory variables from a memory (.mem) file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bRESTORE FROM <xcMemFile> [ADDITIVE]

 ^bArguments^b

     ^b<xcMemFile>^b is the memory (.mem) file to load from disk.  If an
     extension is not specified, the extension (.mem) is assumed.  The
     filename may be specified as a literal string or as a character
     expression enclosed in parentheses.

     ^bADDITIVE^b causes memory variables loaded from the memory file to be
     added to the existing pool of memory variables.

 ^bDescription^b

     RESTORE is a memory variable command that recreates public and private
     variables previously SAVEd to a memory (.mem) file and initializes them
     with their former values.  The scope of the variable is not SAVEd with
     the variable but is instead established when the variable is RESTOREd.
     Arrays and local variables cannot be SAVEd or RESTOREd.

     When memory variables are RESTOREd, they are recreated as private
     variables with the scope of the current procedure or user-defined
     function unless they exist as public variables and you specify the
     ADDITIVE clause .  If ADDITIVE is specified, public and private
     variables with the same names are overwritten unless hidden with
     PRIVATE.  If ADDITIVE is not specified, all public and private variables
     are released before the memory file is loaded.

     Local and static variables are unaffected by RESTORE.  If a local or
     static variable has been declared in the current procedure or
     user-defined function, and a variable with the same name is RESTOREd,
     only the local or static variable is visible unless references to the
     RESTOREd variable are prefaced with the MEMVAR alias.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a typical application of SAVE and
        RESTORE.  Here memory variables containing screens are SAVEd TO and
        RESTOREd FROM memory files:

        // Create and use a pseudoarray of screens
        SAVE SCREEN TO cScreen1
        SAVE ALL LIKE cScreen* TO Screens
        //
        <statements>...
        //
        RESTORE FROM Screens ADDITIVE
        nNumber = "1"
        RESTORE SCREEN FROM ("cScreen" + nNumber)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_004.ngo:"LOCAL" c52g_004.ngo:"PRIVATE" c52g_004.ngo:"PUBLIC" "SAVE" 
'------------------------------------------------------------------------------



!short: RESTORE SCREEN* Display a saved screen
'------------------------------------------------------------------------------
 ^bRESTORE SCREEN*^b
 Display a saved screen
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bRESTORE SCREEN [FROM <cScreen>]

 ^bArguments^b

     ^bFROM <cScreen>^b specifies a character expression to display to the
     screen.

 ^bDescription^b

     RESTORE SCREEN is a command synonym for the RESTSCREEN() function that
     redisplays a previously saved screen, and is used with SAVE SCREEN to
     avoid repainting the original screen painted with @...SAY, @...GET, and
     ? commands.

     RESTORE SCREEN works in two ways depending on whether or not you specify
     the FROM clause .  If the you specify the FROM clause, the SCREEN is
     RESTOREd FROM <cScreen>.  <cScreen> is a character expression, usually a
     variable assigned a screen image by SAVE SCREEN.  If you do not specify
     the FROM clause, the SCREEN is RESTOREd from the default save screen
     buffer created by SAVE SCREEN specified without the TO clause.

     SAVESCREEN() and RESTORESCREEN() functions supersede SAVE SCREEN and
     RESTORE SCREEN commands.

     RESTORE SCREEN is a compatibility command and not recommended.

     ^bWarning! ^b SAVE SCREEN, RESTORE SCREEN, SAVESCREEN(), and
     RESTSCREEN() are supported when using the default (IBM PC memory mapped)
     screen driver.  Other screen drivers may not support saving and
     restoring screens.

 ^bExamples^b

     ^b^CFE^b  This example displays a small alert popup box using SAVE and
        RESTORE SCREEN:

        IF FileAlert()
           COPY FILE Them.txt TO My.txt
        ELSE
           BREAK
        ENDIF
        RETURN

        FUNCTION FileAlert
           LOCAL lAnswer := .F., cScreen
           SAVE SCREEN TO cScreen
           @ 10, 10 CLEAR TO 12, 45
           @ 10, 10 TO 12, 45 DOUBLE
           @ 11, 12 SAY "File exists, overwrite? (y/n) ";
                  GET lAnswer PICTURE "Y"
           READ
           RESTORE SCREEN FROM cScreen
           RETURN lAnswer

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "RESTORE" c52g_001.ngo:"RESTSCREEN()" "SAVE" c52g_001.ngo:"SAVESCREEN()" 
'------------------------------------------------------------------------------



!short: RUN             Execute a DOS command or program
'------------------------------------------------------------------------------
 ^bRUN^b
 Execute a DOS command or program
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bRUN | !* <xcCommandLine>

 ^bArguments^b

     ^b<xcCommandLine>^b is any executable program including resident DOS
     commands and COMMAND.COM.  It may be specified either as a literal
     string or as a character expression enclosed in parentheses.

 ^bDescription^b

     RUN executes a DOS command or program from within a compiled
     application.  When you RUN a DOS program, CA-Clipper executes another
     copy of COMMAND.COM, passing the DOS command line at the same time.
     This has two implications.  First, you must have enough memory for
     COMMAND.COM (27K for DOS 3.2) and the program you wish to execute.
     Second, COMMAND.COM must be available on the path specified by COMSPEC
     (the default is the root directory of the disk where you boot DOS).  If
     COMMAND.COM is not located on this disk or the disk is changed, SET
     COMSPEC to the new location prior to running the CA-Clipper application.
     Note that SET DEFAULT and SET PATH have no effect on RUN.

     The ! form of the RUN command is provided for compatibility purposes
     only and therefore not recommended.

     ^bWarning! ^b Do not RUN memory-resident programs from within CA-Clipper
     since you may lose memory when the control returns to your application
     program.

 ^bExamples^b

     ^b^CFE^b  This example uses RUN with MEMOREAD() and MEMOWRIT() to create
        a user-defined function that calls a text editor with the current
        memo field:

        lSuccess = EditorMemo("Qedit", "Notes")
        RETURN

        FUNCTION EditorMemo( cEditor, cMemofld )
           IF MEMOWRIT("Clipedit.tmp", &cMemofld.)
              RUN (cEditor + " Clipedit.tmp")
              REPLACE &cMemofld. WITH MEMOREAD("Clipedit.tmp")
              ERASE Clipedit.tmp
              RETURN .T.
           ELSE
              RETURN .F.
           ENDIF

     ^b^CFE^b  One of the options you may want to give your users is direct
        access to DOS.  Do this with:

        RUN COMMAND

        To make it easier for the user to return to the application program,
        change the DOS prompt in the application batch file like this:

        REM Application Batch File
        ECHO OFF
        PROMPT DOS Access: Type EXIT to return to ;
                 application$_$p$g
        <your application program>
        PROMPT $p$g

        Then, instruct the user to execute the application batch file in
        place of the application .EXE file.

 ^bFiles:^b  Library is CLIPPER.LIB.

!seealso: 
'------------------------------------------------------------------------------



!short: SAVE            Save variables to a memory (.mem) file
'------------------------------------------------------------------------------
 ^bSAVE^b
 Save variables to a memory (.mem) file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSAVE TO <xcMemFile> [ALL [LIKE | EXCEPT <skeleton>]]

 ^bArguments^b

     ^b<xcMemFile>^b is the memory (.mem) file to SAVE to disk.  You may
     specify the filename as a literal string or as a character expression
     enclosed in parentheses.  If you specify no extension, the file is
     created with a (.mem) extension.

     ^bALL [LIKE|EXCEPT <skeleton>]^b defines the set of visible private and
     public memory variables to save to <xcMemFile>.  <skeleton> is the
     wildcard mask that characterizes a group of memory variables to SAVE.
     The wildcard characters supported are * and ?.

 ^bDescription^b

     SAVE copies public and private memory variables visible within the
     current procedure or user-defined function to a memory (.mem) file.
     Arrays and local and static variables, however, cannot be SAVEd.  When
     variables are SAVEd, they are copied without any reference to scope.
     Variables hidden by PRIVATE or LOCAL declarations are not SAVEd.

     If you specify the ALL LIKE clause, variable names matching the
     <skeleton> mask are saved.  By contrast, if you specify ALL EXCEPT,
     variable names not matching the <skeleton> are saved.

     You can specify a <skeleton> that includes wildcard characters.  The
     wildcard character * matches any group of adjacent characters ending a
     variable name and can be specified only at the end of the <skeleton>.
     The wildcard character ? matches any single character and can be
     specified anywhere within the <skeleton>.

 ^bExamples^b

     ^b^CFE^b  This example saves all visible private and public variables to
        Temp.mem:

        PRIVATE cOne := "1"
        SAVE ALL TO Temp

     ^b^CFE^b  This example saves all visible private and public variables
        with names beginning with c to Myvars.mem:

        SAVE ALL LIKE c* TO MyVars

     ^b^CFE^b  This example saves all visible private and public variables
        with names that do not begin with c to Myvars2.mem:

        SAVE ALL EXCEPT c* TO MyVars2

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_004.ngo:"LOCAL" c52g_004.ngo:"PRIVATE" c52g_004.ngo:"PUBLIC" "RESTORE" 
'------------------------------------------------------------------------------



!short: SAVE SCREEN*    Save current screen to a buffer or variable
'------------------------------------------------------------------------------
 ^bSAVE SCREEN*^b
 Save current screen to a buffer or variable
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSAVE SCREEN [TO <idVar>]

 ^bArguments^b

     ^bTO <idVar>^b specifies a variable to contain the current screen
     contents as a character value.  If <idVar> is not visible or does not
     exist, a private memory variable is created and assigned to the screen.

 ^bDescription^b

     SAVE SCREEN is a command synonym for the SAVESCREEN() function that
     saves the screen from 0, 0 to MAXROW(), MAXCOL() in a the default screen
     buffer, or an optional variable.  If the screen is saved to a variable,
     the variable can be any storage class including field, local, static, or
     an array element.  Note, however, you cannot SAVE an array or local or
     static variable to (.mem) files to save multiple screens to disk.

     SAVE SCREEN is used with RESTORE SCREEN to eliminate repainting an
     original screen that has been temporarily replaced.  You may save
     multiple screens by assigning each screen to a separate variable.

     SAVE SCREEN is a compatibility command and not recommended.  It is
     superseded by the SAVESCREEN() function which can save partial or full
     screens.

     ^bWarning! ^b SAVE SCREEN, RESTORE SCREEN, SAVESCREEN(), and
     RESTSCREEN() are supported when using the default (IBM PC memory mapped)
     screen driver.  Other screen drivers may not support saving and
     restoring screens.

 ^bExamples^b

     ^b^CFE^b  This code skeleton uses a static array to store saved screens:

        STATIC aScreens[10]
        SAVE SCREEN TO aScreens[1]
        //
        <statements>...
        //
        RESTORE SCREEN FROM aScreens[1]

     ^b^CFE^b  This example saves and restores screens using a database file:

        USE Screens INDEX Name NEW
        APPEND BLANK

        Screens->Name := "Screen001"          // Save the screen name
        SAVE SCREEN TO Screens->Image         // Save a new screen image
        //
        <statements>...
        //
        SEEK "Screen001"                      // Find the screen
        RESTORE SCREEN FROM Screens->Image    // Restore it

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "RESTORE" c52g_001.ngo:"RESTSCREEN()" "SAVE" c52g_001.ngo:"SAVESCREEN()" 
'------------------------------------------------------------------------------



!short: SEEK            Search an index for a specified key value
'------------------------------------------------------------------------------
 ^bSEEK^b
 Search an index for a specified key value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSEEK <expSearch>

 ^bArguments^b

     ^b<expSearch>^b is an expression to match with an index key.

 ^bDescription^b

     SEEK is a database command that searches the controlling index starting
     with the first key and proceeds until a match is found or there is a key
     value greater than <expSearch>.  If there is a match, the record pointer
     is positioned to the record number found in the index.  If SOFTSEEK is
     OFF (the default) and SEEK does not find a match, the record pointer is
     positioned to LASTREC() + 1, EOF() returns true (.T.), and FOUND()
     returns false (.F.).  If SOFTSEEK is ON, the record pointer is
     positioned to the record with the first key value greater than the
     search argument and FOUND() returns false (.F.).  In this case, EOF()
     only returns true (.T.) if there are no keys in the index greater than
     the search argument.

     SET EXACT has no effect on the operation of SEEK.

 ^bExamples^b

     ^b^CFE^b  This example illustrates the SEEK command:

        USE Sales INDEX Branch NEW
        SEEK "100"
        ? FOUND(), EOF(), RECNO()      // Result: .T. .F. 1

     ^b^CFE^b  This user-defined function performs an exact SEEK for an index
        with a character key:

        USE Invoice INDEX Invoice NEW
        IF SeekExact("10001")
           ? "Invoice on file"
        ELSE

           ? "Invoice not on file"
        ENDIF
        RETURN

        FUNCTION SeekExact( cSearch )
           SEEK PADR(cSearch, LEN(&(INDEXKEY(0))))
           RETURN (FOUND())

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"EOF()" c52g_001.ngo:"FOUND()" "SET SOFTSEEK" c52g_001.ngo:"DBSEEK()" 
'------------------------------------------------------------------------------



!short: SELECT          Change the current work area
'------------------------------------------------------------------------------
 ^bSELECT^b
 Change the current work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSELECT <xnWorkArea> | <idAlias>

 ^bArguments^b

     ^b<xnWorkArea>^b is the work area number between zero and 250 inclusive.
     This argument is an extended expression and can be specified either as a
     literal number or as a numeric expression enclosed in parentheses.

     ^b<idAlias>^b is the name of an existing work area to SELECT if there is
     a database file open in that area.

 ^bDescription^b

     SELECT is a database command that changes work areas.  CA-Clipper
     supports 250 work areas, with each work area a logical handle to an open
     database file and all of its attributes.  You can refer to work areas
     with SELECT by number or by alias.  The alias of a work area is
     automatically assigned when a database file is USEd in that work area or
     by using the ALIAS clause.

     Work area zero refers to the first empty or next available work area.
     Using this, you can SELECT 0 and USE <xcDatabase> as a method of opening
     database files.

 ^bNotes^b

     ^b^CFE  Aliased expressions:^b Aliased expressions are a much more
        powerful method of selecting new work areas than the SELECT command.
        Instead of SELECTing a work area then performing an operation for
        that work area, you can apply an alias to an expression that performs
        the operation.  This is done by specifying the alias of the remote
        work area and the expression enclosed in parentheses.  For example,
        to access the value of EOF() in an unselected work area, you would
        normally execute a series of statements like the following:

     SELECT Remote
        ? EOF()

        SELECT Main

        Using the aliased expression form, these statements become:

        ? Remote->(EOF())

     ^b^CFE  USE...NEW:^b Instead of using SELECT0 and USE <xcDatabase> to
        open a database file in a new work area, the preferred method is to
        USE <xcDatabase> NEW.

 ^bExamples^b

     ^b^CFE^b  This example opens a series of database files by SELECTing
        each work area by number then USEing each database file in that work
        area:

        SELECT 1
        USE Customer
        SELECT 2
        USE Invoices
        SELECT 3
        USE Parts
        SELECT Customer

     ^b^CFE^b  A better method is to open each database in the next available
        work area by specifying the NEW clause on the USE command line.  In
        this example USE...NEW is employed instead of SELECT0 then USE:

        USE Customer NEW
        USE Invoices NEW
        SELECT Customer

     ^b^CFE^b  This code fragment changes work areas while saving the current
        work area name to a variable using the SELECT() function.  After
        executing an operation for the new work area, the original work area
        is restored:

        nLastArea := SELECT()
        USE Newfile NEW
        //
        <statements>...
        //
        SELECT (nLastArea)

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"ALIAS()" c52g_001.ngo:"SELECT()" "SET INDEX" "USE" c52g_001.ngo:"USED()" 
'------------------------------------------------------------------------------



!short: SET ALTERNATE   Echo console output to a text file
'------------------------------------------------------------------------------
 ^bSET ALTERNATE^b
 Echo console output to a text file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET ALTERNATE TO [<xcFile> [ADDITIVE]]
     ^bSET ALTERNATE on | OFF | <xlToggle>

 ^bArguments^b

     ^bTO <xcFile>^b opens a standard ASCII text file for output with a
     default extension of (.txt).  The filename may optionally include an
     extension, drive letter, and/or path.  You may specify <xcFile> either
     as a literal filename or as a character expression enclosed in
     parentheses.  Note that if a file with the same name exists, it is
     overwritten.

     ^bADDITIVE^b causes the specified alternate file to appended to instead
     of overwritten.  If not specified, the specified alternate file is
     truncated before new information is written to it.

     ^bON^b causes console output to be written to the open text file.

     ^bOFF^b discontinues writing console output to the text file without
     closing the file.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     SET ALTERNATE is a console command that lets you write the output of
     console commands to a text file.  Commands such as LIST, REPORT FORM,
     LABEL FORM, and ? that display to the screen without reference to row
     and column position are console commands.  Most of these commands have a
     TO FILE clause that performs the same function as SET ALTERNATE.
     Full-screen commands such as @...SAY cannot be echoed to a disk file
     using SET ALTERNATE.  Instead you can use SET PRINTER TO <xcFile> with
     SET DEVICE TO PRINTER to accomplish this.

     SET ALTERNATE has two basic forms.  The TO <xcFile> form creates a DOS
     text file with a default extension of (.txt) and overwrites any other
     file with the same name.  Alternate files are not related to work areas
     with only one file open at a time.  To close an alternate file, use
     CLOSE ALTERNATE, CLOSE ALL, or SET ALTERNATE TO with no argument.

     The on|OFF form controls the writing of console output to the current
     alternate file.  SET ALTERNATE ON begins the echoing of output to the
     alternate file.  SET ALTERNATE OFF suppresses output to the alternate
     file but does not close it.

 ^bExamples^b

     ^b^CFE^b  This example creates an alternate file and writes the results
        of the ? command to the file for each record in the Customer database
        file:

        SET ALTERNATE TO Listfile
        SET ALTERNATE ON

        USE Customer NEW
        DO WHILE !EOF()
           ? Customer->Lastname, Customer->City
           SKIP
        ENDDO
        SET ALTERNATE OFF
        CLOSE ALTERNATE
        CLOSE Customer

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CLOSE" c52g_001.ngo:"FOPEN()" c52g_001.ngo:"FWRITE()" "SET CONSOLE" "SET PRINTER" 
'------------------------------------------------------------------------------



!short: SET BELL        Toggle bell sounding during full-screen operations
'------------------------------------------------------------------------------
 ^bSET BELL^b
 Toggle automatic sounding of the bell during full-screen operations
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET BELL on | OFF | <xlToggle>

 ^bArguments^b

     ^bON^b enables the BELL.

     ^bOFF^b disables the BELL.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     SET BELL is an environment command that toggles the sound of the bell.
     If SET BELL is ON, the bell sounds in the following situations:

     ^b^CFE^b  The user enters a character at the last position in a GET.

     ^b^CFE^b  The user attempts to enter invalid data into a GET.  The data
        is validated by the data type of the GET variable, the PICTURE
        template, and by the RANGE clause.  Violating a VALID condition does
        not sound the bell, regardless of the SET BELL status.

     To sound the bell explicitly, you can use either ?? CHR(7) or the TONE()
     function.  TONE() is perhaps more useful since you can vary both the
     pitch and duration of the sound.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...GET" c52g_001.ngo:"CHR()" "SET CONFIRM" c52g_001.ngo:"TONE()" 
'------------------------------------------------------------------------------



!short: SET CENTURY     Modify the date format to include or omit century digits
'------------------------------------------------------------------------------
 ^bSET CENTURY^b
 Modify the date format to include or omit century digits
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET CENTURY on | OFF | <xlToggle>

 ^bArguments^b

     ^bON^b allows input and display of the century digits for dates.

     ^bOFF^b suppresses the input and display of the century digits for
     dates.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     SET CENTURY modifies the current date format as set by SET DATE.  SET
     CENTURY ON changes the date format to contain four digits for the year.
     With the date format set to four digits for the year, date values
     display with a four-digit year, and dates of any century can be input.

     SET CENTURY OFF changes the date format to contain only two digits for
     the year.  With the date format set to only two digits for the year
     (CENTURY OFF), the century digits of dates are not displayed and cannot
     be input.

     Note that only the display and input format of dates is affected; date
     calculations maintain the century information regardless of the date
     format.

     CA-Clipper supports all dates in the range 01/01/0100 to 12/31/2999.

 ^bExamples^b

     ^b^CFE^b  This example shows the results of a simple SET CENTURY
        command:

        SET CENTURY OFF
        ? DATE()                  // Result: 09/15/90
        SET CENTURY ON
        ? DATE()                  // Result: 09/15/1990

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"CTOD()" c52g_001.ngo:"DATE()" c52g_001.ngo:"DTOC()" "SET DATE" "SET EPOCH" 
'------------------------------------------------------------------------------



!short: SET COLOR*      Define screen colors
'------------------------------------------------------------------------------
 ^bSET COLOR*^b
 Define screen colors
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET COLOR | COLOUR TO [[<standard>]
     ^b   [,<enhanced>] [,<border>] [,<background>]
     ^b   [,<unselected>]] | (<cColorString>)

 ^bArguments^b

     ^b<standard>^b is the color that paints all console, full-screen, and
     interface commands and functions when displaying to the screen.  This
     includes commands such as @...PROMPT, @...SAY, and ?; and functions such
     as ACHOICE(), DBEDIT(), and MEMOEDIT().

     ^b<enhanced>^b is the color that paints highlighted displays.  This
     includes GETs with INTENSITY ON, the MENU TO, DBEDIT(), and ACHOICE()
     selection highlight.

     ^b<border>^b is the color that paints the area around the screen that
     cannot be written to.

     ^b<background>^b is not currently supported by any machines for which
     Computer Associates provides drivers.  This setting is supplied for
     compatibility purposes only.

     ^b<unselected>^b is a color pair that provides input focus by displaying
     the current GET in the enhanced color while other GETs are displayed in
     this color.

     ^b<cColorString>^b is a character string enclosed in parentheses
     containing the color settings.  This facility lets you specify the color
     settings as an expression in place of a literal string or macro
     variable.

     SET COLOR TO with no argument restores the default colors to W/N, N/W,
     N, N, N/W.

 ^bDescription^b

     SET COLOR, a command synonym for the SETCOLOR() function, defines colors
     for subsequent screen painting activity.  Each SET COLOR command
     specifies a list of color settings for the five types of screen painting
     activity.  Each setting is a foreground and background color pair
     separated by the slash (/) character.  Foreground defines the color of
     characters displayed on the screen.  Background defines the color
     displayed behind the character.  Spaces and nondisplay characters
     display as background only.

     In addition to color, a foreground setting can have an attribute, high
     intensity or blinking.  With a monochrome display, high intensity
     enhances brightness of painted text.  With a color display, high
     intensity changes the hue of the specified color making it a different
     color.  For example, N displays foreground text as black where N+
     displays the same text as gray.  High intensity is denoted by +.  The
     blinking attribute causes the foreground text to flash on and off at a
     rapid interval.  Blinking is denoted with *.  An attribute character can
     occur anywhere in a setting, but is always applied to the foreground
     color regardless of where it occurs.

     Each color can be specified using either a letter or a number, but
     numbers and letters cannot be mixed within a setting.  Note that numbers
     are supplied for compatibility purposes and are not recommended.

     All settings are optional.  If a setting is skipped, its previous value
     is retained with only new values set.  Skipping a foreground or
     background color within a setting sets the color to black.

     The following colors are supported:

     ^bColor Table^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bColor          Letter    Number   Monochrome^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Black          N, Space  0        Black
     Blue           B         1        Underline
     Green          G         2        White
     Cyan           BG        3        White
     Red            R         4        White
     Magenta        RB        5        White
     Brown          GR        6        White
     White          W         7        White
     Gray           N+        8        Black
     Bright Blue    B+        9        Bright Underline
     Bright Green   G+        10       Bright White
     Bright Cyan    BG+       11       Bright White
     Bright Red     R+        12       Bright White
     Bright Magenta RB+       13       Bright White
     Yellow         GR+       14       Bright White
     Bright White   W+        15       Bright White
     Black          U                  Underline
     Inverse Video  I                  Inverse Video
     Blank          X                  Blank
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     SET COLOR is a compatibility command and not recommended.  It is
     superseded by the SETCOLOR() function which can return the current color
     as well as set a new color.

 ^bNotes^b

     ^b^CFE  Monochrome monitors:^b On monochrome monitors, color is not
        supported.  CA-Clipper, however, supports the monochrome attributes
        inverse video (I) and underlining (U).

     ^b^CFE  Screen drivers:^b SET COLOR TO, using numbers, may not be
        supported by other than the default screen driver.

 ^bExamples^b

     ^b^CFE^b  This example uses the unselected setting to make the current
        GET red on white while the rest are black on white:

        cColor:= "W/N,R/W,,,N/W"
        SET COLOR TO (cColor)
        cOne := cTwo := SPACE(10)

        @ 1, 1 SAY "Enter One: " GET cOne
        @ 2, 1 SAY "Enter Two: " GET cTwo
        READ

     ^b^CFE^b  In this example a user-defined function gets a password from
        the user using the blank (X) enhanced setting to hide the password as
        the user types:

        IF !DialogPassWord(12, 13, "W+/N", "FUNSUN", 3)
           ? "Sorry, your password failed"
           QUIT
        ENDIF

        FUNCTION DialogPassWord( nRow, nCol, ;
               cStandard, cPassword, nTries )
           LOCAL nCount := 1, cColor := SETCOLOR()
           SET COLOR TO (cStandard + ", X")      // Blank input
           //
           DO WHILE nCount < nTries
              cUserEntry:= SPACE(6)
              @ nRow, nCol SAY  "Enter password: " GET ;
                       cUserEntry
              READ
              //
              IF LASTKEY() == 27
                 SET COLOR TO (cColor)
                 RETURN .F.
              ELSEIF cUserEntry == cPassword
                 SET COLOR TO (cColor)
                 RETURN .T.
              ELSE
                 nCount++
              ENDIF
           ENDDO
           //
           SET COLOR TO (cColor)
           RETURN .F.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...GET" "@...SAY" c52g_001.ngo:"ISCOLOR()" c52g_001.ngo:"SETCOLOR()" c52g_001.ngo:"SETBLINK()" c52g_010.ngo:"Colors" 
'------------------------------------------------------------------------------



!short: SET CONFIRM     Toggle required exit key to terminate GETs
'------------------------------------------------------------------------------
 ^bSET CONFIRM^b
 Toggle required exit key to terminate GETs
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET CONFIRM on | OFF | <xlToggle>

 ^bArguments^b

     ^bON^b requires the user to press an exit key to leave a GET.

     ^bOFF^b allows the user to leave a GET by typing past the end without
     pressing an exit key.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     SET CONFIRM determines whether an exit key is required to leave a GET.
     If CONFIRM is OFF, the user can type past the end of a GET and the
     cursor will move to the next GET, if there is one.  If there isn't
     another GET, the READ terminates.  If, however, CONFIRM is ON, an exit
     key must be pressed to leave the current GET.

     In all cases, attempting to leave the current GET executes the RANGE or
     VALID clauses, unless the user presses the Esc key.

     See @...GET for more information on the behavior of GETs.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...GET" "READ" "SET BELL" 
'------------------------------------------------------------------------------



!short: SET CONSOLE     Toggle console display to the screen
'------------------------------------------------------------------------------
 ^bSET CONSOLE^b
 Toggle console display to the screen
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET CONSOLE ON | off | <xlToggle>

 ^bArguments^b

     ^bON^b displays the output of console commands on the screen.

     ^bOFF^b suppresses the screen display of console commands.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     SET CONSOLE determines whether or not console commands send output to
     the screen.  Console commands are commands that display to the screen
     without reference to row and column position.  In addition to sending
     output to the screen, console commands can simultaneously send output to
     the printer and/or a DOS text file.  Output is sent to the printer using
     the TO PRINTER clause common to many console commands, or with the SET
     PRINTER ON command.  Output is sent to a file using the TO FILE clause,
     SET ALTERNATE, or SET PRINTER TO.

     With CONSOLE ON, console commands display to the screen.  With CONSOLE
     OFF, the screen display of console commands is suppressed, but the
     echoing of output to either a file or the printer is unaffected.  This
     lets you send the output of console commands such as REPORT and LABEL
     FORM to the printer without the screen display--a common occurrence.

 ^bNotes^b

     ^b^CFE  Keyboard input:^b For console commands that accept input
        (including ACCEPT, INPUT, and WAIT), SET CONSOLE affects the display
        of the prompts as well as the input areas.  As a consequence, a SET
        CONSOLE OFF before one of these commands will not only prevent you
        from seeing what you type, but will also prevent the display of the
        message prompt.

     ^b^CFE  Full-screen commands:^b Full-screen commands such as @...SAY
        display to the screen independent of the current CONSOLE SETting.
        For this category of output commands, device control is performed
        using SET DEVICE to control whether output goes to the screen or
        printer, and SET PRINTER TO to echo output to a file.

 ^bExamples^b

     ^b^CFE^b  This example uses REPORT FORM to output records to the printer
        while suppressing output to the screen:

        USE Sales NEW
        SET CONSOLE OFF
        REPORT FORM Sales TO PRINTER
        SET CONSOLE ON

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "SET DEVICE" 
'------------------------------------------------------------------------------



!short: SET CURSOR      Toggle the screen cursor on or off
'------------------------------------------------------------------------------
 ^bSET CURSOR^b
 Toggle the screen cursor on or off
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET CURSOR ON | off | <xlToggle>

 ^bArguments^b

     ^bON^b enables the cursor display.

     ^bOFF^b disables the cursor display.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     SET CURSOR toggles the screen cursor on or off.  When the CURSOR is OFF,
     keyboard entry and screen display are unaffected.  The cursor is merely
     hidden and data entry may still be accomplished without the cursor being
     visible.  ROW() and COL() are updated as if the cursor was visible.

     This command suppresses the cursor while the screen is being painted.
     Ideally, the only time the cursor shows in a production program is when
     the user is editing GETs, MEMOEDIT(), or some kind of line edit.

 ^bExamples^b

     ^b^CFE^b  This example shows a typical use of SET CURSOR:

        LOCAL lAnswer := .F.
        @ 24, 0
        @ 24, 15 SAY "Do you want to QUIT? [Y/N]";
           GET lAnswer;
           PICTURE "Y"
        SET CURSOR ON
        READ
        SET CURSOR OFF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "SET CONSOLE" c52g_001.ngo:"SETCURSOR()" c52g_001.ngo:"SETPOS()" 
'------------------------------------------------------------------------------



!short: SET DATE        Set the date format for input and display
'------------------------------------------------------------------------------
 ^bSET DATE^b
 Set the date format for input and display
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET DATE FORMAT [TO] <cDateFormat>
     ^bSET DATE [TO] AMERICAN | ansi | british | french
     ^b   | german | italian | japan | usa

 ^bArguments^b

     ^b<cDateFormat>^b is a character expression that directly specifies the
     date format when the FORMAT clause is specified.  <cDateFormat> must
     evaluate to a string of 12 or fewer characters.

     When specified, <cDateFormat> is analyzed to determine the proper
     placement and number of digits for the day, month, and year digits.  The
     position of the day, month, and year digits is determined by scanning
     the string for one or more occurrences of the letters d, m, and y,
     respectively.  Other characters in the string are copied verbatim into
     displayed date values.

     When FORMAT is not used, one of several keywords describes the date
     format.  The following table shows the format for each keyword setting:

     ^bSET DATE Formats^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bSETting   Format^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     AMERICAN  mm/dd/yy
     ANSI      yy.mm.dd
     BRITISH   dd/mm/yy
     FRENCH    dd/mm/yy
     GERMAN    dd.mm.yy
     ITALIAN   dd-mm-yy
     JAPAN     yy/mm/dd
     USA       mm-dd-yy
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bDescription^b

     SET DATE is an environment command that sets the display format for date
     values.  SET DATE is a global setting that affects the behavior of dates
     throughout a program, allowing you to control date formatting in a way
     that facilitates porting applications to foreign countries.

 ^bExamples^b

     ^b^CFE^b  In this example the FORMAT clause directly specifies the date
        format:

        SET DATE FORMAT "yyyy:mm:dd"

     ^b^CFE^b  This example configures the date setting at runtime by passing
        a DOS environment variable to the program, retrieving its value with
        GETENV(), and setting DATE with the retrieved value:

        C>SET CLIP_DATE=dd/mm/yy

        In the configuration section of the application program, the date
        format is set like this:

        FUNCTION AppConfig
           SET DATE FORMAT TO GETENV("CLIP_DATE")
           RETURN NIL

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"CTOD()" c52g_001.ngo:"DATE()" c52g_001.ngo:"DTOC()" c52g_001.ngo:"DTOS()" "SET CENTURY" "SET EPOCH" 
'------------------------------------------------------------------------------



!short: SET DECIMALS    Set the number of decimal places displayed
'------------------------------------------------------------------------------
 ^bSET DECIMALS^b
 Set the number of decimal places displayed
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET DECIMALS TO [<nDecimals>]

 ^bArguments^b

     ^bTO <nDecimals>^b is the number of decimal places to display.  The
     default value is two.

     SET DECIMALS TO with no argument is equivalent to SET DECIMALS TO 0.

 ^bDescription^b

     SET DECIMALS determines the number of decimal places displayed in the
     results of numeric functions and calculations.  Its operation depends
     directly on the FIXED setting.  If FIXED is OFF, SET DECIMALS
     establishes the minimum number of decimal digits displayed by EXP(),
     LOG(), SQRT(), and division operations.  If FIXED is ON, all numeric
     values are displayed with exactly the number of decimal places specified
     by SET DECIMALS.  Note that neither SET DECIMALS nor SET FIXED affects
     the actual numeric precision of calculations--only the display format is
     affected.

     To provide finer control of numeric display, you can use the PICTURE
     clause of @...SAY, @...GET, and the TRANSFORM() function.

 ^bExamples^b

     ^b^CFE^b  These examples show various results of the SET DECIMALS
        command:

        SET FIXED ON
        SET DECIMALS TO 2            // The default setting
        ? 2/4                        // Result: 0.50
        ? 1/3                        // Result: 0.33
        SET DECIMALS TO 4
        ? 2/4                        // Result: 0.5000
        ? 1/3                        // Result: 0.3333

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...GET" "@...SAY" "SET FIXED" c52g_001.ngo:"TRANSFORM()" 
'------------------------------------------------------------------------------



!short: SET DEFAULT     Set the CA-Clipper default drive and directory
'------------------------------------------------------------------------------
 ^bSET DEFAULT^b
 Set the CA-Clipper default drive and directory
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET DEFAULT TO [<xcPathspec>]

 ^bArguments^b

     ^bTO <xcPathspec>^b identifies a disk drive and the directory as the
     default and can be specified either as a literal path specification or
     as a character expression enclosed in parentheses.  If you specify both
     a drive and directory, a colon must be included after the drive letter.

     SET DEFAULT TO specified without an argument defaults to the current DOS
     drive and directory.

 ^bDescription^b

     SET DEFAULT sets the drive and directory where the application program
     creates and saves files, with the exception of temporary files and files
     created with the low-level file functions.

     SET DEFAULT does not change the DOS drive and directory.  When
     attempting to access files, the DEFAULT drive and directory are searched
     first.  To set additional search paths for file access, use SET PATH.

 ^bNotes^b

     ^b^CFE  Initial Default:^b When a CA-Clipper program starts, the default
        drive and directory are the current DOS drive and directory.  Within
        the program, you can change this with SET DEFAULT.

     ^b^CFE  Running external programs:^b Executing a RUN command accesses
        the current DOS drive and directory.

 ^bExamples^b

     ^b^CFE^b  This example shows a typical use of SET DEFAULT:

        SET PATH TO
        ? FILE("Sales.dbf")      // Result: .F.
        //
        SET DEFAULT TO C:\CLIPPER\FILES
        ? FILE("Sales.dbf")      // Result: .T.
        //
        SET DEFAULT TO C:        // Change default drive
        SET DEFAULT TO \         // Change to root directory
        SET DEFAULT TO ..        // Change to parent directory

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"CURDIR()" "SET PATH" 
'------------------------------------------------------------------------------



!short: SET DELETED     Toggle filtering of deleted records
'------------------------------------------------------------------------------
 ^bSET DELETED^b
 Toggle filtering of deleted records
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET DELETED on | OFF | <xlToggle>

 ^bArguments^b

     ^bON^b ignores deleted records.

     ^bOFF^b processes deleted records.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     SET DELETED toggles automatic filtering of records marked for deletion in
     all work areas.  When SET DELETED is ON, most commands ignore deleted
     records.  If, however, you refer to a record by record number (GOTO or any
     command that supports the RECORD scope) the record is not ignored even if
     marked for deletion.  Additionally, SET DELETED ON has no effect on INDEX
     or REINDEXing.

     RECALL ALL honors SET DELETED and does not recall any records.

 ^bNotes^b

     ^b^CFE  Filtering deleted records in a single work area:^b To confine
        the filtering of deleted records to a particular work area, SELECT
        the work area, then SET FILTER TO !DELETED().

 ^bExamples^b

     ^b^CFE^b  This example illustrates the effect of using SET DELETED:

        USE Sales NEW
        ? LASTREC()                  // Result: 84
        //
        DELETE RECORD 4
        COUNT TO nCount
        ? nCount                     // Result: 84
        //
        SET DELETED ON
        COUNT TO nCount
        ? nCount                     // Result: 83

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DELETE" c52g_001.ngo:"DELETED()" "RECALL" "SET FILTER" 
'------------------------------------------------------------------------------



!short: SET DELIMITERS  Toggle or define GET delimiters
'------------------------------------------------------------------------------
 ^bSET DELIMITERS^b
 Toggle or define GET delimiters
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET DELIMITERS on | OFF | <xlToggle>
     ^bSET DELIMITERS TO [<cDelimiters> | DEFAULT]

 ^bArguments^b

     ^bON^b displays delimiters for GET variables.

     ^bOFF^b suppresses the delimiter display.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

     ^bTO <cDelimiters>^b defines a one or two character delimiter.
     Specifying a single character uses the same character as both the
     beginning and ending delimiter.  Specifying two characters uses the
     first as the beginning delimiter and the second as the ending delimiter.

     ^bTO DEFAULT^b or no delimiters SETs the delimiters to colons which are
     the default delimiters.

 ^bDescription^b

     SET DELIMITERS is a dual purpose command that both defines characters
     used to delimit GETs and toggles the automatic display of delimiters ON
     or OFF.  The @...GET command can display delimiters that surround a GET
     object's display.  If DELIMITERS is ON, the delimiters add two
     characters to the length of the Get object display.

     You can configure the delimiter characters using the TO <cDelimiters>
     clause.  The DEFAULT delimiter character is the colon (:).  When
     specifying delimiters, the beginning and ending delimiter characters can
     be different.  If you wish to suppress either the right, left, or both
     delimiters, use a space instead of the delimiter character.

     Typically, delimiters are unnecessary since GETs display in reverse
     video or enhanced color if INTENSITY is ON.

 ^bExamples^b

     ^b^CFE^b  This example SETs DELIMITERS TO a colon and a space for the
        first GET and the square bracket characters for the second:

        LOCAL cVar := SPACE(5), cVar2 := SPACE(5)
        SET DELIMITERS ON
        SET DELIMITERS TO ": "
        @ 1, 0 SAY "Enter" GET cVar
        SET DELIMITERS TO "[]"
        @ 2, 0 SAY "Enter" GET cVar2
        READ

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...GET" "SET INTENSITY" 
'------------------------------------------------------------------------------



!short: SET DEVICE      Direct @...SAYs to the screen or printer
'------------------------------------------------------------------------------
 ^bSET DEVICE^b
 Direct @...SAYs to the screen or printer
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET DEVICE TO SCREEN | printer

 ^bArguments^b

     ^bTO SCREEN^b directs all @...SAYs to the screen and is independent of
     the SET PRINTER and CONSOLE settings.

     ^bTO PRINTER^b directs all @...SAYs to the device set with SET PRINTER
     TO.  This can include a local printer port, a network spooler, or a
     file.

 ^bDescription^b

     SET DEVICE directs the output of @...SAY commands to either the screen
     or the printer.  When DEVICE is SET TO PRINTER, @...SAY commands are
     sent to the printer and not echoed to the screen.  In addition, @...SAY
     commands observe the current SET MARGIN value.

     When sending @...SAYs to the printer, CA-Clipper performs an automatic
     EJECT whenever the current printhead row position is less than the last
     print row position.  An EJECT resets PCOL() and PROW() values to zero.
     To reset PCOL() and PROW() to new values, use the SETPRC() function.

     To send @...SAYs to a file, use SET PRINTER TO <xcFile> with SET DEVICE
     TO PRINTER.

 ^bExamples^b

     ^b^CFE^b  This example directs @...SAYs to the printer:

        SET DEVICE TO PRINTER
        @ 2,10 SAY "Hello there"
        EJECT

     ^b^CFE^b  This example directs @...SAYs to a file:

        SET PRINTER TO Output.txt
        SET DEVICE TO PRINTER
        @ 10, 10 SAY "File is: Output.txt"
        @ 11, 10 SAY DATE()
        SET PRINTER TO            // Close the output file
        SET DEVICE TO SCREEN

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...SAY" "EJECT" c52g_001.ngo:"PCOL()" c52g_001.ngo:"PROW()" "SET PRINTER" c52g_001.ngo:"SETPRC()" 
'------------------------------------------------------------------------------



!short: SET EPOCH       Control the interpretation of dates with no century digits
'------------------------------------------------------------------------------
 ^bSET EPOCH^b
 Control the interpretation of dates with no century digits
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET EPOCH TO <nYear>

 ^bArguments^b

     ^bTO <nYear>^b specifies the base year of a 100-year period in which all
     dates containing only two year digits are assumed to fall.

 ^bDescription^b

     SET EPOCH is an environment command that determines the interpretation
     of date strings containing only two year digits.  When such a string is
     converted to a date value, its year digits are compared with the year
     digits of <nYear>.  If the year digits in the date are greater than or
     equal to the year digits of <nYear>, the date is assumed to fall within
     the same century as <nYear>.  Otherwise, the date is assumed to fall in
     the following century.

     The default value for SET EPOCH is 1900, causing dates with no century
     digits to be interpreted as falling within the twentieth century.

     CA-Clipper supports all dates in the range 01/01/0100 to 12/31/2999.

 ^bExamples^b

     ^b^CFE^b  This example shows the effects of SET EPOCH:

        SET DATE FORMAT TO "mm/dd/yyyy"
        ? CTOD("05/27/1904")          // Result: 05/27/1904
        ? CTOD("05/27/67")            // Result: 05/27/1967
        ? CTOD("05/27/04")            // Result: 05/27/1904
        //
        SET EPOCH TO 1960
        ? CTOD("05/27/1904")          // Result: 05/27/1904
        ? CTOD("05/27/67")            // Result: 05/27/1967
        ? CTOD("05/27/04")            // Result: 05/27/2004

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"CTOD()" c52g_001.ngo:"DATE()" c52g_001.ngo:"DTOC()" c52g_001.ngo:"DTOS()" "SET CENTURY" "SET DATE" 
'------------------------------------------------------------------------------



!short: SET ESCAPE      Toggle Esc as a READ exit key
'------------------------------------------------------------------------------
 ^bSET ESCAPE^b
 Toggle Esc as a READ exit key
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET ESCAPE ON | off | <xlToggle>

 ^bArguments^b

     ^bON^b enables Esc as a as a READ exit key.

     ^bOFF^b disables Esc as a READ exit key.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     If SET ESCAPE is ON, Esc terminates the current READ.  Any changes made
     to the current Get object are lost, and validation with RANGE or VALID
     is bypassed.  When SET ESCAPE is OFF and the user presses Esc, the key
     press is ignored.  With SET KEY, however, you can reassign Esc for
     special handling, regardless of the status of SET ESCAPE.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "READ" c52g_001.ngo:"READEXIT()" "SET KEY" c52g_001.ngo:"SETCANCEL()" c52g_001.ngo:"SETKEY()" 
'------------------------------------------------------------------------------



!short: SET EXACT*      Toggle exact matches for character strings
'------------------------------------------------------------------------------
 ^bSET EXACT*^b
 Toggle exact matches for character strings
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET EXACT on | OFF | <xlToggle>

 ^bArguments^b

     ^bON^b enforces exact comparison of character strings, including length.

     ^bOFF^b resumes normal character string comparison.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     SET EXACT determines how two character strings are compared using the
     relational operators (=, >, <, =>, =<).  When EXACT is OFF, strings are
     compared according to the following rules; assume two character strings
     cLeft and cRight where the expression to test is (cLeft = cRight):

     ^b^CFE^b  If cRight is a null string (""), return true (.T.).

     ^b^CFE^b  If LEN(cRight) is greater than LEN(cLeft), return false (.F.).

     ^b^CFE^b  Otherwise, compare all characters in cRight with cLeft.  If
        all characters in cRight equal cLeft, return true (.T.); otherwise
        return false (.F.).

     With EXACT ON, all relational operators except the double equal operator
     (==) treat two strings as equal, if they match exactly, excluding
     trailing spaces.  With the double equal operator (==), all characters in
     the string are significant, including trailing spaces.

     SET EXACT is a compatibility command and not recommended.

 ^bNotes^b

     ^b^CFE  Compatibility:^b In CA-Clipper, unlike other dialects, SET EXACT
        has no effect on operations other than relational operators.  This
        includes the SEEK and FIND commands.  If you need to seek exact
        matches of character keys, use the example user-defined function
        SeekExact() in the SEEK command reference.

 ^bExamples^b

     ^b^CFE^b  These examples show various results of the equal operator (=)
        with SET EXACT:

        SET EXACT OFF
        ? "123" = "12345"            // Result: .F.

        ? "12345" = "123"            // Result: .T.
        ? "123" = ""                 // Result: .T.
        ? "" = "123"                 // Result: .F.
        ? "123" = "123  "            // Result: .F.
        //
        SET EXACT ON
        ? "123" = "12345"            // Result: .F.
        ? "12345" = "123"            // Result: .F.
        ? "123" = ""                 // Result: .F.
        ? "" = "123"                 // Result: .F.
        ? "123" = "123  "            // Result: .T.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "SEEK" 
'------------------------------------------------------------------------------



!short: SET EXCLUSIVE*  Establish shared or exclusive USE of database files
'------------------------------------------------------------------------------
 ^bSET EXCLUSIVE*^b
 Establish shared or exclusive USE of database files
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET EXCLUSIVE ON | off | <xlToggle>

 ^bArguments^b

     ^bON^b causes database files to be opened in exclusive (nonshared) mode.

     ^bOFF^b causes database files to be opened in shared mode.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     In a network environment, SET EXCLUSIVE determines whether a USE command
     specified without the EXCLUSIVE or SHARED clause automatically opens
     database, memo, and index files EXCLUSIVE.  When database files are
     opened EXCLUSIVE, other users cannot USE them until they are CLOSEd.  In
     this mode, file and record locks are unnecessary.

     When EXCLUSIVE is ON (the default), all database and associated files
     open in a nonshared (exclusive) mode unless the USE command is specified
     with the SHARED clause.  Use EXCLUSIVE only for operations that
     absolutely require EXCLUSIVE USE of a database file, such as PACK,
     REINDEX, and ZAP.

     When EXCLUSIVE is OFF, all files are open in shared mode unless the USE
     command is specified with the EXCLUSIVE clause.  Control access by other
     users programmatically using RLOCK() and FLOCK().

     SET EXCLUSIVE is a compatibility command and not recommended.  It is
     superseded by the EXCLUSIVE and SHARED clauses of the USE command.

     Refer to the Network Programming chapter in the Programming and
     Utilities guide for more information.

 ^bNotes^b

     ^b^CFE  Error handling:^b Attempting to USE a database file already
        opened EXCLUSIVE by another user generates a runtime error and sets
        NETERR() to true (.T.).  After control returns to the point of error,
        you can test NETERR() to determine whether the USE failed.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"FLOCK()" c52g_001.ngo:"NETERR()" c52g_001.ngo:"RLOCK()" "USE" 
'------------------------------------------------------------------------------



!short: SET FILTER      Hide records not meeting a condition
'------------------------------------------------------------------------------
 ^bSET FILTER^b
 Hide records not meeting a condition
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET FILTER TO [<lCondition>]

 ^bArguments^b

     ^bTO <lCondition>^b is a logical expression that defines a specific set
     of current work area records accessible for processing.

     SET FILTER TO without an argument deactivates the filter condition.

 ^bDescription^b

     When a FILTER condition is SET, the current work area acts as if it
     contains only the records that match the specified condition.  A filter
     condition is one of the properties of a work area.  Once a FILTER has
     been SET, the condition can be returned as a character string using the
     DBFILTER() function.

     Most commands and functions that move the record pointer honor the
     current filter with the exception of those commands that access records
     by record number.  This includes GOTO, commands specified with the
     RECORD clause, and RELATIONs linked by numeric expression to a work area
     with no active index.

     Once a FILTER is SET, it is not activated until the record pointer is
     moved from its current position.  You can use GO TOP to activate it.

     As with SET DELETED, a filter has no effect on INDEX and REINDEX.

     ^bNote: ^b Although SET FILTER makes the current work area appear as if
     it contains a subset of records, it, in fact, sequentially processes all
     records in the work area.  Because of this, the time required to process
     a filtered work area will be the same as an unfiltered work area.

 ^bExamples^b

     ^b^CFE^b  This example filters Employee.dbf to only those records where
        the age is greater than 50:

        USE Employee INDEX Name NEW
        SET FILTER TO Age > 50
        LIST Lastname, Firstname, Age, Phone
        SET FILTER TO

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"DBFILTER()" c52g_001.ngo:"DBSETFILTER()" "SET DELETED" 
'------------------------------------------------------------------------------



!short: SET FIXED       Toggle fixing of the number of decimal digits displayed
'------------------------------------------------------------------------------
 ^bSET FIXED^b
 Toggle fixing of the number of decimal digits displayed
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET FIXED on | OFF | <xlToggle>

 ^bArguments^b

     ^bON^b fixes the decimal places display at the number of digits
     specified by SET DECIMALS.

     ^bOFF^b allows the operation or function to determine the number of
     decimal places to display.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     SET FIXED toggles control of the display of decimal digits by the
     current DECIMALS setting.  When FIXED is ON, display of all numeric
     output is fixed at the DECIMALS setting (two places if the SET DECIMALS
     default value is in effect).  When FIXED is OFF, numeric output displays
     according to the default rules for numeric display.  These are described
     in the Basic Concepts chapter of the Programming and Utilities guide.

     Note that SET FIXED and SET DECIMALS affect only the display format of
     numeric values and not the actual numeric precision of calculations.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"EXP()" c52g_001.ngo:"LOG()" "SET DECIMALS" c52g_001.ngo:"SQRT()" c52g_001.ngo:"VAL()" 
'------------------------------------------------------------------------------



!short: SET FORMAT*     Activate a format when READ is executed
'------------------------------------------------------------------------------
 ^bSET FORMAT*^b
 Activate a format when READ is executed
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET FORMAT TO [<idProcedure>[.<ext>]]

 ^bArguments^b

     ^bTO <idProcedure>^b is a format (.fmt) file, a program (.prg) file, or
     a procedure.

     ^b<ext>^b is the extension of the format file.  If not specified, the
     default extension is (.fmt).

     SET FORMAT TO with no argument deactivates the current format.

 ^bDescription^b

     SET FORMAT defines a procedure to execute when a READ is invoked.
     Unlike the interpreted environment, formats are not opened and executed
     at runtime.  Instead, the CA-Clipper compiler treats SET FORMAT the same
     as a DO command.  The compiler first looks to see whether it has already
     compiled a procedure with the same name as <idProcedure>.  If it has, it
     uses that procedure for the reference.  If <idProcedure> is not found,
     the compiler looks to disk for a file with the same name.  If this file
     is not found, an external reference is generated that must be resolved
     at link time.

     SET FORMAT is a compatibility command and not recommended.

 ^bNotes^b

     ^b^CFE  Active format procedures:^b Unlike other dialects where each
        work area can have an active format, CA-Clipper supports only one
        active format procedure for all work areas.

     ^b^CFE  Screen CLEARing:^b CA-Clipper does not clear the screen when a
        format procedure is executed.

     ^b^CFE  Legal statements:^b Format procedures allow statements and
        commands in addition to @...SAY and @...GET.

     ^b^CFE  Multiple pages:^b CA-Clipper does not support multiple-page
        format procedures.

 ^bExamples^b

     ^b^CFE^b  This example uses a format procedure to add records to a
        database file until the user presses Esc:

        USE Sales NEW
        SET FORMAT TO SalesScr
        DO WHILE LASTKEY() != 27
           APPEND BLANK
           READ
        ENDDO
        RETURN

        PROCEDURE SalesScr
           @ 12, 12 SAY "Branch     : " GET  Branch
           @ 13, 12 SAY "Salesman   : " GET  Salesman
           RETURN

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...GET" "@...SAY" c52g_004.ngo:"PROCEDURE" "READ" 
'------------------------------------------------------------------------------



!short: SET FUNCTION    Assign a character string to a function key
'------------------------------------------------------------------------------
 ^bSET FUNCTION^b
 Assign a character string to a function key
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET FUNCTION <nFunctionKey> TO <cString>

 ^bArguments^b

     ^b<nFunctionKey>^b is the number of the function key to receive the
     assignment.

     ^bTO <cString>^b specifies the character string to assign to
     <nFunctionKey>.

 ^bDescription^b

     SET FUNCTION assigns a character string to a function key numbered
     between 1 and 40 inclusive.  When the user presses the assigned function
     key, <cString> is stuffed into the keyboard buffer.  <cString> can
     include control characters, such as a Ctrl-C or Ctrl-S to perform
     navigation or editing actions in a wait state.

     ^bList of Function Key Mappings^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bFunction Key    Actual Key^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     1 - 10          F1 - F10
     11 - 20         Shift-F1 - Shift-F10
     21 - 30         Ctrl-F1 - Ctrl-F10
     31 - 40         Alt-F1 - Alt-F10
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^bWarning! ^b In CA-Clipper, SET FUNCTION is preprocessed into SET KEY
     and KEYBOARD commands.  This means that SET FUNCTION has the effect of
     clearing any SET KEY for the same key number and vice versa.  This is
     incompatible with previous releases, which maintained separate lists of
     SET FUNCTION keys and SET KEY keys.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "KEYBOARD" "SET KEY" c52g_001.ngo:"SETKEY()" 
'------------------------------------------------------------------------------



!short: SET INDEX       Open index file(s) in the current work area
'------------------------------------------------------------------------------
 ^bSET INDEX^b
 Open index file(s) in the current work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET INDEX TO [<xcIndex list>]

 ^bArguments^b

     ^bTO <xcIndex list>^b is a list of up to 15 index (.ntx or .ndx)
     filenames, separated by commas.  Any reference to an index filename that
     results in either a null string ("") or spaces is ignored.  You can
     specify each index file as a literal filename or as a character
     expression enclosed in parentheses.  If you specify no extension, a
     default extension is supplied by the current database driver.  (.ntx) is
     the extension supplied by the CA-Clipper driver, and (.ndx) is the
     extension supplied by the dBASE III PLUS driver.

     SET INDEX TO without an argument closes all indexes open in the current
     work area.

 ^bDescription^b

     SET INDEX closes all currently open index files then opens the specified
     index files in the current work area.  When more than one index file is
     opened, the first index becomes the controlling index.  The record
     pointer is initially positioned at the first logical record in the
     index.  During database file processing, all open indexes are updated
     whenever a key value is appended or changed.  To change the controlling
     index without issuing another SET INDEX command, use SET ORDER.  To add
     indexes without closing the currently opened indexes, use DBSETINDEX().

     SET INDEX is used primarily to open index files in a network environment
     instead of the INDEX clause of the USE command.  Generally, USE the
     <xcDatabase> then test to determine whether the USE succeeded.  If it
     did succeed, open the associated indexes with SET INDEX.  See the
     example below.

 ^bExamples^b

     ^b^CFE^b  This example opens index files using extended expressions.
        Note how each index filename is specified by a separate variable:

        xcIndex1:= "Name"
        xcIndex2:= "Account"
        SET INDEX TO (xcIndex1), (xcIndex2)

     ^b^CFE^b  This example demonstrates using SET INDEX in a network
        environment to open indexes:

        USE Sales SHARED
        IF !NETERR()
           SET INDEX TO Sales, Territory
        ELSE
           ? "USE failed"
           BREAK
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CLOSE" c52g_001.ngo:"DBSETINDEX()" "INDEX" "REINDEX" "SET ORDER" "USE" 
'------------------------------------------------------------------------------



!short: SET INTENSITY   Toggle enhanced display of GETs and PROMPTs
'------------------------------------------------------------------------------
 ^bSET INTENSITY^b
 Toggle enhanced display of GETs and PROMPTs
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET INTENSITY ON | off | <xlToggle>

 ^bArguments^b

     ^bON^b enables both standard and enhanced display colors.

     ^bOFF^b disables enhanced display color.  All screen output then uses
     the current standard color.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     SET INTENSITY toggles the display of GETs and menu PROMPTs between
     enhanced and standard color settings.  When INTENSITY is OFF, GETs and
     SAYs appear in the standard color setting.  When INTENSITY is ON, GETs
     appear in the enhanced color setting.

     When INTENSITY is OFF, all menu PROMPTs appear in the standard color
     setting, and the cursor appears at the current PROMPT.  If INTENSITY is
     ON (the default), the current PROMPT appears in the enhanced color
     setting, and the cursor is hidden.

     Note that INTENSITY has no effect on ACHOICE() or DBEDIT().

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...GET" "@...PROMPT" "@...SAY" c52g_001.ngo:"SETCOLOR()" 
'------------------------------------------------------------------------------



!short: SET KEY         Assign a procedure invocation to a key
'------------------------------------------------------------------------------
 ^bSET KEY^b
 Assign a procedure invocation to a key
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET KEY <nInkeyCode> TO [<idProcedure>]

 ^bArguments^b

     ^b<nInkeyCode>^b is the INKEY() value of the key that receives the
     assignment.

     ^bTO <idProcedure>^b specifies the name of a procedure that executes
     when the user presses the assigned key.  If <idProcedure> is not
     specified, the current <nInkeyCode> definition is released.

 ^bDescription^b

     SET KEY is a keyboard command that allows a procedure to be executed
     from any wait state when a designated key is pressed.  A wait state is
     any mode that extracts keys from the keyboard except for INKEY().  These
     modes include ACHOICE(), DBEDIT(), MEMOEDIT(), ACCEPT, INPUT, READ and
     WAIT.  After a key is redefined, pressing it executes the specified
     procedure, passing three automatic parameters corresponding to:
     PROCNAME(), PROCLINE(), and READVAR().  The procedure and variable
     parameters are character data type, while the line number is numeric
     data type.

     You may define a maximum of 32 keys at one time.  At startup, the system
     automatically defines the F1 key to execute Help.  If a procedure with
     this name is linked into the current program and it is visible, pressing
     F1 from a wait state invokes it.

     Note that SET KEY procedures should preserve the state of the
     application (i.e., screen appearance, current work area, etc.) and
     restore it before exiting.

     ^bWarning! ^b In CA-Clipper, SET FUNCTION is preprocessed into the SET
     KEY and KEYBOARD commands.  This means that SET FUNCTION has the effect
     of clearing any SET KEY for the same key number and vice versa.  This is
     incompatible with previous releases, which maintained separate lists of
     SET FUNCTION keys and SET KEY keys.

 ^bNotes^b

     ^b^CFE  Precedence:^b SET KEY definitions take precedence over SET
        ESCAPE and SETCANCEL().

     ^b^CFE  CLEAR with a SET KEY procedure:^b Do not use CLEAR to clear the
        screen within a SET KEY procedure since it also CLEARs GETs and,
        therefore, terminates READ.  When you need to clear the screen, use
        CLEAR SCREEN or CLS instead.

     ^b^CFE  Terminating a READ from a SET KEY procedure:^b The following
        table illustrates several ways to terminate a READ from within a SET
        KEY procedure.

        ^bTerminating a READ from a SET KEY Procedure^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bCommand             Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        CLEAR GETS          Terminates READ without saving current GET
        BREAK               Terminates READ without saving current GET
        KEYBOARD Ctrl-W     Terminates READ and saves the current GET
        KEYBOARD Esc        Terminates READ without saving current GET
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bExamples^b

     ^b^CFE^b  This example uses SET KEY to invoke a procedure that presents
        a picklist of account identification numbers when the user presses F2
        while entering data into the account identification field:

        #include   "Inkey.ch"

        //
        SET KEY K_F2 TO ScrollAccounts
        USE Accounts NEW
        USE Invoices NEW
        @ 10, 10 GET Invoices->Id
        READ
        RETURN

        PROCEDURE ScrollAccounts( cProc, nLine, cVar )
           IF cVar = "ID"
              SAVE SCREEN
              Accounts->(DBEDIT(10, 10, 18, 40, {"Company"}))
              KEYBOARD CHR(K_CTRL_Y) + Accounts->Id + ;
                       CHR(K_HOME)
              RESTORE SCREEN
           ELSE
              TONE(100, 2)
           ENDIF
           RETURN

 ^bFiles:^b  Library is CLIPPER.LIB, header file is Inkey.ch.
!seealso: c52g_001.ngo:"INKEY()" "KEYBOARD" "READ" c52g_001.ngo:"SETKEY()" c52g_009.ngo:"Inkey codes" 
'------------------------------------------------------------------------------



!short: SET MARGIN      Set the page offset for all printed output
'------------------------------------------------------------------------------
 ^bSET MARGIN^b
 Set the page offset for all printed output
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET MARGIN TO [<nPageOffset>]

 ^bArguments^b

     ^bTO <nPageOffset>^b is a positive number that defines the number of
     column positions to indent from the left side of the page for subsequent
     printed output.  A negative value resets the MARGIN to zero.

     SET MARGIN TO with no argument resets the page offset to zero, the
     default value.

 ^bDescription^b

     SET MARGIN is valid for all output directed to the printer from console
     commands and @...SAY.  With console output, the <nPageOffset> indent is
     output whenever there is a new line.  With @...SAY, <nPageOffset> is
     added to each column value.  SET MARGIN has no effect on screen output.

     ^bNote: ^b Printing with @...SAY and PCOL() with a MARGIN SET in most
     cases adds the MARGIN to each column position.  This happens since
     PCOL() accurately reflects the print column position including the last
     <nPageOffset> output.  The best approach is to avoid the use of SET
     MARGIN with PCOL() for relative column addressing.

 ^bExamples^b

     ^b^CFE^b  This example sets a page offset of 5 then prints a list from
        Sales.dbf:

        USE Sales NEW
        SET MARGIN TO 5
        LIST Branch, Salesman TO PRINTER
        SET MARGIN TO

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...SAY" c52g_001.ngo:"PCOL()" "SET DEVICE" "SET PRINTER" 
'------------------------------------------------------------------------------



!short: SET MESSAGE     Set the @...PROMPT message line row
'------------------------------------------------------------------------------
 ^bSET MESSAGE^b
 Set the @...PROMPT message line row
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET MESSAGE TO [<nRow> [CENTER | CENTRE]]

 ^bArguments^b

     ^bTO <nRow>^b specifies the message row position.

     ^bCENTER | CENTRE^b centers the message on the specified row.

     Specifying SET MESSAGE TO 0 or SET MESSAGE TO without an argument
     suppresses the display of messages.

 ^bDescription^b

     SET MESSAGE is a menu command that defines the screen row where the
     @...PROMPT messages display.  When a CA-Clipper program is invoked the
     default message row value is zero, suppressing all defined messages.
     Messages appear on <nRow>, column 0 unless the CENTER option is used.

 ^bExamples^b

     ^b^CFE^b  This example creates a small lightbar menu with an activated
        and centered message line:

        SET MESSAGE TO 23 CENTER
        SET WRAP ON
        @ 5, 5 PROMPT "One" MESSAGE "Choice one"
        @ 6, 5 PROMPT "Two" MESSAGE "Choice two"
        MENU TO nChoice
        //
        IF nChoice == 0
           EXIT
        ELSEIF nChoice == 1
           Proc1()
        ELSEIF nChoice == 2
           Proc2()
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...PROMPT" "MENU TO" "SET WRAP" 
'------------------------------------------------------------------------------



!short: SET ORDER       Set a new controlling index
'------------------------------------------------------------------------------
 ^bSET ORDER^b
 Set a new controlling index
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET ORDER TO [<nIndex>]

 ^bArguments^b

     ^bTO <nIndex>^b specifies the new controlling index by pointing to its
     position in the list of open indexes in the current work area.  This
     number can be in the range of zero to 15.

     If <nIndex> is not specified, ORDER is SET to zero.

 ^bDescription^b

     When you SET ORDER TO a new controlling index, all indexes are properly
     updated when you either append or edit records.  This is true even if
     you SET ORDER TO 0.  After a change of controlling indexes, the record
     pointer still points to the same record.

     SET ORDER TO 0 or SET ORDER TO with no argument restores the database
     file to natural order (record number order), leaving all indexes open.

     To determine which index is the current controlling index, use
     INDEXORD().

 ^bExamples^b

     ^b^CFE^b  This example shows typical uses of the SET ORDER command:

        USE Customers NEW
        INDEX ON Lastname TO Names
        INDEX ON City + State TO Region
        SET INDEX TO Names, Region
        //
        SET ORDER TO 2
        ? INDEXKEY(INDEXORD())      // Result: City + State
        //
        SET ORDER TO 0
        ? INDEXKEY(INDEXORD())      // Result: null value
        //
        SET ORDER TO 1
        ? INDEXKEY(INDEXORD())      // Result: Lastname

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "INDEX" c52g_001.ngo:"INDEXORD()" "SEEK" "SET INDEX" "USE" 
'------------------------------------------------------------------------------



!short: SET PATH        Specify the CA-Clipper search path for opening files
'------------------------------------------------------------------------------
 ^bSET PATH^b
 Specify the CA-Clipper search path for opening files
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET PATH TO [<xcPathspec list>]

 ^bArguments^b

     ^bTO <xcPathspec list>^b identifies the paths CA-Clipper uses when
     searching for a file not found in the current directory.  You can
     specify it as a literal list or as a character expression enclosed in
     parentheses.  The list of paths can be separated by commas or
     semicolons.  However, continuation of a SET PATH command line with a
     semicolon is not supported unless <xcPathspec> is specified as a
     character expression enclosed in parentheses.

 ^bDescription^b

     SET PATH allows commands and functions that open database and associated
     files to find and open existing files in another drive and/or directory.
     It does this by specifying a path list to search if a referenced file
     cannot be found in the DEFAULT or specified directory.  Note that memo
     and low-level file functions respect neither the DEFAULT nor the PATH
     SETting.

     A path is a pointer to a directory.  It consists of an optional drive
     letter and colon, followed by a list of directories from the root to the
     desired directory separated by backslash (\) characters.  A path list is
     the sequence of paths to search, each separated by a comma or semicolon.

     When you attempt to access a file, CA-Clipper first searches the default
     drive and directory.  The default disk drive and directory are
     established by DOS when your CA-Clipper application is loaded, or,
     during execution, by SET DEFAULT.  If the file is not found, CA-Clipper
     then searches each path in the specified path list until the first
     occurrence of the file is found.

     To create new files in another drive or directory, use SET DEFAULT TO
     <xcPathspec> or explicitly declare the path when specifying a new
     filename.

     SET PATH TO with no argument releases the path list and CA-Clipper
     searches only the DEFAULT directory.

 ^bExamples^b

     ^b^CFE^b  This example is a typical PATH command:

        SET PATH TO A:\INVENTORY;B:\VENDORS

     ^b^CFE^b  This example configures a path setting at runtime by passing a
        DOS environment variable to a program, retrieving its value with
        GETENV(), then SETting PATH with this value.  For example, in DOS:

        SET CLIP_PATH=C:\APPS\DATA,C:\APPS\PROGS

        Later in the configuration section of your application program:

        SET PATH TO (GETENV("CLIP_PATH"))

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"CURDIR()" "SET DEFAULT" 
'------------------------------------------------------------------------------



!short: SET PRINTER     Print console output, and set printer destination
'------------------------------------------------------------------------------
 ^bSET PRINTER^b
 Toggle echo of console output to the printer or set the destination of
 printed output

컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET PRINTER on | OFF | <xlToggle>
     ^bSET PRINTER TO [<xcDevice> | <xcFile> [ADDITIVE]]

 ^bArguments^b

     ^bON^b echoes console output to the printer.

     ^bOFF^b suppresses the printing of console output.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

     ^bTO <xcDevice>^b identifies the name of the device where all subsequent
     printed output will be sent.  You can specify a device name as a literal
     character string or a character expression enclosed in parentheses.
     Additionally, a device can be either local or network.  SETting PRINTER
     TO a nonexisting device creates a file with the name of the device.
     When specifying device names, do not use a trailing colon.

     ^bTO <xcFile>^b identifies the name of the output file.  You can specify
     the filename as a literal string or as a character expression enclosed
     in parentheses.  If a file extension is not specified, (.prn) is
     assumed.

     ^bADDITIVE^b causes the specified output file to be appended to instead
     of overwritten.  If ADDITIVE is not specified, an existing output file
     is truncated before new information is written to it.  The ADDITIVE
     clause is only meaningful when SETting PRINTER TO an output file.

     If SET PRINTER TO is specified with no arguments, the currently
     specified device or file is closed and the default destination is then
     reselected.

 ^bDescription^b

     SET PRINTER, like many other SET commands, has two basic forms with each
     having its own functionality.  The on|OFF form of SET PRINTER controls
     whether the output of console commands is echoed to the printer.
     Console commands generally do not specify row and column coordinates.
     All of these commands, except ?|??, have a TO PRINTER clause that also
     directs output to the printer.  Output from console commands is
     displayed to the screen unless CONSOLE is OFF.  Be aware that @...SAYs
     are not affected by SET PRINTER ON.  To send them to the printer, use
     SET DEVICE TO PRINTER instead.

     SET PRINTER TO determines the destination of output from all commands
     and functions that send output to the printer.  This includes @...SAYs
     if DEVICE is SET TO PRINTER.  Output can be sent to a device or to a
     file.  If the destination is a device, the following names are valid:
     LPT1, LPT2, LPT3 (all parallel ports), COM1, and COM2 (serial ports),
     CON and PRN.  The default device is PRN.

     If the destination is a file, it is created in the current DEFAULT
     directory.  If a file with the same name exists in the same location, it
     is overwritten by the new file without warning.  All subsequent output
     to the printer is then written to this file until the file is closed
     using SET PRINTER TO with no argument.

     Use SET PRINTER TO for:

     ^b^CFE^b  Managing multiple printers by swapping ports

     ^b^CFE^b  Directing output to a file for printing later or for
        transferring to a remote computer via telecommunications

     ^b^CFE^b  Emptying the printer spooler and resetting the default device

 ^bNotes^b

     ^b^CFE  Compatibility:^b CA-Clipper does not support the syntax SET
        PRINTER TO \\SPOOLER or \\CAPTURE.  Specifying SET PRINTER with
        either of these options creates the files Spooler.prn or Capture.prn.
        The symbols \\ are ignored.

     ^b^CFE  End of file marks:^b When printer output is redirected to a
        file, an end of file mark (CHR(26)) is not written when the file is
        closed.  To terminate a file with an end of file mark, issue a ??
        CHR(26) just before the SET PRINTER command that closes the file.

     ^b^CFE  Networking:^b For some networks, the workstation's printer
        should first be redirected to the file server (usually by running the
        network spooler program).

 ^bExamples^b

     ^b^CFE^b  This example echoes the output of the ? command to printer,
        suppressing the console screen display by SETting CONSOLE OFF:

        USE Customer NEW
        SET PRINTER ON
        SET CONSOLE OFF
        DO WHILE !EOF()

           ? Customer->Name, Customer->Phone
           SKIP
        ENDDO
        EJECT
        SET PRINTER OFF
        SET CONSOLE ON
        CLOSE
        RETURN

     ^b^CFE^b  This example directs printer output to LPT1 and empties the
        print spooler upon completion:

        SET PRINTER TO LPT1
        <Printing statements>...
        SET PRINTER TO            // Empty the print spooler

     ^b^CFE^b  This example sends printer output to a text file, overwriting
        an existing file with the same name:

        SET PRINTER TO Prnfile.txt
        SET DEVICE TO PRINTER
        SET PRINTER ON
        //
        @ 0, 0 SAY "This goes to Prnfile.txt"
        ? "So will this!"
        //
        SET DEVICE TO SCREEN
        SET PRINTER OFF
        SET PRINTER TO            // Close the print file

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...SAY" "EJECT" "SET CONSOLE" "SET DEVICE" c52g_001.ngo:"SETPRC()" 
'------------------------------------------------------------------------------



!short: SET PROCEDURE*  Compile procedures and functions into the current .OBJ file
'------------------------------------------------------------------------------
 ^bSET PROCEDURE*^b
 Compile procedures and functions into the current .OBJ file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET PROCEDURE TO [<idProgramFile>[.<ext>]]

 ^bArguments^b

     ^bTO <idProgramFile>^b is the name of the procedure file to compile into
     the current object file.  It can optionally include a path and/or drive
     designator.

     ^b<ext>^b is the optional extension of the procedure.  If not specified,
     (.prg) is assumed.

     SET PROCEDURE TO with no argument is ignored.

 ^bDescription^b

     SET PROCEDURE directs the compiler to compile all procedures and
     user-defined functions declared within the specified procedure file into
     the current object file (.OBJ).

     SET PROCEDURE is a compatibility command and not recommended.  It has
     been superseded by other facilities more appropriate to the compiled
     environment (e.g., the compiler script file (.clp)).

     See the CA-Clipper Compiler chapter in the Programming and Utilities
     guide for a full discussion of program architecture and configuration.
!seealso: c52g_006.ngo:"#include" c52g_004.ngo:"DO*" c52g_004.ngo:"FUNCTION" c52g_004.ngo:"PROCEDURE" c52g_004.ngo:"RETURN" 
'------------------------------------------------------------------------------



!short: SET RELATION    Relate two work areas by a key value or record number
'------------------------------------------------------------------------------
 ^bSET RELATION^b
 Relate two work areas by a key value or record number
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET RELATION TO [<expKey> | <nRecord> INTO <xcAlias>]
     ^b   [, [TO] <expKey2> | <nRecord2> INTO <xcAlias2>...]
     ^b   [ADDITIVE]

 ^bArguments^b

     ^bTO <expKey>^b is an expression that performs a SEEK in the child work
     area each time the record pointer moves in the parent work area.  For
     this to work, the child work area must have an index in USE.

     ^bTO <nRecord>^b is an expression that performs a GOTO to the matching
     record number in the child work area each time the record pointer moves
     in the parent work area.  If <nRecord> evaluates to RECNO(), the
     relation uses the parent record number to perform a GOTO to the same
     record number in the child work area.  For a numeric expression type of
     relation to execute correctly, the child work area must not have an
     index in USE.

     ^bINTO <xcAlias>^b identifies the child work area and can be specified
     either as the literal alias name or as a character expression enclosed
     in parentheses.

     ^bADDITIVE^b adds the specified child relations to existing relations
     already set in the current work area.  If this clause is not specified,
     existing relations in the current work area are released before the new
     child relations are set.

     SET RELATION TO with no arguments releases all relations defined in the
     current work area.

 ^bDescription^b

     SET RELATION is a database command that links a parent work area to one
     or more child work areas using a key expression, record number, or
     numeric expression.  Each parent work area can be linked to as many as
     eight child work areas.  A relation causes the record pointer to move in
     the child work area in accordance with the movement of the record
     pointer in the parent work area.  If no match is found in the child work
     area, the child record pointer is positioned to LASTREC() + 1, EOF()
     returns true (.T.), and FOUND() returns false (.F.).

     The method of linking the parent and child work areas depends on the
     type of <expKey> and presence of an active index in the child work area.
     If the child work area has an active index, the lookup is a standard
     SEEK.  If the child work area does not have an active index and the type
     of <expKey> is numeric, a GOTO is performed in the child work area
     instead.

 ^bNotes^b

     ^b^CFE  Cyclical relations:^b Do not relate a parent work area to itself
        either directly or indirectly.

     ^b^CFE  Soft seeking:^b SET RELATION does not support SOFTSEEK and
        always behaves as if SOFTSEEK is OFF even if SOFTSEEK is ON.  This
        means that if a match is not found in the child work area, the child
        record pointer is always positioned to LASTREC() + 1.

     ^b^CFE  Record number relations:^b To relate two work areas based on
        matching record numbers, use RECNO() for the SET RELATION TO
        expression and make sure the child work area has no active indexes.

 ^bExamples^b

     ^b^CFE^b  This example relates three work areas in a multiple parent-child
        configuration with Customer related to both Invoices and Zip:

        USE Invoices INDEX Invoices NEW
        USE Zip INDEX Zipcode NEW
        USE Customer NEW
        SET RELATION TO CustNum INTO Invoices, Zipcode INTO Zip
        LIST Customer, Zip->City, Invoices->Number, ;
                 Invoices->Amount

     ^b^CFE^b  Sometime later, you can add a new child relation using the
        ADDITIVE clause, like this:

        USE BackOrder INDEX BackOrder NEW
        SELECT Customer
        SET RELATION TO CustNum INTO BackOrder ADDITIVE

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"DBRELATION()" c52g_001.ngo:"DBRSELECT()" c52g_001.ngo:"FOUND()" c52g_001.ngo:"RECNO()" 
'------------------------------------------------------------------------------



!short: SET SCOREBOARD  Toggle the message display from READ or MEMOEDIT()
'------------------------------------------------------------------------------
 ^bSET SCOREBOARD^b
 Toggle the message display from READ or MEMOEDIT()
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET SCOREBOARD ON | off | <xlToggle>

 ^bArguments^b

     ^bON^b allows the display of messages from READ and MEMOEDIT() on line
     zero of the screen.

     ^bOFF^b suppresses these messages.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     SET SCOREBOARD controls whether or not messages from READ and MEMOEDIT()
     display on line zero.  When SCOREBOARD is ON, READ displays messages for
     RANGE errors, invalid dates, and insert status.  MEMOEDIT() displays an
     abort query message and the insert status.

     To suppress the automatic display of these messages, SET SCOREBOARD OFF.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...GET" c52g_001.ngo:"MEMOEDIT()" "READ" 
'------------------------------------------------------------------------------



!short: SET SOFTSEEK    Toggle relative SEEKing
'------------------------------------------------------------------------------
 ^bSET SOFTSEEK^b
 Toggle relative SEEKing
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET SOFTSEEK on | OFF | <xlToggle>

 ^bArguments^b

     ^bON^b causes the record pointer to be moved to the next record with a
     higher key after a failed index search.

     ^bOFF^b causes the record pointer to be moved to EOF() after a failed
     index search.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     SET SOFTSEEK enables relative seeking, a method of searching an index
     and returning a record even if there is no match for a specified key.

     When SOFTSEEK is ON and a match for a SEEK is not found, the record
     pointer is set to the next record in the index with a higher key value
     than the SEEK argument.  Records not visible because SET FILTER and/or
     SET DELETED are skipped when searching for the next higher key value.
     If there is no record with a higher key value, the record pointer is
     positioned at LASTREC() + 1, EOF() returns true (.T.), and FOUND()
     returns false (.F.).  FOUND() returns true (.T.) only if the record is
     actually found.  It never returns true (.T.) for a relative find.

     When SOFTSEEK is OFF and a SEEK is unsuccessful, the record pointer is
     positioned at LASTREC() + 1, EOF() returns true (.T.), and FOUND()
     returns false (.F.).

 ^bNotes^b

     ^b^CFE  SET RELATION:^b SET RELATION ignores SOFTSEEK updating the
        record pointer in all linked child work areas as if SOFTSEEK is OFF.

 ^bExamples^b

     ^b^CFE^b  This example illustrates the possible results of a SEEK with
        SET SOFTSEEK ON:

        SET SOFTSEEK ON
        USE Salesman INDEX Salesman NEW
        ACCEPT "Enter Salesman: " TO cSearch
        SEEK cSearch
        DO CASE
        CASE FIELD->Salesman = cSearch
           ? "Match found:", FOUND(), EOF(), FIELD->Salesman
        CASE !EOF()
           ? "Soft match found:", FOUND(), EOF(), ;
                    FIELD->Salesman
        OTHERWISE
           ? "No key matches:", FOUND(), EOF(), FIELD->Salesman
        ENDCASE

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"FOUND()" "SEEK" "SET INDEX" "SET ORDER" "SET RELATION" 
'------------------------------------------------------------------------------



!short: SET TYPEAHEAD   Set the size of the keyboard buffer
'------------------------------------------------------------------------------
 ^bSET TYPEAHEAD^b
 Set the size of the keyboard buffer
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET TYPEAHEAD TO <nKeyboardSize>

 ^bArguments^b

     ^bTO <nKeyboardSize>^b specifies the number of keystrokes the keyboard
     buffer can hold from a minimum of zero to a maximum of 4096.  The
     default size of the keyboard buffer is machine-dependent but 16 is the
     minimum size.

 ^bDescription^b

     SET TYPEAHEAD defines the size of the CA-Clipper keyboard buffer that
     caches keystrokes input directly by the user.  SET TYPEAHEAD, however,
     does not affect the number of characters that can be stuffed
     programmatically using the KEYBOARD command.  When executed, SET
     TYPEAHEAD clears the keyboard buffer and sets the size to
     <nKeyboardSize>.

     When TYPEAHEAD is SET TO zero, keyboard polling is suspended.  An
     explicit request for keyboard input, however, will temporarily enable
     the keyboard and read any pending keystrokes from the BIOS buffer.
     Calling NEXTKEY() constitutes such an explicit request.  NEXTKEY() reads
     any pending keystrokes from the BIOS buffer and returns the INKEY()
     value of the first keystroke read, or zero if no keystrokes are pending.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"ALTD()" "CLEAR TYPEAHEAD" c52g_001.ngo:"INKEY()" "KEYBOARD" c52g_001.ngo:"NEXTKEY()" 
'------------------------------------------------------------------------------



!short: SET UNIQUE*     Toggle inclusion of nonunique keys into an index
'------------------------------------------------------------------------------
 ^bSET UNIQUE*^b
 Toggle inclusion of nonunique keys into an index
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET UNIQUE on | OFF | <xlToggle>

 ^bArguments^b

     ^bON^b causes index files to be created with a uniqueness attribute.

     ^bOFF^b causes index files to be created without a uniqueness attribute.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     SET UNIQUE is a database command that controls whether indexes are
     created with uniqueness as an attribute.  With UNIQUE ON, new indexes
     are created including only unique keys.  This is the same as creating an
     index with the INDEX...UNIQUE command.

     If, during the creation or update of an unique index, two or more
     records are encountered with the same key value, only the first record
     is included in the index.  When the unique index is updated, REINDEXed,
     or PACKed, only unique records are maintained, without regard to the
     current SET UNIQUE value.

     Changing key values in a unique index has important implications.
     First, if a unique key is changed to the value of a key already in the
     index, the changed record is lost from the index.  Second, if there is
     more than one instance of a key value in a database file, changing the
     visible key value does not bring forward another record with the same
     key until the index is rebuilt with REINDEX, PACK, or INDEX...UNIQUE.

     With UNIQUE OFF, indexes are created with all records in the index.
     Subsequent updates to the database files add all key values to the index
     independent of the current UNIQUE SETting.

     SET UNIQUE is a compatibility command not recommended.  It is superseded
     by the UNIQUE clause of the INDEX command.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"DBCREATEIND()" "INDEX" "PACK" "REINDEX" "SEEK" 
'------------------------------------------------------------------------------



!short: SET WRAP        Toggle wrapping of the highlight in MENUs
'------------------------------------------------------------------------------
 ^bSET WRAP^b
 Toggle wrapping of the highlight in MENUs
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSET WRAP on | OFF | <xlToggle>

 ^bArguments^b

     ^bON^b enables the highlight to wrap around when navigating a lightbar
     menu.

     ^bOFF^b disables wrapping when navigating a lightbar menu.

     ^b<xlToggle>^b is a logical expression that must be enclosed in
     parentheses.  A value of true (.T.) is the same as ON, and a value of
     false (.F.) is the same as OFF.

 ^bDescription^b

     SET WRAP is a menu command that toggles wrapping of the highlight in an
     @...PROMPT menu from the first menu item to the last menu item and vice
     versa.  When WRAP is ON and the last menu item is highlighted,
     Rightarrow or Dnarrow moves the highlight to the first menu item.
     Likewise, when the first menu item is highlighted, Leftarrow or Uparrow
     moves the highlight to the last menu item.

     When WRAP is OFF, pressing Uparrow or Leftarrow from the first menu item
     or Dnarrow or Rightarrow from the last menu item does nothing.

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...PROMPT" "MENU TO" "SET MESSAGE" 
'------------------------------------------------------------------------------



!short: SKIP            Move the record pointer to a new position
'------------------------------------------------------------------------------
 ^bSKIP^b
 Move the record pointer to a new position
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSKIP [<nRecords>] [ALIAS <idAlias> | <nWorkArea>]

 ^bArguments^b

     ^b<nRecords>^b is a numeric expression specifying the number of records
     to move the record pointer from the current position.  A positive value
     moves the record pointer forward and a negative value moves the record
     pointer backward.

     ^bALIAS <idAlias>|<nWorkArea>^b specifies the alias name as a literal
     identifier or the work area as a numeric expression.

     SKIP specified with no arguments moves the record pointer forward one
     record.

 ^bDescription^b

     SKIP moves the record pointer to a new position relative to the current
     position in the current work area and within the current filter if there
     is one.  SKIP is generally used for operations, such as reporting, that
     need to go to the next record in a database file.

     If the alias clause is specified, the pointer can be moved in another
     work area without SELECTing that work area.  SKIP can move either
     forward or backward.  If there is no active index, SKIP moves the record
     pointer relative to the current position in the target database file.
     If there is an active index, SKIP moves the pointer relative to the
     current position in the index instead of the database file.

     Attempting to SKIP forward beyond the end of file positions the record
     pointer at LASTREC() + 1 and EOF() returns true (.T.).  Attempting to
     SKIP backward beyond the beginning of file moves the pointer to the
     first record and BOF() returns true (.T.).

     In a network environment, any record movement command, including SKIP,
     makes changes to the current work area visible to other applications if
     the current file is shared and the changes were made during an RLOCK().
     To force an update to become visible without changing the current record
     position, use SKIP 0.  If, however, the changes were made during an
     FLOCK(), visibility is not guaranteed until the lock is released, a
     COMMIT is performed, or the file is closed.  Refer to the Network
     Programming chapter in the Programming and Utilities guide for more
     information.

 ^bExamples^b

     ^b^CFE^b  This example uses SKIP with various arguments and shows the
        result:

        USE Customers NEW
        SKIP
        ? RECNO()                  // Result: 2
        SKIP 10
        ? RECNO()                  // Result: 12
        SKIP -5
        ? RECNO()                  // Result: 7

     ^b^CFE^b  This example moves the record pointer in a remote work area:

        USE Customers NEW

        USE Invoices NEW
        SKIP ALIAS Customers

     ^b^CFE^b  This example prints a report using SKIP to move the record
        pointer sequentially through the Customer database file:

        LOCAL nLine := 99
        USE Customers NEW
        SET PRINTER ON
        DO WHILE !EOF()
           IF nLine > 55
              EJECT
              nLine := 1
           ENDIF
              Customer, Address, City, State, Zip
              nLine++
              SKIP
           ENDDO
        SET PRINTER OFF
        CLOSE Customers

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"BOF()" "COMMIT" c52g_001.ngo:"DBSKIP()" c52g_001.ngo:"EOF()" "GO" "LOCATE" c52g_001.ngo:"RECNO()" "SEEK" 
'------------------------------------------------------------------------------



!short: SORT            Copy to a (.dbf) file in sorted order
'------------------------------------------------------------------------------
 ^bSORT^b
 Copy to a (.dbf) file in sorted order
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSORT TO <xcDatabase> ON <idField> [/[A | D][C]]
     ^b   [, <idField2> [/[A | D][C]]...]
     ^b   [<scope>] [WHILE <lCondition>] [FOR <lCondition>]

 ^bArguments^b

     ^bTO <xcDatabase>^b is the name of the target file for the sorted
     records and can be specified either as a literal filename or as a
     character expression enclosed in parentheses.  Unless otherwise
     specified, the new file is assigned a (.dbf) extension.

     ^bON <idField>^b is the sort key and must be a field variable.

     ^b/[A|D][C]^b specifies how <xcDatabase> is to be sorted.  /A sorts in
     ascending order.  /D sorts in descending order.  /C sorts in dictionary
     order by ignoring the case of the specified character field.  The
     default SORT order is ascending.

     ^b<scope>^b is the portion of the current database file to SORT.  The
     default is ALL records.

     ^bWHILE <lCondition>^b specifies the set of records meeting the
     condition from the current record until the condition fails.

     ^bFOR <lCondition>^b specifies the conditional set of records to SORT
     within the given scope.

 ^bDescription^b

     SORT is a database command that copies records from the current work
     area to another database file in sorted order.  CA-Clipper SORTs
     character fields in accordance with the ASCII value of each character
     within the string unless the /C option is specified.  This option causes
     the database file to be SORTed in dictionary order--capitalization is
     ignored.  Numeric fields are SORTed in numeric order, date fields are
     SORTed chronologically, and logical fields are sorted with true (.T.) as
     the high value.  Memo fields cannot be SORTed.

     SORT performs as much of its operation as possible in memory then it
     spools to a uniquely named temporary disk file.  This temporary file can
     be as large as the size of the source database file.  Note also that a
     SORT uses up three file handles: the source database file, the target
     database file, and the temporary file.

     In a network environment, you must lock the database file to be SORTed
     with FLOCK() or USE it EXCLUSIVEly.

 ^bNotes^b

     ^b^CFE  Deleted source records:^b If DELETED is OFF, SORT copies deleted
        records to the target database file; however, the deleted records do
        not retain their deleted status.  No record is marked for deletion in
        the target file regardless of its status in the source file.

        If DELETED is ON, deleted records are not copied to the target
        database file.  Similarly, filtered records are ignored during a SORT
        and are not included in the target file.

     ^b^CFE  SET EXACT:^b SET EXACT has no effect on SORTing.

 ^bExamples^b

     ^b^CFE^b  This example copies a sorted subset of a mailing list to a
        smaller list for printing:

        USE Mailing INDEX Zip
        SEEK "900"
        SORT ON LastName, FirstName TO Invite WHILE Zip = "900"
        USE Invite NEW
        REPORT FORM RsvpList TO PRINTER

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"ASORT()" c52g_001.ngo:"FLOCK()" "INDEX" "USE" 
'------------------------------------------------------------------------------



!short: STORE*          Assign a value to one or more variables
'------------------------------------------------------------------------------
 ^bSTORE*^b
 Assign a value to one or more variables
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSTORE <exp> TO <idVar list>
     ^b<idVar> = <exp>
     ^b<idVar> := [ <idVar2> := ...] <exp>

 ^bArguments^b

     ^b<exp>^b is a value of any data type that is assigned to the specified
     variables.

     ^bTO <idVar list>^b defines a list of one or more local, static, public,
     private, or field variables that are assigned the value <exp>.  If any
     <idVar> is not visible or does not exist, a private variable is created
     and assigned <exp>.

 ^bDescription^b

     STORE assigns a value to one or more variables of any storage class.
     The storage classes of CA-Clipper variables are local, static, field,
     private, and public.  STORE is identical to the simple assignment
     operators (=) and (:=).  In fact, a STORE statement is preprocessed into
     an assignment statement using the inline operator (:=).  Like all of the
     assignment operators, STORE assigns to the most recently declared and
     visible variable referenced by <idVar>.  If, however, the variable
     reference is ambiguous (i.e., not declared at compile time or not
     explicitly qualified with an alias), it is assumed to be MEMVAR.  At
     runtime, if no private or public variable exists with the specified
     name, a private variable is created.

     To override a declaration, you can specify the <idVar> prefaced by an
     alias.  If <idVar> is a field variable, use the name of the work area.
     For private and public variables, you can use the memory variable alias
     (MEMVAR->).  To assign to a field variable in the currently selected
     work area (as opposed to a particular named work area), you can use the
     field alias (FIELD->).

     As a matter of principle, all variables other than field variables
     should be declared.  Preface field variables with the alias.  Use of
     private and public variables is discouraged since they violate basic
     principles of modular programming and are much slower than local and
     static variables.

     Note that the STORE command is a compatibility command and not
     recommended for any assignment operation.  CA-Clipper provides
     assignment operators that supersede the STORE command, including the
     inline assignment operator (:=), the increment and decrement operators
     (++) and (--), and the compound assignment operators (+=, -=, *=, /=).
     Refer to the Operators and Variables sections of the Basic Concepts
     chapter in the Programming and Utilities guide for more information.

 ^bNotes^b

     ^b^CFE  Assigning a value to an entire array:^b In CA-Clipper, neither
        the STORE command nor the assignment operators can assign a single
        value to an entire array.  Use the AFILL() function for this purpose.

     ^b^CFE  Memo fields:^b Assigning a memo field to a variable assigns a
        character value to that variable.

 ^bExamples^b

     ^b^CFE^b  These statements create and assign values to undeclared
        private variables:

        STORE "string" TO cVar1, cVar2, cVar3
        cVar1:= "string2"
        cVar2:= MEMVAR->cVar1

     ^b^CFE^b  These statements assign multiple variables using both STORE
        and the inline assignment operator (:=).  The methods produce
        identical code:

        STORE "value" to cVar1, cVar2, cVar3
        cVar1 := cVar2 := cVar3 := "value"

     ^b^CFE^b  These statements assign values to the same field referenced
        explicitly with an alias.  The first assignment uses the field alias
        (FIELD->), where the second uses the actual alias name:

        USE Sales NEW
        FIELD->CustBal = 1200.98
        Sales->CustBal = 1200.98

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_004.ngo:"PRIVATE" c52g_004.ngo:"PUBLIC" "RELEASE" "REPLACE" "RESTORE" "SAVE" 
'------------------------------------------------------------------------------



!short: SUM             Sum numeric expressions to variables
'------------------------------------------------------------------------------
 ^bSUM^b
 Sum numeric expressions to variables
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bSUM <nExp list> TO <idVar list>
     ^b   [<scope>] [WHILE <lCondition>] [FOR <lCondition>]

 ^bArguments^b

     ^b<nExp list>^b is the list of numeric values to sum for each record
     processed.

     ^bTO <idVar list>^b identifies the receiving variables to assign the
     results of the sum.  Variables that either do not exist or are not
     visible are created as private variables.  <idVar list> must contain the
     same number of elements as <nExp list>.

     ^b<scope>^b is the portion of the current database file to SUM.  The
     default scope is ALL records.

     ^bWHILE <lCondition>^b specifies the set of records meeting the
     condition from the current record until the condition fails.

     ^bFOR <lCondition>^b specifies the conditional set of records to SUM
     within the given scope.

 ^bDescription^b

     SUM is a database command that totals a series of numeric expressions
     for a range of records in the current work area and assigns the results
     to a series of variables.  The variables specified in <idVar list> can
     be field, local, private, public, or static.

     Note that the <nExp list> is required and not optional as it is in other
     dialects.

 ^bExamples^b

     ^b^CFE^b  This example illustrates the use of SUM:

        LOCAL nTotalPrice, nTotalAmount
        USE Sales NEW
        SUM Price * .10, Amount TO nTotalPrice, nTotalAmount
        //
        ? nTotalPrice               // Result: 151515.00
        ? nTotalAmount              // Result: 150675.00

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "AVERAGE" c52g_001.ngo:"DBEVAL()" "TOTAL" 
'------------------------------------------------------------------------------



!short: TEXT*           Display a literal block of text
'------------------------------------------------------------------------------
 ^bTEXT*^b
 Display a literal block of text
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bTEXT [TO PRINTER] [TO FILE <xcFile>]
     ^b   <text>...
     ^bENDTEXT

 ^bArguments^b

     ^b<text>^b is the block of literal characters to display to the screen.
     Text is displayed exactly as formatted.

     ^bTO PRINTER^b echoes the display to the printer.

     ^bTO FILE <xcFile>^b echoes the display to the specified file.  <xcFile>
     may be specified as a literal filename or as a character expression
     enclosed in parentheses.  If no extension is specified, (.txt) is
     assumed.

 ^bDescription^b

     TEXT...ENDTEXT is a console command construct that displays a block of
     text to the screen, optionally echoing output to the printer and/or a
     text file.  To suppress output to the screen while printing or echoing
     output to a file, SET CONSOLE OFF before the TEXT command line.

     Text within the TEXT construct displays exactly as formatted, including
     any indentation.  Hard carriage returns are output as new lines, soft
     carriage returns as the character CHR(141).  Macro variables found
     within TEXT...ENDTEXT are expanded.  However, macro expressions are not.

     TEXT...ENDTEXT is a compatibility command and not recommended.
     CA-Clipper has other facilities for text processing and output.  For
     example, MEMOLINE() in combination with MLCOUNT() can word wrap long
     strings according to a specified line length.  ? or @...SAY can display
     formatted text extracted from a long string with MEMOLINE().

 ^bExamples^b

     ^b^CFE^b  This example demonstrates how to use TEXT...ENDTEXT to print a
        form letter:

        USE Sales NEW
        DO WHILE !EOF()
           FormLetter()
           SKIP
        ENDDO
        RETURN

        FUNCTION FormLetter
           LOCAL dDate := DTOC(DATE()), cSalesman := ;
                    RTRIM(Salesman)
           TEXT TO PRINTER
           &dDate.
           Dear &cSalesman.,
           How are you!
           ENDTEXT
           EJECT
           RETURN NIL

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "?|??" "@...SAY" c52g_001.ngo:"MEMOLINE()" c52g_001.ngo:"MLCOUNT()" "SET CONSOLE" 
'------------------------------------------------------------------------------



!short: TOTAL           Summarize records by key value to a (.dbf) file
'------------------------------------------------------------------------------
 ^bTOTAL^b
 Summarize records by key value to a (.dbf) file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bTOTAL ON <expKey> FIELDS <idField list>
     ^b   TO <xcDatabase>
     ^b   [<scope>] [WHILE <lCondition>] [FOR <lCondition>]

 ^bArguments^b

     ^bON <expKey>^b defines the group of records that produce a new record
     in the target database file.  To make the summarizing operation
     accurate, the source database file should be INDEXed or SORTed on this
     expression.

     ^bFIELDS <idField list>^b specifies the list of numeric fields to TOTAL.
     If the FIELDS clause is not specified, no numeric fields are totaled.
     Instead each numeric field in the target file contains the value for the
     first record matching the key expression.

     ^bTO <xcDatabase>^b is the name of the target file that will contain the
     copy of the summarized records.  Specify this argument as a literal
     filename or as a character expression enclosed in parentheses.  Unless
     otherwise specified, TOTAL assumes a (.dbf) extension.

     ^b<scope>^b is the portion of the current database file to TOTAL.  The
     default is ALL records.

     ^bWHILE <lCondition>^b specifies the set of records meeting the
     condition from the current record until the condition fails.

     ^bFOR <lCondition>^b specifies the conditional set of records to TOTAL
     within the given scope.

 ^bDescription^b

     TOTAL is a database command that sequentially processes the current
     database file summarizing records by the specified key value and copying
     them to a new database file.  TOTAL works by first copying the structure
     of the current database file to <xcDatabase>, except for memo fields.
     It then sequentially scans the current database file within the
     specified scope of records.  As each record with a unique <expKey> value
     is encountered, that record is copied to the new database file.  The
     values of numeric fields specified in <idField list> from successive
     records with the same <expKey> value are added to fields with the same
     names in <xcDatabase>.  Summarization proceeds until a record with a new
     key value is encountered.  The process is then repeated for this record.

     Since TOTAL processes the source database file sequentially, it must be
     INDEXed or SORTed in <expKey> order for the summarization to be correct.

     To successfully TOTAL numeric fields, the source numeric fields must be
     large enough to hold the largest total possible for that numeric field.
     If not, a runtime error is generated.

 ^bNotes^b

     ^b^CFE  Deleted source records:^b If DELETED is OFF, deleted records in
        the source file are TOTALed.  Records in the target <xcDatabase>
        inherit the deleted status of the first matching record in the source
        file, just as nontotaled fields inherit their values.  If DELETED is
        ON, however, none of the deleted source records are TOTALed.

 ^bExamples^b

     ^b^CFE^b  In this example, a database file is TOTALed ON the key
        expression of the controlling index using a macro expression.  When
        the macro expression is encountered, the expression is evaluated and
        the resulting character string is substituted for the TOTAL <expKey>
        argument:

        USE Sales INDEX Branch NEW
        TOTAL ON &(INDEXKEY(0)) FIELDS Amount TO Summary

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "AVERAGE" "INDEX" "SORT" "SUM" 
'------------------------------------------------------------------------------



!short: TYPE            Display the contents of a text file
'------------------------------------------------------------------------------
 ^bTYPE^b
 Display the contents of a text file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bTYPE <xcFile> [TO PRINTER] [TO FILE <xcOutFile>]

 ^bArguments^b

     ^b<xcFile>^b is the name of the file, including extension, to display to
     the screen.  This argument may be specified as a literal filename or as
     a character expression enclosed in parentheses.  <xcFile> must be
     specified with an extension if it has one.

     ^bTO PRINTER^b echoes the display to the printer.

     ^bTO FILE <xcOutFile>^b echoes the display to the specified file.
     <xcOutFile> may be specified either as a literal filename or as a
     character expression enclosed in parentheses.  If no extension is
     specified, (.txt) is added.

 ^bDescription^b

     TYPE is a console command that displays the contents of a text file to
     the screen, optionally echoing the display to the printer and/or another
     text file.  To suppress output to the screen while printing or echoing
     output to a file, SET CONSOLE OFF before the TYPE invocation.

     If <xcFile> is specified without a path and/or drive designator, TYPE
     searches the current DEFAULT directory then the current PATH.  If
     <xcOutFile> is specified without a path and/or drive designator, TYPE
     creates the file in the current DEFAULT directory.

     TYPE performs no special formatting on the listing.  There are no
     special headings or pagination when the output is sent to the printer.

     To pause output, use Ctrl-S.  Note that you cannot interrupt a listing
     with Esc.

 ^bExamples^b

     ^b^CFE^b  This example illustrates the TYPE command:

        TYPE Main.prg TO PRINTER

 ^bFiles:^b  Library is EXTEND.LIB.
!seealso: "COPY FILE" "SET DEFAULT" "SET PATH" "SET PRINTER" 
'------------------------------------------------------------------------------



!short: UNLOCK          Release file/record locks set by the current user
'------------------------------------------------------------------------------
 ^bUNLOCK^b
 Release file/record locks set by the current user
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bUNLOCK [ALL]

 ^bArguments^b

     ^bALL^b releases all current locks in all work areas.  If not specified,
     only the lock in the current work area is released.

 ^bDescription^b

     UNLOCK is a network command that releases file or record locks set by
     the current user.  Use it when you want to release the current lock
     without setting a new lock.  Both FLOCK() and RLOCK() release the
     current lock before setting a new one.

     After an UNLOCK, an update to a shared database file and associated
     index and memo files becomes visible to DOS and other applications but
     is not guaranteed to appear on disk until you perform a COMMIT or close
     the file.

     Refer to the Network Programming chapter in the Programming and
     Utilities guide for more information on the principles of locking and
     update visibility.

 ^bNotes^b

     ^b^CFE  SET RELATION:^b UNLOCK does not automatically release a record
        lock along a RELATION chain unless you UNLOCK ALL.

 ^bExamples^b

     ^b^CFE^b  This example attempts an update operation that requires a
        record lock.  If the RLOCK() is successful, the record is updated
        with a user-defined function and the RLOCK() is released with UNLOCK:

        USE Sales INDEX Salesman SHARED NEW
        IF RLOCK()
           UpdateRecord()
           UNLOCK
        ELSE
           ? "Record update failed"
           BREAK
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: c52g_001.ngo:"FLOCK()" c52g_001.ngo:"RLOCK()" "SET RELATION" "USE" c52g_001.ngo:"DBUNLOCK()" 
'------------------------------------------------------------------------------



!short: UPDATE          Update current database file from another database file
'------------------------------------------------------------------------------
 ^bUPDATE^b
 Update current database file from another database file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bUPDATE FROM <xcAlias>
     ^b   ON <expKey> [RANDOM]
     ^b   REPLACE <idField> WITH <exp>
     ^b   [, <idField2> WITH    <exp2>...]

 ^bArguments^b

     ^bFROM <xcAlias>^b specifies the alias of the work area used to update
     records in the current work area.  This argument may be specified either
     as a literal filename or as a character expression enclosed in
     parentheses.

     ^bON <expKey>^b specifies the expression that defines matching records
     in the FROM work area.

     ^bREPLACE <idField>^b specifies a field in the current work area to
     replace with a new value.

     ^bWITH <exp>^b specifies the value to replace into the current field.
     You must reference any field contained in the FROM work area with the
     correct alias.

     ^bRANDOM^b allows records in the FROM database file to be in any order.
     If this option is specified, the current database file must be indexed
     on <expKey>.

 ^bDescription^b

     UPDATE is a database command that replaces fields in the current work
     area with values from another work area based on the specified key
     expression.  UPDATE is designed to update only current work area records
     based on a one-to-one or one-to-many relation with the FROM work area.
     This means that UPDATE can only update records in the current work area
     with unique key values.  When there is more than one instance of a key
     value, only the first record with the key value is updated.  The FROM
     work area, however, can have duplicate key values.

     There are two formulations of the command depending on whether the FROM
     work area records are sorted or indexed on <expKey> or not.  If RANDOM
     is not specified, both the current work area and the FROM work area must
     be indexed or sorted in <expKey> order.  If RANDOM is specified, the
     current work area must be indexed by <expKey>, but the FROM work area
     records can be in any order.

     To use UPDATE in a network environment, the current database file must
     be locked with FLOCK() or USEed EXCLUSIVEly.  The FROM database file may
     be used in any mode.  Refer to the Network Programming chapter in the
     Programming and Utilities guide for more information.

 ^bNotes^b

     ^b^CFE  Deleted records:^b If DELETED is OFF, deleted records in both
        source files are processed.  Records in the file being updated retain
        their deleted status and are not affected by the deleted status of
        records in the FROM file.  If DELETED is ON, however, no deleted
        records are processed from either source file.

 ^bExamples^b

     ^b^CFE^b  This example UPDATEs Customers database file with outstanding
        invoice amounts:

        USE Invoices NEW
        USE Customer INDEX Customer NEW
        UPDATE FROM Invoices ON Last;
           REPLACE Owed WITH Owed + Invoices->Amount RANDOM

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "INDEX" "JOIN" "REPLACE" "SET UNIQUE*" "SORT" "TOTAL" 
'------------------------------------------------------------------------------



!short: USE             Open an existing (.dbf) and its associated files
'------------------------------------------------------------------------------
 ^bUSE^b
 Open an existing (.dbf) and its associated files
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bUSE [<xcDatabase>
     ^b   [INDEX <xcIndex list>]
     ^b   [ALIAS <xcAlias>] [EXCLUSIVE | SHARED]
     ^b   [NEW] [READONLY]
     ^b   [VIA <cDriver>]]

 ^bArguments^b

     ^b<xcDatabase>^b is the name of the database file to open and may be
     specified either as a literal filename or as a character expression
     enclosed in parentheses.


     ^bINDEX <xcIndex list>^b specifies the names of 1 to 15 index files to
     open in the current work area.  Specify each index as a literal filename
     or as a character expression enclosed in parentheses.  The first index
     in the list becomes the controlling index.  If you specify an <xcIndex>
     as an expression and the value returned is spaces or NIL, it is ignored.

     ^bALIAS <xcAlias>^b specifies the name to associate with the work area
     when the database file is opened.  You may specify the alias name as a
     literal name or as a character expression enclosed in parentheses.  A
     valid <xcAlias> may be any legal identifier (i.e., it must begin with an
     alphabetic character and may contain numeric or alphabetic characters
     and the underscore).  Within a single application, CA-Clipper  will not
     accept duplicate aliases.  If this clause is omitted, the alias defaults
     to the database filename.

     ^bEXCLUSIVE^b opens the database file for nonshared use in a network
     environment.  All other users are denied access until the database file
     is CLOSEd.

     ^bSHARED^b opens the database file for shared use in a network
     environment.  Specifying this clause overrides the current EXCLUSIVE
     setting.

     ^bNEW^b opens <xcDatabase> in the next available work area making it the
     current work area.  If this clause is not specified, <xcDatabase> is
     opened in the current work area.

     ^bREADONLY^b opens <xcDatabase> with a read-only attribute.  This lets
     you open database files marked read-only.  If you cannot open the
     <xcDatabase> this way, a runtime error is generated.  If this clause is
     not specified, <xcDatabase> is opened read-write.

     ^bVIA <cDriver>^b specifies the replaceable database driver (RDD) with
     which to process the current work area.  <cDriver> is name of the RDD
     specified as a character expression.  If <cDriver> is specified as a
     literal value, it must be enclosed in quotes.

     If the VIA clause is omitted, the DBFNTX driver is used by default.
     Note that if the specified driver is not linked, an unrecoverable error
     occurs.

     In no arguments are specified, the database file open in the current
     work area is closed.

 ^bDescription^b

     USE opens an existing database (.dbf) file, its associated memo (.dbt)
     file, and optionally associated index (.ntx or .ndx) file(s) in the
     current or the next available work area.  In CA-Clipper, there are 250
     work areas with a maximum of 255 total files open in DOS 3.3 and above.
     Before USE opens a database file and its associated files, it closes any
     active files already open in the work area.  When a database file is
     first opened, the record pointer is positioned at the first logical
     record in the file (record one if there is no index file specified).

     In a network environment, you may open database files as EXCLUSIVE or
     SHARED.  EXCLUSIVE precludes the USE of the database file by other users
     until the file is closed.  SHARED allows other users to USE the database
     file for concurrent access.  If the database file is SHARED,
     responsibility for data integrity falls upon the application program.
     In CA-Clipper, FLOCK() and RLOCK() are the two basic means of denying
     other users access to a particular work area or record.  If a USE is
     specified and neither EXCLUSIVE nor SHARED are specified, the database
     file is opened according to the current EXCLUSIVE setting.  In
     CA-Clipper, all USE commands should explicitly specify how the database
     file is to be opened, EXCLUSIVE or SHARED.  The implicit open mode
     specified by SET EXCLUSIVE is supplied for compatibility purposes only
     and not recommended.

     Opening a database file in a network environment requires some special
     handling to be successful.  First, attempt to USE the database file
     without specifying the INDEX list.  Then, test for the success of the
     operation using NETERR().  If NETERR() returns false (.F.), the open
     operation succeeded and you can SET INDEX TO the index list.  A USE will
     fail in a network environment if another user has EXCLUSIVE USE of the
     database file.  Refer to the Network Programming chapter in the
     Programming and Utilities guide for more information on opening files in
     a network environment.

     You can open index files with USE or SET INDEX.  The first index in the
     list of indexes defines the current ordering of records when they are
     accessed.  This index is referred to as the controlling index.  You can
     change the current controlling index without closing any files by using
     the SET ORDER command.

     To close a database and its associated files in the current work area,
     specify USE or CLOSE with no arguments.  To close database files in all
     work areas, use CLOSE DATABASEs.  To close index files in the current
     work area without closing the database file, use CLOSE INDEX or SET
     INDEX TO with no arguments.

     Refer to the Database System section of the Basic Concepts chapter in
     the Programming and Utilities guide for more information about the
     CA-Clipper database paradigm.

 ^bNotes^b

     ^b^CFE  Setting the maximum open files:^b Control of the number of file
        handles available to a CA-Clipper application is controlled by a
        combination of the CONFIG.SYS FILES command, and the F parameter of
        the CLIPPER environment variable.  The F parameter specifies the
        maximum number of files that can be open at any one time within the
        current CA-Clipper program.  CA-Clipper determines the number of
        files that can be opened using the smaller of the two parameters.
        For example, if the FILES command is set to 120 and the F parameter
        is set to 50, the maximum number of files that can be opened is 50.

        The file limit is controlled by the operating system.  Under DOS
        versions less than 3.3, the maximum number of files that can be
        opened at one time is 20 files.  In DOS versions 3.3 and greater, the
        maximum limit is 255 files.

     ^b^CFE  Opening the same database file in more than one work area:^b
        Although opening a database file in more than one work area is
        possible in a network environment, this practice is strongly
        discouraged.  If done, each file must be opened with a different
        alias, otherwise a runtime error will occur.

     ^b^CFE  Opening two database files with the same names, in different^b
        ^bdirectories:^b Although opening two database files with the same
        names, in different directories is possible, the database files MUST
        have unique alias names, otherwise a runtime error will occur.

 ^bExamples^b

     ^b^CFE^b  This example opens a shared database file with associated
        index files in a network environment.  If NETERR() returns false
        (.F.), indicating the USE was successful, the indexes are opened:

        USE Accounts SHARED NEW
        IF !NETERR()
           SET INDEX TO AcctNames, AcctZip
        ELSE
           ? "File open failed"
           BREAK
        ENDIF

     ^b^CFE^b  This example opens a database file with several indexes
        specified as extended expressions.  Note how the array of index names
        is created as a constant array:

        xcDatabase = "MyDbf"
        xcIndex = {"MyIndex1", "MyIndex2", "MyIndex3"}
        USE (xcDatabase) INDEX (xcIndex[1]), ;
              (xcIndex[2]), (xcIndex[3])

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "CLOSE" c52g_001.ngo:"NETERR()" "SELECT" "SET INDEX" c52g_001.ngo:"USED()" c52g_001.ngo:"DBUSEAREA()" 
'------------------------------------------------------------------------------



!short: WAIT*           Suspend program processing until a key is pressed           ^r^CE4^r
'------------------------------------------------------------------------------
 ^bWAIT*^b
 Suspend program processing until a key is pressed
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bWAIT [<expPrompt>] [TO <idVar>]

 ^bArguments^b

     ^b<expPrompt>^b is an expression of any data type displayed as a prompt.
     If no <expPrompt> is specified, the default prompt displayed is:  "Press
     any key to continue..."

     ^bTO <idVar>^b is the variable, of any storage class, that holds the
     value of the key pressed as a character value.  If <idVar> does not
     exist or is not visible, it is created as a private variable and then
     assigned the character value.

 ^bDescription^b

     WAIT is a console command and wait state that displays a prompt after
     sending a carriage return/linefeed to the screen.  It then waits for the
     user to press a key.  If the TO clause is specified, <idVar> is assigned
     the keystroke as a character value.  If an Alt or Ctrl key is pressed,
     WAIT assigns CHR(0) to <idVar>.  Nonalphanumeric values entered by
     pressing an Alt-keypad combination assign the specified character.  If
     the character can be displayed, it is echoed to the screen.  Function
     keys are ignored unless assigned with SET FUNCTION or SET KEY.

     WAIT is a compatibility command and therefore not recommended for
     general usage.  It is superseded by both @...GET/READ and INKEY() for
     getting single character input.

 ^bNotes^b

     ^b^CFE  WAITing without a prompt:^b To pause execution without
        displaying a prompt, specify WAIT "" or INKEY(0).  The latter is
        recommended since it doesn't disturb the current screen cursor
        position.

 ^bExamples^b

     ^b^CFE^b  This example illustrates how to store the WAIT keystroke as an
        array element:

        aVar := ARRAY(6)

        WAIT "Press a key..." TO aVar[1]
        ? aVar[1]               // Result: key pressed in
                                // response to WAIT
        ? aVar[2]               // Result: NIL
        ? VALTYPE(aVar)         // Result: A
        ? VALTYPE(aVar[1])      // Result: C

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "@...GET" "ACCEPT" c52g_001.ngo:"INKEY()" "INPUT" "MENU TO" 
'------------------------------------------------------------------------------



!short: ZAP             Remove all records from the current database file
'------------------------------------------------------------------------------
 ^bZAP^b
 Remove all records from the current database file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bZAP

 ^bDescription^b

     ZAP is a database command that permanently removes all records from
     files open in the current work area.  This includes the current database
     file, index files, and associated memo file.  Disk space previously
     occupied by the ZAPped files is released to the operating system.  ZAP
     performs the same operation as DELETE ALL followed by PACK but is almost
     instantaneous.

     To ZAP in a network environment, the current database file must be USEd
     EXCLUSIVEly.  Refer to the Network Programming chapter in the
     Programming and Utilities guide for more information.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a typical ZAP operation in a network
        environment:

        USE Sales EXCLUSIVE NEW
        IF !NETERR()
           SET INDEX TO Sales, Branch, Salesman
           ZAP
           CLOSE Sales
        ELSE
           ? "Zap operation failed"
           BREAK
        ENDIF

 ^bFiles:^b  Library is CLIPPER.LIB.
!seealso: "DELETE" "PACK" "USE" 
'------------------------------------------------------------------------------



