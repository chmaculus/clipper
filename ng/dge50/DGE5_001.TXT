!short: AreaGraph()     Draw an area graph
'------------------------------------------------------------------------------
^BSyntax^B
DataStore(<nAmplitude>, <nFill>, <nXPosition>, <nColor>)
AreaGraph(<nX>, <nY>, <nXInc>, <nHeight>, <nStyle>,
          <nGroups> )

^BDescription^B
Draws an area graph. The data may be graphed in either 
absolute or relative style.

The absolute style graphs each amplitude value starting from 
the X axis. With the relative style the starting point for each 
amplitude value is where a corresponding value in the previous 
data group ended. In other words, the relative style shows 
cumulative values, or totals with subtotals, just as a stacked bar 
graph does.

Both styles accept two options. One shows data as percentile 
values. Another lets you specify individual positions along the X 
axis for each data point. If you wish, you can combine the two 
options. For example, a relative style graph can show data as
percentile values and also use variable X axis values.

^BData^B
If you select the relative style, the first data group will be on the 
bottom and each succeeding group will be stacked above the 
group that came before. Even so, you should store your data in 
point order, not in group order. In other words, store it just as 
you would for a stacked bar graph.

For example, if your data has nine values in three groups, store 
the first point in group one, then the first point in group two, 
then the first point in group three. These values will graph one 
above the other at the first position on the X axis.

After you have stored the first point for all three groups, begin 
storing the second point of each group. Then do the same for the 
third group.

Assuming that you are storing data from three arrays of equal 
length, your code might look like this:

DataReset()
FOR i = 1 to LEN(aGroup1)
   r = DataStore(aGroup1[i], nFill1, 0, nColor1)
   r = DataStore(aGroup2[i], nFill2, 0, nColor2)
   r = DataStore(aGroup3[i], nFill3, 0, nColor3)
NEXT i

If you select the absolute style, the procedure is much the 
same. However, since with this style all values are measured 
from the X axis, dGE will assume that the largest values are in 
the last group and will draw that group first, then the next to 
the last, and so on. This is done to avoid masking lesser values 
when greater values are graphed.

This method of drawing has important implications. If the 
values you are graphing do not range from smaller to larger, it is 
possible that some values will be masked. To see why, it may 
help to compare the absolute style area graph with a clustered 
bar graph of the same data:

The clustered bar graph shows, in effect, a side view of the 
absolute area graph. It also suggests what may happen if you 
reverse the order of the groups, storing the largest values first.

In this case the larger values mask the lesser ones. You can 
avoid this problem only if you know something about your data. 
If you do not, it is best to select the relative style area graph.

^BParameters^B

^UDataStore(<nAmplitude>, <nFill>, <nXPosition>, <nColor>)^U

^U<nAmplitude>^U
Amplitude value. The value may be either positive or negative for 
all styles with one exception. When you are using the percentile 
option, all values must be positive.

^U<nFill>^U
Instructions for filling the space between lines. dGE uses only
the value for the first point in each group.

        Value           Meaning
        컴컴컴          컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 19         Fill with one of the hatch patterns
                        illustrated at Appendix A.

        20              Fill with the current pattern background
                        color.

^U<nXPosition>^U
Position along the horizontal axis. This value is graphed only if 
the nXInc argument for AreaGraph() is zero. Even then, dGE will 
use only the first X position value in each group. In other words, 
the first point in all groups will be aligned along the X axis, as 
will the second point in all groups, and the third, and so on.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal(). As with
nFill, dGE uses only the value for the first point in each group.

^UAreaGraph(<nX>, <nY>, <nXInc>, <nHeight>, <nStyle>, <nGroups> )^U

^U<nX>^U
X origin for the graph.

^U<nY>^U
Y origin for the graph.

dGE's default coordinate system is described under the entry for 
SetVer().

^U<nXInc>^U
Selects either fixed or variable increments along the X axis.

        Value   Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        > 0     Points are spaced nXInc apart along the X
                axis.
          0     Points are drawn in scatter format. 
                Positions along the X axis are variable, 
                each set by the third argument 
                (nXPosition) passed to DataStore().

^U<nHeight>^U
Height of the graph in screen units. dGE uses this information 
only when you select the percentile style option. In this case, the 
graph has a height of nHeight screen units and each amplitude 
value is graphed as a percentage of nHeight . See nStyle below.

^U<nStyle>^U
Graph style.

        Value   Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Relative. Amplitude values define each
                data point's distance above a 
                corresponding point in the data group 
                graphed immediately below it.

          1     Absolute. Amplitude values define a 
                distance above the horizontal axis.

        + 4     Percentile. Amplitude values are 
                expressed as a percentage of the sum of 
                all data points at a given X position.
                Selecting this option will generate a 
                runtime error if any amplitude values are 
                negative.

^U<nGroups>^U
Number of groups. If the total number of data points cannot be 
evenly divided by nGroups, dGE will omit the remainder. For 
example, if you store twelve data points and then specify five 
groups, dGE will graph only the first ten data points, omitting 
the last two.

^BRemarks^B
Like ordinary line graphs, area graphs show trends, particularly
if the values along the X axis represent increments of time. But 
unlike line graphs, area graphs also emphasize comparisons 
between quantities. Because the area between the lines is filled 
with a solid color or pattern, the eye is invited to focus on that 
space-and the mind to focus on the amounts represented-rather 
than on the lines alone and the trends they suggest. Thus an 
area graph can combine the visual impact of a line graph with 
that of a bar graph.

^BExample^B
PROCEDURE MAIN

SET CURSOR OFF

* Set screen in graphics mode
r = SetGMode(18)
r = SetHiRes(0)

* Draw grid
r = XYAxes(0, 0, 1350, 1000, 2, 2, 4 + 16 + 64, 7)

* Draw graph grids and identifying text
r = XYAxes(100, 100, 475, 300, 10, 10, 4 + 16 + 64, 7)
r = XYAxes(100, 600, 475, 300, 10, 10, 4 + 16 + 64, 7)
r = XYAxes(775, 100, 475, 300, 10, 10, 4 + 16 + 64, 7)
r = XYAxes(775, 600, 475, 300, 10, 10, 4 + 16 + 64, 7)

r = SayString(25, 525, 0, 0, 14, 'Absolute')
r = SayString(700, 525, 0, 0, 14, 'Scatter and Relative')
r = SayString(25, 25, 0, 0, 14, 'Relative')
r = SayString(700, 25, 0, 0, 14, 'Percentile')

* Store 3 groups of data, 4 data points per group

* First point of each group
r = DataStore(10, 1, 0, 9)
r = DataStore(200, 1, 0, 10)
r = DataStore(150, 1, 0, 11)

* Second point of each group
r = DataStore(50, 1, 118, 9)
r = DataStore(10, 2, 0, 10)
r = DataStore(100, 2, 0, 11)

* Third point of each group
r = DataStore(110, 2, 150, 9)
r = DataStore(150, 2, 0, 10)
r = DataStore(5, 3, 0, 11)

* Last point of each group
r = DataStore(20, 3, 475, 9)
r = DataStore(15, 3, 0, 10)
r = DataStore(50, 3, 0, 11)

* This section draws the area graphs.  Each graph
* is drawn with the same dataset.
r = AreaGraph(100, 100, 158, 300, 0, 3)
r = AreaGraph(775, 100, 158, 300, 4, 3)
r = AreaGraph(100, 600, 158, 300, 1, 3)
r = AreaGraph(775, 600, 0, 300, 0, 3)

* Pause to admire.
r = INKEY(0)

* Restore text mode
r = SetText()
QUIT

!seealso: "DataStore()" "XYAxes()" "LabelX()" "LabelY()" 
'------------------------------------------------------------------------------



!short: BarGraph()      Draw a bar graph
'------------------------------------------------------------------------------
^BSyntax^B
DataStore( <nAmplitude>, <nFill>, 0, <nColor> )
BarGraph( <nX>, <nY>, <nXInc>, <nStyle>, <nGroupSize> )

^BDescription^B
Draws a bar graph in simple, stacked, or clustered style. The 
bars may extend vertically or horizontally, and may be drawn 2D 
or 3D. The angle of perspective for 3D drawing is such that the 
sides of the bars appear at 38 degrees from the horizontal.

^BData^B
A simple bar graph has one bar for each data point. You'll need 
to store one amplitude value for each bar.

A clustered bar graph groups or clusters data points, separating 
each group with a space. The number of amplitude values that 
you'll need to store is GroupSize times the number of data 
groups.

A stacked bar graph has one bar for each data group. Each data 
point within the group is one segment of the bar. If the bars are 
vertical, the first data point is the bottom segment; if the bars 
are horizontal, it is the first segment on the left. Each 
succeeding data point is stacked above (vertical bars) or to the 
right (horizontal) of the one before. As with a clustered bar 
graph, the number of amplitude values that you'll need to store 
is GroupSize times the number of data groups.

^BParameters^B

^UDataStore( <nAmplitude>, <nFill>, 0, <nColor> )^U

^U<nAmplitude>^U
Amplitude value. For a vertical bar, an amplitude value is 
graphed as the bar's height, measured in screen units from the 
Y origin. For a stacked bar, it is graphed as the length of a 
segment of a bar.

Amplitude may be either positive or negative for all graph styles 
except stacked. Amplitude for stacked bar graphs must be 
positive.

^U<nFill>^U
Instructions for filling the bar. By default the bar is outlined 
with a solid line of nColor.

        Value           Meaning
        컴컴컴         컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 19         Fill the bar with one of the hatch
                        patterns illustrated at Appendix A.

           20           Fill the bar with the current pattern
                        background color.

        +  32           Transparent fill. The fill pattern will
                        be painted over an underlying image in
                        the background.

                        For example, a value of 34 (that is, 2 +
                        32) will draw a rectangle and fill it
                        with a pattern. The open spaces of the
                        pattern will show whatever was on screen
                        before the rectangle was drawn.

        +  64           Outline only. The bar will be outlined in
                        the color specified by nColor, and the
                        interior will be left untouched.

                        For example, a value of 84 (that is, 20 +
                        64) will draw a rectangle and clear the
                        interior to the pattern background color.

        + 128           No outline. The interior of the bar will
                        be filled but the box outline will not be
                        drawn.

                        For example, passing a value of
                        130 (that is, 2 + 128) will fill the
                        interior of the rectangle with pattern 2
                        but will not draw the sides.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^UBarGraph( <nX>, <nY>, <nXInc>, <nStyle>, <nGroupSize> )^U

^U<nX>^U
X origin for the graph.

^U<nY>^U
Y origin for the graph.

The X, Y coordinate pair locates the graph's bottom left corner.

dGE's coordinate mapping system is described under the entry 
for SetVer().

^U<nXInc>^U
Distance in screen units between adjacent bars. If the graph has 
vertical bars, nXInc is the distance from the left edge of one bar 
to the left edge of the next bar. Thus the width of a bar is one-
half the value of nXInc, and the width of the space between bars 
is also one-half the value of nXInc.



If the bars are horizontal, nXInc is the distance from the bottom 
edge of one bar to the bottom edge of the bar above it.

When the graph is drawn in clustered style, the value of nXInc is 
the distance from the left edge of the first bar in a group to the 
left edge of the first bar in the next group. The width of each bar 
and of the space between groups is nXInc divided by nGroupSize 
plus one.

^U<nStyle>^U
Graph style.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Simple. One bar is drawn for each data
                point. Adjacent bars are separated by a 
                space.

          1     Stacked. One bar is drawn for each data 
                group. Data points within each group are 
                represented as segments of a bar. 
                Adjacent bars are separated by a space.

          2     Clustered. One bar is drawn for each data 
                point, and bars are clustered by data 
                group. Bars of the same group are drawn 
                next to one another, with no intervening 
                space. Adjacent groups are separated by a 
                space.

        + 4     Horizontal bars.

        + 8     No space between adjacent bars.

        + 16    3D bars with top and sides outlined.

        + 32    3D bars with top and sides filled by 
                shading.

^U<nGroupSize>^U
Specifies the number of data points (1 to 384) per data group. 
dGE will derive the number of groups by dividing the value of 
nGroupSize into the number of data points stored with
DataStore().

If you store six data points and pass a value of three for 
nGroupSize, dGE will conclude that there are two data groups. If 
you pass a value of two for nGroupSize, dGE will conclude that 
there are three data groups.

^BRemarks^B
A bar graph is usually a good choice if you want to compare 
relative amounts. However, you should be aware that when the 
bars are vertical, viewers are predisposed to attributing a time 
sequence (running from left to right) even when none is 
intended. If you do not want to suggest a trend, select the 
horizontal option.

Stacked bars are a good choice when, in addition to comparing 
relative amounts, you also want to show subtotals.

A common variation on the stacked bar graph displays 
percentages rather than actual values. This permits
comparisons of, let's say, market share claimed by competing 
products over a number of quarters or perhaps years. The 
BarGraph() function will not draw this style automatically, but 
you can achieve it easily. Simply total the values for each data 
group, and then use the total to convert each value to a 
percentage when you pass it to DataStore().

^BExample^B
*::::::::::::::::::::::::::::::::::::::::::::::::::::
*                   BAR.PRG
*::::::::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN
   SET CURSOR OFF

* Set 640x480x16 graphics mode
r = SetGMode(18)
r = SetHiRes(0)

* Use BoxFill() to set the background to white
r = BoxFill(0, 0, 1350, 1000, 0, 15)

* Set the default font as LEGA18.PTX
r = LoadCSet(0, "LEGA18.PTX")

* Reset dGE's internal array
r = DataReset()

* Store some amplitude data
r = DataStore(140, 10, 0, 7)
r = DataStore(60, 8, 0, 7)
r = DataStore(120, 10, 0, 7)

r = DataStore(20, 8, 0, 7)
r = DataStore(130, 10, 0, 7)

r = DataStore(30, 8, 0, 7)
r = DataStore(144, 10, 0, 7)

* Using the XYAxes() function, draw a blue 3x3 grid
r = XYAxes(0, 0, 1350, 1000, 3, 3, 0 + 4 + 16, 1)

* Simple bar chart, vertical bars.         Label it A
r = BarGraph(30, 700, 50, 0, 1)
r = SayString(5, 671, 0 + 4, 0, 1, "A")

* Simple bar chart, horizontal bars.       Label it B
r = BarGraph(500, 700, 40, 0 + 4, 1)
r = SayString(455, 671, 0 + 4, 0, 1, "B")

* Simple bar chart, 3D,  top and sides
* outlined, no spaces between bars.        Label it C
r = BarGraph(950, 700, 50, 0 + 16 + 8, 1)
r = SayString(905, 671, 0 + 4, 0, 1, "C")

* Stacked bar chart, 3D, 
* top and sides filled.                    Label it D
r = BarGraph(30, 380, 100, 1 + 32, 2)
r = SayString(5, 338, 0 + 4, 0, 1, "D")

* Stacked bar chart, 2D
* no space between bars.                   Label it E
r = BarGraph(500, 380, 100, 1 + 8, 2)
r = SayString(455, 338, 0 + 4, 0, 1, "E")

* Stacked bar chart, 2D.                   Label it F
r = BarGraph(950, 380, 100, 1, 2)
r = SayString(905, 338, 0 + 4, 0, 1, "F")

* Clustered bar chart, horizontal, 3D,
* top and sides outlined.                  Label it G
r = BarGraph(30, 30, 100, 2 + 4 + 16, 2)
r = SayString(5, 5, 0 + 4, 0, 1, "G")

* Clustered bar chart, 3D, 
* top and sides filled.                    Label it H
r = BarGraph(500, 30, 100, 2 + 32, 2)
r = SayString(455, 5, 0+4, 0, 1, "H")

* Clustered bar chart, 2D.                 Label it I
r = BarGraph(950, 30, 100, 2, 2)
r = SayString(905, 5, 0 + 4, 0, 1, "I")

* Wait for a keypress
WAIT

* Set screen back to text mode
r = SetText()
QUIT

!seealso: "DataStore()" "XYAxes()" "LabelX()" "LabelY()" "BoxFill()" 
'------------------------------------------------------------------------------



!short: BestFit()       Draw a linear best-fit line
'------------------------------------------------------------------------------
^BSyntax^B
BestFit( <nWidth>, <nHeight>, <nLineStyle>, <nColor> )

^BDescription^B
Draws a linear best-fit line through data graphed with 
XYGraph() or HLCGraph(). The line is calculated using a least-
squares regression of Y on X.

^BParameters^B
The best-fit line is drawn in a window that is positioned with its 
lower left corner at the origin of the graph. nWidth and nHeight 
define the dimensions of the window. Typically nWidth will 
correspond to the length of the X axis and nHeight will 
correspond to the length of the Y axis.

^UNote^U   If your graph extends in the negative X or Y 
directions, define a window by calling SetWin(). Then pass zero 
as nLength when you call BestFit().

^U<nWidth>^U
Width, in screen units, of the window for the best-fit line. The 
window extends in a positive direction from the X origin of the 
graph.

If nWidth is zero, dGE will draw the lines within a window 
previously defined by a call to SetWin().

^U<nHeight>^U
Height, in screen units, of the window for the best-fit line.

^U<nLineStyle>^U
Selects the type of line to be drawn.

         Value          Meaning
        컴컴컴          컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0             Solid line.

        > 0             Broken line with an interval of nStyle
                        pixels between segments.

        + (n * 128)     For plotters only. The value n is the 
                        plotter's line style index, which may be
                        used to select various mark/space
                        patterns. Refer to your plotter
                        documentation for details.

                      ^UNote^U   If n = 0, the default style is
                        2 (even mark/space). Style 0, a single
                        dot, is not available.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^BExample^B
*:::::::::::::::::::::::::::::::::::::::::::::::::::::::
*                   BEST-FIT.PRG
*:::::::::::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN

SET CURSOR OFF
* Set screen into graphics mode
r = SetHiRes(0)

* Put title on screen
r = SayString(675, 950, 0, 0 + 8, 12, ;
              "This is a standard best-fit line")

* Loop to draw graph 5 times
FOR i = 1 to 5
   * Clear lower 90% of screen, erasing graph
   * but leaving title

   r = BoxFill(0, 0, 1350, 900, 20, 0)
   * Reset DataStore array
   r = DataReset()
   * Store random data
   r = DataStore(RND(600), 0, 0, 0)

   r = DataStore(RND(600), 0, 0, 0)
   r = DataStore(RND(600), 0, 0, 0)
   r = DataStore(RND(600), 0, 0, 0)
   r = DataStore(RND(600), 0, 0, 0)

   * Draw graph
   r = XYGraph(275, 100, 200, 1, 14)
   * Draw axes
   r = XYAxes(275, 100, 800, 600, 4, 10, 8 + 32, 7)

   * Draw best-fit line
   r = BestFit(800, 600, 0, 15)

   * Wait
   r = INKEY(0)
NEXT i

* Restore text mode
r = SetText()

* Randomizer for Clipper
* For FoxPro, use the built-in random number function.
FUNCTION RND(nMax)
STATIC nSeed, m:=67110144, b:=31415927
   IF(nSeed == NIL, nSeed := SECONDS(), )
RETURN (nMax*((nSeed := MOD(nSeed*b + 1, m)) / m))

!seealso: "CurveFit()" "GetBF()" "GetCC()" "SetWin()" "XYGraph()" 
'------------------------------------------------------------------------------



!short: BoxFill()       Draw a rectangular box and fill it
'------------------------------------------------------------------------------
^BSyntax^B
BoxFill( <nX>, <nY>, <nWidth>, <nHeight>, <nFill>, <nColor> )

^BDescription^B
Draws a rectangular box and fills it with a pattern or color. By
default, the interior of the box is cleared before filling. You may
optionally select transparent fill, which will permit whatever
image is in the background to show through the fill pattern. You
may also instruct dGE to outline to box but not fill it, or to fill
the box but not outline it.

^BParameters^B
^U<nX>^U
X coordinate for the bottom left corner of the box.

^U<nY>^U
Y coordinate for the bottom left corner of the box.

dGE's default coordinate system is described under the entry for 
SetVer().

^U<nWidth>^U
Width of the box in screen units.

^U<nHeight>^U
Height of the box in screen units.

^U<nFill>^U
Instructions for filling the space within the box.

        Value     Meaning
        컴컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 19   Fill with one of the hatch patterns
                  illustrated at Appendix A.

           20     Fill with the current pattern background
                  color.

        +  32     Transparent fill. The fill pattern will
                  be painted over an underlying image in
                  the background.

        +  64     No pattern; just outline the box.

        + 128     No outline; just fill the space.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value
returned by GetVideo(6). See the entry for SetRGBPal().

^BExample^B
*:::::::::::::::::::::::::::::::::::::::::::::
*           DITHER.PRG
*  Combines patterns and colors to create
*  dithered colors beyond the standard 16
*  simultaneous colors available with EGA/VGA.
*:::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN

SET CURSOR OFF

* Set graphics mode on
r = SetHiRes(0)

* Draw title
r = SayString(700, 40, 1, 0 + 8, 15, ;
    "This shows how transparency (mode + 32)")
r = SayString(700 ,10, 1, 0 + 8, 15, ;
    "can createcolors through dithering!")

FOR i = 1 to 15

   * Draw underlying colored boxes
   FOR j = i to 15
      r = BoxFill(i * 70 + 115, j * 55, 50, 40, 0, j)
   NEXT j

   FOR k = i to 15
      * Draw boxes for transparent overlay
      r = BoxFill(i * 70  +  115, k * 55, 50, 40, ;
                  1 + 32 + 128, i)
      * Draw side (y) labels
      r = SayString(155, k * 55, 1, 0 + 16, 13, ;
                    ALLTRIM(STR(k)))
   NEXT k

   * Draw bottom (x) labels
   r = SayString(i * 70 + 115, 15, 1, 0, 13, ;
                 ALLTRIM(STR(i)))

NEXT i

* Draw axis titles
r = SayString(675, 930, 1, 0  +  8, 14, "Overlay color")
r = SayString(60, 690, 1, 1, 14, "Underlying color")

* Wait
r = INKEY(0)

* Set text mode
r = SetText()

!seealso: "Polygon()" "SetBkFill()" "Shade()" "XORBlock()" 
'------------------------------------------------------------------------------



!short: BubbleChrt()    Draw a bubble chart
'------------------------------------------------------------------------------
^BSyntax^B
DataStore( <nX>, <nY>, <nRadius>, <nPattern_Color> )
BubbleChrt( <nX>, <nY>, <nStyle> )

^BDescription^B
Draws a bubble chart, a graph type used to represent three 
variables in two dimensions. One variable determines a bubble's 
position along the X axis, another its position along the Y axis, 
and a third determines its radius. Each bubble may be 
individually patterned or colored.

^BData^B
You'll need to call DataStore() once for each bubble that you 
want to be drawn.

^BParameters^B

^UDataStore( <nX>, <nY>, <nRadius>, <nPattern_Color> )^U

^U<nX>^U
X coordinate for the center of the bubble.

^U<nY>^U
Y coordinate for the center of the bubble.

dGE's coordinate mapping system is described under the entry 
for SetVer().

^U<nRadius>^U
Radius of the bubble in screen units.

^U<nPattern_Color>^U
Instruction for filling the bubble with either a pattern or a color, 
depending on the style selected with the function BubbleChrt().

If nPattern_Color specifies a color, the value should fall within 
the range 0 to (nColors - 1) where nColors is the value returned 
by GetVideo(6). See the entry for SetRGBPal().

If nPattern_Color specifies a pattern, the bubble will be 
monochrome. Acceptable values are:

        Value     Meaning
        컴컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 19   Fill the bubble with one of the hatch
                  patterns illustrated at Appendix A.

        20        Fill the bubble with the current pattern
                  background color.

        + 32      Transparent fill. The fill pattern will
                  be painted over an underlying image in
                  the background.

                  For example, a value of 34 (that is, 2 +
                  32) will draw a circle and fill it with a
                  pattern. The open spaces of the pattern
                  will show whatever was on screen before
                  the circle was drawn.

^UBubbleChrt( <nX>, <nY>, <nStyle> )^U

^U<nX>^U
X origin for the graph.

^U<nY>^U
Y origin for the graph.

The X, Y coordinate pair locates the graph's bottom left corner.

^U<nStyle>^U
Instructions for interpreting the value of nPattern_Color stored 
with other chart data in calls to DataStore().

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     nPattern_Color specifies a color.

          1     nPattern_Color specifies a pattern. The 
                bubbles will be monochrome but patterned.

^BRemarks^B
A bubble chart is often used in business as a tool for market 
analysis. Each bubble might represent a product, the diameter 
of the bubble might represent the product's percentage of gross 
sales, and the two axes could be used to measure market size in 
one direction and market share in another. Such a chart can, in 
a single view, show each product's position in the market, its 
potential for growth, and its contribution to the company.

^BExample^B
PROCEDURE MAIN

* You must set the cursor off before starting dGE!
SET CURSOR OFF

* Set screen in graphics mode.
r = SetHiRes(0)

* Use BoxFill() to set the background to white.
r = BoxFill(0, 0, 1350, 1000, 0, 15)

* Reset DataStore() array
r = DataReset()

* Store some data
FOR i = 1 TO 10
   r = DataStore(i * 90, i * 50, i * 5, i)
NEXT i

* Draw a blue 3x3 grid with the XYAxes() function.
r = XYAxes(200, 200, 1000, 700, 10, 10, 0 + 4 + 16, 1)

* Draw two bubble charts with the same data, but offset.
* One is color, the other monochrome
r = BubbleChrt(200, 200, 1)
r = BubbleChrt(200, 350, 0)

* Put some explanatory text on the screen
r = SayString(0, 50, 0 + 4, 0, 0, ;
    "You can overlay multiple charts on each other")

* Pause
INKEY(0)

* Set the background to white
r = BoxFill(0, 0, 1350, 1000, 0, 1)

* Put some explanatory text on the screen
r = SayString(0, 50, 1 + 4, 0, 15, ;
    "This shows the type of information " + ;
    "graphed on a bubble chart")

* Reset DataStore() array
r = DataReset()

* Store some data
r = DataStore(100, 430, 80, 10)
r = DataStore(350, 120, 100, 11)
r = DataStore(500, 300, 85, 12)
r = DataStore(800, 250, 125, 13)

* Draw a white 10x10 grid Using the XYAxes() function
r = XYAxes(200, 200, 1000, 700, 10, 10, 0 + 4 + 16, 15)

* Draw a bubble chart
r = BubbleChrt(200, 200, 0)

* Title
r = SayString(657, 950, 0 + 4, 0 + 8 + 64, 15, ;
              "Bubble size indicates sales volume")

* Label on top of each bubble.
* Uses the same coordinates as each bubble
* plus the x and y axis offset.
r = SayString(300, 630, 0 + 4, 0 + 8 + 64, 0, "Brand W")
r = SayString(550, 320, 0 + 4, 0 + 8 + 64, 0, "Brand X")
r = SayString(700, 500, 0 + 4, 0 + 8 + 64, 0, "Brand Y")
r = SayString(1000, 450, 0 + 4, 0 + 8 + 64, 0, "Brand Z")

* X legend
r = SayString(700, 120, 0 + 4, 0 + 8 + 64, 14, ;
              "-  Quality   + ")

* Y legend. Because it is drawn on
* its side, use vector text.
r = LoadVText("STANDARD.VTX")
r = DrawVText(110, 250, 90, 600, 65, 0 + 128, 0, 14, ;
              " +  Affordability -")

* Pause to admire
r = INKEY(0)

* Restore text mode  
r = SetText()

QUIT

!seealso: "DataStore()" "XYAxes()" "LabelX()" "LabelY()" 
'------------------------------------------------------------------------------



!short: ClipWin()       Set a rectangular area as the clipping window
'------------------------------------------------------------------------------
^BSyntax^B
ClipWin( <nX0>, <nY0>, <nX1>, <nY1> )

^BParameters^B
^U<nX0>^U
X coordinate for the lower left corner of the window.

^U<nY0>^U
Y coordinate for the lower left corner.

^U<nX1>^U
X coordinate for the upper right corner.

^U<nY1>^U
Y coordinate for the upper right corner.

dGE's coordinate system is described under the entry for 
SetVer().

^BDescription^B
Sets a rectangular area as the clipping window. The parts of an 
object that extend outside this area are clipped (that is, they are 
not shown).

By default the active clipping window is the entire screen. After 
setting a smaller clipping window, you can restore the the 
clipping window to the entire screen by calling SetHiRes() or 
ClrScreen().

Printing
You can expand the area of the active clipping window for 
printing by using the mode parameter of the vector printing 
function VPOn(). The clipping window must be set before calling 
VPOn().

Plotting
The process is just the reverse. Call PlotOn() before calling 
ClipWin(). Plotting is affected only by a clipping window 
established after plotting begins.

^BExample^B
* Demonstrates clipping by drawing a circle several
* times in succession at the same coordinates, each time
* moving the active clipping window.

* Define the circle (this does not change).
nX = 675        && Center of circle
nY = 500
nRadius = 200   && Radius of circle

nMoves = 40     && How many times to move window.
nYInc = 2 * nRadius / nMoves

* Define initial coordinates for the window.
nX0 = nX - nRadius
nX1 = nX + nRadius
nY0 = nY + nRadius
nY1 = nY0 + nYInc

nClr = 6        && Initial background color for pattern

* First move the window down in increments.
* Then move it up in increments.
FOR i = 1 TO 2
   r = SetBkFill(nClr)

   * Redefine the vertical position of the window.
   FOR j = 1 TO nMoves + 1
      nY0 = nY0 - nYInc
      nY1 = nY1 - nYInc

      r = ClipWin(nX0, nY0, nX1, nY1)
      * Pattern foreground is Hi version of background.
      r = DrawCircle(nX, nY, nRadius, 0, 360, ;
                     8, 3, nClr + 8)

      r = INKEY(.1) && Slight pause
   NEXT j

   nClr = 4     && New colors
   * Reverse directions, now moving window up.
   nYInc = -nYInc

NEXT i

* Pause to admire
r = INKEY(0)

!seealso: "ClrScreen()" "PlotOn()" "VPOn()" "SetHiRes()" 
'------------------------------------------------------------------------------



!short: ClrLine()       Clear a line of characters from the screen
'------------------------------------------------------------------------------
^BSyntax^B
ClrLine( <nX>, <nY>, <nNumChars> )

^BDescription^B
Clears a line of characters from the screen. The function 
calculates the length of the line by multiplying nNumChar by the
width of a character in the currently loaded font. It does not 
clear vertical strings, nor does it clear strings displayed with 
proportional fonts (PTX).

^BParameters^B
^U<nX>^U
X coordinate for the start of the line.

^U<nY>^U
Y coordinate for the start of the line.

dGE's coordinate system is described under the entry for 
SetVer().

^U<nNumChars>^U
Number of characters to clear.

^BRemarks^B
This function is similar to another dGE function, ClrString(). A 
key difference is that ClrLine() operates on any string currently
displayed, whereas ClrString() operates only on the last string
written to the display. Another difference is that with ClrLine()
you can erase a portion of a string, whereas ClrString() removes
all of the string.

^BExample^B
nX = 620
nY = 500
cString = "Hello, world!"

* Load a font and display the string.
r = LoadCSet(0, "..\fonts\rmn1628.stx")
r = SayString(nX, nY, 0, 0, 15, cString)
r = INKEY(0)

* Erase the characters ", world!"
nOffset = GetStrLen("Hello")  && Length in current font
r = ClrLine(nX + nOffset, ;   && Start X
                      nY, ;   && Start Y
                          8)  && Number of characters
r = INKEY(0)

!seealso: "ClrString()" "GetStrLen()" "SayString()" 
'------------------------------------------------------------------------------



!short: ClrScreen()     Clear the entire screen
'------------------------------------------------------------------------------
^BSyntax^B
ClrScreen()

^BDescription^B
Clears the entire screen to black or to whatever color was set as 
color zero with the SetRGBPal() function. In addition, the 
function sets the active clipping window to the entire screen.

If you want to clear only a portion of the screen, call ClrWin().

^UNote^U   When in graphics mode, never issue the Clipper or 
FoxPro commands CLEAR, CLEAR SCREEN, or CLEAR 
WINDOWS. These commands are designed for text mode 
operation. Instead, call dGE's ClrScreen().

^BExample^B
r = ClrScreen()

!seealso: "BoxFill()" "ClrWin()" "SetRGBPal()" 
'------------------------------------------------------------------------------



!short: ClrString()     Clear the last SayString or VecString
'------------------------------------------------------------------------------
^BSyntax^B
ClrString()

^BDescription^B
Clears the string previously drawn with SayString() or 
VecString(). This function is included for convenience in clearing 
transient messages and prompts.

^UNote^U   The function does not clear vertical strings.

^BExample^B
nX = 620
nY = 500
cString = "Now you see it..."

* Load a font and display the string.
r = LoadCSet(0, "..\fonts\rmn1628.stx")
r = SayString(nX, nY, 0, 0, 15, cString)
r = INKEY(0)

* Erase the string
r = ClrString()
r = INKEY(0)

!seealso: "ClrLine()" "SayString()" "VecString()" 
'------------------------------------------------------------------------------



!short: ClrWin()        Clear a rectangular area
'------------------------------------------------------------------------------
^BSyntax^B
ClrWin( <nX0>, <nY0>, <nX1>, <nY1> )

^BParameters^B
^U<nX0>^U
X coordinate for the bottom left corner of the window.

^U<nY0>^U
Y coordinate for the bottom left corner of the window.

^U<nX1>^U
X coordinate for the upper right corner of the window.

^U<nY1>^U
Y coordinate for the upper right corner of the window.

dGE's coordinate system is described under the entry for 
SetVer().

^BDescription^B
Clears a rectangular window to black or to whatever color was 
set as color zero with the SetPal() function for CGA or the 
SetRGBPal() function for EGA/VGA.

^BExample^B
SET CURSOR OFF
r = SetGMode(18)  && 640x480x16
r = SetHiRes(0)
FOR i := 1 to 15
   * Set the background color for patterned fills.
   * This is not the color used for clearing the

   * screen or a window.
   r = SetBkFill(16 - i)
   r = BoxFill(0, 0, 1350, 1000, 4, i)

   * Set color 0. This is the color used in clearing the
   * screen or a window, and in the background of text.
   r = SetRGBPal(0, 60 - (4 * i))
   r = ClrWin(400, 250, 950, 750)
   WAIT
NEXT
r = SetText()

!seealso: "BoxFill()" "ClipWin()" "ClrScreen()" "SetRGBPal()" 
'------------------------------------------------------------------------------



!short: CurveFit()      Fit and draw a curve through data
'------------------------------------------------------------------------------
^BSyntax^B
CurveFit( <nType>, <nOrder>, <nSteps>, 
          <nLineMode>, <nLineStyle>, <nLineColor> )

^BDescription^B
Fits and draws a curve through data graphed with XYGraph() or 
HLCGraph(). The curve is clipped to appear within a window 
defined by SetWin().

^BParameters^B
^U<nType>^U
Curve type. Currently the only model implemented is the 
variable-order polynomial.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Variable-order polynomial.

^U<nOrder>^U
Order, 1 to 10, of a variable-order polynomial.

^UNote^U   The graph of a first order polynomial is identical to 
the least squares regression line of BestFit().

^U<nSteps>^U
Number of steps. This defines the granularity (number of 
discrete straight-line elements) of the curve. As nSteps 
increases, so does the smoothness of the curve. A value of 50 
works well on a VGA screen.

^U<nLineMode>^U
Raster line-drawing mode.

        Value   Meaning
        컴컴   컴컴컴컴
          0     REPLACE
          1     OR
          2     XOR

^U<nLineStyle>^U
Selects the type of line to be drawn.

         Value          Meaning
        컴컴컴          컴컴컴컴컴컴
          0             Solid line.

        > 0             Broken line with an interval of nStyle
                        pixels between segments.

        + (n * 128)     For plotters only. The value n is the 
                        plotter's line style index, which may be
                        used to select various mark/space
                        patterns. Refer to your plotter
                        documentation for details.

                      ^UNote^U   If n = 0, the default style is
                        2 (even mark/space). Style 0, a single
                        dot, is not available.

^U<nLineColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^BExample^B
*::::::::::::::::::::::::::::::::::::::::
*           CURVE.PRG
*::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN

SET CURSOR OFF

* Set screen into graphics mode
r = SetHiRes(0)

* Put title on screen
r = SayString(675, 950, 0, 0 + 8, 12, ;
    "This is a demonstration of curve-fitting")

* Reset DataStore array
r = DataReset()

* Store random data - minimum of one, maximum of 600
FOR pts = 1 to 21
   r = DataStore(RND(599) + 1, 0, 0, 0)
NEXT pts

* Draw graph
r = XYGraph(275, 100, 40, 1, 14)

* Draw axes
r = XYAxes(275, 100, 800, 600, 4, 10, 8 + 32, 7)

* Define stats window
r = SetWin(275, 100, 1075, 700)

FOR i = 1 to 10

   * Draw curve fit line
   r = CurveFit(0, i, 50, 2, 0, 15)

   * Draw subtitle indicating polynomial order
   r = SayString(675, 10, 0 + 16, 0 + 8, 14, ;
       "Polynomial order - " + ALLTRIM(STR(i)))

   * Wait
   r = INKEY(0)

   * XOR (erase) curve fit line
   r = CurveFit(0, i, 50, 2, 0, 15)

   * XOR (erase) subtitle indicating polynomial order
   r = SayString(675, 10, 0 + 16, 0 + 8, 14, ;
       "Polynomial order - " + ALLTRIM(STR(i)))

NEXT i


* Restore text mode
r = SetText()
QUIT

* Randomizer for Clipper
* For FoxPro, use the built-in random number function.
FUNCTION RND(nMax)
STATIC nSeed, m := 67110144, b := 31415927

   IF(nSeed == NIL, nSeed := SECONDS(), )
RETURN (nMax * ((nSeed := MOD(nSeed  * b + 1, m)) / m))

!seealso: "BestFit()" "GetCurveCF()" "HLCGraph()" "SetWin()" "XYGraph()" 
'------------------------------------------------------------------------------



!short: DataPc()        Scale data stored in dGE's internal array
'------------------------------------------------------------------------------
^BSyntax^B
DataPc( <nPercentage> )

^BParameters^B
^U<nPercentage>^U
Percentage scaling factor, 1 to 10,000.

^BDescription^B
Adjusts the scale of data stored in dGE's internal array. The 
scaling applies to all graphing or polyline drawing functions that 
execute after your program calls DataPc().

^UNote^U   The data in the array remains unchanged.

Subsequent calls to DataPc() are not cumulative, but 
instead rescale the data from the original 100 percent. 
That is, 

r = DataPc(50)
r = DataPc(50)

does not produce a modifying factor of 0.5 X 0.5. The second call 
to DataPc() changes nothing; the modifying factor after both 
calls is 0.5.

You can restore the default scaling to 100 percent by calling 
DataReset().

^BExample^B
*::::::::::::::::::::::::::::::::::::::::::::::
*               DATA_PC.PRG
*::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN

SET CURSOR OFF

* Set screen into graphics mode
r = SetHiRes(0)

* Put title on screen
r = SayString(675, 950, 1, 0 + 8, 12, ;
    "This is a demonstration of DataPC(). Each time the")
r = SayString(675, 910, 1, 0 + 8, 12, ;
    "graph is drawn, the DataStore() array is " + ;
    "scaled down 10%.")

* Reset DataStore array
r = DataReset()

* Store random data
r = DataStore(RND(600), 0, 0, 0)
r = DataStore(RND(600), 0, 0, 0)
r = DataStore(RND(600), 0, 0, 0)
r = DataStore(RND(600), 0, 0, 0)
r = DataStore(RND(600), 0, 0, 0)

* Loop to draw graph 5 times
FOR i = 100 to 10 step -10
  
   * Scale data
   r = DataPc(i)

   * Clear lower 90% of screen, erasing graph but
   * leaving title
   r = BoxFill(0, 0, 1350, 900, 20, 0)

   * Draw graph
   r = XYGraph(275, 100, 200, 0, 14)

   * Draw axes
   r = XYAxes(275, 100, 800, 600, 4, 10, 8 + 32, 7)

   * Show scale percent
   r = SayString(675, 10, 0, 0 + 8, 14, ALLTRIM(STR(i)) ;
       +  " percent of original DataStore()")

  * Wait
  r = INKEY(0)

NEXT i

* RESTORE text mode
r = SetText()
QUIT

* Randomizer for Clipper
* For FoxPro, use the built-in random number function.
FUNCTION RND(nMax)
STATIC nSeed, m := 67110144, b := 31415927
   IF(nSeed == NIL, nSeed := SECONDS(), )
RETURN (nMax * ((nSeed := MOD(nSeed * b + 1, m)) / m))

!seealso: "DataRange()" "DataReset()" "DataStore()" "TimeData()" 
'------------------------------------------------------------------------------



!short: DataRange()     Define a subset of the data stored
'------------------------------------------------------------------------------
^BSyntax^B
DataRange( <nFirst>, <nLast> )

^BParameters^B
^U<nFirst>^U
Index (base zero) to the first data point to be portrayed.

^U<nLast>^U
Index (base zero) to the last data point to be portrayed.

^BDescription^B
Defines a subset of the complete data set stored in dGE's 
internal array. The range defined applies to all graphing or 
polyline drawing functions that execute after your program calls 
DataRange().

Note that the index for dGE's internal array is base zero. Thus to 
set the first element as the first point in the range, you would 
pass 0 as nFirst. To set the third element as the last point in the 
range, you would pass 2 as nLast.

A subsequent call to DataRange() defines a new subset. You can 
restore the range to the complete data set by defining a range 
that includes all points or by calling DataReset().

^UNote^U   Calling DataReset() will discard all currently stored 
data and reinitialize dGE's internal array.

^BExample^B
*::::::::::::::::::::::::::::::::::::::::::::::::::::
*                  RANGE.PRG
*    Stores a set of data (progression from
*    2^0 to 2^9) and then defines several
*    subsets in succession, graphing each one.
*::::::::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN

  SET SCOREBOARD OFF
  CLEAR SCREEN
  SET CURSOR OFF

  * Set graphics mode 640x480x16
  r = SetGMode(18)
  r = SetHiRes(0)

  * Reset internal array
  r = DataReset()

  * Store the data
  FOR i = 0 TO 9
      r = DataStore(2**i, 1, 0, 0)
  NEXT i

  nHeight = 600
  FOR nLast = 2 TO 9
     * Define a data subset
     r = DataRange(0, nLast)
     * Clear the screen to black
     r = BoxFill(0, 0, 1350, 1000, 0, 0)
     * Graph it
     r = GraphXY(0, nLast, nHeight)
     * Wait for a keypress
     r = INKEY(0)
  NEXT nLast

  * Set the screen back to text mode
  r = SetText()
  QUIT

*::::::::::::::::::: END OF MAIN ::::::::::::::::::::

FUNCTION GraphXY
      PARAMETERS nFirst, nLast, nHeight

      * Define style options
      nAxisClr = 15
      nAxisStyle = 40
      nLineClr = 12
      nLineStyle = 2

      r = DataPc(100)       && Be sure we're at 100%
      nMax = GetMax()       && Get the current max value
      nMax10 = INT(GetLog10(nMax)) && Count powers of ten
      nMin = GetMin()       && Get the current min value
      nMin10 = INT(GetLog10(nMin)) && Count powers of ten

      * Y Axis
      IF nMax10 = nMin10    && Calculate increment
         nYInc = INT(10**nMax10)
      ELSE
        nYInc = INT(10**(nMax10 - nMin10))
      ENDIF
      nYTicks = INT(nMax / nYInc) + 1  && Divisions

      * Scale to fit
      nScale = INT(nHeight/ (nYInc * nYTicks) * 100)
      r = DataPc(nScale)

      * Load labels for the Y axis in an array
      DECLARE  aYLabels[nYTicks + 1]
      nYLabLen = 0
      FOR i = 1 TO nYTicks + 1
         aYLabels[i] = LTRIM(STR((i - 1) * nYInc))
         IF LEN(aYLabels[i]) > nYLabLen
            nYLabLen = LEN(aYLabels[i])
         ENDIF
      NEXT

      * X Axis
      nXLen = ROUND(nHeight * 1.14, 0)
      nXTicks = nLast - nFirst   && Number of divisions
      nXInc = nXLen / nXTicks    && Calculate interval

      * Load labels for the X axis in an array
      DECLARE aXLabels[nLast - nFirst + 1]
      FOR i = 1 TO nLast + 1
          aXLabels[i] = LTRIM(STR(nFirst + i - 1))
      NEXT

      nX = (1350 - nXLen) / 2    && Center horizontally
      nY = (1000 - nHeight) / 2  && Center vertically

      * Draw the axes, then the graph
      r = XYAxes(nX, nY, nXLen, nHeight, nXTicks, ;
             nYTicks, nAxisStyle, nAxisClr)

      r = LabelX(nX, nY, nXInc, 0, 1, 128,  ;
                nAxisClr, aXLabels)
      r = LabelY(nX, nY, nHeight / nYTicks, ;
                 0, 1, 16, nAxisClr, aYLabels)
      r = XYGraph(nX, nY, nXInc, nLineStyle, nLineClr)

RETURN 0

!seealso: "DataRange()" "DataReset()" "DataStore()" "TimeData()" 
'------------------------------------------------------------------------------



!short: DataReset()     Empty dGE's internal data array
'------------------------------------------------------------------------------
^BSyntax^B
DataReset()

^BDescription^B
Empties dGE's internal data array and resets the array counter,
the range pointer, the scale modifier, and empties all other
internal buffers. That is,

^uAll currently stored data is discarded.
^uThe array counter is set to zero.
^uThe range pointer is set to the entire data set.
^uThe scaling factor is set to 100%.
^uThe current position (used for vector and relative drawing) is reset at 0, 0.
^uIf the vector font is loaded, it is unloaded from memory.

The function applies to all data stored with DataStore(),
LogData(), or TimeData().

^BExample^B
r = DataReset()

!seealso: "DataPc()" "DataRange()" "DataStore()" "LogData()" "TimeData()" 
'------------------------------------------------------------------------------



!short: DataStore()     Store data in dGE's internal array
'------------------------------------------------------------------------------
^BSyntax^B
DataStore( <nExp1>, <nExp2>, <nExp3>, <nExp4> )

^BParameters^B
All four accept only integer values. The significance of each 
parameter varies with the graphing function that uses the data.

^BDescription^B
Stores four values in dGE's internal array for later use by a 
graphing or polyline drawing function.

Each call to DataStore() stores values for a single data point and 
automatically increments the internal array's counter. The 
maximum number of data points that may be stored is 1024. If 
you exceed this number, trailing data will be discarded.

To discard all data and restart the array's counter, call 
DataReset().

^BExample^B
r = DataReset()               && Initialize the array
r = DataStore(10, 20, 30, 0)

!seealso: "DataPc()" "DataRange()" "DataReset()" "LogData()" "TimeData()" 
'------------------------------------------------------------------------------



!short: DrawArc()       Draw a full or partial ellipse
'------------------------------------------------------------------------------
^BSyntax^B
DrawArc( <nMode>, <nDepth>, <nLinePatt>,
         <nColorTop>, <nColorSide> )

^BDescription^B
Draws an arc, ellipse, or a filled arc or ellipse in either two or 
three dimensions. Three-dimensional arcs appear just as they 
do in 3D pie charts. Owing to the large number of parameters 
needed, you must first call SetArc() to establish the geometry of 
the arc.

^BParameters^B
^U<nMode>^U
Line drawing mode.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     REPLACE
          1     OR
          2     XOR
        + 4     Draw radii connecting the end points of 
                the arc with the origin.
        + 8     Fill the interior with a pattern. The 
                pattern itself is selected with the 
                nLinePattern parameter.

^U<nDepth>^U
For a 2D arc, pass zero. For a 3D arc, pass a number greater 
than zero. The number determines the depth in screen units for 
the side of the arc.

^U<nLinePatt>^U
Selects a line or pattern style.

-       nMode is 0 through 7
When nMode is 0 through 7, nLinePatt selects a line style.

         Value  Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
           0    Solid line.
         > 0    Broken line with an interval of nStyle
                pixels between segments.

-       nMode is greater than 7
When nMode is greater than 7, nLinePatt selects a fill pattern. 
In this case line style is forced to solid. If the figure is an arc, 
connecting radii are also drawn automatically.

         Value    Meaning
        컴컴컴    컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 1    Fill with one of the hatch patterns
                  illustrated at Appendix A.
        + 32      Transparent fill. The fill pattern will
                  be painted over an underlying image in
                  the background.

^U<nColorTop>^U
Foreground color for the pattern used to fill the interior of a 2D 
arc or the top of a 3D arc, 0 to (nColors - 1) where nColors is the 
value returned by GetVideo(6). See the entry for SetRGBPal().

^U<nColorSide>^U
Color for the side of a 3D arc, 0 to (nColors - 1) where nColors is 
the value returned by GetVideo(6). See the entry for 
SetRGBPal().

^BExample^B
* Show the relationship between the bounding box,
* the start and stop coordinates, and the arc by
* letting you select points with the mouse.

PROCEDURE MAIN

SET CURSOR OFF

* Set screen in graphics mode
r = SetGMode(18)
r = SetHiRes(0)

* Reset mouse.
r = MReset()
* Restrict mouse movement.
r = MSetWin(0, 50, 1300, 1000)

* Turn the mouse cursor on
r = MCurOn()

*
* Get the corners of the bounding box from the user.
*

* Put instructions on the screen.
r = SayString(1, 5, 0 + 16, 0, 15, ;
              "Select the lower left corner" + ;
              " of the arc bounding box")

* Start loop
Flag = .T.
DO WHILE Flag = .T.

  * If the mouse button is down, get the coordinates.
  IF MStatus() = 1
  * Get the current x and y coordinate
     nX0BBox = MGetX()
     nY0BBox = MGetY()

   * Restrict mouse movement.
    r = MSetWin(nX0BBox, nY0BBox, 1300, 1000)
    r = DrawIcon(nX0BBox, nY0BBox, 0, 0, 15)

    DO WHILE MStatus() != 0
    ENDDO
    Flag = .F.
  ENDIF
ENDDO

* Erase last and put new instructions on the screen
r = SayString(1, 5, 0 + 16, 0, 15, ;
              "Select the lower left corner" + ;
              " of the arc bounding box")

r = SayString(1, 5, 0 + 16 ,0, 15, ;
              "Select the upper right corner" + ;
              " of the arc bounding box")

* Starts loop
Flag = .T.
DO WHILE Flag = .T.

  * If the mouse button is down, get the coordinates.
  IF MStatus() = 1

  * Get the current x and y coordinate
     nX1BBox = MGetX()
     nY1BBox = MGetY()

   * Restrict mouse movement.
    r = MSetWin(nX0BBox, nY0BBox, nX1BBox , nY1BBox)
    r = DrawIcon(nX1BBox, nY1BBox, 0, 0, 15)

    DO WHILE MStatus() != 0
    ENDDO
    Flag = .F.
  ENDIF
ENDDO

* Draw the bounding box.
r = BoxFill(nX0BBox, nY0BBox, nX1BBox - nX0BBox, ;
            nY1BBox - nY0BBox, 0 + 64, 1)

*
* Get the start and stop points from the user.
*

* Erase last and put new instructions on the screen
r = SayString(0, 960, 0 + 16, 0, 12, ;
              "Remember that the arc is drawn " + ;
              "from the start point to the end")
r = SayString(0, 960, 0 + 16, 0 + 4, 12, ;
              "point counter-clockwise!")

r = SayString(1, 5, 0 + 16, 0, 15, ;
              "Select the upper right corner" + ;
              " of the arc bounding box")
r = SayString(1, 5, 0 + 16, 0, 15, ;
              "Select the start point for the arc")

* Starts loop
Flag = .T.
DO WHILE Flag = .T.

  * If the mouse button is down, get the coordinates.
  IF MStatus() = 1
     * Get the current x and y coordinate
     nX = MGetX()
     nY = MGetY()

     IF nX < nX0BBox + 2   ;
     .OR. nX > nX1BBox -4  ;
     .OR. nY < nY0BBox + 2 ;
     .OR. nY > nY1BBox - 4

       nX0Arc = MGetX()
       nY0Arc = MGetY()
       r = DrawIcon(nX0Arc,nY0Arc,0,1,14)
       DO WHILE MStatus() != 0
       ENDDO
       Flag = .F.
     ENDIF
  ENDIF
ENDDO

* Erase last and put new instructions on the screen
r = SayString(1, 5, 0 + 16, 0, 15, ;
              "Select the start point for the arc")
r = SayString(1, 5, 0 + 16 ,0, 15, ;
             "Select the end point for the arc")

* Start loop
Flag = .T.
DO WHILE Flag = .T.
  * If the mouse button is down, get the coordinates.
  IF MStatus() = 1

     * Get the current x and y coordinate
     nX = MGetX()
     nY = MGetY()

     IF nX < nX0BBox + 2   ; 
     .OR. nX > nX1BBox - 4 ;
     .OR. nY < nY0BBox + 2 ;
     .OR. nY > nY1BBox - 4

       nX1Arc = MGetX()
       nY1Arc = MGetY()
       r = DrawIcon(nX1Arc, nY1Arc, 0, 1, 14)

       DO WHILE MStatus() != 0
       ENDDO
       Flag = .F.
     ENDIF
  ENDIF
ENDDO

*
* Now that the arc has been defined,
* show it in several modes.
*

* Set the bounding box for the arc.
r = SetArc(nX0BBox, nY0BBox, nX1BBox, nY1BBox, ;
           nX0Arc, nY0Arc, nX1Arc, nY1Arc)
* Draw the arc.
r = DrawArc(2, 0, 0, 10, 2)

* Erase last and put new instructions on the screen
r = SayString(1, 5, 0 + 16, 0, 15, ;
              "Select the end point for the arc")
r = SayString(1, 5, 0 + 16, 0, 15, "Press a key...")

r = INKEY(0)
r = MCurOff()

* Erase the bounding box.
r = BoxFill(0, 0, 1350, 1000, 0, 0)

* Draw a simple arc.
r = SayString(0, 960, 0 + 16, 0, 12, ;
              "Here is the arc you just made " + ;
              "with additional modes...")
r = SayString(0, 900, 0 + 16, 0, 12, "a plain arc, ")
r = DrawArc(2 + 0, 0, 0, 10, 2)
r = INKEY(0)

* Erase the last drawing and draw an arc with radii.
r = DrawArc(2 + 0, 0, 0, 10, 2)

r = SayString(0, 900, 0 + 16, 0, 12, "a plain arc, ")

r = SayString(0, 900, 0 + 16, 0, 12,           ;
              "an arc drawn as a slice " +     ;
              "(radii connecting endpoints " + ;
              "to the center), ")

r = DrawArc(2 + 4, 0, 0, 10, 2)

r = INKEY(0)

* Erase the last drawing and draw a filled arc.
r = DrawArc(2 + 4, 0, 0, 10, 2)
r = SayString(0, 900, 0 + 16, 0, 12,           ;
              "an arc drawn as a slice " +     ;
              "(radii connecting endpoints " + ;
              "to the center), ")
r = SayString(0, 900, 0 + 16, 0, 12, "a filled slice, ")
r = DrawArc(2 + 4 + 8, 0, 0, 10, 2)
r = INKEY(0)

* Erase the last drawing and draw a 3D arc.
r = DrawArc(2 + 4 + 8, 0, 0, 10, 2)
r = SayString(0, 900, 0 + 16, 0, 12, "a filled slice, ")
r = SayString(0, 900, 0 + 16, 0, 12, "a 3D arc, ")
r = DrawArc(2 + 0, 40, 0, 10, 2)
r = INKEY(0)

* Erase the last drawing and draw a 3D slice.
r = DrawArc(2 + 0, 40, 0, 10, 2)
r = SayString(0, 900, 0 + 16, 0, 12, "a 3D arc, ")
r = SayString(0, 900, 0 + 16, 0, 12, "a 3D slice, ")
r = DrawArc(2 + 4, 40, 0, 10, 2)
r = INKEY(0)

* Erase the last drawing and draw a filled 3D slice.
r = DrawArc(2 + 4, 40, 0, 10, 2)
r = SayString(0, 900, 0 + 16, 0, 12, "a 3D slice, ")
r = SayString(0, 900, 0 + 16, 0, 12, ;
              "a 3D filled slice, ")
r = DrawArc(2 + 4 + 8, 40, 0, 10, 2)
r = INKEY(0)

* Erase the drawing.
r = DrawArc(2 + 4 + 8, 40, 0, 10, 2)
* Reset text mode and exit.
r = SetText()
QUIT

!seealso: "DrawCircle()" "Pie3D()" "SetArc()" 
'------------------------------------------------------------------------------



!short: DrawCircle()    Draw a circle or an arc
'------------------------------------------------------------------------------
^BSyntax^B
DrawCircle( <nX>, <nY>, <nRadius>, 
            <nStartAngle>, <nStopAngle>,
            <nMode>, <nStyle>, <nColor> )

^BDescription^B
Draws a circle or an arc. You may select a line-drawing mode, 
line style, and color. Arcs may optionally be drawn with 
connecting radii. Both circles and arcs may be filled with a 
pattern.

^BParameters^B
^U<nX>^U
X coordinate for the center.

^U<nY>^U
Y coordinate for the center.

dGE's coordinate system is described under the entry for 
SetVer().

^U<nRadius>^U
Radius, in screen units.

^U<nStartAngle>^U
Starting angle of arc. May be either positive or negative. Positive 
angles are measured counterclockwise from zero degrees (three 
o'clock). Negative angles are measured clockwise from zero.

^U<nStopAngle>^U
Ending angle of arc. May be either positive or negative.

^U<nMode>^U
Line drawing mode.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴
          0     REPLACE
          1     OR
        + 4     Draw connecting radii.
        + 8     Fill with a pattern.

^U<nStyle>^U

^uMode is 0 through 4
When nMode is 0 through 4, nStyle selects a line style.

        Value   Meaning
        컴컴컴  컴컴컴컴
          0     Solid line.
        > 0     Broken line with an interval of nStyle 
                pixels between segments.

^unMode is greater than 4
When nMode is greater than 4, nStyle selects a fill pattern. In 
this case line style is forced to solid. If the figure is an arc, 
connecting radii are also drawn automatically.

         Value  Meaning
        컴컴컴 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 19 Fill with one of the hatch patterns
                illustrated at Appendix A.
        + 32    Transparent fill. The fill pattern will 
                be painted over an underlying image in 
                the background.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^BExample^B
r = MyPie(300, 500, 100, 45, 0, 14)
r = INKEY(0)

.
.
.

FUNCTION MyPie
   PARAMETERS nX, nY, nRadius, nStart, nStop, nClr

   IF nStart < nStop
      nSwap = nStop
      nStop = nStart
      nStart = nSwap
   ENDIF

   * Draw the larger arc.
   r = DrawCircle(nX, nY, nRadius, ;
                  nStart, nStop, 8, 0, nClr)

   * Explode second arc a distance 1/2 radius.
   * Calculate offset using a vector move.
   r = FixPos(nX, nY) && Fix vector position.
   r = MoveVec(nRadius / 2, ;
               nStop + ((nStart - nStop) / 2))

   * Draw second arc, reversing the order of the angles.
   r = DrawCircle(GetCurX(), GetCurY(), nRadius, ;
                  nStop, nStart, 8, 0, nClr)
RETURN

!seealso: "DrawArc()" 
'------------------------------------------------------------------------------



!short: DrawIcon()      Draw an icon
'------------------------------------------------------------------------------
^BSyntax^B
DrawIcon( <nX>, <nY>, <nMode>, <nIcon>, <nColor> )

^BDescription^B
Draws an icon selected from dGE's internal library or from a file.

^BParameters^B
^U<nX>^U
X coordinate for the center of the icon or, in vector mode, the 
distance from the current position.

^U<nY>^U
Y coordinate for the center of the icon or, in vector mode, the 
angle from the current position.

^U<nMode>^U
Location method and display options.

        Value   Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
            0   Location is in Cartesian (X, Y) format.
            1   Location is in vector (distance, angle)
                format.
        +   4   REPLACE
        +   8   OR (Not supported for Windows icons.)
        +  16   XOR (Not supported for Windows icons.)
        +  64   INVERSE (Not supported for Windows
                icons.)
        + 128   Windows icon. Must first be loaded by
                calling LoadIcon().
        + 256   Windows icon, but do not set the screen
                palette to the image palette. The icon
                must first be loaded by calling
                LoadIcon().

^U<nIcon>^U
Icon index number plus icon type.

        Value   Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 9  Standard icon. See Appendix A and also
                the entry for UserIcon().
        + 16    SuperIcon. Only eight per file. The file 
                must first be loaded by calling 
                LoadIcon().

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

Windows icons are not affected by foreground color.

^BRemarks^B
dGE's internal library has ten standard icons. They are 16 x 16 
pixels. You can redefine any of these icons by calling the 
function UserIcon().

^UNote^U   Only the standard icons will be drawn on a plotter.

SuperIcons are icons you create using the GFONT editor. They 
are 64 x 64 pixels. You may store up to eight icons per file, and 
the file must have an .ICO extension. To access them within 
dGE, load the file by calling LoadIcon(), and then select an icon 
by passing its index number in the file plus 16 as the argument 
for nIcon.

Windows icons, like clipart, seem to be everywhere. If you have 
the Windows 3.1 SDK, you can create your own icons using its 
Image Editor. The icons are two 32 x 32 pixel bitmaps, an AND 
followed by an OR. They are stored one icon per file, and the file 
extension is .ICO.

^UNote^U   The palette in a Windows .ICO file may differ from 
the default VGA or SVGA palette. It will be suppressed if nMode 
is 256.

^BExample^B
* Draw a dozen Windows icons across the screen
r = BoxFill(0, 0, 1350, 1000, 0, 7) && Clear to gray
r = LoadIcon("GSTDRAW3.ICO")        && Windows icon file
FOR x = 100 to 1200 STEP 100
  r = DrawIcon(x, 100, 128, 0, 0)   && Draw
NEXT

!seealso: "LoadIcon()" "MoveVec()" "UserIcon()" 
'------------------------------------------------------------------------------



!short: DrawLine()      Draw a line using X, Y coordinates
'------------------------------------------------------------------------------
^BSyntax^B
DrawLine( <nX0>, <nY0>, <nX1>, <nY1>, 
          <nMode>, <nStyle>, <nColor> )

^BDescription^B
Draws a straight line between two points defined by Cartesian 
coordinates.

The line may optionally be continued from the end point of the 
last line drawn with this function. To do this, simply add 16 to 
nMode, and pass any value (zero will do) as nXO and nY0. If no 
previous line was drawn, the line will begin at coordinates 0, 0.

^BParameters^B
^U<nX0>^U
X coordinate for start of line segment.

^U<nY0>^U
Y coordinate for start of line segment.

^U<nX1>^U
X coordinate for end of line segment.

^U<nY1>^U
Y coordinate for end of line segment.

dGE's coordinate system is described under the entry for 
SetVer().

^U<nMode>^U
Line drawing mode.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
           0    REPLACE
           1    OR
           2    XOR
        + 16    Continue from the last end point.

^U<nStyle>^U
Line style.

        Value           Meaning
        컴컴           컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0             Solid line.

        > 0             Broken line with an interval of nStyle
                        pixels between segments.

        + (n * 128)     For plotters only. The value n is the 
                        plotter's line style index, which may be
                        used to select various mark/space
                        patterns. Refer to your plotter
                        documentation for details.

                      ^UNote^U   If n = 0, the default style is
                       2 (even mark/space). Style 0, a single
                       dot, is not available.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^BExample^B
* Draws the outline of a flower with nPetals of nLength
* at coordinates nXCenter, nYCenter in nColor.
FUNCTION CardioidLine
   PARAMETERS nXCenter, nYCenter, nLength, nPetals, nClr

   * Define starting point and fix it.
   nX1 = nXCenter + (nLength * GetSin(0, 1)) && Sin
   nY1 = nYCenter + (nLength * GetSin(0, 0)) && Cos
   r = DrawLine(nX1, nY1, nX1, nY1, 0, 0, nClr)

   * Draw the flower.
   FOR nAngle = 1 TO 360
      * Polar equation for a flower
      nRadius = 1 + GetSin(nPetals * nAngle, 0)

      * Multiply by distance from origin.
      nRadius = nRadius * nLength

      * Convert polar to cartesian coordinates
      nX1 = nXCenter + (nRadius * GetSin(nAngle, 1))
      nY1 = nYCenter + (nRadius * GetSin(nAngle, 0))

      * Draw a line segment from the last point.
      r = DrawLine(0, 0, nX1, nY1, 16, 0, nClr)

   NEXT nAngle
RETURN

!seealso: "DrawVec()" "DrawXY()" "PolyVec()" 
'------------------------------------------------------------------------------



!short: DrawVec()       Draw a line using vector coordinates
'------------------------------------------------------------------------------
^BSyntax^B
DrawVec( <nLength>, <nAngle>, <nUpdate>,
         <nMode>, <nStyle>, <nColor> )

^BDescription^B
Draws a line from the current position to the point located at a 
distance of nLength in a direction of nAngle. The function may 
optionally update the current position. In this case the next 
current position becomes the end point of the line.

^BParameters^B
^U<nLength>^U
Length of line in screen units.

^U<nAngle>^U
Angle from current position, in degrees. The angle may be either 
positive or negative.

By default, the current position is 0, 0 until a draw, move, or 
positioning function is executed. Calling DataReset() restores the 
default.

^U<nUpdate>^U
Indicates whether the current position should be updated.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Current position for the next vector
                drawing function becomes the end point of 
                the line drawn with this function.

          1     Current position is unchanged.

^U<nMode>^U
Line drawing mode.

        Value   Meaning
        컴컴   컴컴컴컴
          0     REPLACE
          1     OR
          2     XOR

^U<nStyle>^U
Line style.

        Value           Meaning
        컴컴컴컴컴      컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0             Solid line.

        > 0             Broken line with an interval of nStyle
                        pixels between segments.

        + (n * 128)     For plotters only. The value n is the
                        plotter's line style index, which may be
                        used to select various mark/space
                        patterns. Refer to your plotter
                        documentation for details.

                      ^UNote^U   If n = 0, the default style is
                        2 (even mark/space). Style 0, a single
                        dot, is not available.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^BExample^B
* Draws a flower with nPetals of nLength at coordinates
* nX, nY in nColor. Figure is drawn with a series
* of radial lines from the origin.

FUNCTION CardioidVec
   PARAMETERS nX, nY, nLength, nPetals, nClr

   * Fix starting point.
   r = FixPos(nX, nY)

   * Draw the flower.
   FOR nAngle = 1 TO 360
      * Polar equation for a flower
      nRadius = 1 + GetSin(nPetals * nAngle, 0)
      * Multiply by distance from origin.
      nRadius = nRadius * nLength

      * Draw a line segment.
      r = DrawVec(nRadius, nAngle, 1, 0, 0, nClr)
   NEXT nAngle

RETURN

!seealso: "DataReset()" "DrawLine()" "FixPos()" "MoveVec()" "PolyVec()" 
'------------------------------------------------------------------------------



!short: DrawVText()     Display text using the vector font
'------------------------------------------------------------------------------
^BSyntax^B
DrawVText( <nX>, <nY>, <nAngle>, 
          <nLength>, <nHeight>, <nMode>,
          <nPosition>, <nColor>, <cString> )

^BDescription^B
Draws vector text using the vector font loaded with LoadVText(). 
This font permits a string to be rotated from the horizontal. In 
addition, the characters may be stretched vertically, and the 
string itself (though not the characters) may be stretched to a 
specified length.

^UNote^U   The vector text font uses the same internal buffer as 
is used by DataStore(), LogData(), and TimeData(). Thus use you 
cannot use the font and keep data in memory at the same time.

^BParameters^B
^U<nX>^U
X coordinate for positioning the text.

^U<nY>^U
Y coordinate for positioning the text.

dGE's coordinate system is described under the entry for 
SetVer().

^U<nAngle>^U
Angle in degrees from the horizontal.

^U<nLength>^U
Length of the text, in screen units.

^U<nHeight>^U
Height of the text, as a percentage. Valid percentages range from 
10 to 1000, inclusive.

^U<nMode>^U
Line drawing mode.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
            0   REPLACE
        +   8   OR
        + 128   Bold. The default character weight is a 
                line one pixel wide. Bold doubles this.

^U<nPosition>^U
Text position relative to the coordinates nX, nY.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
           0    nX, nY is the start of the text line.
        +  8    nX, nY is the center of the text line.
        + 16    nX, nY is the end of the text line.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^U<cString>^U
Text string.

^BExample^B
* Load the vector font
r =LoadVText("..\FONTS\STANDARD.VTX")

* Set the position, length, and height
nX = 675
nY = 500
nLength = 300  && Screen units
nHeight = 100  && 100%

* Draw the text at intervals of 40 degrees.
FOR nAngle = 0 to 360 STEP 40
   r = DrawVText(nX, nY, nAngle, nLength, nHeight, ;
                 128, 16, 15, "Hello, whirled!   ")
NEXT nAngle

* Draw the world
r = DrawCircle(nX, nY, 60, 0, 360, 8, 0, 9)
* Pause to admire
r = INKEY(0)

!seealso: "LoadVText()" "VecString()" 
'------------------------------------------------------------------------------



!short: DrawXY()        Draw a line using relative X, Y coordinates
'------------------------------------------------------------------------------
^BSyntax^B
DrawXY( <nXRel>, <nYRel>, <nUpdate>, 
        <nMode>, <nStyle>, <nColor> )

^BDescription^B
Draws a line from the current position to a position determined 
by relative X, Y coordinates. The function may optionally update 
the current position. In this case the next current position 
becomes the end point of the line.

^BParameters^B
^U<nXRel>^U
Horizontal distance, in screen units, from the current position.

By default, the current position is 0, 0 until a draw, move, or 
positioning function is executed. Calling DataReset() restores the 
default.

^U<nYRel>^U
Vertical distance, in screen units, from the current position.

^U<nUpdate>^U
Indicates whether the current position should be updated.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Current position for the next vector
                drawing function becomes the end point of 
                the line drawn with this function.
          1     Current position is unchanged.

^U<nMode>^U
Line drawing mode.

        Value   Meaning
        컴컴   컴컴컴컴컴
          0     REPLACE
          1     OR
          2     XOR

^U<nStyle>^U
Line style.

        Value           Meaning
        컴컴컴컴컴      컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0             Solid line.

        > 0             Broken line with an interval of nStyle
                        pixels between segments.

        + (n * 128)     For plotters only. The value n is the 
                        plotter's line style index, which may be
                        used to select various mark/space
                        patterns. Refer to your plotter
                        documentation for details.

                      ^UNote^U   If n = 0, the default style is
                       2 (even mark/space). Style 0, a single
                       dot, is not available.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^BExample^B
* Draw a series of progressively smaller boxes
r = FixPos(525, 350)
nDistance = 300
DO WHILE nDistance > 10
   r = DrawXY(nDistance, 0, 0, 0, 0, 7)
   r = DrawXY(0, nDistance, 0, 0, 0, 7)
   r = DrawXY(-nDistance, 0, 0, 0, 0, 7)
   r = DrawXY(0, -nDistance, 0, 0, 0, 7)
   nDistance = nDistance - 10
ENDDO

!seealso: "DataReset()" "DrawLine()" "DrawVec()" "FixPos()" "MoveXY()" 
'------------------------------------------------------------------------------



!short: EdString()      Display a string for editing
'------------------------------------------------------------------------------
^BSyntax^B
cNewString = EdString( <nX>, <nY>, <nCSet>, <nColor>, <cString> )

^BDescription^B
Displays a string and allows a user to edit it. By default, the 
string is delimited by colons. You can select another delimiter or 
eliminate the delimiting character altogether by calling 
SetDelim().

^BParameters^B
^U<nX>^U
X coordinate for the start of the string. If nX is zero. the starting 
point is calculated from the final point of a preceding 
SayString().

^U<nY>^U
Y coordinate for the start of the string.

^U<nCSet>^U
Number of the character set.

        Value   Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 1  Character set number. If no font has
                been loaded with LoadCSet(), 0
                selects standard, and 1 selects
                small. If a font has been loaded,
                pass 0 as the argument.

                ^UNote^U   A proportional font will
                appear as if it were monospaced.

        + 64    INVERSE

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value
returned by GetVideo(6). See the entry for SetRGBPal().

^U<cString>^U
String to be edited.

^BReturns^B
Edited string.

^BRemarks^B
        ^UEditing keys^U
        Key             Action
        컴컴컴컴       컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        Enter           Terminate editing.
        Leftarrow       Move one character left.
        Ctrl+S          Move one character left.
        Rightarrow      Move one character right.
        Crtl+D          Move one character right.
        Backspace       Delete character to the left of cursor.
        Delete          Delete character under the cursor.
        Ctrl+G          Delete character under the cursor.
        Ctrl+V          Toggle insert.
        Ctrl+Y          Delete the line.

EdString() always displays the string for editing as a fixed-pitch
font, regardless whether a fixed or proportional font is currently 
loaded.

^UNote^U   Clipper programmers can use the @...GET command 
in graphics mode if the replacement terminal driver has been 
linked.

^BExample^B
* Get a title for a graph from the user
cPrompt = "Enter a title for the graph: "
cTitle = " Graph Title                   "

r = SayString(0, 500, 0, 0, 7, cPrompt)

r = SetDelim(0) && No delimiter for edit line
cTitle = EdString(GetStrLen(cPrompt), ; && Start of line
                                 500, ;
                                  64, ; && Reverse colors
                                  15, ; && Text Color
                                cTitle) && String to edit

cTitle = ALLTRIM(cTitle)
r = ClrScreen()

* Load a large font and display the string.
r = LoadCSet(0, "..\FONTS\SWI4937.PTX")
r = SayString(675, 500, 0, 8, 4, cTitle) && Centered
r = INKEY(0)

* Unload font and load a smaller one
* for other work...
r = LoadCSet(0, "")  && Unload font
r = LoadCSet(0, "..\FONTS\DGE1108.STX")

!seealso: "LoadCSet()" "SetDelim()" 
'------------------------------------------------------------------------------



!short: EnumMPrn()      Get the config name of a dot-matrix printer
'------------------------------------------------------------------------------
^BSyntax^B
cPrinter = EnumMPrn( <nIndex>, <cConfigFile> )

^BDescription^B
Reads the printer configuration file, MPRN.DAT, and returns the 
name of a dot-matrix or Canon BubbleJet printer. The printer 
name can then be used as an argument to LoadMPrn().

^BParameters^B
^U<nIndex^U
Index number of the printer in the printer configuration file, 
MPRN.DAT.

^U<cConfigFile>^U
String containing the name of the printer configuration 
file. The string may optionally include a drive and path:

"DRV:\PATH\MPRN.DAT"

^BReturns^B
String containing a printer name corresponding to the index 
number. A null string indicates EOF.

^BRemarks^B
The file MPRN.DAT can be viewed or edited using the utility 
program EDITMPRN.EXE.

^BExample^B
* List (in text mode) the names of all printers
nIndex = 0
cPrinter = EnumMPrn(nIndex, "..\UTILS\MPRN.DAT")
DO WHILE LEN(cPrinter) <> 0
   ? cPrinter && In graphics mode use SayString()
   nIndex = nIndex + 1
   cPrinter = EnumMPrn(nIndex, "..\UTILS\MPRN.DAT")
ENDDO && Stop at null string

!seealso: "LoadMPrn()" "PrintScrn()" 
'------------------------------------------------------------------------------



!short: FixPos()        Fix the current position for vector drawing
'------------------------------------------------------------------------------
^BSyntax^B
FixPos( <nX>, <nY> )

^BDescription^B
Fixes the current position for vector drawing. Subsequent vector 
or relative X, Y moves are from this position.

^BParameters^B
^U<nX>^U
X coordinate for the current position.

^U<nY>^U
Y coordinate for the current position.

dGE's coordinate system is described under the entry for 
SetVer().

^BExample^B
* Make the current position the center of the screen.
r = FixPos(675, 500)

!seealso: "MoveVec()" "MoveXY()" 
'------------------------------------------------------------------------------



!short: Gantt()         Draw a Gantt chart
'------------------------------------------------------------------------------
^BSyntax^B
DataStore( <nAmplitude>, <nFill>, 0, <nColor> )
Gantt( <nX>, <nY>, <nXInc>, <nStyle>, <nGroupSize> )

^BDescription^B
This function draws a Gantt chart, a specialized version of a bar 
graph with stacked, horizontal bars. A Gantt chart is often used 
to provide a graphic view of a project schedule, with each bar 
representing task in the project. A bar's displacement from the 
left margin represents a start time; the length of each segment 
shows the duration of a subtask; and the total length of the bar, 
the time required to complete the entire task.

^BData^B
Each bar on the graph represents a data group. Thus the 
number of amplitude values you must store is the number of 
bars the graph will have times nGroupSize.

nGroupSize depends on how many segments you want for each 
bar. You'll need one amplitude value for the bar's starting 
position-its displacement from the left margin-and a value for 
each segment. For bars with one segment, store two amplitude 
values per bar, one to specify a starting position, and a second 
value to specify a length. For bars with two segments, store 
three amplitude values per bar, one for the starting position, 
plus two for the lengths of the segments.

        Segments        GroupSize       Amplitude values to store
        컴컴컴컴        컴컴컴컴       컴컴컴컴컴컴컴컴컴컴컴컴
            1               2           2 x Number of bars
            2               3           3 x Number of bars
            3               4           4 x Number of bars
            4               5           5 x Number of bars

The first bar is drawn at the bottom of the graph, close to the X 
axis. The next bar is drawn above it, and the next above that. In 
other words, the order in which bars are drawn corresponds to 
the order in which amplitude values are stored. This means that 
if you want the bar that begins closest to the left margin to be at 
the top of the graph, as in the illustrations above, then you'll 
need to store the values for that bar last, the values for the bar 
below it next to last, and so on in reverse order.

^BParameters^B

^UDataStore( <nAmplitude>, <nFill>, 0, <nColor> )^U

^U<nAmplitude>^U
Amplitude value.

The first amplitude value in a group specifies the starting 
position for the bar. The remaining three parameters of 
DataStore() are ignored and may be passed as zero.

Subsequent amplitude values specify lengths of segments. 
Corresponding values for <nFill> and <nColor> set the fill 
pattern and foreground color for the segments.

^U<nFill>^U
Instructions for filling the segment. By default the segment is 
outlined with a solid line of the foreground color specified as 
nColor.

        Value     Meaning
        컴컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 19   Fill the segment with one of the hatch
                  patterns illustrated at Appendix A.

          20      Fill the segment with the current pattern
                  background color.

        + 32      Transparent fill. The fill pattern will
                  be painted over an underlying image or
                  background.

        + 64      Outline only. The segment will be
                  outlined in the color specified by
                  nColor, and the interior will be left
                  untouched.

        + 128     No outline. The interior will be filled
                  but the box outline will not be drawn.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^UGantt( <nX>, <nY>, <nXInc>, <nStyle>, <nGroupSize> )^U

^U<nX>^U
X origin for the graph.

^U<nY>^U
Y origin for the graph.

The X, Y coordinate pair locates the graph's bottom left corner.

dGE's coordinate mapping system is described under the entry 
for SetVer().

^U<nXInc>^U
Distance in screen units from the bottom edge of one bar to the 
bottom edge of the bar above it.

^U<nStyle>^U
Style options. May be a combination of these values:

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        + 1     No space between bars. Does not apply to
                3D bars.
        + 2     3D bars with top and sides outlined.
        + 4     3D bars with top and sides filled by 
                shading.

^U<nGroupSize>^U
Specifies the number of data points (2 to 384) per data group. 
dGE will derive the number of groups-and thus the number of 
bars-by dividing the value of GroupSize into the number of data 
points stored with DataStore().

^BExample^B
*::::::::::::::::::::::::::::::::::::::::::::::::::::::
*                 GANTT_.PRG
*::::::::::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN

* Turn the cursor off
SET CURSOR OFF

* Set screen in graphics mode
r = SetGMode(18)  && VGA
r = SetHiRes(0)

* Reset data
r = DataReset()

* Generate data
FOR i = 1 TO 4
  FOR j = 1 TO 4
    r = DataStore(RND(300), 1, 0, j)
  NEXT j
NEXT i

* Graph parameters
nX = 100
nY = 300
nWidth = 1200
nHeight = 700
nGroups = 4
nInc = nHeight / nGroups

* Draw four Gantt charts
r = GChart(0)
r = GChart(1)
r = GChart(2)
r = GChart(4)

* Restore text mode
r = SetText()
QUIT

PROCEDURE GChart(nStyle)

   * Draw axes and graph
   r = Gantt(nX, nY, nInc, nStyle, 4)
   r = XYAxes(nX, nY, nWidth, nHeight, 10, 10, 0, 15)

   * Draw title
   r = SayString(675, 100, 0, 0 + 8, 13, ;
       "This chart is drawn in style "   ;
       + ALLTRIM(STR(nStyle)))

   * WAIT
   r = INKEY(0)

   * Clear lower part of screen
   r = BoxFill(0, 0, 1350, 950, 20, 0)

RETURN

* For FoxPro, use the built-in random number function.
FUNCTION RND(nMax)
STATIC nSeed, m := 67110144, b := 31415927
   IF(nSeed == NIL, nSeed := SECONDS(), )
RETURN (nMax*((nSeed := MOD(nSeed * b + 1, m)) / m))

!seealso: "BarGraph()" "XYAxes()" "LabelX()" "LabelY()" 
'------------------------------------------------------------------------------



!short: GetASin()       Get an angle from a sine or cosine
'------------------------------------------------------------------------------
^BSyntax^B
nAngle = GetASin( <nInteger>, <nASinACos> )

^BDescription^B
Returns the angle corresponding to a sine or cosine.

^BParameters^B
^U<nInteger>^U
A numeric value convertible to an ArcSin or ArcCos. Must be an 
integer in the range -10, 000 to +10, 000, inclusive.

To obtain the ArcSin of a sine or the ArcCos of a cosine, first 
convert the four-place decimal to an integer by multiplying by 
10, 000. Then pass that product to the function as nInteger.

^U<nASinACos>^U
Indicates whether the function should return ArcSin or ArcCos.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Return ArcSin (angle corresponding to a
                sine).
          1     Return ArcCos (angle corresponding to a 
                cosine).

^BReturns^B
A numeric value accurate to two decimal places. Depending on 
the second argument, the function will return:

-       ArcSin in the range -90 to +90 degrees
-       ArcCos in the range 0 to 180 degrees.

^BExamples^B
nAngle = GetASin(1 * 10000, 0)      && Result: 90.00

nAngle = GetASin(1 * 10000, 1)      && Result:  0.00

nAngle = GetASin(0.7071 * 10000, 0) && Result: 45.00

nAngle = GetASin(0.7071 * 10000, 1) && Result: 45.00

!seealso: "GetSin()" 
'------------------------------------------------------------------------------



!short: GetBF()         Get the slope/intercept of a best-fit line
'------------------------------------------------------------------------------
^BSyntax^B
nM_or_Y = GetBF( <nMode> )

^BDescription^B
Returns the slope or intercept of the linear regression best-fit 
line.

You must call the BestFit() function before calling this function. 
BestFit() calculates the line; this function calculates the slope or 
intercept of the line.

^BParameter^B
^U<nMode>^U
Selects which value the function should return.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴
          0     Return slope.
          1     Return intercept.

^BReturns^B
A floating point numeric value.

^BExample^B
SET CURSOR OFF

* Set screen into graphics mode
r = SetHiRes(0)

* Loop five times
FOR i = 1 TO 5

  * Clear bottom part of screen
  r = BoxFill(0, 0, 1350, 900, 20, 1)

  * Reset r = DataStore array
  r = DataReset()

  * Store random data
  r = DataStore(RND(600), 0, 0, 0)
  r = DataStore(RND(600), 0, 0, 0)
  r = DataStore(RND(600), 0, 0, 0)
  r = DataStore(RND(600), 0, 0, 0)
  r = DataStore(RND(600), 0, 0, 0)

  * Draw graph
  r = XYGraph(275, 100, 200, 1, 14)
  
  * Draw axes
  r = XYAxes(275, 100, 800, 600, 4, 10, 8 + 32, 7)

  * Draw best-fit line
  r = BestFit(800, 600, 0, 15)
  
  * Put slope and intercept on screen
  nSlope = GetBF(0)
  nIntercept = GetBF(1)

  r = SayString(10, 150, 0, 0, 15, "Slope: " ;
                + ALLTRIM(STR(nSlope)))
  r = SayString(10, 50, 0, 0, 15, "Intercept: " ;
                + ALLTRIM(STR(nIntercept)))

  * Wait
  INKEY(0)

NEXT i

* Restore text mode
SetText()

* For FoxPro, use the built-in random number function.
FUNCTION RND(nMax)
STATIC nSeed, m := 67110144, b := 31415927
   IF(nSeed == NIL, nSeed := SECONDS(), )
RETURN (nMax*((nSeed := MOD(nSeed * b + 1, m)) / m))

!seealso: "BestFit()" "GetCC()" "GetCurveCF()" 
'------------------------------------------------------------------------------



!short: GetCC()         Get the correlation coefficient
'------------------------------------------------------------------------------
^BSyntax^B
nCoefficient = GetCC()

^BDescription^B
Returns the correlation coefficient of the least-squares 
regression of Y over X for the current data set or subset.

If the values for X are in fixed increments, you will need to call 
the graphing function to establish the values for X before calling 
this function to correlate them.

^BReturns^B
A numeric value in the range -1.0000 to +1.0000

^BRemarks^B
The correlation coefficient is calculated from whatever subset 
has been defined by DataRange(). If no subset has been defined, 
the value is calculated from the complete data set.

If you scale the data for Y, be sure to apply the same scaling 
factor to the data (or increment) for X. This is necessary because 
the correlation coefficient is dependent on both X and Y.

Integer rounding within the function may introduce an error of 
up to 0.1% on a full-scale graph.

!seealso: "BestFit()" "DataRange()" "GetCurveCF()" 
'------------------------------------------------------------------------------



!short: GetCurveCF()    Get the coefficients for a fitted curve
'------------------------------------------------------------------------------
^BSyntax^B
nCoefficient = GetCurveCF( <nIndex> )

^BDescription^B
Returns the coefficients of the polynomial for the curve drawn 
by CurveFit().

You must call CurveFit() before calling this function. CurveFit() 
calculates the polynomial values; this function returns the 
coefficients of the polynomial.

^BParameters^B
^U<nIndex>^U
Index number of the polynomial coefficient. 

For example, GetCurveCF(2) returns the coefficient C in the
equation

Y = A + BX + CX**2 + DX**3

^BReturns^B
A floating point numeric value.

!seealso: "CurveFit()" "GetCC()" 
'------------------------------------------------------------------------------



!short: GetCurX()       Get the current X position in screen units
'------------------------------------------------------------------------------
^BSyntax^B
nX = GetCurX()

^BDescription^B
Obtains the current X position in screen units, thus enabling 
you to determine the current screen position after vector moves 
and draws.

^BReturns^B
X coordinate (0 to 1350) for the current drawing position.

^BExample^B
* Determine if the current position is too close to the
* right edge of the screen to draw all of a figure that
* is 200 screen units wide.
IF GetCurX() > 1150
   r = FixPos(0, GetCurY())
ENDIF

!seealso: "GetCurY()" "FixPos()" 
'------------------------------------------------------------------------------



!short: GetCurY()       Get the current Y position in screen units
'------------------------------------------------------------------------------
^BSyntax^B
nY = GetCurY()

^BDescription^B
Obtains the current Y position in screen units, thus enabling 
you to determine the current screen position after vector moves 
and draws.

^BReturns^B
Y coordinate (0 to 1000) for the current drawing position.

^BExample^B
* Clear an area of the screen 200 x 200, lower left
* corner at the current position.
nX = GetCurX()
nY = GetCurY()
r = ClrWin(nX, nY, nX + 200, nY + 200)

!seealso: "GetCurX()" "FixPos()" 
'------------------------------------------------------------------------------



!short: GetFontInf()    Get character dimensions of the current font
'------------------------------------------------------------------------------
^BSyntax^B
nUnits = GetFontInf( <nMode> )

^BDescription^B
Reports the dimensions of a character on screen as it would be 
drawn in the currently selected font. Can also report the screen 
dimensions of a SuperIcon.

^BParameter^B
^U<nMode>^U
Indicates what type of information the function should return.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Return width of current font. If the
                current font is proportional, the 
                function will return the width of a 
                monospaced (that is, not proportionally 
                spaced) character. To calculate the 
                actual display width of a string of 
                proportionally spaced characters, call 
                GetStrLen().
          1     Return height of current font.
          2     Return width of 64x64 icon.
          3     Return height of 64x64 icon.

^BReturns^B
Size of the font or icon in screen units.

^BExample^B
* Space two lines of text.
nLineSpace = 2 * GetFontInf(1)
r = SayString(675, 500, 4, 8, "Hello,")
r = SayString(675, 500 - nLineSpace, 4, 8, "world!")

!seealso: "GetStrLen()" "LoadCSet()" "LoadIcon()" 
'------------------------------------------------------------------------------



!short: GetGMode()      Test for a graphics mode in the host PC
'------------------------------------------------------------------------------
^BSyntax^B
nOK = GetGMode( <nMode> )

^BDescription^B
Tests for support of a graphics mode in the host PC.

^UNote^U   To run SVGA modes, the host PC's video adapter 
must support the Video Electronics Standards Association 
(VESA) BIOS. Many SVGA cards require a TSR that patches the 
BIOS so that the card will support VESA. Unfortunately, this 
function does not detect the presence of the TSR. If you plan to 
use an SVGA mode, it may be wise to warn your users to load 
the TSR before running your program.

^BParameters^B
^U<nMode>^U
Graphics mode. See the list under the entry for SetGMode().

^BReturns^B
Zero if the mode is not supported by the current hardware. 
Otherwise, non-zero.

^BExample^B
lSVGA = .F.
nMode = 257
DO WHILE !lSVGA .AND. nMode < 262
   IF GetGMode(nMode) <> 0
      lSVGA = .T.
      ? "SVGA detected. If your video adapter is not"
      ? "VESA compatible, you must first load the VESA"
      ? "TSR supplied by the manufacturer."
   ENDIF
   nMode = nMode + 1
ENDDO

!seealso: "SetGMode()" "GetVideo()" 
'------------------------------------------------------------------------------



!short: GetLog10()      Calculate the base-10 logarithm of a number
'------------------------------------------------------------------------------
^BSyntax^B
nLog10 = GetLog10( <nValue> )

^BDescription^B
Calculates the base-10 logarithm of a number.

^BParameters^B
^U<nValue>^U
A numeric value to convert to its base 10 logarithm. Must be 
greater than zero.

^BReturns^B
Base-10 logarithm of the value passed as nValue.

^BRemarks^B
The function returns y in the following equation:

x = 10**y

where x is the numeric expression used as the argument to 
GetLog10(), as in:

y = GetLog10(x)

Just as with the Clipper or FoxPro LOG() function, the accuracy 
of GetLog10() is limited by rounding and can be improved by 
issuing the command:

SET DECIMALS TO <integer>

However, since the rounding in calculations within GetLog10() is 
beyond your control, you may, in some cases, prefer to do your 
own calculation using natural logarithms returned by the 
Clipper or FoxPro LOG() function.

To calculate the base-n logarithm for any number x use this 
formula:

Logn = LOG(x) / LOG(n)

Thus

Log10 = LOG(x) / LOG(10)

calculates the base-10 logarithm of x.

^BExamples^B
? GetLog10(.1)     && Result: -1.00
? GetLog10(1)      && Result:  0.00
? GetLog10(10)     && Result:  1.00
? GetLog10(100)    && Result:  2.00

!seealso: "LogData()" 
'------------------------------------------------------------------------------



!short: GetMax()        Get the maximum value stored, in screen units
'------------------------------------------------------------------------------
^BSyntax^B
nMaxVal = GetMax()

^BDescription^B
Reports the maximum value stored in dGE's internal array, as it 
would display on screen.

^BReturns^B
Maximum value of the current data set, or current subset, in 
screen units.

^BRemarks^B
The maximum is calculated from whatever subset has been 
defined by DataRange(). If no subset has been defined, the value 
is calculated from the complete data set.

^UNote^U   The value returned is the value graphed by the 
MinMax() function. You do not, of course, need to call MinMax() 
before calling GetMax().

If you have scaled the data using DataPc(), the value returned by 
GetMax() will also be scaled. To convert this number to the true 
data value, divide it by the current scaling factor expressed as a 
decimal.

For example, if the greatest value stored was 100 and the 
current scaling factor is 50%, GetMax() will return 50. To 
convert the return value to the actual maximum value in the 
data set, you would divide 50 by 0.50.

Obviously precision may be lost in rounding. If you need a 
precise maximum, you should obtain it from your original data. 
Use the value returned by GetMax() where precision is not 
necessary, such as in scaling axes and positioning on screen.

^BExample^B
nScale = 400
r = DataPc(100)
nMax = GetMax()   && Returns true maximum
r = DataPc(nScale)
nMax = GetMax()   && Returns maximum as it will display
* Convert to approximate true maximum
nMax = nMax / nScale * 100

!seealso: "GetMin()" "GetMean()" "MinMax()" "DataPc()" "DataRange()" 
'------------------------------------------------------------------------------



!short: GetMean()       Get the mean value stored, in screen units
'------------------------------------------------------------------------------
^BSyntax^B
nMean = GetMean()

^BDescription^B
Reports the mean value stored in dGE's internal array by calls 
to DataStore(), LogData(), or TimeData().

^BReturns^B
Mean value stored in dGE's internal array. If a subset has been 
defined, then the mean value of the subset is returned. If the 
data has been scaled, the return value will also be scaled.

^BRemarks^B
The mean is calculated from whatever subset has been defined 
by DataRange(). If no subset has been defined, the value is 
calculated from the complete data set.

^UNote^U   The value returned is the value graphed by the 
Stats() function. You do not, of course, need to call Stats() before 
calling GetMean().

If you have scaled the data using DataPc(), the value returned by 
GetMean() will also be scaled. To convert this number to the true 
data value, divide it by the current scaling factor expressed as a 
decimal.

For example, if the true mean is 70 and the current scaling 
factor is 50%, GetMin() will return 35. To convert the return
value to the actual mean value in the data set, you would divide 
35 by .50.

^BExample^B
nScale = 400
r = DataPc(100)
nMean = GetMean()   && Returns true mean
r = DataPc(nScale)
nMean = GetMean()   && Returns mean as it will display
* Convert to approximate true mean
nMean = nMean / nScale * 100

!seealso: "DataPc()" "DataRange()" "GetMax()" "GetMin()" "Stats()" 
'------------------------------------------------------------------------------



!short: GetMin()        Get the minimum value stored, in screen units
'------------------------------------------------------------------------------
^BSyntax^B
nMinVal = GetMin()

^BDescription^B
Returns the minimum value stored in dGE's internal array by 
calls to DataStore(), LogData(), or TimeData().

^BReturns^B
Minimum value of the current data set, or current subset, in 
screen units.

^BRemarks^B
The minimum is calculated from whatever subset has been 
defined by DataRange(). If no subset has been defined, the value 
is calculated from the complete data set.

^UNote^U   The value returned is the value graphed by the 
MinMax() function. You do not, of course, need to call MinMax() 
before calling GetMin().

If you have scaled the data using DataPc(), the value returned by 
GetMin() will also be scaled. To convert this number to the true 
data value, divide it by the current scaling factor expressed as a 
decimal.

For example, if the smallest value stored was 10 and the current 
scaling factor is 50%, GetMin() will return 5. To convert the 
return value to the actual minimum value in the data set, you 
would divide 5 by 0.50.

Obviously precision may be lost in rounding. If you need a 
precise minimum, you should obtain it from your original data. 
Use the value returned by GetMin() where precision is not 
necessary, such as in scaling axes and positioning on screen.

^BExample^B
nScale = 400
r = DataPc(100)
nMin = GetMin()   && Returns true minimum
r = DataPc(nScale)
nMin = GetMin()   && Returns minimum as it will display
* Convert to approximate true minimum
nMin = nMin / nScale * 100

!seealso: "DataPc()" "DataRange()" "GetMax()" "GetMean()" "MinMax()" 
'------------------------------------------------------------------------------



!short: GetPix()        Get the color of a pixel
'------------------------------------------------------------------------------
^BSyntax^B
nColor = GetPix( <nX>, <nY> )

^BDescription^B
Reports the color index number to which a pixel at a location on 
screen is set.

^BParameters^B
^U<nX>^U
X coordinate for the pixel.

^U<nY>^U
Y coordinate for the pixel.

dGE's coordinate system is described under the entry for 
SetVer().

^BReturns^B
Color index number, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^BExample^B
* Draw circles filled with colors 1 to 15,
* reporting the color of the center pixel of each.

FOR nColor = 1 TO 15
   r = DrawCircle(675, 500, 200, 0, 360, 8, 0, nColor)
   r = SayString(640, 250, 0, 0, 15, ;
                 LTRIM(STR(GetPix(675, 500))))
   r = INKEY(0) && Pause
NEXT nColor

!seealso: "SetPix()" "SetRGBPal()" "SetRGBDAC()" 
'------------------------------------------------------------------------------



!short: GetSD()         Get the standard deviation for data stored
'------------------------------------------------------------------------------
^BSyntax^B
nSD = GetSD()

^BDescription^B
Returns the standard deviation of data stored in dGE's internal 
array by calls to DataStore(), LogData(), or TimeData().

^BReturns^B
Standard deviation of the data stored in dGE's internal array. If 
a subset has been defined, then the standard deviation of the 
subset is returned. If the data has been scaled, the return value 
will also be scaled.

^BRemarks^B
The standard deviation is calculated from whatever subset has 
been defined by DataRange(). If no subset has been defined, the 
value is calculated from the complete data set. In either case, 
the value is calculated with only the precision needed for 
graphing. Rounding of integers in dGE's algorithm may 
introduce an error as high as 0.1% on a full scale graph.

^UNote^U   The value returned is the value graphed by the 
Stats() function. You do not, of course, need to call Stats() before 
calling GetSD().

If you have scaled the data using DataPc(), the value returned by 
GetSD() will also be scaled. To convert this number to the true 
data value, divide it by the current scaling factor expressed as a 
decimal.

!seealso: "DataPc()" "DataRange()" "GetMean()" "Stats()" 
'------------------------------------------------------------------------------



!short: GetSin()        Get the sine or cosine for an angle
'------------------------------------------------------------------------------
^BSyntax^B
nTrig = GetSin( <nAngle>, <nSinCos> )

^BDescription^B
Returns the sine or cosine for an angle.

^BParameters^B
^U<nAngle>^U
An angle in degrees. Accepts positive or negative integers.

^U<nSinCos>^U
Indicates whether the function should return Sin or Cos.

        Value   Meaning
        컴컴   컴컴컴컴컴
          0     Return Sin.
          1     Return Cos.

^BReturns^B
A numeric value accurate to four decimal places. Depending on 
the second argument, the function will return:

     Sin of an angle.
         -or-
     Cos of an angle.

^BExample^B
*
* Draw sine and cosine waves
*

&& Clear the screen in black
r = BoxFill(0, 0, 1350, 1000, 0, 0) 

nX = 495   && X origin
nY = 500   && Y origin

&& Draw a set of axes with a negative Y arm
XYAxes(nX, nY, 360, 180, 2, 2, 1, 15)

&& Call a function to draw waves for each
r = DrawWave(nX, nY, 0)  && Draw sine wave
r = DrawWave(nX, nY, 1)  && Draw cosine wave
.
.
.

FUNCTION DrawWave
   PARAMETERS nX, nY, nSinCos

   IF nSinCos = 0
      nLColor = 12  && Red line for sine wave
   ELSE
      nLColor = 10  && Green line for cosine wave
   ENDIF

   nXOrigin = nX    && Save the origin
   nYOrigin = nY

&& Set starting position
r = DrawLine(nX, nY + (90 * nSinCos), ;
             nX, nY + (90 * nSinCos), ;
             0, 0, nLColor)

&& Draw the wave
   FOR nAngle = 1 To 360 STEP 10
      nX = nXOrigin + nAngle
      nY = nYOrigin + (90 * GetSin(nAngle, nSinCos))
      r = DrawLine(0, 0, nX, nY, 16, 0, nLColor)
   NEXT

RETURN 0

!seealso: "GetASin()" 
'------------------------------------------------------------------------------



!short: GetStrLen()     Get the length of a string in the current font
'------------------------------------------------------------------------------
^BSyntax^B
nLength = GetStrLen( <cString> )

^BDescription^B
Reports the length of a character string as it would be drawn 
using the currently selected font.

^BParameter^B
^U<cString>^U
Character string.

^BReturns^B
Length in screen units.

^BRemarks^B
With fixed fonts (file extension .STX), the length of the string is
simply the character width multiplied by the number of 
characters. Character width can be obtained by calling 
GetFontInf().

With proportional fonts (file extension .PTX), calculating the 
length of a string is not as easy as multiplying width times 
number of characters. This is where GetStrLen() can be 
particularly useful.

^BExample^B
* Compare the lengths of a string in fixed and
* proportional versions of the same font.

cTest = "Hello, world!"

r = LoadCSet(0, "RMN1628.STX") && Load a fixed font
nMonoLen = GetStrLen(cTest)    && Result: 767

r = LoadCSet(0, "")            && Release the file

r = LoadCSet(0, "RMN1628.PTX") && Load a proportional font
nPropLen = GetStrLen(cTest)    && Result: 371

!seealso: "GetFontInf()" "LoadCSet()" 
'------------------------------------------------------------------------------



!short: GetVideo()      Get current graphics configuration
'------------------------------------------------------------------------------
^BSyntax^B
nAnswer = GetVideo( <nQuestion> )

^BDescription^B
Reports information on the current graphics configuration.

^BParameter^B
^U<nQuestion>^U
Indicates the type of information that the function should 
return.

        Value   Asks for                   Returns
        컴컴   컴컴컴컴컴컴컴컴컴컴컴     컴컴컴컴
          0     Video adapter type.        3    HERCULES
                                           4    CGA
                                           6    EGA
                                           7    VGA

         1      Current BIOS video mode.   Refer to the IBM Technical
                                           Reference.

         3      System ID.                 PS/2 Model 30 returns ID
                                           250. For others, see the
                                           IBM Technical Reference.

         4      Horizontal resolution.     Number of pixels.

         5      Vertical resolution.       Number of pixels.

         6      Number of colors.          2, 16, 256

         7      Coordinate system.         0     dGE's coordinate map
                                                 (1350 x 1000).
                                           <> 0  Native pixel mode
                                                 set by a call to
                                                 SetVer(64)

^BRemarks^B
This function has been partially superseded by GetGMode(). In 
particular, if you call GetGMode() to determine whether a 
graphics mode is appropriate for the hardware, you should not 
need to call GetVideo() for information about the video adapter, 
BIOS video mode, or System ID.

Even though you may no longer need to know what the function
can tell you about video hardware, it does return useful
information about the current video mode.

        After you remap the coordinate system by calling SetVer(64),
        you may want to call GetVideo(4) and GetVideo(5) to get the
        current dimensions of the screen in pixels.

        Before you display an image with PicRead(), first call
        GetVideo(6) to be sure that the the image does not contain
        more colors than are supported by the current graphics mode.

^BExample^B
* Tile the screen with a bitmap image.
* The number of colors in the image must be
* appropriate for the current graphics mode.
nColors = GetVideo(6)       && Returns 2, 16 or 256

DO CASE
CASE nColors = 256
   cFileName = "256color.bmp"
CASE nColors = 16
   cFileName = "16color.bmp"
OTHERWISE
   cFileName = "2color.bmp"
ENDCASE

* Display the bitmap
r = PicRead(0, 0, 1 + 128 , cFileName) && Tile the image
r = INKEY(0)

!seealso: "GetGMode()" "PicRead()" "SetVer()" 
'------------------------------------------------------------------------------



!short: HLCGraph()      Draw a High-Low-Close graph
'------------------------------------------------------------------------------
^BSyntax^B
DataStore( <nHigh>, <nLow>, <nClose>, 
           <nOpen>|<nXPosition> )
HLCGraph( <nX>, <nY>, <nXInc>, <nColor> )

^BDescription^B
Draws a High-Low-Close graph, a specialized variety of line 
graph that is commonly used to show fluctuations in stock 
prices over time.

The graph displays a series of vertical lines, each of which plots 
a range of values. The low value is shown by a tick mark at the 
bottom of the vertical bar, the high value by a tick at the top, 
and a normative value, usually a closing price, by a third tick on 
the right side of the vertical bar. 

You have the option to add a fourth tick mark showing the 
opening price on the left side of the bar. You can opt for the Wall
Street Journal style, which omits high and low tick marks. A 
third option lets you space the vertical bars at regular intervals, 
as you might if you were showing daily changes, or scatter them 
irregularly along the X axis, as you might if you wanted to show 
gaps for non-trading days.

^BData^B
Each call to DataStore() places four values in dGE's internal 
data array. All four apply to a single vertical line.

High, Low, Close
The first three values, High, Low, and Close, may be passed in 
any order. Low, Close, High and Close, High, Low are both 
acceptable arrangements; so are all other permutations. The 
graphing function will sort the values by descending rank and 
mark the graph appropriately.

The only reason for giving thought to how you order the values 
is that you may want to overlay the graph with statistical lines 
using dGE's statistics functions. These functions consider only
the first amplitude value in the set. Thus you must select the 
element on which the statistics function will operate, High, Low, 
or Close, by placing the desired value first in the argument list 
when you call DataStore().

^UFourth Parameter^U
The fourth parameter for DataStore() has a dual purpose. If you 
want your graph to show four values, High, Low, Close, and 
Open, then pass the value for Open as the fourth argument and 
tell dGE that the value is an opening price by selecting the Open 
option in your call to HLCGraph().

The other purpose for the fourth parameter is to store X-axis 
positioning data for the scatter-style graph. This style option lets 
you specify individual offsets from the left margin for each 
vertical line. Depending on your needs, you may choose either 
values that space the lines evenly, occasionally skipping space, 
or values that place the lines at arbitrary points along the 
horizontal axis.

You must store a value (zero will work) for the fourth parameter 
even if you do not intend to ask for an Open mark or a scatter-
style graph.

^BParameters^B

^UDataStore( <nHigh>, <nLow>, <nClose>, <nOpen>|<nXPosition> )^U

^U<nHigh>, <nLow>, nClose>^U
High, Low, and Close may be stored in any order. Even though 
you may not want to plot a Close value, you still must provide a 
value for it, and the value must be in the range. The value could 
be identical to the Low or High, or it could be the mean of these. 
In the last case, you could use one of the statistics functions to 
analyze the mean.

^U<nOpen>^U
Open value in the range Low to High. This value will be 
represented by a tick on the left side of the vertical bar. It will be 
graphed only when selected by adding + 512 to the nColor
argument for HLCGraph().

^U<nXPosition>^U
Displacement of the vertical line from the left margin. Bars will 
not be evenly spaced along the X axis. Instead, each bar will be 
placed according to the value stored for nXPosition. This style is 
selected by passing zero as the nXInc argument for HLCGraph().

^UNote^U   It is not possible to have a scatter-style graph with 
an Open mark, since both take their values from the fourth 
argument for DataStore(). If you call HLCGraph() with zero as 
nXInc and also nColor + 512, dGE will use the same data for the 
opening position and the X axis position.

Further, if you have previously graphed the same data with another 
option, you will need to call DataReset() and then store the data 
again before calling HLCGraph() with nColor + 512.

We acknowledge that this procedure is a kludge. However, we are 
trapped between our desire to satisfy customers and our need to
maintain compatibility with earlier verions of dGE.

^UHLCGraph( <nX>, <nY>, <nXInc>, <nColor> )^U

^U<nX>^U
X origin of the graph.

^U<nY>^U
Y origin of the graph.
The X, Y coordinate pair locates the graph's bottom left corner.

dGE's coordinate mapping system is described under the entry 
for SetVer().

^U<nXInc>^U
Selects either standard or scatter style.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        > 0     Lines are spaced nXInc apart along the X
                axis.
          0     Lines are drawn in scatter style. 
                Positions along the X axis are variable, 
                each set by the fourth argument passed to 
                DataStore().

^U<nColor>^U
Foreground color and style options.

        Value           Meaning
        컴컴컴컴컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to nColors-1  Foreground color. nColors is the value
                        returned by GetVideo(6). See the entry
                        for SetRGBPal().

        + 256           Wall Street Journal style vertical
                        bars. High and Low tick marks are
                        omitted.

        + 512           Open tick mark. The value is taken from
                        the fourth argument to DataStore().

^BExample^B
*:::::::::::::::::::::::::::::::::::::::::::::::
*                 HLOC.PRG
*:::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN

SET CURSOR OFF
* Set screen in graphics mode
r = SetGMode(18) && VGA
r = SetHiRes(0)

* Draw grid
r = XYAxes(0, 0, 1350, 1000, 2, 2, 4 + 16 + 64, 7)

* Draw graph grids and identifying text
r = XYAxes(100, 100, 470, 300, 10, 10, 4 + 16 + 64, 8)
r = XYAxes(100, 600, 470, 300, 10, 10, 4 + 16 + 64, 8)
r = XYAxes(775, 100, 470, 300, 10, 10, 4 + 16 + 64, 8)
r = XYAxes(775, 600, 470, 300, 10, 10, 4 + 16 + 64, 8)

r = SayString(25, 525, 0 + 4, 0, 14, ;
             'Scatter Hi-Lo-Close')
r = SayString(700, 525, 0 + 4, 0, 14, ;
             'WSJ style Open-Hi-Lo-Close')
r = SayString(25, 25, 0 + 4, 0, 14, 'Hi-Lo-Close')
r = SayString(700, 25, 0 + 4, 0, 14, 'WSJ Hi-Lo-Close')

* This section draws the H-L-C graphs.
* The GetData() procedure just loads
* a different set of data for each graph.
r = GetData()
r = HLCGraph(100, 100, 47, 10)

r = GetData()
r = HLCGraph(775, 100, 47, 13 + 256)
r = GetData()
r = HLCGraph(100, 600, 0, 14)

* This section loads the data for the
* O-H-L-C graph and displays it.
r = DataReset()
FOR i = 1 TO 10
  nLo = RND(90)

  nClose = nLo + RND(90)
  nHi = nClose + RND(90)
  nOpen = nLo + RND(90)

  r = DataStore(nHi, nLo, nClose, nOpen)
NEXT i

r = HLCGraph(775, 600, 47, 12 + 256 + 512)

* WAIT
r = INKEY(0)
* Restore text mode
r = SetText()
QUIT

FUNCTION GetData()
  * Store data
  r = DataReset()
  FOR i = 1 TO 10
    nLo = RND(90)
    nClose = nLo + RND(90)
    nHi = nClose + RND(90)
    nXInc = RND(470)
    r = DataStore(nHi, nLo, nClose, nXInc)
  NEXT i
RETURN

* For FoxPro, use the built-in random number function.
FUNCTION RND(nMax)
STATIC nSeed, m := 67110144, b := 31415927
   IF(nSeed == NIL, nSeed := SECONDS(), )
RETURN (nMax*((nSeed := MOD(nSeed * b + 1, m)) / m))

!seealso: "XYAxes()" "LabelX()" "LabelY()" 
'------------------------------------------------------------------------------



!short: HScroll()       Scroll an area of the screen left or right
'------------------------------------------------------------------------------
^BSyntax^B
HScroll( <nX0>, <nY0>, <nX1>, <nY1>, <nXDistance>, <nColor> )

^BDescription^B
Scrolls a rectangular area of the screen left or right. After the 
move, the empty area of the screen may be left unpainted or 
filled with a solid color.

^BParameters^B
^U<nX0>^U
X coordinate for the lower left corner of the area to scroll.

^U<nY0>^U
Y coordinate for the lower left corner.

^U<nX1>^U
X coordinate for the upper right corner.

^U<nY1>^U
Y coordinate for the upper right corner.

dGE's coordinate system is described under the entry for 
SetVer().

^U<nXDistance>^U
Distance in screen units to move the designated image. A 
positive integer moves to the right. A negative integer moves to 
the left.

^UnColor>^U
Color to paint the area vacated after the move. The value may a 
an integer in the range 0 to (nColors - 1) where nColors is the 
value returned by GetVideo(6). See the entry for SetRGBPal().

Alternatively, passing -1 will leave the area unpainted.

^BRemarks^B
Clipper. In order to avoid a conflict with FUNCky, this function
is named _HScroll() in the Clipper libraries. DGEDEFS.CH 
redefines the function as HScroll() but you must include this file 
to get the benefit of the #define. Otherwise, call it as _HScroll().

^BExample^B
*:::::::::::::::::::::::::::::::::::::::::::::::::::
*               H_SCROLL.PRG
*    Draws a circle on screen, moves it right,
*    then left to center screen, and finally
*    scrolls left and right toward the center.
*:::::::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN

SET CURSOR OFF
CLEAR

* Set screen in graphics mode
r = SetHiRes(0)

* Put a circle at the left of the screen.
nRadius = 175
r = DrawCircle(nRadius, 500, nRadius, 0, 360, 8, 0, 4)

* Define the coordinates for a box containing the circle.
nX1 = 0
nY1 = 500 - nRadius
nX2 = 2 * nRadius
nY2 = 500 + nRadius

* Move the box to the right until it reaches 
* the right side of the screen.
nMove = 10
DO WHILE nX2 <= 1349
   r = HScroll(nX1, nY1, nX2, nY2, nMove, 0)
   nX1 = nX1 + nMove
   nX2 = nX2 + nMove
ENDDO

* Now move it right, until it reaches center screen.
nMove = -nMove
DO WHILE nX1 >= 675 - nRadius
   r = HScroll(nX1, nY1, nX2, nY2, nMove, 0)
   nX1 = nX1 + nMove
   nX2 = nX2 + nMove
ENDDO

* Now squeeze it from both sides.
nMove = 2
FOR i = 1 TO nRadius STEP nMove
   r = HScroll(nX1 - nMove, nY1, ;
               nX2 - nRadius - nMove, nY2, nMove, 0)
   r = HScroll(nX1 + nRadius + nMove, nY1, ;
               nX2 + nMove, nY2, -nMove, 0)
NEXT i

* Exit
r = SetText()
QUIT

!seealso: "ClipWin()" "VScroll()" 
'------------------------------------------------------------------------------



!short: LabelPie()      Display labels for a pie chart 
'------------------------------------------------------------------------------
^BSyntax^B
LabelPie( <nXOffset>, <nRadius>, <nLabelLength>, <nCSet>,
          <nMode>, <nColor>, <cLabels> | <acLabels> )

^BDescription^B
Draws labels for a pie chart. 

The pie chart must be drawn first because this function 
calculates some measurements from the arguments for the 
preceding call to PieChart() or Pie3D().

By default, labels are taken from text that you pass as an 
argument to this function. Optionally, dGE will display each 
segment's percentage of the whole rather than displaying the 
text. In this case you have the additional option of specifying the 
decimal precision of the percentage.

Labels are positioned along an arc on each side of the pie. By
default, labels are connected to corresponding segments of the 
pie by pointing lines. You may optionally omit these lines.

^BParameters^B
^U<nXOffset>^U
Horizontal offset for labels. Labels are connected to 
corresponding segments of the pie by pointing lines. Each 
pointing line is drawn horizontally from the label for a distance 
of nXOffset, then radially toward the center of the pie so that it 
bisects the segment to which it corresponds.

^U<nRadius>^U
The radius, in screen units, of the arc used to position the 
labels. The greater the length of nRadius, the greater the 
separation between labels.

We recommend a radius that is greater than 1.1 times the 
radius of the pie if no segments are exploded. If one or more 
segments are exploded, we recommend a radius greater than 
1.35 times the radius of the pie.

If nRadius is less than the radius of the pie, pointing lines are 
not drawn, nXOffset is forced to zero, and text is aligned on the 
center line of each segment.

^U<nLabelLength>^U
If you choose to pass text for labels, this argument gives the 
length (number of characters) of each label. dGE uses this value 
only when labels are passed as a single string.

If you choose to have dGE display percentages as labels, then 
this argument sets the decimal precision of the percentage. 
Acceptable values range from 0 to 2.

^U<nCSet>^U
Character set number. 

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
           0    Character set loaded in buffer 0. At
                startup, a standard-size system font is
                loaded in this buffer.
           1    Character set loaded in buffer 1. At
                startup, a small version of the system
                font is loaded in this buffer.

Optionally, the following values may be added:

        Value   Meaning
        컴컴   컴컴컴컴
        +  4    REPLACE
        +  8    OR

                ^UNote^U   If labels are positioned close
                to the pie, there is a risk that they
                will overwrite the pie. This option will
                superimpose the parts of the labels that
                extend over the pie.

        + 16    XOR
        + 64    INVERSE

^U<nMode>^U
Selects display options.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴
          0     Text format.
        + 4     Percentage format.
        + 8     Omit connecting lines.

^UnColor>^U
If nColor is 0, each label will take its color from its 
corresponding pie segment.

If nColor is greater than zero, all labels will have the same color. 
Acceptable values range from 1 to (nColors - 1) where nColors is 
the value returned by GetVideo(6). See the entry for 
SetRGBPal().

^U<cLabels>^U
Label text, passed as a single string. All labels must be of equal 
length, and the string must contain no delimiters.

For example, if nLabelLength is three, a series of four labels 
might be passed to the function as:

"JANFEBMARAPR"

In this case, dGE will parse the string by dividing its length by 
the value of nLabelLength.

^UNote^U   The number of labels must be equal to the number 
of pie segments.

If you choose the have dGE display percentage values, then pass 
a null string as cLabels and the decimal precision as 
nLabelLength.

^U<acLabels>^U
Clipper and FoxPro programmers have the option to pass label 
text as an array of strings. In FoxPro, the array name must be 
preceded by an @.

^UNote^U   C programmers have no alternative. Labels must be 
passed as a single string.

^BExample^B
* Display two 2D pie charts and two 3D pie charts
* with both text and percentage labels
SET CURSOR OFF
r = SetGMode(18) && 640x480x16
r = SetHiRes()

* Set variables for the labels
DECLARE aLabels[4]
aLabels[1] =" Jan "
aLabels[2] =" Feb "
aLabels[3] =" Mar "
aLabels[4] =" Apr "

nXOffset = 50
nLabelLen = 0    && Zero decimal places
nCSet = 1
nMode = 0
nColor = 15

* Store the data for the pie.
r = DataReset()
r = DataStore(20, 0, 0, 2)
r = DataStore(20, 0,  1, 14)
r = DataStore(45, 0,  0,  1)
r = DataStore(35, 0,  0,  4)

nRadius = 100

* 2D Pie, text labels
nX = 340 ; nY = 750
r = PieChart(nX, nY, nRadius)
r = LabelPie(50, nRadius * 1.4, nLabelLen, nCSet, ;
             nMode, nColor, aLabels)

* 3D Pie, text labels
nX = 1000 ; nDepth = 25 ; nTilt = 50 ; nStyle = 2
r = Pie3D(nX, nY, nRadius, nDepth, nTilt, nStyle)
r = LabelPie(nXOffset , nRadius * 1.4, nLabelLen, ;
             nCSet, nMode, nColor, aLabels)

* 2D Pie, percentage labels
nX = 340 ; nY = 250 ; nMode = 4
r = PieChart(nX, nY, nRadius)
r = LabelPie(nXOffset , nRadius * 1.4, nLabelLen, ;
             nCSet, nMode, nColor, aLabels)

* 3D Pie, percentage labels
nX = 1000
r = Pie3D(nX, nY, nRadius, nDepth, nTilt, nStyle)
LabelPie(80, nRadius * 1.2, nLabelLen, nCSet, ;
         nMode, nColor, aLabels)

* Pause to admire
r = INKEY(0)
r = SetText()

!seealso: "LoadCSet()" "PieChart()" "Pie3D()" "SayString()" 
'------------------------------------------------------------------------------



!short: LabelX()        Display labels for an X axis
'------------------------------------------------------------------------------
^BSyntax^B
LabelX( <nX>, <nY>, <nXInc>, <nLabelLength>, <nCSet>, 
        <nMode>, <nColor>, <cLabels> | <acLabels> )

^BDescription^B
Draws a horizontal series of labels starting at nX, nY. Labels are 
placed at intervals of nXInc to the right of this point.

^BParameters^B
^U<nX>^U
X coordinate for the first label in the series.

^U<nY>^U
Y coordinate for the first label in the series.

dGE's coordinate system is described under the entry for 
SetVer().

^U<nXInc>^U
Horizontal distance from the left edge of one label to the left edge
of the next label.

^U<nLabelLength>^U
Length (number of characters) of each label. dGE uses this value 
only when labels are passed as a single string.

^U<nCSet>^U
Character set number. 

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Character set loaded in buffer 0. At
                startup, a standard-size system font is 
                loaded in this buffer.
          1     Character set loaded in buffer 1. At 
                startup, a small version of the system 
                font is loaded in this buffer.

Optionally, the following values may be added:

        Value   Meaning
        컴컴   컴컴컴컴컴
        +  4    REPLACE
        +  8    OR
        + 16    XOR
        + 64    INVERSE

^U<nMode>^U
Orientation of the labels.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Each label is written horizontally.
                By default, labels are left-justified,
                and nY is the location of the bottom line
                of the characters.
          1     Each label is written vertically.
                Most likely you will want to offset the
                labels by the height one or more
                characters. To determine the height of a
                character in the currently loaded font,
                call GetFontInf(1).

If nMode is 0 (horizontal labels), you may specify one or more
positioning options:

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        +   8   nX, nY describe the location for the
                center of the first label.
        +  16   nX, nY describe the location for the end
                of the first label.
        +  64   Coordinate nY describes the center line
                of the characters.
        + 128   Coordinate nY describes the top line of
                the characters.
        + 256   Stagger positions. Alternate labels are
                dropped down one line.

^UnColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^U<cLabels>^U
Label text passed as a single string. All labels must be of equal 
length, and the string must contain no delimiters.

For example, if nLabelLength is three, a series of four labels 
might be passed to the function as:

"JANFEBMARAPR"

In this case, dGE will parse the string by dividing its length by 
the value of nLabelLength.

^U<acLabels>^U
Clipper and FoxPro programmers have the option to pass label
text as an array of strings. In FoxPro, the array name must be 
preceded by an @.

^UNote^U   C programmers have no alternative. Labels must be 
passed as a single string.

^BExample^B
cXLabels = ""
USE Temps
GO TOP
r = DataReset()

FOR i = 1 TO 28
   r = DataStore(Temps->high, Temps->low, ;
                 Temps->low, 0)
   cXLabels = cXLabels + STR(DAY(Temps->day), 2)
   SKIP
NEXT i
USE

.
.
.

* Mode for X labels is centered, positioned
* vertically by the character tops
r = LabelX(nX, nY, nXInc, 2, 0, ;
           0 + 8 + 128, ; && Mode
           7, cXLabels)

!seealso: "LabelY()" "LoadCSet()" "SayString()" 
'------------------------------------------------------------------------------



!short: LabelY()        Display labels for a Y axis
'------------------------------------------------------------------------------
^BSyntax^B
LabelY( <nX>, <nY>, <nYInc>, <nLabelLength>, <nCSet>, 
        <nMode>, <nColor>, <cLabels> | <acLabels> )

^BDescription^B
Draws a vertical series of labels starting at nX, nY. Labels are 
placed at intervals of nYInc above this point.

^BParameters^B
^U<nX>^U
X coordinate for the first label in the series.

^U<nY>^U
Y coordinate for the first label in the series.

dGE's coordinate system is described under the entry for 
SetVer().

^U<nYInc>^U
Distance from the top of one label to the top of the next label.

^U<nLabelLength>^U
Length (number of characters) of each label. dGE uses this value 
only when labels are passed as a single string.

^U<nCSet>^U
Character set number. 

        Value   Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
           0    Character set loaded in buffer 0. At
                startup, a standard-size system font is
                loaded in this buffer.
           1    Character set loaded in buffer 1. At
                startup, a small version of the system
                font is loaded in this buffer.

Optionally, the following values may be added:

        Value   Meaning
        컴컴   컴컴컴컴컴
        +  4    REPLACE
        +  8    OR
        + 16    XOR
        + 64    INVERSE

^U<nMode>^U
Orientation of the labels.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Each label is written horizontally.
                By default, labels are left-justified,
                and nY is the location of the bottom line
                of the characters.
          1     Each label is written vertically.
                Most likely you will want to offset the 
                labels by the width one or more 
                characters. To determine the width of a 
                character in the currently loaded font, 
                call GetFontInf(0).

If nMode is 0 (horizontal labels), you may specify one or more 
positioning options:

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        +   8   Coordinate nX describes the location for
                the center of each label.
        +  16   Coordinate nX describes the location for
                the end of each label.
        +  64   Coordinate nY describes the center line
                of the characters in the first label.
        + 128   Coordinate nY describes the top line of
                the characters in the first label.

^UnColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value
returned by GetVideo(6). See the entry for SetRGBPal().

^U<cLabels>^U
Label text, passed as a single string. All labels must be of equal 
length, and the string must contain no delimiters.

For example, if nLabelLength is three, a series of four labels 
might be passed to the function as:

"100150200250"

In this case, dGE will parse the string by dividing its length by 
the value of nLabelLength.

^U<acLabels>^U
Clipper and FoxPro programmers have the option to pass label 
text as an array of strings. In FoxPro, the array name must be 
preceded by an @.

^UNote^U   C programmers have no alternative. Labels must be 
passed as a single string.

^BExample^B
* nHeight is a trial height for the graph.
* It will be adjusted to account for rounding.
nHeight = 400

* Mark the Y axis from 0 to the maximum.
* value, in increments of 10
nMax = GetMax()
IF nMax % 10 = 0
   nYDivs = nMax / 10
ELSE
   nYDivs = INT(nMax / 10) + 1
ENDIF

* Calculate the Y axis increments, then adjust
* the graph height to account for rounding.
nYInc = INT(nHeight / nYDivs)
nHeight = nYInc * nYDivs

.
.
.

* We will store labels in an array, but
* a string would work as well.
DECLARE acYLabels[nYDivs + 1]
FOR i = 0 TO nYDivs
   acYLabels[i + 1] = ALLTRIM(STR(i * 10))
NEXT i

.
.
.

* Mode for Y labels is left justified, 
* vertically centered.
r = LabelY(nX, nY, nYInc, 2, 0, ;
           0 + 16 + 64, ; && Mode
           7, acYLabels)

!seealso: "LabelX()" "LoadCSet()" "SayString()" 
'------------------------------------------------------------------------------



!short: LoadCSet()      Load an external font
'------------------------------------------------------------------------------
^BSyntax^B
LoadCSet( <nCSet>, <cFile> )

^BDescription^B
Loads a new font from a file. Subsequent calls to any of the dGE 
text functions will use the new font.

^BParameters^B
^U<nCSet>^U
This parameter is for compatibility with earlier versions of dGE. 
With the current version, simply pass zero.

^U<cFile>^U
File specification in the form:

"DRV:\PATH\FILENAME.EXT"

^UNote^U   Font files are opened in shared mode for network 
operations.

Font files generally follow a naming convention that 
concatenates three characters of the face name with a two-digit 
number indicating character height in pixels and another two-
digit number indicating character width in pixels. 

The filename RMN1609 indicates that the font face name is
Times-Roman, its character height is 16 pixels, and its 
character width is 9 pixels.

Files for fixed-pitch fonts have the extension .STX. Files for 
proportional fonts have the extension .PTX.

^BRemarks^B
At startup dGE loads an internal font with a standard-size 
character set in buffer number 0 and a small-size character set 
in buffer number 1.

Calling LoadCSet() replaces the startup font with an external 
font. Calling LoadCSet() a second time replaces the font loaded 
in the first call.

Only one external font can reside in memory. Moreover, unlike 
the internal font loaded at startup, external fonts have only one 
character set.

Even though dGE keeps only one font in its internal buffers, it is
good programming practice to unload a previously loaded font 
before loading a new one. This will release the handle to the file 
and free memory used to store the handle.

To unload a font, call LoadCSet() with a null string as the font 
file name:

LoadCSet(0, "")  && Unloads the resident font.

^UNote^U   It is not possible to return to using the startup font 
after you have loaded an external font. Thus if you load an 
external font and then later unload it but neglect to load a new 
font to replace it, text will not display on the screen.

!seealso: "LoadIcon()" "SayString()" 
'------------------------------------------------------------------------------



!short: LoadIcon()      Load an icon from a file
'------------------------------------------------------------------------------
^BSyntax^B
LoadIcon( <cFile> )

^BDescription^B
Loads an icon file from disk into memory.

^BParameters^B
^U<cFile>^U
Icon file name in the form:

"DRV:\PATH\FILENAME.EXT"

By convention, icon files have the extension .ICO.

^BRemarks^B
To conserve memory, icon files are loaded dynamically into the 
dGE buffer. The file remains open until the end of the session or 
until LoadIcon("") is called. Passing a null string as the filename 
forces the file to be closed.

^BExample^B
r = LoadIcon("..\ICONS\SAMPLE.ICO")

!seealso: "DrawIcon()" 
'------------------------------------------------------------------------------



!short: LoadMPrn()      Load dot-matrix printer configuration
'------------------------------------------------------------------------------
^BSyntax^B
LoadMPrn( <nOrient>, <cPrinter> )

^BDescription^B
Loads dot-matrix or Canon BubbleJet printer configuration 
details from the file MPRN.DAT before sending output to the 
printer.

^BParameters^B
^U<nOrient>^U
Selects orientation of printed material on the page.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Landscape (horizontal) orientation.
          1     Portrait (vertical) orientation.

^U<cPrinter>^U
String (up to 30 characters) containing the name of the printer
configuration file followed by a space followed by the printer 
name. The string may optionally include a drive and path:

"DRV:\PATH\MPRN.DAT PRINTER NAME"

The printer name must exactly match the name in the file.

^BRemarks^B
The file MPRN.DAT can be viewed or edited using the utility 
program EDITMPRN.EXE.

Printer names can also be listed from within your program by 
calling EnumMPrn().

^BExample^B
r = LoadMPrn(1, ; && Portrait orientation
  "..\UTILS\MPRN.DAT EPSON SQ,LQ 24-PIN") && Printer name
r = PrintScrn()   && Print the screen

!seealso: "EnumMPrn()" "PrintScrn()" 
'------------------------------------------------------------------------------



!short: LoadVText()     Load the vector text font
'------------------------------------------------------------------------------
^BSyntax^B
LoadVText( <cFilespec> )

^BDescription^B
Loads the vector text font (there is only one) from disk into 
memory.

^UNote^U   The vector text font uses the same internal buffer as 
is used by DataStore(), LogData(), and TimeData(). Thus use you 
cannot use the font and keep data in memory at the same time.

^BParameters^B
^U<cFilespec>^U
File specification for the vector text font, in the form:

"DRV:\PATH\STANDARD.VTX"

^BRemarks^B
You must load the vector font before calling DrawVText(). When
your work with vector text is done, unload the font by calling 
LoadVText(""), passing a null string as the file specification.

!seealso: "DrawVText()" 
'------------------------------------------------------------------------------



!short: LogAxis()       Draw a logarithmically scaled axis 
'------------------------------------------------------------------------------
^BSyntax^B
LogAxis( <nX>,  <nY>,  <nAxisLength>,  <nTickLength>, 
         <nCycles>,  <nDirection>,  <nStyle>,  <nColor> )

^BDescription^B
Draws an axis in either the X or the Y direction. The other axis 
may be added using the XYAxes() function. Call XYAxes() first, 
then LogAxis() to draw over one arm of the set.

Tick marks are spaced at logarithmic distances, nine per cycle, 
and may extend outside, inside, or through the axis.

^BParameters^B
^U<nX>^U
X coordinate for the origin of the axis.

^U<nY>^U
Y coordinate for the origin of the axis.

dGE's coordinate system is described under the entry for 
SetVer().

^U<nAxisLength>^U
Length of the axis in screen units. A negative value will draw an 
axis in the negative X or negative Y direction.

^U<nTickLength>^U
Length of the tick marks in screen units. (nStyle defines the 
placement of tick marks.)

^U<nCycles>^U
Number of cycles of data. 

A graph ranging from a base value of 1 to a maximum of 10 
contains one cycle. A graph ranging from 1 to 100 has two 
cycles. A graph ranging from 1 to 1000 has three cycles.

The base value and number of cycles can be calculated from the 
minimum and maximum data values using the dGE function 
GetLog10():

Base = 10**(INT(GetLog10(Min) + 1000) - 1000)
Cycles = INT(GetLog10(Max) - 1000) + 1000 - GetLog10(Base)

You can obtain the maximum and minimum values stored in 
dGE's internal array by calling GetMax() and GetMin(). Certain 
limitations apply. For details, see the entries for those functions.

^U<nDirection>^U
Selects the direction of the axis.

        Value   Meaning
        컴컴   컴컴컴컴컴컴
          0     Draw X axis.
          1     Draw Y axis.

^U<nStyle>^U
Selects the style for tick marks.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Tick marks outside the axis (left on a Y
                axis, bottom on an X axis).
          2     Tick marks inside the axis.
          4     Tick marks strike through the axis.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^BExample^B
* Given the coordinates for the origin, the desired
* height of the graph, an array of data, and an array
* of labels, this UDF draws a log/lin graph.

FUNCTION GraphLog
      PARAMETERS nX0, nY0, nHeight, aXYData, aXLabels

      * Define style options
      nAxisClr = 15
      nGridClr = 7
      nAxisStyle = 40
      nLineClr = 12
      nLineStyle = 2

      * X Axis
      nXLen = ROUND(nHeight * 1.14, 0)
      nXDivs = LEN(aXYData) - 1  && Number of divisions
      nXInc = nXLen / nXDivs     && Calculate interval

      * Y Axis

      * Find the min and max values.
      nMin = aXYData[1]
      nMax = aXYData[1]
      FOR i = 1 TO LEN(aXYData)
         IF aXYData[i] > nMax
            nMax = aXYData [i]
         ENDIF

         IF aXYData[i] < nMin
            nMin = aXYData[i]
         ENDIF
      NEXT i 

      * Calculate the base value.
      nBase10 = INT(GetLog10(nMin) + 1000) - 1000
      nBase = 10**nBase10

      * Calculate the number of cycles.
      nCycles = INT(GetLog10(nMax) - 1000) + ;
                1000 - GetLog10(nBase)

      * Calculate cycle height based on height of graph.
      nCycleHt = nHeight / nCycles

      * Store data in dGE's internal array.
      r = DataReset()
      FOR i = 1 TO LEN(aXYData)
         r = LogData(aXYData[i], 0, 0, nCycleHt, nBase)
      NEXT i 

      * Load labels for the Y axis in an array
      DECLARE  aYLabels[nCycles + 1]
      FOR i = 0 TO nCycles
         aYLabels[i + 1] = ;
            LTRIM(STR(INT(10**(nBase10 + i))))
      NEXT i

      * Draw the labels, grid, axes, and the graph.
      * (Labels first, to avoid overwriting tick marks.)
      r = LabelX(nX0, nY0, nXInc, 0, 1, 128,   ;
                nAxisClr, aXLabels)
      r = LabelY(nX0, nY0, nCycleHt, 0, 1, 16, ;
                 nAxisClr, aYLabels)

      r = LogGrid(nX0, nY0, nHeight, nXLen, nCycles, ; 
                  1, 1, nGridClr)
      r = XYAxes(nX0, nY0, nXLen, nHeight, nXDivs,   ;
                 1, 0, nAxisClr)

      r = LogAxis(nX0, nY0, nHeight, 10, nCycles,    ; 
                  1, 0, nAxisClr)
      r = XYGraph(nX0, nY0, nXInc, nLineStyle, nLineClr)

RETURN 0

!seealso: "LogData()" "LogGrid()" "GetLog10()" "XYGraph()" 
'------------------------------------------------------------------------------



!short: LogData()       Store data for a log/lin graph 
'------------------------------------------------------------------------------
^BSyntax^B
LogData( <nAmplitude>, <nMark>, <XPosition>, 
         <nCycleHeight>, <nBaseValue> )

^BDescription^B
Stores data for a log/lin graph. The graph itself is drawn by 
calling XYGraph().

^BParameters^B
^U<nAmplitude>^U
Amplitude value. The value must be greater than zero.

^U<nMark>^U
Selects a line style or icon. How dGE interprets the value 
depends on whether the nStyle argument to XYGraph() indicates 
that points should be marked with chained lines or with icons.

      ^UnStyle = 0 (Chained Lines)^U

        Value           Meaning
        컴컴           컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0             Solid line.
        > 0             Broken line with an interval of nMark pixels.

        + 128 * nMark   Line index (for plotters only).

      ^UnStyle = 1 (Icons) or nStyle = 2 (Lines and Icons)^Y

        Value   Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 9  Icon code. See Appendix A.
        + 16    Use a SuperIcon from a file.

^U<XPosition>^U
Position along the horizontal axis. dGE uses this value only if 
the value for nXInc passed to XYGraph() is zero.

^U<nCycleHeight>^U
The height in screen units of one cycle of data; the distance, for 
example, from 1 to 10 or 10 to 100.

^UNote^U   For C interface, the variables nCycleHeight and
nBaseValue are floating point doubles.

^U<nBaseValue>^U
The base value at which the graph is origined, usually a power
of ten: 0.1, 1, 10, 100....  It must be greater than zero.

      Minimum Amplitude     Base Value
      컴컴컴컴컴컴컴컴     컴컴컴컴컴
        .001 - .009               .001
         .01 - .09                .01
          .1 - .9                 .1
           1 - 9                  1
          10 - 99                10
         100 - 999              100
        1000 - 9999            1000

The base value can be calculated from the minimum data values
using the dGE function GetLog10():

Base = 10**(INT(GetLog10(Min) + 1000) - 1000)

!seealso: "XYGraph()" "LogAxis()" "LogGrid()" "GetLog10()" 
'------------------------------------------------------------------------------



!short: LogGrid()       Draw grid lines at logarithmic intervals
'------------------------------------------------------------------------------
^BSyntax^B
LogGrid( <nX>, <nY>, <nAxisLength>, <nGridLength>, 
         <nCycles>, <nDirection>, <nLineStyle>, <nColor> )

^BDescription^B
Draws grid lines at logarithmic intervals along either the X or Y 
axis, parallel to the Y or X axis. Nine grid lines are drawn for 
each cycle of data.

^BParameters^B
^U<nX>^U
X coordinate for the origin of the grid.

^U<nY>^U
Y coordinate for the origin of the grid.

dGE's coordinate system is described under the entry for 
SetVer().

^U<nAxisLength>^U
Length of the axis, in screen units. Which axis to measure 
depends on the direction of your grid lines. When grid lines are 
horizontal, nAxisLength determines the height of the grid, and so 
you'll want the length of the Y axis. When grid lines are vertical, 
nAxisLength determines the width of the grid, and so you'll want 
the length of the X axis.

^U<nGridLength>^U
Length of the grid lines, in screen units. You'll probably want 
this to be equal to the length of the axis that is parallel to the 
grid lines. If the grid lines are horizontal, nGridLength is usually 
the length of the X (horizontal) axis. If the grid lines are vertical, 
nGridLength is usually the length of the Y (vertical) axis.

^U<nCycles>^U
Number of cycles of data. 

A graph ranging from a base value of 1 to a maximum of 10 
contains one cycle. A graph ranging from 1 to 100 has two 
cycles. A graph ranging from 1 to 1000 has three cycles.

The base value and number of cycles can be calculated from the 
minimum and maximum data values using the dGE function 
GetLog10():

Base = 10**(INT(GetLog10(Min) + 1000) - 1000)
Cycles = INT(GetLog10(Max) - 1000) + 1000 - GetLog10(Base)

You can obtain the maximum and minimum values stored in 
dGE's internal array by calling GetMax() and GetMin(). Certain 
limitations apply. For details, see the entries for those functions.

^U<nDirection>^U
Selects the direction of the grid.

        Value   Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Draw X grids, parallel to the Y axis.
          1     Draw Y grids, parallel to the X axis.

^U<nLineStyle>^U
Selects the line style for the grid. Zero produces a solid line. A 
value greater than zero produces a broken line with an interval 
of nLineStyle pixels.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

!seealso: "LogAxis()" "LogData()" "GetLog10()" "GetMax()" "GetMin()" 
'------------------------------------------------------------------------------



!short: MCurOff()       Turn off the mouse cursor
'------------------------------------------------------------------------------
^BSyntax^B
MCurOff()

^BDescription^B
Turns off the mouse cursor.

If you have called MCurOn(), you must call MCurOff() every time 
you exit a dGE graphics module and before quitting your 
program.

^BExample^B
r = SetGMode(18)
r = SetHiRes(0)
r = MReset()
r = MCurOn()
.
.
.
r = MCurOff()
r = SetText()
SET MOUSE ON  && FoxPro

!seealso: "MCurOn()" "MReset()" "SetText()" 
'------------------------------------------------------------------------------



!short: MCurOn()        Turn on the mouse cursor
'------------------------------------------------------------------------------
^BSyntax^B
MCurOn()

^BDescription^B
Turns on the mouse cursor.

You must first have initialized the mouse interface by calling 
MReset() and you must also be in graphics mode before calling 
MCurOn().

Immediately after a call to MReset(), the mouse cursor is 
positioned at the center of the screen. Otherwise, the cursor is 
repositioned whenever the mouse is moved, even when the 
cursor is off. Thus if you turn the cursor off and then later back 
on again, it will appear wherever the last mouse move positioned 
it.

^UNote^U   Certain dGE functions suppress the mouse cursor
while they are writing to the screen. In general, these are 
functions, such as SayString(), that write bitmapped images.

^BExample^B
nButtons = MReset()
IF nButtons > 0
   r = MCurOn()
ENDIF

!seealso: "MCurOff()" "MReset()" "MCurType()" 
'------------------------------------------------------------------------------



!short: MCurType()      Select a mouse cursor shape
'------------------------------------------------------------------------------
^BSyntax^B
MCurType( <nType> )

^BDescription^B
Selects a mouse cursor shape.

^BParameters^B
^U<nType>^U
Selects a cursor shape.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴
          0     Standard arrow. (Default)
          1     Cross-hairs.
          2     Four-directional arrow.

^BRemarks^B
Whenever you call MReset() the mouse cursor is automatically 
initialized as an arrow shape. Thus you need call this function 
only to change the cursor from the default shape or back to the 
default shape.

^BExample^B
* Set the cursor shape to cross-hairs at startup.
r = MReset()
r = MCurType(1)
r = MCurOn()

!seealso: "MCurOn()" "MReset()" 
'------------------------------------------------------------------------------



!short: MFixPos()       Move the mouse cursor to a new position
'------------------------------------------------------------------------------
^BSyntax^B
MFixPos( <nX>, <nY> )

^BDescription^B
Moves the mouse cursor to a new position.

^BParameters^B
^U<nX>^U
X coordinate for the new location of the mouse cursor.

^U<nY>^U
Y coordinate for the new location of the mouse cursor.

^BRemarks^B
This function is useful for initializing the mouse position at 
startup or for positioning the cursor near to a default choice on 
a menu or pick list.

The effect of jumping from one position to another may be 
displeasing to some eyes. In that case, simply turn the mouse 
cursor off before moving it.

^BExample^B
r = MCurOff()
r = MFixPos(675, 500)
r = MCurOn()

!seealso: "FixPos()" "MCurOff()" 
'------------------------------------------------------------------------------



!short: MGetHot()       Find which hot spot has received a mouse click
'------------------------------------------------------------------------------
^BSyntax^B
nRegion = MGetHot()

^BDescription^B
Reports the identity of a region that has received a mouse click. 
The region must first have been defined with MSetHot().

^BReturns^B
A numeric value indicating the hot region that has received a 
mouse click.

        Value     Meaning
        컴컴컴   컴컴컴컴컴컴컴컴
        0         No hot region.
        1 to 70   Region number hit.

^BRemarks^B
The recommended procedure is to first poll MStatus() until a 
mouse button is pressed, then call MGetHot() to determine if the 
button was pressed within a hot region.

^UNote^U   Sometimes a user will start clicking around just 
before you display a dialog box and begin checking for hits on, 
let's say, an OK button. How are you to know if the hit was 
meant for your button?  Easy. Just wait for the mouse button to 
be up before polling for button presses. See the example below.

^BExample^B
* Define a hot region.
r = MSetHot(1, 625, 450, 100, 100)

* Wait for the mouse button to be up.
nButton = 0
DO WHILE nButton <> 0
   nButton = MStatus()
ENDDO

* Poll for a button press.
DO WHILE nButton = 0
   nButton = MStatus()
ENDDO

* Determine the region hit and respond.
nRegion = MGetHot()

DO CASE
CASE nRegion = 1
   * Highlight it.
   XORBlock(625, 450, 100, 100, 15)

CASE nRegion = 2
   * ...etc.
OTHERWISE
ENDCASE

!seealso: "MStatus()" "MSetHot()" 
'------------------------------------------------------------------------------



!short: MGetX()         Get the mouse cursor's X coordinate
'------------------------------------------------------------------------------
^BSyntax^B
nX = MGetX()

^BDescription^B
Reads the mouse cursor's current position and returns the X 
coordinate.

^UNote^U   Always call MStatus() before reading the mouse 
coordinates.

^BReturns^B
X coordinate (0 to 1350) for the mouse cursor's current position.

^BExample^B
* Show the current coordinates of the mouse cursor.

nButtons = MReset()
r = MCurOn()

* Read the initial position.
nClick = MStatus()
cX = LTRIM(STR(MGetX()))
cY = LTRIM(STR(MGetY()))
r = SayString(0, 0, 0, 0, 15, cX + ", " + cY)

* Update the position when the mouse moves.
DO WHILE INKEY() != 27
   IF MMotion() > 0
      nClick = MStatus()
      cX = LTRIM(STR(MGetX()))
      cY = LTRIM(STR(MGetY()))
      r = SayString(0, 0, 0, 0, 15, cX + ", " + cY)
   ENDIF
ENDDO
r = MCurOff()

!seealso: "MGetY()" "MFixPos()" "MReset()" "MStatus()" 
'------------------------------------------------------------------------------



!short: MGetY()         Get the mouse cursor's Y coordinate
'------------------------------------------------------------------------------
^BSyntax^B
nY = MGetY()

^BDescription^B
Reads the mouse cursor's current position and returns the Y 
coordinate.

^UNote^U   Always call MStatus() before reading the mouse 
coordinates.

^BReturns^B
Y coordinate (0 to 1000) for the mouse cursor's current position.

!seealso: "MGetX()" "MFixPos()" "MReset()" "MStatus()" 
'------------------------------------------------------------------------------



!short: MinMax()        Draw minimum and maximum lines
'------------------------------------------------------------------------------
^BSyntax^B
MinMax( <nLength>, <nLineStyle>, <nColor> )

^BDescription^B
Draws lines representing the minimum and maximum values of 
the current data set or subset. The data must first have been 
graphed by a graphing function.

^BParameters^B
^U<nLength>^U
Length, in screen units, of the statistical lines. The lines will 
extend in a positive direction from the X origin of the graph, and 
will be drawn parallel to the X axis.

If nLength is zero, dGE will draw the lines within a window 
previously defined by a call to SetWin().

^UNote^U   If your graph extends in the negative X or Y 
directions, define a window by calling SetWin(). Then pass zero 
as nLength when you call MinMax().

^U<nLineStyle>^U
Selects the type of line to be drawn.

         Value           Meaning
        컴컴컴컴       컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
           0             Solid line.

         > 0             Broken line with an interval of nStyle
                         pixels between segments.

        + (n * 128)      For plotters only. The value n is the
                         plotter's line style index, which may be
                         used to select various mark/space
                         patterns. Refer to your plotter
                         documentation for details.

                      ^UNote^U   If n = 0, the default style is
                        2 (even mark/space). Style 0, a single
                        dot, is not available.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value
returned by GetVideo(6). See the entry for SetRGBPal().

^BRemarks^B
The function calculates minimum and maximum values from 
the first parameter of DataStore(). This has relevance to the 
High, Low, Close graph drawn by HLCGraph(). See the entry for 
that function.

^BExample^B
r = MinMax(100, ; && Length
             1, ; && Broken line, segments 1 pixel long
             4)   && Color

!seealso: "HLCGraph()" "GetMax()" "GetMin()" "SetWin()" "Stats()" 
'------------------------------------------------------------------------------



!short: MMotion()       Determine if the mouse has moved
'------------------------------------------------------------------------------
^BSyntax^B
MMotion()

^BDescription^B
Reports whether the mouse has moved since the last time this
function was called. The motion counter is reset whenever you 
call MReset().

^BReturns^B
A numeric value indicating whether the mouse cursor has 
moved since the last call to MMotion().

        Value   Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     No movement since last call.
          1     Mouse has moved since last call.

^BExample^B
* Display current coordinates whenever the
* mouse cursor is moved.
r = ClrScreen()
r = MReset()
r = MCurOn()
DO WHILE INKEY() != 27
   IF MMotion() > 0
      nClick = MStatus()
      cX = LTRIM(STR(MGetX()))
      cY = LTRIM(STR(MGetY()))
      r = SayString(0, 0, 0, 0, 15, cX + ", " + cY)
   ENDIF
ENDDO
r = MCurOff()

!seealso: "MReset()" "MStatus()" 
'------------------------------------------------------------------------------



!short: MoveVec()       Move using vector coordinates
'------------------------------------------------------------------------------
^BSyntax^B
MoveVec( <nDistance>, <nAngle> )

^BDescription^B
Moves the current position nDistance screen units in the 
direction nAngle. The new position applies to the next vector 
draw or move.

^BParameters^B
^U<nDistance>^U
Distance from the current position, in screen units.

By default, the current position is 0, 0 until a draw, move, or 
positioning function is executed. See the entry for FixPos().

^U<nAngle>^U
Angle from current position, in degrees. The angle may be either 
positive or negative.

^BExample^B
* Make the new current position a point 100 screen units
* away at an angle of 45 degrees.
r = MoveVec(100, 45)

!seealso: "FixPos()" "MoveXY()" 
'------------------------------------------------------------------------------



!short: MoveXY()        Move using relative Cartesian coordinates
'------------------------------------------------------------------------------
^BSyntax^B
MoveXY( <nXRel>, <nYRel> )

^BDescription^B
Moves the current position a relative horizontal and vertical 
distance.

^BParameters^B
^U<nXRel>^U
Horizontal distance, in screen units, from the current position.

By default, the current position is 0, 0 until a draw, move, or 
positioning function is executed. Calling DataReset() restores the 
default.

^U<nYRel>^U
Vertical distance, in screen units, from the current position.

^BExample^B
* Move the current position right 100 screen units,
* down 50 screen units.
r = MoveXY(100, -50).

!seealso: "FixPos()" "MoveVec()" 
'------------------------------------------------------------------------------



!short: MReset()        Check for a mouse and initialize
'------------------------------------------------------------------------------
^BSyntax^B
nButtons = MReset()

^BDescription^B
Checks for the presence of a Microsoft or compatible mouse. If a 
mouse is found, the function initializes it and returns the 
number of buttons detected.

^UNote^U   Call MReset() before calling any other mouse 
functions.

^BReturns^B
Number of buttons on the mouse, or zero if no mouse is found.

^BRemarks^B
The mouse cursor initializes as an arrow. You can select another 
shape by calling MCurType().

The mouse cursor will not display until it is turned on by a call
to MCurOn(). The cursor's initial position is near the center of 
the screen. If this is not satisfactory, call MFixPos() to relocate 
the cursor before displaying it.

FoxPro  If a mouse is present in the system, FoxPro will turn the 
mouse cursor on whenever you call SetHiRes(0). You may not see 
the cursor until you move it, but it will be there. Since the mouse 
cursor slows drawing, the best procedure is to turn the cursor off 
immediately after entering graphics mode. The calls to do this are:
r = SetHiRes(0)
r = MReset()
r = MCurOff()
Turn the cursor back on whenever it is appropriate for your 
application. To do this, just call MCurOn().

^BExample^B
IF MReset() > 0
   r = MCurOn()
ENDIF

!seealso: "MCurOn()" "MCurType()" "MFixPos()" "MStatus()" 
'------------------------------------------------------------------------------



!short: MSetHot()       Define a mouse hot spot
'------------------------------------------------------------------------------
^BSyntax^B
MSetHot( <nRegion>, <nX>, <nY>, <nWidth>, <nHeight> )

^BDescription^B
Defines a rectangular hot region for reporting mouse hits.

^BParameters^B
^U<nRegion>^U
Hot region number, 1 to 70.

^U<nX>^U
X coordinate for the bottom left of the hot region.

^U<nY>^U
Y coordinate for the bottom left of the hot region.

^U<nWidth>^U
Width of the hot region, in screen units.

^U<nHeight>^U
Height of the hot region, in screen units.

^BRemarks^B
Once you have defined a region, call MStatus() to check for a 
button press, and then MGetHot() to see if the mouse was within 
a hot region when it was clicked.

You may define as many as seventy regions. Take care, however,  
that regions do not overlap. If they do, MGetHot() will return the 
identity of the lower numbered region that is hit.

Clear all regions from memory by calling SetHiRes(). Clear an 
individual region by redefining it with a width and height of 
zero.

!seealso: "MGetHot()" 
'------------------------------------------------------------------------------



!short: MSetWin()       Restrict mouse cursor movement
'------------------------------------------------------------------------------
^BSyntax^B
MSetWin( <nX0>, <nY0>, <nX1>, <nY1> )

^BDescription^B
Restricts mouse cursor movement to a rectangular window.

^BParameters^B
^U<nX0>^U
X coordinate for the bottom left corner.

^U<nY0>^U
Y coordinate for the bottom left corner.

^U<nX1>^U
X coordinate for the upper right corner.

^U<nY1>^U
Y coordinate for the upper right corner.

^BRemarks^B
By default, the window for mouse cursor movement is the entire
area of the screen. After defining a more narrow scope with 
MSetWin() you can later return to the default by calling MReset() 
or by calling MSetWin(0, 0, 1350, 1000).

^BExample^B
* Restrict mouse movement to within an area bounded
* by coordinates 200, 300 and 1150, 700.
nX0 = 200
nY0 = 300
nX1 = 1150
nY1 = 700
r = MReset()
r = MSetWin(nX0, nY0, nX1, nY1)
* Move the cursor to the center of the window.
r = MFixPos(nX0 + ((nX1 - nX0)/2), nY0 + ((nY1 - nY0)/2)
* Turn the cursor on.
r = MCurOn()
DO WHILE INKEY() != 27
ENDDO
r = MCurOff()

!seealso: "MCurOn()" "MFixPos()" "MReset()" 
'------------------------------------------------------------------------------



!short: MStatus()       Determine which mouse buttons are down 
'------------------------------------------------------------------------------
^BSyntax^B
nButtonDown = MStatus()

^BDescription^B
Returns a value indicating which buttons, if any, are now down. 
When both buttons are up, the function returns zero.

^BReturns^B
A numeric value indicating which mouse buttons are pressed.

        Value   Meaning
        컴컴   컴컴컴컴컴컴
          0     No button.
          1     Left button.
          2     Right button.
          3     Both buttons.

^BRemarks^B
The function freezes the cursor position momentarily so that its 
coordinates may be obtained using MGetX() and MGetY(). The 
delay is very slight and will not be perceptible on most 
machines.

^BExample^B
nButtons = MReset()
r = MCurOn()
.
.
.
nClick = MStatus()
nX = MGetX()       && Get the position
nY = MGetY()       && of the mouse cursor.
DO CASE
CASE nClick = 1    && Left button
   && Do something
CASE nClick = 2    && Right button
   && Do something
CASE nClick = 3    && Both buttons
   && Do something
OTHERWISE          && No buttons
   && Do something
ENDCASE

!seealso: "MGetHot()" "MGetX()" "MGetY()" "MReset()" 
'------------------------------------------------------------------------------



!short: PCLFont()       Define the font for a PCL 5 laser printer
'------------------------------------------------------------------------------
^BSyntax^B
PCLFont( <SymbolSet>, <nPitch>, <nPosture>, <nWeight>, <nFamily> )

^BDescription^B
Redefines the characteristics of the font used by VPOn() for 
printing on a LaserJet III or IV, or on a compatible laser printer.

^BParameters^B
^U<SymbolSet>^U
International code set. Typical values are:

        Value   Meaning
        컴컴   컴컴컴컴
          21    ASCII
          37    UK
          39    German
          83    Spanish
         277    Roman-8
         341    PC-8

                ^UNote^U  We recommend that users outside 
                of the UK and US use this symbol set to get 
                standard upper-ASCII characters.

^U<nPitch>^U
Fixed or proportional.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Fixed (Stick only)
          1     Proportional (all other scalable fonts)

^U<nPosture>^U
Upright or Italic.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴
          0     Upright
          1     Italic
          2     Alternate italic

^U<nWeight>^U
Stroke weight.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴
        - 7     Ultra thin (minimum)
        - 3     Light
          0     Medium
        + 3     Bold
        + 7     Ultra thick (maximum)

^U<nFamily>^U
Typeface code. Some are listed below. See your font cartridge or
printer documentations for others.

        Value   Meaning
        컴컴   컴컴컴컴
          5     CG Times
         52     Univers
         48     Stick

^BRemarks^B
By default, VPOn() takes font characteristics from the header of 
the dGE screen font file currently loaded. This function enables 
you to override the default behavior, taking better advantage of 
the PCL5 fonts resident in your printer.

The characteristics of several screen fonts are given below.

        ^USystem Fonts^U
        Symbol Set      277     Roman-8
        Pitch             0     Fixed
        Posture           0     Upright
        Weight            0     Medium
        Typeface         48     Stick

        ^URMN .STX Fonts^U
        Symbol Set      277     Roman-8
        Pitch             1     Proportional
        Posture           0     Upright
        Weight            0     Medium
        Typeface          5     CG Times

        ^USWI .STX Fonts^U
        Symbol Set      277     Roman-8
        Pitch             1     Proportional
        Posture           0     Upright
        Weight            0     Medium
        Typeface         52     Univers

!seealso: "VPOn()" 
'------------------------------------------------------------------------------



!short: PicRead()       Display an image from a file
'------------------------------------------------------------------------------
^BSyntax^B
PicRead( <nX>, <nY>, <nFormat>, <cFile> )

^BDescription^B
Displays an image from a file. The image is located according to
the coordinates you specify for the bottom left (or, optionally, top
left) corner. If this location will not allow all of the image to fit
within the active clipping area, the portions extending beyond
the boundary will be clipped.

^BParameters^B
^U<nX>^U
X coordinate for the origin of the image.

^U<nY>^U
Y coordinate for the origin of the image.

By default, the origin is the lower left corner of the image. dGE's 
coordinate system is described under the entry for SetVer().

^U<nFormat>^U
File format and display options.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
           0    PCX  Any PCX file with 2, 16, or 256
                colors, including monochrome with 4 bits 
                per pixel.

           1    BMP MS Windows bitmap files in 2, 16, or 
                256 colors. Run-length encoded formats 
                (RLE4 and RLE8) are not currently 
                supported.
                ^UNote^U   Because BMP files are not 
                compressed, they have a speed advantage 
                over PCX files.

        +  8    XOR the image.

        + 16    Reverse black and white (monochrome image 
                only).

        + 32    Do not set the screen palette to the 
                image palette.

        + 64    Origin is top left corner of the image. 
                The default is lower left corner.

        + 128   Tile the screen (BMP only). dGE ignores 
                nX, nY and, starting at the lower left 
                corner of the screen, draws the bitmap 
                repeatedly until the entire screen is 
                filled.

^U<cFile>^U
File name in the form

"DRV:\PATH\FILENAME.EXT"

^BRemarks^B
dGE will not display images that are larger than the current 
screen resolution will permit or that have more colors than the 
current graphics mode supports. The rule of thumb for 
displaying images is that you can move up from the graphics
mode used to prepare the image, but never down.

However, you may encounter another problem if you move up to 
a higher resolution than was used to prepare the image: the 
image will probably appear distorted. This is because BMP and 
PCX image formats are screen resolution dependent. The revised 
rule of thumb is, for best results, display an image using the 
same graphics mode used to prepare it.

You should also keep in mind that in order to display any image 
correctly, dGE needs to read the image's color palette and set 
the screen palette to match. This will affect any other images 
currently on display. You can tell dGE not to use the image 
palette by passing + 32 in the nFormat argument. Or, if you do 
use the image's color palette, after you have removed the image 
from the screen you can reset the screen palette to the system 
default by calling ResetPal().

^BExample^B
* Compare the screen palette before and after
* displaying a PCX image.

SET CURSOR OFF
CLEAR SCREEN

IF GetGMode(18) <> 0
   r = SetGMode(18)   && A 16 color mode.

ELSE
   ? "Graphics mode not supported by this hardware."
   QUIT
ENDIF

r = SetHiRes()

* Display the palette for this graphics mode.
r = ShowPalette()
r = INKEY(0)

* Now display an image, and then the palette.
r = ClrScreen()
r = ShowBird()
r = ShowPalette()
r = INKEY(0)

* Remove the image and reset the screen palette.
r = ClrScreen()
r = ResetPal()
r = ShowPalette()
r = INKEY(0)

r = SetText()
QUIT


* Displays the screen palette
FUNCTION ShowPalette
   PRIVATE i, nX, nY, nWid, nHt, nColors, nRows

   nX = 200  && Bottom left of first row
   nY = 880
   nWid = 60 && Size of a box
   nHt = 55

   nColors = GetVideo(6) && Number of colors for this mode
   nRows = nColors / 16

   * Draw row(s) of 16 boxes filled with color
   FOR i = 0 to nRows - 1
      * Label the row
      r = SayString(nX - 60, nY - (i * nHt), ;
                    16, 0, 15, RIGHT(STR(i), 2))

      * Fill a row of boxes
      FOR j = 0 to 15
         * Label the column
         r = SayString(nX + (j * nWid), nY + nHt + 8, ;
                       0, 0, 15, RIGHT(STR(j), 2))

         * Draw a box and fill it with the color
         r = BoxFill(nX + 2 + (j * nWid),  ;
                     nY + 2 - (i * nHt),   ;
                     nWid - 5, nHt - 4, 32,;
                     j + (i * 16))
      NEXT j
   NEXT i
RETURN 0

* Displays the version of an image that is correct
* for this graphics mode.
FUNCTION ShowBird()
   PRIVATE nColors, cPcx

   nColors = GetVideo(6) && Number of colors for this mode

   DO CASE
   CASE nColors == 256
      cPcx = "..\PCX\BIRD256.PCX"

   CASE nColors == 16
      cPcx = "..\PCX\BIRD16.PCX"
   OTHERWISE
      cPcx = "..\PCX\BIRD2.PCX"
   ENDCASE
   PicRead(0, 0, 0, cPcx)
RETURN 0

!seealso: "LoadIcon()" "PicWrite()" "ResetPal()" "SetGMode()" 
'------------------------------------------------------------------------------



!short: PicWrite()      Save an image to a file
'------------------------------------------------------------------------------
^BSyntax^B
PicWrite( <nX0>, <nY0>, <nX1>, <nY1>, <nFormat>, <cFilename> )

^BDescription^B
Saves a complete or partial screen image to a named file.

^BParameters^B
^U<nX0>^U
X coordinate for the bottom left corner.

^U<nY0>^U
Y coordinate for the bottom left corner.

^U<nX1>^U
X coordinate for the top right corner.

^U<nY1>^U
Y coordinate for the top right corner.

^U<nFormat>^U
Image format.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     PCX format. Uses file compression and so
                PCX files require less disk space than 
                BMP files.

          1     BMP format. Does not use file compression 
                and so BMP files are written and read
                faster than PCX files.

^U<cFilename>^U
File name in the form

"DRV:\PATH\FILENAME.EXT"

^BExample^B
r = PicWrite(100,      ; && Left
             100,      ; && Bottom
             300,      ; && Right
             300,      ; && Top
               1,      ; && BMP
             "TEST.BMP") && Filename.ext

!seealso: "DrawIcon()" "PicRead()" 
'------------------------------------------------------------------------------



!short: PieChart()      Draw a two-dimensional pie chart
'------------------------------------------------------------------------------
^BSyntax^B
DataStore( <nAmplitude>, <nFill>, <nExplode>, <nColor> )
PieChart( <nX>, <nY>, <nRadius> )

^BDescription^B
Draws a graph that represents the whole of a thing as a circle. 
Parts of the whole are shown as proportionally sized slices. Each 
slice may be individually patterned, colored, and exploded or 
displaced from the center.

^BData^B
A pie chart represents a single data group. Each data point 
within the group is shown as a segment of the pie. The size of a 
segment is calculated as a proportion of the total of all values in 
the data set.

All amplitude values stored must be positive integers. If your 
data includes fractions, you must either round individual values 
or scale all of the data before storing it.

In addition, another limitation is that the PieChart() function 
cannot graph integers larger than 32K. If your data has very 
large numbers, you must scale the values before storing them.

^BParameters^B

^UDataStore( <nAmplitude>, <nFill>, <nExplode>, <nColor> )^U

^U<nAmplitude>^U
Amplitude value for a pie segment. Must be a positive integer in 
the range 0 to 32768.

^U<nFill>^U
Segment fill pattern.

        Value     Meaning
        컴컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 19   Fill the segment with one of the hatch
                  patterns illustrated at Appendix A.

             20   Fill the segment with the current pattern
                  background color.

           + 32   Transparent fill. The fill pattern will
                  be painted over an underlying image or
                  background.

^U<nExplode>^U
The value that you pass determines whether the segment will be 
exploded.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Do not explode the segment.

          1     Explode the segment. The origin of the
                segment will be displaced by 1/4 of the 
                pie's radius.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^UPieChart( <nX>, <nY>, <nRadius> )^U

^U<nX>^U
X coordinate for center.

^U<nY>^U
Y coordinate for center.

dGE's coordinate mapping system is described under the entry 
for SetVer().

^U<nRadius>^U
Radius of the pie in screen units. The value must be greater 
than 25.

^BRemarks^B
If you have more than one group of data to graph, you can of 
course draw multiple pie graphs on screen. If this doesn't suit 
your purpose, you may want to consider using either a stacked 
bar graph or a percentile area graph.

^BExample^B
*::::::::::::::::::::::::::::::::::::::::::::::::::::
*                PIE.PRG
*
*    Displays multiple pie charts using
*    a different subset of the stored data
*    for each.
*
*::::::::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN

SET CURSOR OFF

* Set screen in graphics mode
r = SetHiRes(0)

* Set data values for pie charts
r = DataReset()
r = DataStore(20, 0, 1, 1)
r = DataStore(10, 0, 0, 2)
r = DataStore(35, 0, 0, 3)
r = DataStore(40, 0, 0, 4)
r = DataStore(25, 0, 1, 5)
r = DataStore(20, 1, 0, 9)

r = DataStore(10, 2, 0, 10)
r = DataStore(35, 3, 1, 11)
r = DataStore(40, 4, 0, 12)
r = DataStore(25, 5, 0, 13)

* Draw grid
r = XYAxes(0, 0, 1350, 1000, 2, 2, 4 + 16 + 64, 7)

* Draw PieChart with all data values
r = PieChart(315, 750, 200)

* ...with first 5 data values
r = DataRange(0, 4)
r = PieChart(1035, 750, 200)

* ...with last 5 data values
r = DataRange(5, 9)
r = PieChart(315, 270, 200)

* ...with middle 3 data values
r = DataRange(4, 6)
r = PieChart(1035, 270, 200)

* Pause to admire
r = INKEY(0)

* Restore text mode
r = SetText()

QUIT

!seealso: "Pie3D()" "LabelPie()" 
'------------------------------------------------------------------------------



!short: Pie3D()         Draw a three-dimensional pie chart
'------------------------------------------------------------------------------
^BSyntax^B
DataStore( <nAmplitude>, <nFill>, <nExplode>, <nColor> )
Pie3D( <nX>, <nY>, <nRadius> , <nDepth>, <nTilt>, <nStyle> )

^BDescription^B
Draws a three-dimensional pie chart that is tilted at a specified 
angle, with a specified thickness. Each segment may be 
individually patterned, colored, and exploded.

^BData^B
A pie chart represents a single data group. Each data point 
within the group is shown as a segment of the pie. The size of a 
segment is calculated as a proportion of the total of all values in 
the data set.

All amplitude values stored must be positive integers. If your 
data includes fractions, you must either round individual values 
before storing them or scale all data before graphing it. See the 
entry for DataPc().

Another limitation is that the Pie3D() function cannot graph 
integers larger than 32K. If your data has very large numbers, 
you must scale the values before graphing them.

^BParameters^B

^UDataStore( <nAmplitude>, <nFill>, <nExplode>, <nColor> )^U

^U<nAmplitude>^U
Amplitude value for a pie segment. Must be a positive integer in 
the range 0 to 32768.

^U<nFill>^U
Segment fill pattern.

        Value     Meaning
        컴컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 19   Fill the segment with one of the hatch
                  patterns illustrated at Appendix A.

             20   Fill the segment with the current pattern
                  background color.

           + 32   Transparent fill. The fill pattern will
                  be painted over an underlying image or
                  background.

^U<nExplode>^U
The value that you pass determines whether the segment will be 
exploded.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Do not explode the segment.

          1     Explode the segment. The origin of the 
                segment will be displaced by 1/4 of the 
                pie's radius.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value
returned by GetVideo(6). See the entry for SetRGBPal().

^UPie3D( <nX>, <nY>, <nRadius> , <nDepth>, <nTilt>, <nStyle> )^U

^U<nX>^U
X coordinate.

^U<nY>^U
Y coordinate.

The X, Y coordinate pair locate the center of the pie on screen.

dGE's coordinate mapping system is described under the entry 
for SetVer().

^U<nRadius>^U
Radius of the pie in screen units. The value must be greater 
than 25.

^U<nDepth>^U
Depth of the side walls in screen units. Increasing this value 
increases the thickness of the pie.

^U<nTilt>^U
Angle that the pie should be tilted from the vertical. Must be a 
positive integer in the range 0 to 90.

^U<nStyle>^U
Indicates how the sides of the segments should be colored.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     The side and top of each segment are both
                in nColor, the color associated with the 
                data point when the data was stored.

          1     The top of each segment is nColor. The 
                side is in the current pattern background 
                color. See the entry for SetBkFill().

          2     The top and sides are outlined in the 
                current pattern background color. See the 
                entry for SetBkFill().

^BRemarks^B
HPGL Plotting  This function uses the fill polygon command of
the HPGL language. If your plotter does not support this 
command, the 3D pie will be rendered in outline only.

^BExample^B
PROCEDURE MAIN

SET CURSOR OFF

* Set screen in graphics mode
r = SetHiRes(0)

* Set data values for pie charts
r = DataReset()
r = DataStore(20, 0, 1, 2)
r = DataStore(10, 0, 0, 3)
r = DataStore(35, 0, 0, 4)
r = DataStore(40, 0, 0, 5)
r = DataStore(25, 0, 1, 6)

r = DataStore(20, 1, 0, 10)
r = DataStore(10, 2, 0, 11)
r = DataStore(35, 3, 1, 12)
r = DataStore(40, 4, 0, 13)
r = DataStore(25, 5, 0, 14)

* Load a nice, small font
r = LoadCSet(0, "..\FONTS\PE16.PTX")

*
* This section looks at the various modes
*

* Put a blue background on the screen
r = BoxFill(0, 0, 1350, 1000, 0, 1)

* Draw grid
r = XYAxes(0, 0, 1350, 1000, 2, 2, 4 + 16 + 64, 7)

* Titles for pie charts
r  =  SayString(25, 525, 1 + 4, 0, 14, ;
      'Standard 3-D Pie')
r  =  SayString(700, 525, 1 + 4, 0, 14, ;
      'Sides set to background fill color')
r  =  SayString(25, 25, 1 + 4, 0, 14, ;
      'Outline in background fill color')
r  =  SayString(700, 25, 1 + 4, 0, 14, ;
      'Sides/outline in background fill color')

* Draw piechart in standard mode
r  = Pie3D(315, 775, 200, 30, 45, 0)

* ...with sides set to background fill color
r  = Pie3D(1035, 775, 200, 30, 45, 1)

* ...with slices outlined in background fill color
r  = Pie3D(315, 270, 200, 30, 45, 2)

* ...slices and sides outlined in background fill color
r  = Pie3D(1035, 270, 200, 30, 45, 3)

* Pause to admire
r = INKEY(0)

*
* This section looks at tilt
*

* Put a blue background on the screen
r = BoxFill(0, 0, 1350, 1000, 0, 1)

* Draw grid
r = XYAxes(0, 0, 1350, 1000, 2, 2, 4 + 16 + 64, 7)

* Titles for pie charts
r  =  SayString(25, 525, 1 + 4, 0, 14,  ;
      '10 degrees tilt')
r  =  SayString(700, 525, 1 + 4, 0, 14, ;
      '25 degrees tilt')
r  =  SayString(25, 25, 1 + 4, 0, 14,   ;
      '50 degrees tilt')
r  =  SayString(700, 25, 1 + 4, 0, 14,  ;
      '80 degrees tilt')

* Draw piechart with a 10 degree tilt
r  =  Pie3D(315, 775, 170, 30, 10, 2)

* ...with a 25 degree tilt
r  =  Pie3D(1035, 775, 170, 30, 25, 2)

* ...with a 50 degree tilt
r  = Pie3D(315, 270, 170, 30, 50, 2)

* ...with an 80 degree tilt
r  = Pie3D(1035, 270, 170, 30, 80, 2)

* Pause to admire
r = INKEY(0)

*
* This section looks at depth
*

* Put a blue background on the screen
r = BoxFill(0, 0, 1350, 1000, 0, 1)

* Draw grid
r = XYAxes(0, 0, 1350, 1000, 2, 2, 4 + 16 + 64, 7)

* Titles for pie charts
r  =  SayString(25, 525, 1 + 4, 0, 14, '20 depth')
r  =  SayString(700, 525, 1 + 4, 0, 14, '40 depth')
r  =  SayString(25, 25, 1 + 4, 0, 14, '60 depth')
r  =  SayString(700, 25, 1 + 4, 0, 14, '80 depth')

* Draw piechart with a depth of 20
r  =  Pie3D(315, 775, 200, 20, 45, 2)

* ...with a depth of 40
r  = Pie3D(1035, 775, 200, 40, 45, 2)

* ...with a depth of 60
r  = Pie3D(315, 270, 200, 60, 45, 2)

* ...with a depth of 80
r  = Pie3D(1035, 270, 200, 80, 45, 2)

* Pause to admire
r = INKEY(0)

* Restore text mode
r = SetText()

QUIT

!seealso: "PieChart()" "LabelPie()" "DataPc()" "SetBkFill()" 
'------------------------------------------------------------------------------



!short: PlotCSet()      Select a plotter character set
'------------------------------------------------------------------------------
^BSyntax^B
PlotCSet( <nDGECSet>, <nHeight>, <nWidth>, <nFont> )

^BDescription^B
Selects a plotter character set.

^UNote^U   The first three parameters are for backward 
compatibility. In the current version of dGE, the size of 
characters on screen is automatically matched in output to the 
plotter.

^BParameters^B
^U<nDGECSet>^U
Specify -1 for the current version of dGE.

^U<nHeight>^U
Specify 100 for the current version of dGE.

^U<nWidth>^U
Specify 100 for the current version of dGE.

^U<nFont>^U
Identifying code for one of the plotter's international character 
sets. Typical values are listed below. See your plotter's 
documentation.

        Value   Meaning
        컴컴   컴컴컴컴
          0     US
         33     Germany
         34     France
         35     UK

!seealso: "LoadCSet()" "PlotOn()" 
'------------------------------------------------------------------------------



!short: PlotOff()       Terminate plotter output
'------------------------------------------------------------------------------
^BSyntax^B
PlotOff()

^BDescription^B
Terminates plotter output. If output has been redirected to a file, 
the file is closed. If the call to PlotOn() specified page eject, a 
page eject command is issued.

^UNote^U   If the plotter is turned off or is not connected to the 
computer, dGE will report a device error.

It is prudent to issue PlotOff() whenever entering a program that 
uses plotter output in case plotter output has inadvertently been 
enabled. As long as PlotOn() is in effect, all graphics functions 
drawn on the screen will also be sent to the plotter.

^BExample^B
r = PlotOff()

!seealso: "PlotOn()" 
'------------------------------------------------------------------------------



!short: PlotOn()        Begin output to a plotter
'------------------------------------------------------------------------------
^BSyntax^B
PlotOn( <nHOffset>, <nVOffset>, <nXLen>, <nMode>, <nUnits> )

^BDescription^B
Defines plotter parameters and directs graphical output to a 
plotter. After a call to PlotOn(), all drawing functions are output 
simultaneously to the plotter and to the screen. Plotter output 
will continue until you call PlotOff().

^UNote^U   Call PlotPen() to define the relationship between 
screen colors and pen numbers. Call PlotCSet() to select a 
character set for the plotter.

^BParameters^B
^U<nHOffset>^U
Horizontal offset (margin), in millimeters, from the left side of 
the plotter table.

^U<nVOffset>^U
Vertical offset (margin), in millimeters, from the base of the 
plotter table.

^U<nXLen>^U
Length of the X axis (width of the image), in millimeters. This 
will govern the overall size of the image, as dGE calculates the 
height of the plotted image from the height of the image on
screen, maintaining the screen aspect ratio. Since the aspect 
ratio for dGE's default screen coordinate system is 1.35:1, the 
ratio of width to height for plotter output will also be 1.35:1.

^U<nMode>^U
Plotter options.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
           0    Landscape (horizontal) orientation.
           1    Portrait (vertical) orientation.
        +  8    Send reset before plotting.
        + 16    Send page eject after plotting.

^U<nUnits>^U
Plotter units per millimeter. For many A3 and A4 plotters the 
basic unit is 0.025mm. Thus for these plotters units per 
millimeter are 40.

^BRemarks^B
If you do not want to view the graphical output on the screen as 
it is sent to the plotter, simply omit a call to SetHiRes().

By default, plotter output is sent to LPT1. You can specify 
another port by calling PrnDev(). Or, if you wish, you can direct 
output to a file by calling PrintFile(). The file is will be in HP-GL 
format and can be imported into wordprocessors and other 
programs that read the format.

dGE's driver adheres to the HP-GL 7475A code standard.

^BExample^B
r = PlotOn(  0, ; && Horizontal margin
             0, ; && Vertical margin
           325, ; && Width
             0, ; && Landscape orientation
            40)   && 40 units per mm

!seealso: "PlotCSet()" "PlotPen()" "PrintFile()" "PrnDev()" 
'------------------------------------------------------------------------------



!short: PlotPen()       Define the pens on a plotter
'------------------------------------------------------------------------------
^BSyntax^B
PlotPen( <nColor>, <nPenNo>, <nPenThick> )

^BDescription^B
Defines the relationship between the colors used by dGE on 
screen and corresponding pens on your plotter. Also defines pen 
thickness so that patterned fills will be rendered properly.

^BParameters^B
^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

The default color is black.

^U<nPenNo>^U
Number of the plotter pen, 1 to maximum. The default for all 
colors is pen number 1.

^U<nPenThick>^U
Pen thickness in units of 0.1 mm. The default is 3 (0.3 mm).

^BExample^B
r = PlotPen(7, ; && Screen color index number
            1, ; && Pen number
            3)   && Thickness: 0.3 mm

!seealso: "PlotOn()" 
'------------------------------------------------------------------------------



!short: PolarAxes()     Draw axes for a polar graph
'------------------------------------------------------------------------------
^BSyntax^B
PolarAxes(<nX>, <nY>, <nRadius>, <nDivisions>, <nColor>)

^BDescription^B
Draws a set of polar axes at 45 degree increments. Each arm is
divided by tick marks at regular intervals. Optionally, circular
grid lines may be added at the same interval as the tick marks.

^BParameters^B
^U<nX>^U
X origin for the axes.

^U<nY>^U
Y origin for the axes.

dGE's coordinate system is described under the entry for
SetVer().

^U<nRadius>^U
Length of the arms from the origin.

^U<nDivisions>^U
Number of divisions per arm. The end of each division will be
marked with a tick mark. Grid lines will be drawn if you add 128
to the value of nDivisions. When grid lines are drawn, tick marks
are omitted.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value
returned by GetVideo(6). See the entry for SetRGBPal().

!seealso: "PolarGraph()" 
'------------------------------------------------------------------------------



!short: PolarGraph()    Draw a polar graph
'------------------------------------------------------------------------------
^BSyntax^B
DataStore( <nAmplitude>, <nIcon>, <nAngle>, 0 )
PolarGraph( <nX>, <nY>, <nCycles>, <nStyle>, <nColor> )

^BDescription^B
Draws a polar graph, a circular graph with two variables. The
dependent variable is measured in terms of distance from the
origin at the center of the circle. The independent variable is
measured as angular variation from zero degrees (moving
counterclockwise from three o'clock).

Angular measurements can be in either fixed-increments or
individually specified. Data points can be connected by lines,
marked with icons, or both. A fourth style graphs points by
drawing a series of radial arms from the origin to each point.

^BParameters^B

^UDataStore( <nAmplitude>, <nIcon>, <nAngle>, 0 )^U

^U<nAmplitude>^U
Amplitude value. Graphed as a distance from the origin at the
center of the circle.

^U<nIcon>^U
Icon code, 0 to 9. See the table at Appendix A.

^U<nAngle>^U
Angular measurement counterclockwise from zero degrees (three
o'clock). The angle is used only when the value of the nCycles
argument passed to the PolarGraph() function is zero.

^UPolarGraph( <nX>, <nY>, <nCycles>, <nStyle>, <nColor> )^U

^U<nX>^U
X coordinate for the center.

^U<nY>^U
X coordinate for the center.

dGE's coordinate system is described under the entry for
SetVer().

^U<nCycles>^U
Instructs dGE whether to use variable or fixed angular
increments.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Variable.  dGE will use the values for
                nAngle passed to DataStore().

        > 0     Fixed.  The angular increment between
                points is calculated by dividing 360
                times nCycles by the number of data
                points. Thus the first cycle is
                represented from 0 to 360 degrees, the
                second from 360 to 720, and so on.

^U<nStyle>^U
Selects how data points are marked.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Chained. Points are connected with lines.

          1     Icons. Points are marked with icons
                corresponding the icon codes stored with
                DataStore().
                Note that different icons can be used to
                distinguish between cycles.

          2     Chained with Icons. The first two style
                options are combined.

          3     Radial. A line is drawn from the center
                of the graph to each point.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value
returned by GetVideo(6). See the entry for SetRGBPal().

^BExample^B
*:::::::::::::::::::::::::::::::::::::::::::::::::::
*                    POLARS.PRG
*        Draws four polar graphs with same data
*        but different styles. Then draws a fifth
*        graph in scatter format.
*:::::::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN

SET CURSOR OFF

* Set screen in graphics mode.
r = SetHiRes(0)

* Draw grid to separate graphs.
r = XYAxes(0, 0, 1350, 1000, 2, 2, 4 + 16 + 64, 7)

* Draw the axes for the first four graphs.
r = PolarAxes(315, 750, 200, 5 + 128, 3)
r = PolarAxes(1035, 750, 200, 5, 3)
r = PolarAxes(315, 280, 200, 5, 3)
r = PolarAxes(1035, 280, 200, 5, 3)

* Display identifying text.
r = SayString(25, 525, 0, 0, 14, 'Sticks')
r = SayString(700, 525, 0, 0, 14, 'Icons')
r = SayString(25, 25, 0, 0, 14, 'Lines and Icons')
r = SayString(700, 25, 0, 0, 14, 'Lines')

* Load the data
r = DataReset()
STORE 60 TO nCount
STORE 200 TO nAmp

DO WHILE nCount > 0
  IF nCount > 30
    STORE nAmp - 5 TO nAmp
  ELSE

    STORE nAmp + 5 TO nAmp
  ENDIF
  r = DataStore(nAmp, 8, nCount * 6, 0)
  STORE nCount - 1 TO nCount
ENDDO

* This section draws the polar graphs. Each
* graph is drawn with the same dataset.
r = PolarGraph(315, 750, 1, 3, 14)

r = PolarGraph(1035, 750, 1, 1, 10)
r = PolarGraph(315, 280, 1, 2, 11)
r = PolarGraph(1035, 280, 1, 0, 12)

* Pause, then clear screen.
r = INKEY(0)
r = BoxFill(0, 0, 1350, 1000, 0, 0)

* Scale the data by 240%
r = DataPc(240)

* Title
r = SayString(90, 920, 0, 0, 4, 'Scatter format')

* Draw axes.
r = PolarAxes(675, 500, 480, 5+128, 9)

* Draw scatter polar graph.
r = PolarGraph(675, 500, 0, 1, 10)

* Pause, then restore text mode and exit.
r = INKEY(0)
r = SetText()
QUIT

!seealso: "PolarAxes()" 
'------------------------------------------------------------------------------



!short: Polygon()       Draw a filled polygon
'------------------------------------------------------------------------------
^BSyntax^B
DataStore( <nA>, <nB>, <nDraw>, 0 )
Polygon( <nPos1>, <nPos2>, <nMode>, <nRotation>,
         <nRasterMode>, <nPattern>, <nColor> )

^BDescription^B
Draws a filled polygon from points stored in dGE's internal
array. The last point is connected to the first to make a closed
area.

The locations for the points may be specified in either Cartesian
or vector coordinates. The figure itself may be mirrored
(geometrically reflected) along its horizontal or vertical axis and
rotated about its origin.

^BParameters^B

^UDataStore( <nA>, <nB>, <nDraw>, 0 )^U

^U<nA>^U
In Cartesian (X, Y) mode, the horizontal distance from the origin
to the X coordinate for this point.

In vector (distance, angle) mode, the distance from the last point
to this point.

^U<nB>^U
In Cartesian (X, Y) mode, the vertical distance from the origin to
the Y coordinate for this point.

In vector (distance, angle) mode, the angle from the last point to
this point.

^UNote^U   Due to limitations on the stack size allocated to the
Polygon() function's internal algorithm, you cannot store more
than 250 points for a figure. This limit is absolute, regardless of
whether the points are stored as vector or Cartesian
coordinates.

^U<nDraw>^U
Indicates whether or not a line should be drawn.

        Value    Meaning
        컴컴    컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0      Draw the line to this point.

          1      Move to this point, but do not draw a line.

^UPolygon( <nPos1>, <nPos2>, <nMode>, <nRotation>, <nRasterMode>, ;^U
^U         <nPattern>, <nColor> )^U

^U<nPos1>^U
In Cartesian mode, the horizontal distance from the current
drawing position to the X coordinate for the origin of the figure.

In vector mode, the distance from the current drawing position
to the location of the origin.

^U<nPos2>^U
In Cartesian mode, the vertical distance from the current
drawing position to the Y coordinate for the origin of the figure.

In vector mode, the angle from the current drawing position to
the location of the origin.

^U<nMode>^U
Indicates the format, Cartesian or vector, for the origin of the
figure and for the points stored with DataStore(). Also selects
drawing options.

         Value  Meaning
         컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
           0    Origin is in Cartesian (X, Y) format.

           1    Origin is in vector (distance, angle)
                format.

        +  0    Data is in Cartesian format.

        +  2    Data is in vector format.

        +  4    Drag effect. The previous image is erased
                before a new image is drawn.
                ^UNote^U   If you select this mode, then
                you should also select nPattern + 128
                (fill, no outline). When a polygon is
                outlined and then dragged, bits of
                outline sometimes get left behind.
                Eliminating the outline avoids this
                problem.

        +  8    Mirror the figure on the vertical axis.

        + 16    Mirror the figure on the horizontal axis.
                ^UNote^U   Mirroring is done before
                rotation. In other words, the horizontal
                and vertical axes are calculated from the
                points defined by the stored data, not
                from the drawing on screen.

^U<nRotation>^U
The angle of rotation about the origin. Positive integers rotate
the figure counterclockwise. Negative integers rotate clockwise.

^U<nRasterMode>^U
Raster drawing mode.

        Value   Meaning
        컴컴   컴컴컴컴
          0     REPLACE
          1     OR
          2     XOR

^U<nPattern>^U
Instructions for filling the interior of the polygon.

        Value    Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 19  Fill with one of the hatch patterns
                 illustrated at Appendix A.
             20  Fill with the current pattern background
                 color.
           + 32  Transparent fill. The fill pattern will
                 be painted over an underlying image in
                 the background.
           + 64  No pattern; just outline the figure.
          + 128  No outline; just fill the space.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value
returned by GetVideo(6). See the entry for SetRGBPal().

^BPositioning the Origin^B
The origin of the figure is a point of reference from which the
points that make up the figure are mapped. It is established
only when the figure is drawn. Thus you can draw the same
figure repeatedly, setting a new origin each time.

The coordinates that locate the origin are relative to the current
drawing position. At startup, the current drawing position is 0,
0, the lower left corner of the screen. It can be fixed at another
location by calling FixPos(), MoveXY(), or MoveVec().

Moving from the current drawing position, you can locate the
origin of the figure with either Cartesian or vector coordinates.

^UCartesian coordinates (X, Y)^U
Even though the current drawing position's absolute coordinates
might be different, in relative terms its position is 0, 0. The
ocation of the origin is mapped from this point.

If the origin of the figure is 50 screen units up and 50 to the 
right of the current drawing position, then its coordinates 
are 50, 50. If the origin is 50 screen units down and 50 to 
the left of the current drawing position, then its coordinates 
are -50, -50.

In other words, the origin's X coordinate is a relative 
distance left or right of the current drawing position, and its 
Y coordinate is a relative distance up or down from the 
current drawing position.

^UVector coordinates (distance, angle)^U
The origin of the figure is located by a vector from the current
drawing position.

If the origin of the figure is 50 screen units from the current 
drawing position at an angle of 45 degrees, then its vector 
coordinates are 50, 45.

^UNote^U   Angles are measured counterclockwise from three o'clock.

^BLocating Points in the Figure^B
The figure is made up of a series of connected points. A line is 
drawn from the origin to the first point stored, and from this 
point to the next point stored, and so on until all points are 
connected. Then a line is drawn from the last point to the origin, 
making a closed figure.

^UNote^U   If you exercise the "move but do not draw" (nDraw = 
1) option in storing data for the first point, the connecting lines 
will begin and end at the first point rather than at the origin.
The points of the figure can be located by either Cartesian or 
vector coordinates:

^UCartesian coordinates (X, Y)^U
The figure's origin is located at the relative coordinates 0, 0.
This is the first point in the figure.

Each of the remaining points has an X coordinate that is a 
relative distance, in screen units, left or right of the origin of 
the figure. If a point is left of the origin, its X coordinate is 
negative. If it is to the right, the X coordinate is positive.

Similarly, each point's Y coordinate is a relative distance up 
or down from the origin. If a point is above the origin, the Y 
coordinate is positive. If it is below the origin, its Y 
coordinate is negative.

^UVector coordinates (distance, angle)^U
Each point in the figure is located by a vector from the point
before it. The first point is located by a vector from the origin
of the figure. The second point is located by a vector from the
first point. The third point is located by a vector from the second,
and so on.

^BExample^B
*:::::::::::::::::::::::::::::::::::::::::::::::::
*               POLY.PRG
*    Draws a polygon of nSides, rotates it about
*    the origin, moves it left and right, and then
*    enlarges it to twice its original size.
*:::::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN(nSides)

SET CURSOR OFF
IF nSides == NIL   && NIL is a Clipper data type.
   ? 'Syntax: POLY <Number of Sides Desired>'
   ? 'Example: POLY 8  (Will display an octagon)'
   QUIT
ELSE
   nSides = VAL(nSides)
ENDIF

IF nSides > 250
   ? 'Sorry, the limit is 250 sides.'
   QUIT
ENDIF

r = SetHiRes(0)
r = ClrScreen()

* Define the size, origin, and color of the polygon.
nRadius = 50
nX0 = 675
nY0 = 500
nClr = 14
nMode = 4      && Drag mode
nPattern = 128 && Fill, no outline

* Calculate the degrees of arc to each point.
nArc = 360 / nSides

* The origin is the first and last point.
* Calculate and store remaining points.
r = DataReset()
FOR nAngle = nArc to 360 - nArc STEP nArc
  
  * Convert vectors to points on a circle
  * centered at the origin to Cartesian
  * coordinates.

  nX = GetSin(nAngle, 1) * nRadius    && Cos
  nY = GetSin(nAngle, 0) * nRadius    && Sin
  
  * Because we are using the origin as a point,
  * we need to offset the X coordinate.
  r = DataStore(nX - nRadius, nY, 0, 0)

NEXT nAngle

* Draw the polygon with the origin at the center of
* the screen and then rotate it about the origin
* until a key is pressed.
nRotation = 0
DO WHILE INKEY() < 1
   r = Polygon(nX0, nY0, nMode, nRotation, 0, ;
               nPattern, nClr)
   nRotation = nRotation + 12
ENDDO

* Shuttle the polygon to the left edge of the screen,
* then to the right, then back...until a key is pressed.
nMove = nRadius / 2
DO WHILE INKEY() < 1 
   r = Polygon(nX0, nY0, nMode, 0, 0, nPattern, nClr)

   IF nX0 <  2 * nRadius
      nMove = - nMove
      nMode = nMode - 8
   ENDIF

   IF nX0 > 1350 - (2 * nRadius)
      nMove = - nMove
      nMode = nMode + 8  && Flip on vertical axis
   ENDIF
   nX0 = nX0 + nMove
ENDDO

* Enlarge the polygon.
nMode = nMode - 4
FOR nScale = 100 TO 200 STEP 5
   r = DataPc(nScale)
   r = Polygon(nX0, nY0, nMode, 0, 0, nPattern, nClr)
NEXT nScale

* Pause.
r = INKEY(0)

* Restore text mode and exit.
r = SetText()
QUIT

!seealso: "PolyVec()" 
'------------------------------------------------------------------------------



!short: PolyVec()       Draw a figure by connecting points
'------------------------------------------------------------------------------
^BSyntax^B
DataStore( <nA>, <nB>, <nDraw>, 0 )
PolyVec( <nPos1>, <nPos2>, <nMode>, <nRotation>,
         <nLineMode>, <nLineStyle>, <nLineColor> )

^BDescription^B
Draws a figure by connecting points stored in dGE's internal 
array. The locations for the points may be specified by either 
Cartesian or vector coordinates. The figure may be mirrored 
(geometrically reflected) along either its horizontal or its vertical 
axis, and it may be rotated about its origin.

^BParameters^B

^UDataStore( <nA>, <nB>, <nDraw>, 0 )^U

^U<nA>^U
In Cartesian (X, Y) mode, the horizontal distance from the origin 
to the X coordinate for this point.

In vector (distance, angle) mode, the distance from the last point 
to this point.

^U<nB>^U
In Cartesian (X, Y) mode, the vertical distance from the origin to 
the Y coordinate for this point.

In vector (distance, angle) mode, the angle from the last point to 
this point.

^U<nDraw>^U
Indicates whether or not a line should be drawn.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Draw the line to this point.
          1     Move to this point, but do not draw a line.

^UPolyVec( <nPos1>, <nPos2>, <nMode>, <nRotation>, <nLineMode>,^U
^U         <nLineStyle>, <nLineColor> )^U

^U<nPos1>^U
In Cartesian mode, the horizontal distance from the current 
drawing position to the X coordinate for the origin of the figure.

In vector mode, the distance from the current drawing position 
to the location of the origin.

^U<nPos2>^U
In Cartesian mode, the vertical distance from the current 
drawing position to the Y coordinate for the origin of the figure.

In vector mode, the angle from the current drawing position to 
the location of the origin.

^U<nMode>^U
Indicates the format, Cartesian or vector, for the origin of the 
figure and for the points stored with DataStore(). Also selects
drawing options.

         Value  Meaning
         컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
           0    Origin is in Cartesian (X, Y) format.

           1    Origin is in vector (distance, angle) 
                format.

        +  0    Data is in Cartesian format.

        +  2    Data is in vector format.

        +  4    Delete the last drawing before drawing 
                this figure.

        +  8    Mirror the figure on the vertical axis.

        + 16    Mirror the figure on the horizontal axis.

                ^UNote^U   Mirroring is done before 
                rotation. In other words, the horizontal 
                and vertical axes are calculated from the 
                points defined by the stored data, not 
                from the drawing on screen.

^U<nRotation>^U
The angle of rotation about the origin. Positive integers rotate 
the figure counterclockwise. Negative integers rotate clockwise.

^U<nLineMode>^U
Raster line-drawing mode.

        Value   Meaning
        컴컴   컴컴컴
          0     REPLACE
          1     OR
          2     XOR

^U<nLineStyle>^U
Line style.

        Value           Meaning
        컴컴컴컴컴    컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0             Solid line.

        > 0             Broken line with an interval of nStyle
                        pixels between segments.

        + (n * 128)     For plotters only. The value n is the 
                        plotter's line style index, which may be
                        used to select various mark/space
                        patterns. Refer to your plotter
                        documentation for details.

                       ^UNote^U   If n = 0, the default style is
                        2 (even mark/space). Style 0, a single
                        dot, is not available.

^U<nLineColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value
returned by GetVideo(6). See the entry for SetRGBPal().


^BPositioning the Origin^B
The origin of the figure is a point of reference from which the
points that make up the figure are mapped. The origin is
established only when the figure is drawn. Thus you can draw
the same figure repeatedly, setting a new origin each time.

The coordinates that locate the origin are relative to the current
drawing position. At startup, the current drawing position is 0,
0, the lower left corner of the screen. It can be fixed at another
location by calling FixPos(), MoveXY(), or MoveVec().

Moving from the current drawing position, you can locate the
origin of the figure with either Cartesian or vector coordinates.

^UCartesian coordinates (X, Y)^U
Even though the current drawing position's absolute coordinates
might be different, in relative terms its position is 0, 0. The
location of the origin is mapped from this point.

If the origin of the figure is 50 screen units up and 50 to the
right of the current drawing position, then its coordinates
are 50, 50. If the origin is 50 screen units down and 50 to
the left of the current drawing position, then its coordinates
are -50, -50.

In other words, the origin's X coordinate is a relative
distance left or right of the current drawing position, and its
Y coordinate is a relative distance up or down from the
current drawing position.

^UVector coordinates (distance, angle)^U
The origin of the figure is located by a vector from the current
drawing position. If the origin of the figure is 50 screen units
from the current drawing position at an angle of 45 degrees, then
its vector coordinates are 50, 45.

^UNote^U   Angles are measured counterclockwise from three o'clock.

^BLocating Points in the Figure^B
The figure is made up of a series of connected points. These
points can also be located by either Cartesian or vector 
coordinates:

^UCartesian coordinates (X, Y)^U
The figure's origin is located at the relative coordinates 0, 0.
Each point's X coordinate is a relative distance, in screen units,
left or right of the origin of the figure. If it is left of the
origin, the X coordinate is negative. If it is right of the origin,
the X coordinate is positive. Similarly, each point's Y coordinate
is a relative distance up or down from the origin. If it is above
the origin, the Y coordinate is positive. If it is below the origin,
the Y coordinate is negative.

^UVector coordinates (distance, angle)^U
Each point in the figure is located by a vector from the point before
it. The first point is located by a vector from the origin of the
figure. The second point is located by a vector from the first point.
The third point is located by a vector from the second, and so on.

^BApplications^B
Because positioning is relative, you can store a sequence of
figures in dGE's internal array and then index into the bank of
figures by calling DataRange(). Using this technique you can 
define special symbols and characters, and you can also create 
simple animation.

^BExample^B
* Draw a shell
r = PolyCard(675, 500, 30, 1, 1)
INKEY(0)


* Draws a cardioid figure with nPetals in nClr.
* The figure is drawn repeatedly. Each time, the
* data is scaled larger and the figure is rotated.
FUNCTION PolyCard
   PARAMETERS nX0, nY0, nLength, nPetals, nClr
   PRIVATE nAngle, nRadius, nRotation

   * Fix the origin of the figure.
   r = FixPos(nX0, nY0)

   * Define the first point and store it.
   r = DataReset()
   r = DataStore(nLength * GetSin(0, 1),     ;
                 nLength * GetSin(0, 0), 1, 0)

   * Store the remaining points.
   FOR nAngle = 1 TO 360
      * Polar equation for a flower
      nRadius = nLength*(1 + GetSin(nPetals * nAngle, 0))

      * Convert polar to cartesian coordinates
      nX1 = nRadius * GetSin(nAngle, 1)
      nY1 = nRadius * GetSin(nAngle, 0)
      * Draw a line segment from the last point.
      r = DataStore(nX1, nY1, 0, 0)
   NEXT nAngle

   * Draw the figure several times, each time at
   * a different angle of rotation.
      FOR nRotation = 0 TO 420 STEP 5
        * Scale the data
        r = DataPc(nRotation + 10)
        * Draw the figure.
        r = PolyVec(0, 0, 0, nRotation, 0, 0, nClr)
      NEXT nRotation
RETURN 0

!seealso: "DataRange()" "FixPos()" "MoveXY()" "MoveVec()" "Polygon()" 
'------------------------------------------------------------------------------



!short: PrintFile()     Redirect printer or plotter output to a file
'------------------------------------------------------------------------------
^BSyntax^B
PrintFile( <nOffOn>, <cFile> )

^UNote^U   In the Clipper libraries this function has the name 
PrnFile() to avoid conflict with the Clipper Tools function 
PrintFile().

^BDescription^B
Defines a filename for printer or plotter output, and either 
enables or disables output to that file.

^BParameters^B
^U<nOffOn>^U
Enable or disable output to a file.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Disable
          1     Enable
        + 2     Append to existing file. (Default is to 
                overwrite.)

^U<cFile>^U
File spec as a string in the form:

"DRV:\PATH\FILE.EXT"

^BRemarks^B
If the file does not already exist, it will be created. If the file does 
already exist, it will be overwritten unless the append option
(nOffOn = 1 + 2) is specified.

Once you have enabled output to a file, the next call to a 
printing or plotting function will open it and write to it. The
printing or plotting function will close the file when output is 
complete.

When you are finished capturing output, cancel redirection 
by passing zero as the first argument and a null string as 
the second.

PrintFile(0, "")

The file can later be printed using the DOS command COPY /B 
for raster output or COPY for plotter, postscript, or PCL output.

^UNote^U   Do not use the DOS print spooler, PRINT, with 
raster images. These are binary files, and PRINT does not accept 
binary files.

^BExample^B
* Direct subsequent raster or plotter printing to a file.
r = PrintFile(1, "A:\PICTURE.PRN")
.
.
.

* Disable redirection to the file.
r = PrintFile(0, "")

!seealso: "PrnDev()" "PrintScrn()" "PrintPCL()" "PrintPS()" "PlotOn()" 
'------------------------------------------------------------------------------



!short: PrintPCL()      Print the screen to laser printer or file
'------------------------------------------------------------------------------
^BSyntax^B
PrintPCL( <nMode>, <nHOffset>, <nVOffset>, <nDensity> )

^BDescription^B
Prints the visible screen, sending the printer output either to a
laser printer via a parallel port or to a file. On completion, the
print file is closed.

^BParameters^B
^U<nMode>^U
Printer commands.

        Value   Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        +    1  Issue reset before printing.
        +    2  Issue form-feed after printing.
        +    4  Correct the aspect ratio.
        +    8  Output to a color HP PaintJet.
        +   16  Output to a color HP PaintJet, black and
                white reversed.
        +   32  Landscape mode. (Default is portrait.)

                ^UNote^U   The LaserJet's rotate command
                rotates text, not images. dGE's driver
                rasterizex the image, rotates it 90
                degrees, and prints it in portrait mode,
                although it appears to be in landscape
                mode.

        +  128  Output to Canon LBP-8.
        +  256  Output to a color HP 500C.
                This printer uses only eight colors: red,
                green, blue, cyan, magenta, yellow,
                black, and white. There are no high-
                intensity or dithered colors, as there
                are on the PaintJet.
        +  512  Output to a color HP500C, black and white
                reversed.
        + 1024  Output to a color HP550C or PaintJet
                XL300.
        + 2048  Output to a color HP550C or PaintJet
                XL300, black and white reversed.

^U<nHOffset>^U
Horizontal offset (margin) from the left of the page, in dots.

^U<nVOffset>^U
Vertical offset (margin) from the top of the page, in dots.

^U<nDensity>^U
Dot density. This will govern the size of the image on the page.

^BRemarks^B
Unlike with plotting, it is not possible to use this function
without an attached graphics screen, and the graphics must be
displayed before printing. The higher the screen resolution, the
sharper the printed image.

The printer driver conforms to the Hewlett-Packard Printer
Command Language (PCL) as implemented on the HP LaserJet.
When printing on a Canon printer, the driver uses the LIPS
printer language for raster output.

^UNote^U   The function VPOn() offers greater flexibility for 
PCL5 output to the LaserJet III and IV.

^UForm-feed^U
These printers will print an image only on receipt of a form-feed. 
You can use this fact to advantage. If, for example, you want to 
print more than one image on a page, just omit the trailing form 
feed between images, sending it only after the last image. You 
can also use this technique to superimpose text over an image.

^UMargins^U
Vertical and horizontal margins are specified in dots at 600 dots 
per inch for an HP LaserJet IV, 300 dots per inch for an HP 
LaserJet II or III, and 180 dots per inch for an HP PaintJet.

^UAspect Ratio^U
The aspect ratio of dGE's screen is 1:1.35. However, the density 
of dots on the screen is not uniform. Generally, the horizontal
density exceeds the vertical density. As a result, a direct dump 
of the raster image to a laser printer, which has a dot pattern of 
uniform density, will produce an elongated image. This 
distortion is most apparent with circles.

PrintPCL() can correct the aspect ratio by stretching the vertical 
axis to produce an image with an aspect ratio identical to the 
screen's. However, occasionally a line or row is doubled up, 
sometimes producing unpleasant moir patterns, particularly 
when printing dGE's fill patterns.

^UImage Size^U
You can change the image size by selecting the dot density. The
greater the density, the smaller the printed image. The LaserJet 
IV allows densities of 300 or 600; the LaserJet III, 75, 100, 150, 
and 300; the PaintJet, 90 or 180 dots per inch. (These densities 
are set by the manufacturer.)

^BExample^B
* Print the current screen image on a LaserJet.
r = PrintPCL(  2, ; && Trailing form-feed
             100, ; && Left margin 100 dots
             200, ; && Top margin 200 dots
             150)   && Print density 150 dpi

!seealso: "PrintFile()" "PrnDev()" "VPOn()" 
'------------------------------------------------------------------------------



!short: PrintPS()       Print the screen to Postscript printer or file
'------------------------------------------------------------------------------
^BSyntax^B
PrintPs( <nMode>, <nHOffset>, <nVOffset>, <nHScale>, <nVScale>, <nDensity> )

^BDescription^B
Prints the visible screen, sending the printer output either to a
Postscript printer via a parallel port or to a file. On completion, 
the print file is closed.

^UNote^U   Except for capturing a screen dump or for printing a 
PCX image, this function has been superseded by VPOn(), which 
offers greater flexibility for Postscript printing.

^BParameters^B
^U<nMode>^U
Printer commands.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Print in portrait mode.

        + 1     Print in landscape mode.

        + 2     Print black and white reversed.

^U<nHOffset>^U
Horizontal offset (margin) from the left of the page, in points.

^U<nVOffset>^U
Vertical offset (margin) from the bottom of the page, in points.

^U<nHScale>^U
Horizontal scaling factor, as a percentage.

^U<nVScale>^U
Vertical scaling factor, as a percentage.

^U<nDensity>^U
Dot density, in dots per inch.

^BRemarks^B
Unlike with plotting, it is not possible to use this function 
without an attached graphics screen, and the graphics must be
displayed before printing. The higher the screen resolution, the 
sharper the printed image.

^UMargins^U
Vertical and horizontal margins are measured from the bottom 
of the page and from the left. This follows Postscript convention. 
In landscape mode the locating offsets are still relative to the 
bottom and left of the page as viewed in portrait mode. Offsets 
are in units of points ( 1/72 inch).

^UAspect Ratio^U
The aspect ratio of dGE's screen is 1:1.35. However, the density 
of dots on the screen is not uniform. Generally, the horizontal 
density exceeds the vertical density. As a result, a direct dump 
of the raster image to a laser printer, which has a dot pattern of 
uniform density, will produce an elongated image. This 
distortion is most apparent with circles.

^UScaling^U
nHScale and nVScale determine horizontal and vertical scaling.

   ^UNote^U   nHScale and nVScale reverse meaning in landscape mode.

You can use these arguments to alter the aspect ratio of the
printed image and also its size. If both arguments are 100%, the
image is not scaled in either direction. This does not mean that
the printed image will be of the same size and shape as it
appears on the screen. A scaling factor of 100% simply means
that the image's dimensions in screen pixels are translated
directly to printer dots, one for one.

^UDensity^U
The dot density on the printed page is specified by nDensity.
Typically this is 300 DPI.

^BExample^B
* Print the current screen image on a Postscript printer.
r = PrintPS(  0, ; && Portrait mode
             50, ; && Left margin 50 pt
             75, ; && Bottom margin 75 pt
            100, ; && Horizontal scale 100%
            133, ; && Vertical scale 133%
            300)   && Density 300 dpi

!seealso: "PrnDev()" "PrintFile()" "VPOn()" 
'------------------------------------------------------------------------------



!short: PrintScrn()     Print screen to a dot-matrix printer or file
'------------------------------------------------------------------------------
^BSyntax^B
PrintScrn()

^BDescription^B
Prints the visible screen, sending the printer output to a dot-
matrix or Canon BubbleJet printer via a parallel port or to a file.
On completion, the print file is closed.

A user can interrupt printing at any time by pressing CTRL-C.
This will also interrupt program execution.

Unlike with plotting, it is not possible to use this function
without an attached graphics screen, and the graphics must be
displayed before printing. The higher the screen resolution, the
sharper the printed image.

This function sends printed output with Epson-style control
codes. The printer driver can be configured for a particular
printer by a call to LoadMPrn().

^UColor^U
Epson dot-matrix color printers use a ribbon with picturesque
blue, red, and yellow ink, a selection that offers neither the
additive nor subtractive primary colors. Our solution to the
problem is a pragmatic compromise between speed and veracity.

^BExample^B
* Set the default device, configure for a dot-matrix
* printer, and print the current image.
r = PrnDev(0, ;   && Parallel port
           1)     && LPT1
r = LoadMPrn(1, ; && Portrait
  "..\UTILS\MPRN.DAT EPSON SQ,LQ 24-PIN") && Config
r = PrintScrn()   && Print the screen

!seealso: "LoadMPrn()" "PrintFile()" "PrnDev()" 
'------------------------------------------------------------------------------



!short: PrnDev()        Set the default printer/plotter port 
'------------------------------------------------------------------------------
^BSyntax^B
PrnDev( <nDevice>, <nChannel> )

^BDescription^B
Sets the default output device to either a parallel or serial port. 
Output from all dGE printing and plotting functions will be 
directed to this port unless it is explicitly directed to a file by a 
call to PrintFile().

^BParameters^B
^U<nDevice>^U
Type of printer port.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴
          0     Parallel port (LPT).
          1     Serial port (COM)

^U<nChannel>^U
Port number.

        Value   Meaning
        컴컴   컴컴컴컴컴
          1     LPT1, COM1
          2     LPT2, COM2
          3     LPT3, COM3

^BRemarks^B
Timeout is disabled for serial output. Characters are sent only 
when DSR and CTS are high, which should be controlled by the 
printer as its buffer empties. Xon/Xoff is not supported in dGE.

Set the serial port parameters by calling SetPrn().

^BExample^B
* Set the default printer port to LPT1
r = PrnDev(0, ; && Parallel port
           1)   && Port number

!seealso: "PlotOn()" "PrintFile()" "PrintPCL()" "PrintPS()" "SetPrn()" 
'------------------------------------------------------------------------------



!short: PSFont()        Select a font for Postscript printing
'------------------------------------------------------------------------------
^BSyntax^B
PSFont( <cFace> )

^BDescription^B
Selects an alternate name for the font face used for Postscript 
printing by VPOn().

^BParameter^B
^U<cFace>^U
Font face name.

^BRemarks^B
By default, VPOn() takes the face name from the header of the 
dGE screen font file currently loaded. System screen fonts are 
rendered as Courier Bold. STX and PTX screen fonts are 
rendered according to a face name indicated in the first three 
characters of the font file name. RMN indicates Times Roman, 
SWI indicates Helvetica, and so on.

This function enables you to override the default behavior, 
taking better advantage of the fonts resident in your printer. 
Just specify the face name of a font that you know is resident, 
taking care to spell the name exactly as it is spelled on the type 
cartridge or in the printer's documentation. Failure to specify a 
valid name has unpredictable results.

^UNote^U   An alternative technique is to use the GFONT editor 
to change the face name in the header of dGE's font file itself. 
Then dGE will automatically select your font as the default.

This function does not redefine the size of the font. That is 
always taken from the dimensions of the dGE screen font. If you 
want to change the font size, you will need to load a screen font 
of the appropriate size.

However, fonts of different faces may produce strings of varying 
length on a Postscript printer even though the font metrics 
remain the same. This is a characteristic of variable-pitch fonts.

dGE cannot match the string length on screen exactly when 
rendering the string on a printed page. This difficulty is 
unavoidable. dGE selects fonts to match height, and thus it 
cannot also match length.

^BExample^B
* No matter what font is displayed on screen,
* print Times Roman.
r = PSFont("Times-Roman")

!seealso: "LoadCSet()" "VPOn()" 
'------------------------------------------------------------------------------



!short: ResetPal()      Restore the default color palatte
'------------------------------------------------------------------------------
^BSyntax^B
ResetPal()

^BDescription^B
Restores the default color palatte after you have changed it by
calling SetRGBPal() or SetRGBDAC(), or after it has been
changed by an image that you have displayed.

^UNote^U   You do not need to call this function before calling
           SetText() and exiting graphics mode. SetText() also
           restores the default palette.

^BExample^B
* Display an image, clear the screen, and then 
* restore the default color palette.
r = PicRead(0, 0, 0, "..\PCX\BIRD16.PCX")
r = INKEY(0)
r = ClrScreen()
r = ResetPal()

!seealso: "PicRead()" "SetRGBPal()" "SetRGBDAC()" 
'------------------------------------------------------------------------------



!short: SayString()     Draw text horizontally or vertically
'------------------------------------------------------------------------------
^BSyntax^B
SayString( <nX>, <nY>, <nCSet>, <nMode>, <nColor>, <cString> )

^BDescription^B
Draws a text string either horizontally or vertically using either 
one of the internal system fonts or a font loaded by calling 
LoadCSet().

^BParameters^B
^U<nX>^U
X coordinate for the text.

^U<nY>^U
Y coordinate for the text.

dGE's coordinate system is described under the entry for 
SetVer().

^U<nCSet>^U
Character set and raster options.

        Value   Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 1  Character set number. If no font has been
                loaded with LoadCSet(), 0 selects 
                standard, and 1 selects small. If a font 
                has been loaded, pass 0 as the argument.
        +  4    REPLACE
        +  8    OR
        + 16    XOR
        + 64    INVERSE

^U<nMode>^U
Alignment. The additive values (preceded by +) apply only to 
horizontal text.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
            0   Horizontal text

            1   Vertical text

        +   4   One row down from previous string. In
                this case, nY is ignored. Equivalent to
                xBase "?"

        +   8   Center on nX, nY.

        +  16   nX, nY locate the end point of the text.

        +  32   Concatenate with previous string. In this
                case, nX is ignored. Equivalent to xBase
                "??"

        +  64   nY locates the center line of the
                characters.

        + 128   nY locates the top line of the
                characters.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value
returned by GetVideo(6). See the entry for SetRGBPal().

^U<cString>^U
Text string.

^BExample^B
* Display a string at the center of the screen
r = SayString(675, ; && X coordinate
              500, ; && Y coordinate
                4, ; && Set 0, REPLACE
                8, ; && Horizontal, center
    "Hello, world!") && Text
r = INKEY(0)
r = ClrString()      && Clear the string from the screen.

!seealso: "ClrString()" "LoadCSet()" "VecString()" 
'------------------------------------------------------------------------------



!short: SetArc()        Define the geometry for an arc or ellipse 
'------------------------------------------------------------------------------
^BSyntax^B
SetArc( <nXLeft>, <nYBottom>, <nXRight>, <nYTop>, 
        <nXStart>, <nYStart>, <nXStop>, <nYStop> )

^BDescription^B
Establishes the geometry for an arc or ellipse. Call DrawArc() to 
draw the figure.

^BParameters^B
^U<nXLeft>^U
X coordinate for the lower left corner of the defining rectangle.

^U<nYBottom>^U
Y coordinate for the lower left corner of the defining rectangle.

^U<nXRight>^U
X coordinate for the upper right corner of the defining rectangle.

^U<nYTop>^U
Y coordinate for the upper right corner of the defining rectangle.

^U<nXStart>^U
X coordinate for the start of the curve.

^U<nYStart>^U
Y coordinate for the start of the curve.

^U<nXStop>^U
X coordinate for the end of the curve.

^U<nYStop>^U
Y coordinate for the end of the curve.

nXStart, nYStart and nXStop ,nYStop describe locations along the 
perimeter of the defining rectangle. Arcs are drawn 
counterclockwise from the start position to the stop position.

!seealso: "DrawArc()" 
'------------------------------------------------------------------------------



!short: SetBkFill()     Set the background color for patterned fills
'------------------------------------------------------------------------------
^BSyntax^B
SetBkFill( <nColor> )

^BDescription^B
Sets the background color for subsequent patterned fills.

^BParameter^B
^U<nColor>^U
Background color for fill patterns, 0 to (nColors - 1) where 
nColors is the value returned by GetVideo(6). See the entry for 
SetRGBPal().

      ^UNote^U   In a two-color graphics mode you have only one
                 choice: the color that you did not use for the
                 foreground of the pattern.

^BRemarks^B
Many dGE graphing functions and all rectangle and circle 
drawing functions accept a pattern number for filling interior 
space. By default, a patterned fill clears the space and then
draws the pattern. The pattern itself is drawn in the current 
foreground color, usually set by a parameter for the drawing 
function. The gaps between the lines or dots of the pattern are 
filled with the pattern background color, set by calling 
SetBkFill().

^UNote^U   dGE's graphing and drawing functions offer the 
option to fill transparently. In this case calling SetBkFill() has no
effect on the pattern.

The default pattern background color is color zero and it is reset 
to color zero whenever you call SetGMode() or ClrScreen().

^BExample^B
* Display patterns 0 through 19 with foreground in white.
* Cycle through background colors 0 through 14.

nY = 500
FOR i = 0 to 14
   r = SetBkFill(i)

   FOR j = 0 to 9
      nX = 125 + (j * 110)
      nPatt = j

      r = BoxFill(nX, nY, 110, 110, nPatt, 15)
      r = BoxFill(nX, nY-110, 110, 110, nPatt + 10, 15)
   NEXT j

   r = SayString(125, 300, 0, 0, 15, ;
                 "Background: " + RIGHT(STR(i), 2))
   r = INKEY(0)
NEXT i

!seealso: "BoxFill()" "SetRGBPal()" 
'------------------------------------------------------------------------------



!short: SetDelim()      Set delimiting character on editing line
'------------------------------------------------------------------------------
^BSyntax^B
SetDelim( <nASCII> )

^BDescription^B
Defines the delimiting character displayed at the beginning and 
end of an editing line. The editing line itself is displayed by 
calling EdString().

^BParameter^B
^U<nASCII>^U
ASCII value for the delimiting character. If the value is zero, no 
delimiter will be displayed.

^BExample^B
r = SetDelim(0) && No delimiting character.

!seealso: "EdString()" 
'------------------------------------------------------------------------------



!short: SetGMode()      Select a graphics mode
'------------------------------------------------------------------------------
^BSyntax^B
SetGMode( <nMode> )

^BDescription^B
Selects the graphics mode. The mode selected will not take effect
until you call SetHiRes().

^UNote^U   You can switch from one graphics mode to another
by calling SetGMode() to select the mode and then SetHiRes() to
enter the mode.

^BParameters^B
^U<nMode>^U
Graphics mode. If you prefer using manifest constants, see the
definitions in DGEDEFS.CH.

        컴  Mode 컴
        Dec     Hex     Resolution    Colors   Adapter  Driver
        컴     컴     컴컴컴컴컴    컴컴컴   컴컴컴  컴컴컴
          6       6      640 x 200        2     CGA     DGE2
          7       7      720 x 348        2     Herc    DGE2
         16      10      640 x 350       16     EGA     DGE16
         17      11      640 x 480        2     MCGA    DGE2
         18      12      640 x 480       16     VGA     DGE16
         19      13      320 x 200      256     VGA     DGE256
        257     101      640 x 480      256     SVGA    DGE256
        258     102      800 x 600       16     SVGA    DGE16
        259     103      800 x 600      256     SVGA    DGE256
        260     104     1024 x 768       16     SVGA    DGE16
        261     105     1024 x 768      256     SVGA    DGE256

^BRemarks^B
Modes less than 256 correspond to the BIOS modes. Modes 
greater than 256 correspond to the industry-standard Video 
Electronics Standards Association (VESA) modes. In order to use 
VESA modes, your SVGA card must support the VESA BIOS. 
Many vendors supply a small TSR that patches the BIOS. In 
addition, TSRs for most cards are also available from our BBS.

^BExample^B
*::::::::::::::::::::::::::::::::::::::::::::::::::::
*  TESTMODE.PRG
*  Select the graphics mode with (1) the highest
*  available resolution and (2) the greatest number
*  of colors. Reject anything lower than EGA.
*::::::::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN
   PRIVATE nMode

   nMode = BestMode()
   IF nMode  = 0
      ? "Sorry. This example requires EGA or higher."
      RETURN
   ENDIF

   SET SCOREBOARD OFF
   SET CURSOR OFF
   r = SetGMode(nMode)
   r = SetHiRes(0)

   * Do something graphic.

   r = SetText()
   RETURN
*:::::::::::::::::: END OF MAIN :::::::::::::::::::::

FUNCTION BestMode
   DECLARE aModes[7]

   aModes[1]  = 261   && 1024x768x256
   aModes[2]  = 260   && 1024x768x16
   aModes[3]  = 259   && 800x600x256
   aModes[4]  = 258   && 800x600x16
   aModes[5]  = 257   && 640x480x256
   aModes[6]  = 18    && 640x480x16
   aModes[7]  = 16    && 640x350x16

   * Fall through until we find a mode that works.
   nMode = 0

   FOR i = 1 TO 7
      IF GetGMode(aModes[i]) <> 0
         nMode = aModes[i]
         RETURN nMode
      ENDIF
   NEXT

RETURN nMode

!seealso: "GetGMode()" "GetVideo()" 
'------------------------------------------------------------------------------



!short: SetHiRes()      Enter a graphics mode 
'------------------------------------------------------------------------------
^BSyntax^B
SetHiRes( <nPage> )

^BDescription^B
Sets the display to high-resolution graphics mode. You must 
first designate a graphics mode by calling SetGMode().

As a result of changing the video mode, the function will also 
clear the screen, reset the active clipping window to full screen, 
remove any defined mouse hot regions, reset the color palette to 
the default, and release any saved images from memory.

^BParameter^B
^U<nPage>^U
Paging mode. For all but Hercules adapters, pass zero as the
argument.

        Value     Meaning
        컴컴컴    컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
           0      Use for any adapter.

        1 to 15   Alternative screen page. Available only
                  with some versions of Hercules adapters.

        + 64      Do not clear the screen on execution.
                  This feature is available only for
                  Hercules monochrome.

^BRemarks^B
You must call SetGMode() to select a graphics mode before calling
SetHiRes(). If you do not select a graphics mode before calling this
function, dGE will try to set mode 18, the standard mode for VGA. If
it cannot find the driver DGE16, it will load a null driver and you 
will not see output to the screen.

Clipper and FoxPro  To avoid undesirable screen effects, SET 
CURSOR OFF before entering graphics mode.

Entering a graphics mode not only clears the screen but also 
often causes the screen to blink briefly as a result of hardware 
reset. This combination is displeasing to some. You can make 
the transition somewhat more gracefully if you clear the screen 
first.

FoxPro  If a mouse is present in the system, FoxPro will turn the 
mouse cursor on whenever you call SetHiRes(0). You may not see 
the cursor until you move it, but it will be there. Since the mouse 
cursor slows drawing, the best procedure is to turn the cursor off 
immediately after entering graphics mode. The calls to do this are:
r = SetHiRes(0)
r = MReset()
r = MCurOff()
Turn the cursor back on whenever it is appropriate for your 
application. To do this, just call MCurOn().

^BExample^B
CLEAR SCREEN
SET CURSOR OFF
r = SetGMode(18)  && Select 640x480x16
r = SetHiRes(0)   && Works for any adapter
.
.
.
r = ClrScreen()   && Clear the screen
r = SetText()     && Restore text mode
r = SetGMode(260) && Select 1024x768x16
r = SetHiRes(0)   && Enter the new graphics mode
.
.
.
r = SetText()
QUIT

!seealso: "SetGMode()" "SetText()" 
'------------------------------------------------------------------------------



!short: SetPix()        Set the color of a pixel
'------------------------------------------------------------------------------
^BSyntax^B
SetPix( <nX>, <nY>, <nMode>, <nColor> )

^BDescription^B
Sets a pixel to the color indexed by nColor.

^BParameters^B
^U<nX>^U
X coordinate for the pixel.

^U<nY>^U
Y coordinate for the pixel.

dGE's coordinate system is described under the entry for 
SetVer().

^U<nMode>^U
Raster drawing mode.

        Value   Meaning
        컴컴   컴컴컴
          0     REPLACE
          1     OR
          2     XOR
          3     NOT
          4     AND

^U<nColor>^U
Color index number, 0 to (nColors - 1) where nColors is the value
returned by GetVideo(6). See the entry for SetRGBPal().

^BExample^B
* Compare REPLACE, OR, XOR.
nY = 600
r = SayString(30, nY, 0, 0, 15,"REPLACE")
r = SayString(30, nY - 100, 0, 0, 15,"OR")
r = SayString(30, nY - 200, 0, 0, 15,"XOR")

DO WHILE INKEY() != 27
   * Step backward through the color indexes
   FOR nColor = 15 TO 0 STEP -1
      * Set a line of pixels in each of three modes

      FOR nX = 150 TO 1250
         r = SetPix(nX, nY, 0, nColor)
         r = SetPix(nX, nY - 100, 1, nColor)
         r = SetPix(nX, nY - 200, 2, nColor)
      NEXT nX

      * Loop for a moment
      FOR nWaste = 1 TO 1000
      NEXT nWaste
   NEXT nColor
ENDDO

!seealso: "GetPix()" "SetRGBPal()" "SetRGBDAC()" 
'------------------------------------------------------------------------------



!short: SetPrn()        Configure a serial port for output
'------------------------------------------------------------------------------
^BSyntax^B
SetPrn( <nPort>, <nBaud>, <nParity>, <nBits>, <nStop> )

^BDescription^B
Configures a serial port for output.

^BParameters^B
^U<nPort>^U
Number of the port.

        Value   Meaning
        컴컴   컴컴컴
          0     COM1
          1     COM2

^U<nBaud>^U
Baud rate.

        Value   Meaning
        컴컴   컴컴컴
          0      110
          1      150
          2      300
          3      600
          4     1200
          5     2400
          6     4800
          7     9600

^U<nParity>^U
Parity.

        Value   Meaning
        컴컴   컴컴컴
          0     None
          1     Odd
          2     Even

^U<nBits>^U
Number of bits.

        Value   Meaning
        컴컴   컴컴컴컴컴
          0     7 bit data
          1     8 bit data

^U<nStop>^U
Stop bits.

        Value   Meaning
        컴컴   컴컴컴
          0     1 stop
          1     2 stops

^BRemarks^B
You can direct output from any of the printing and plotting 
functions to a serial port by setting the default printer device
with PrnDev().

^BExample^B
* Configure COM1 for 9600 baud, no parity, 8 bits, 1 stop
r = SetPrn(0, 7, 0, 1, 0)
* Set COM1 as the default
r = PrnDev(1, 1)

!seealso: "PrnDev()" "PlotOn()" 
'------------------------------------------------------------------------------



!short: SetRGBDAC()     Store a color value in a DAC register
'------------------------------------------------------------------------------
^BSyntax^B
SetRGBDAC( <nRegister>, <nRed>, <nGreen>, <nBlue> )

^BDescription^B
Stores a color value in the form of an RGB triplet in one of the 
memory registers of the video adapter.

^BParameters^B
^U<nRegister>^U
Number of the register to set. With VGA, registers are numbered 
from 0 to 63. With SVGA, from 0 to 255.

^U<nRed>^U
Level of red, 0 to 255.

^U<nGreen>^U
Level of green, 0 to 255.

^U<nBlue>^U
Level of blue, 0 to 255.

^BRemarks^B
The color values used by a PC's graphics adapter are stored in 
memory registers accessed by a special circuit, called a digital-
to-analog converter (DAC). The DAC translates binary numbers 
to voltages before passing the signals on to video amplifiers and
ultimately to the display.

There are actually three sets of DAC registers, one for red, one 
for green, and one for blue. All three are indexed by a single 
pointer; with this function the indexing is done by nRegister. 

Although the function SetRGBDAC() accepts color values in the 
range 0 to 255, in reality only SVGA color values are eight-bit 
binary (0 to 255 decimal) numbers. VGA color values are 
actually six-bit binary (0 to 63), but for ease of use this function 
accepts eight bit values regardless of adapter or mode, and 
performs the necessary translation internally.

If you are working in a VGA mode, you must first assign a color 
value for the register you wish to reprogram, and then call 
SetRGBPal() to assign the register to a color index number. For 
example, to reprogram register 36 to 255, 0, 0 and then assign 
that register to color index number 4, your code would be:

r = SetRGBDAC(36, 255, 0, 0)
r = SetRGBPal(4, 36)

You can skip the second step by reprogramming register 4 
directly. However, keep in mind that any object currently 
displayed in color number 4 will instantly change color.

SVGA, in contrast, does not use VGA's method of indirection 
through a table. Thus the operation is always done in one step:

r = SetRGBDAC(36, 255, 0, 0)

With either VGA or SVGA, you can return to the system default 
by calling ResetPal().

If the system default does not meet your needs, you can easily 
set the palette of your choice by declaring three arrays, one for 
red, another for green, and a third for blue. Then initialize and 
later restore your custom palette with code something like this:

nColors = GetVideo(6) && Max colors for current mode
FOR i = 0 to nColors - 1
   SetRGBDAC(i, aRed[i], aGreen[i], aBlue[i])
NEXT i

^UMixing a Custom Palette^U
One method to select a mix of the red, green, and blue 
components of video color is to rely on trial and error. Try 
something and, if you like it, use it. Or you can be a bit more 
methodical and write some code to run through all possible 
combinations while you watch and take notes. This may take 
some time. On a VGA system you'll need to compare 262,144 
color combinations; on an SVGA system, 16,777,216.

You can narrow the search by applying color theory to the 
problem. One of the more useful color models describes color in 
terms of hue, saturation, and luminosity.

Hue is the dominant wavelength of light, so the range of hues is
the same as in a rainbow. An RGB triplet of 255, 0, 255 mixes 
equal parts of red and blue, producing the hue we call magenta.

Saturation is the amplitude or level of color. Fully saturated or 
"pure" red results from an RGB triplet of 255, 0, 0.

Luminosity is often used interchangeably with shade, lightness, 
and darkness. They all mean the same thing: the amount of 
white in a color. A red hue of medium luminosity results from 
an RGB triplet of 255, 127, 127.

The triplet 255, 127, 127 is equivalent to adding medium white, 
127, 127, 127, to medium red, 128, 0, 0. Note that as luminosity 
increases, saturation must decrease, for the actual level of 
saturation is only that which is above the level of luminosity. In 
this case, the white base line is 127. The saturation of red is 
thus 255 - 127 = 128.

As another example, let's consider the RGB triplet 255, 50, 100. 
In this case the white level is 50, and so the levels of red and
blue above that base line are 205 and 50. This suggests that a 
darker shade of the same hue would be produced by the triplet 
205, 0, 50, which in fact it does. Both triplets produce magenta 
with a strong bias toward red.

As the luminosity of a hue increases, the saturation decreases 
and the color appears more pastel. As the luminosity decreases, 
the saturation increases and the color appears richer, a more 
intense version of the hue.

Thus one way to narrow your search for an ideal palette is to 
begin by defining colors with zero luminosity. That is, start by 
mixing only two primaries, leaving one element of the RGB 
triplet at zero. To this base palette add varying amounts of white 
until you have a set of colors that pleases you.

^BExample^B
* Manipulate the value for register 15 to
* cause text to fade in and then out.
r = ClrScreen()

* Load a large font.
r = LoadCSet(0, "..\FONTS\SWI4937.PTX")

* Initialize register 15 as black.
r = SetRGBDAC(15, 0, 0, 0)
* Write the text to the screen.
r = SayString(570, 500, 0, 0, 15, "dGE")

* Gradually increase the luminosity.
FOR i = 0 to 255 STEP 5

   r =SetRGBDAC(15, i, i, i)
   * Slight pause
   r = INKEY(.1)
NEXT i

* Now decrease the luminosity.
FOR i = 255 to 0 STEP -5
   r =SetRGBDAC(15, i, i, i)
   * Slight pause
   r = INKEY(.1)
NEXT i

!seealso: "GetVideo()" "ResetPal()" "SetRGBPal()" "SetGMode()" 
'------------------------------------------------------------------------------



!short: SetRGBPal()     Set one of the 16 EGA/VGA screen colors
'------------------------------------------------------------------------------
^BSyntax^B
SetRGBPal( <nColor>, <nValue> )

^BDescription^B
Resets the value of one of the 16 colors that can be shown 
simultaneously on screen in EGA or VGA graphics modes.

^BParameters^B
^U<nColor>^U
Color index number, 0 through 15.

^U<nValue>^U
For EGA, a color value in the range 0 through 63.

For VGA, the number of a DAC register, 0 through 63.

^BRemarks^B
^UEGA Color^U
The Enhanced Graphics Adapter (EGA) uses a palette 
(sometimes called a lookup table) that has 16 memory registers. 
The number of a register is called a color index and the value 
held in the register is called a color value. Color values are six-
bit binary codes that can be represented in the form rgbRGB, 
where the lowercase letters rgb stand for secondary red, green, 
and blue signals, and the uppercase letters RGB stand for 
primary red, green, and blue signals. The secondary signals are 
1/3 intensity (dimmer) and the primary signals are 2/3 intensity
(brighter). Each of the letters in rgbRGB represents a bit that 
can be either on or off. Because there are 2^6 possible
combinations of bit settings, the entire six-bit code can produce 
64 colors (2 x 2 x 2 x 2 x 2 x 2 = 64).

Listed below are the default color values stored in each of the 16
memory registers of the EGA palette. The binary representation
of these values is helpful because it shows how bits correspond
to letters in rgbRGB. The octal representation is actually more
useful because its first digit shows the 1/3 intensity rgb signal
and its second digit shows the 2/3 intensity RGB signal. But the
last set of numbers, the decimals, are especially important
because they are the numbers you pass as nValue to the
function SetRGBPal().

      컴Index컴                 컴 Actual Color Value 컴
      (nValue)   Color          Binary    Octal  Decimal
      컴컴컴컴   컴컴          컴컴컴   컴컴   컴컴컴
         0       Black          000 000    00       0
         1       Blue           000 001    01       1
         2       Green          000 010    02       2
         3       Cyan           000 011    03       3
         4       Red            000 100    04       4
         5       Magenta        000 101    05       5
         6       Brown          000 110    06       6
         7       White          000 111    07       7
         8       Dark gray      111 000    70      56
         9       Light blue     111 001    71      57
        10       Light green    111 010    72      58
        11       Light cyan     111 011    73      59
        12       Light red      111 100    74      60
        13       Light magenta  111 101    75      61
        14       Yellow         111 110    76      62
        15       Bright white   111 111    77      63

You may notice by the numbers in this table that the first eight
color indexes map to dark shades of color, and the next eight
map to light shades of the same colors. Dark shades are
produced by assigning black (000) to the 1/3 intensity bits, and
light shades are produced by assigning white (111) to the 1/3
intensity bits.

You might prefer another scheme. For example, suppose you
want a red that is redder than the red available in the default
color mapping. You could get the color you want by remapping,
say, color index 12 from light red to pure red. In octal, this value
is 44; in decimal, 36. Your call to SetRGBPal() would then be:

r = SetRGBPal(12, 36)

To return to the default, simply call:

r = SetRGBPal(12, 12)

Or, if you have remapped several color indexes, reset the default
mapping by calling ResetPal().

^UVGA Color^U
Like the EGA, the Video Graphics Array (VGA) adapter displays
only 16 colors simultaneously. Like the EGA, the VGA also uses
a palette system to keep track of the actual values for each of
those 16 colors. But here the two adapters part company.

In the EGA, each of the 16 screen color numbers is an index to
an array, and each element of the array contains a single six-bit
number representing one of 64 color values. In the VGA, each
element of the array contains another index number, in this
case a pointer to one of 64 memory registers. Each register, in
turn, stores not one but three six-bit color values, allowing 64
levels of red, 64 levels of green, and 64 levels of blue. Thus each
of the 16 entries in the VGA screen palette references an actual
color value that can range from 0 through 26 x 26 x 26 (64 x 64
x 64), offering a choice from among 262,144 colors.

The default color values in the 64 VGA registers correspond to
the values produced in the EGA's six-bit numbering scheme.
Thus if you are willing to limit yourself to the EGA color
selection, you can proceed just as if you were working in EGA.
Compute the color value you want as described above, and call
SetRGBPal() to assign the new value to a palette index number.
Although you will not actually be assigning a color value, but
instead a pointer to a register, the result will be the same as it is
in an EGA graphics mode.

However, you can reprogram the memory registers, if you like,
so that the values stored there are not the defaults but are color
values of your own choosing. To do this, you will need to call the
function SetRGBDAC() and then the function SetRGBPal(). For
details, see the entry for SetRGBDAC().

^USVGA Color^U
SuperVGA adapters can display 256 colors on screen
simultaneously. The color values are stored in 256 memory
registers, each of which holds three eight-bit numbers, allowing
256 levels of red, 256 levels of green, and 256 levels of blue, for
a total of 16,777,216 possible color values. The values held in
the registers can be set directly by calling SetRGBDAC(). If you
are working in an SVGA mode, you do not need to call
SetRGBPal().

^BExample^B
* Cycle through 64 registers, pausing to display
* the palette of screen colors available with each set.

r = SetGMode(18) && VGA 640x480x16
r = SetHiRes(0)  && Graphics mode

nX = 200         && Bottom left of first box
nY = 880
nWid = 60        && Width of a box
nHt = 55         && Height of a box

* Increment in sets of 16.
FOR nSet = 0 to 3
   nInc = nSet * 16
   * Draw a line of boxes and fill each with a color.
   FOR nIndex = 1 to 15
      * Set the palette
      r = SetRGBPal(nIndex, nIndex + nInc)

      * Display the register number.
      r = SayString(nX + (nIndex * nWid),      ;
                    nY + nHt + 8,              ;
                    0, 0, 15,                  ;
                    RIGHT(STR(nIndex + nInc), 2))
      r = BoxFill(nX + (nIndex * nWid), nY, ;
                  nWid, nHt, 32, nIndex)
   NEXT nIndex

   * Pause
   INKEY(0)
NEXT nSet

r = SetText() && Text mode

!seealso: "ResetPal()" "SetRGBDAC()" 
'------------------------------------------------------------------------------



!short: SetText()       Return to text mode
'------------------------------------------------------------------------------
^BSyntax^B
SetText()

^BDescription^B
Resets the display to whatever video mode it was in before you
called SetHiRes(). In most applications, this will have the effect
of resetting the display to text mode. Clears the screen and
resets the color palette to the system default.

Call this function every time you change video modes or
exit a dGE graphics module, and also before quitting your
program. If you fail to call SetText() prior to quitting
your program, you will be left in graphics mode at the DOS
prompt. In this event, issue the DOS MODE command to set
the screen to text mode:

MODE CO80

^UNote^U   FoxPro programmers should also SET MOUSE ON
when exiting a dGE graphics module. dGE turns the mouse
cursor off whenever you call SetHiRes().

^BExample^B
r = SetText()

!seealso: "SetHiRes()" "MCurOff()" 
'------------------------------------------------------------------------------



!short: SetVer()        Select a coordinate mapping system
'------------------------------------------------------------------------------
^BSyntax^B
SetVer( <nMap> )

^BDescription^B
Selects a coordinate mapping system.

^BParameter^B
^U<nMap>^U
Coordinate system code.

         Value  Meaning
         컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
           1    dGE version 1. Coordinate mapping is 225
                x 150. Origin (0, 0) is at the bottom 
                left.

           2    dGE version 2 or later. Coordinate 
                mapping is 1350 x 1000. Origin (0, 0) is 
                at the bottom left.

          64    Use native device units. Origin (0, 0) is 
                at the top left.

^BRemarks^B
Ordinarily there should be no need to call this function. By 
default, dGE measures its coordinate space in screen units, 
starting from an origin (0, 0) at the bottom left corner of the 
video display. 

X coordinates range horizontally from zero at the extreme left to 
1350 at the far right. Y coordinates range vertically from zero at 
the bottom of the screen to 1000 at the top. X, Y coordinates for 
the center of the screen are 675, 500.

If you are one of the few who still have code written for dGE 
version 1, you can call SetVer(1) to set the coordinate map to 
225 by 150. To return to the default mapping, call SetVer(2).

Apart from backward compatibility, there is one other reason for 
this function's existence. You can override the default mapping
if you prefer a coordinate system based on device-dependent 
units, pixels, rather than device-independent screen units.

Pixel-based coordinate mapping is useful in calculations for 
placement of icons and other bitmap images.

To select coordinates based on pixels, first call SetVer(64), and 
then call SetGMode() to select the graphics mode. The new 
coordinate map is not effective until after the graphics mode is 
set by a call to SetHiRes(). The origin will then be at the top left 
of the screen.

Once you have called SetVer(64), the dimensions of the 
coordinate space will change with each change in graphics 
mode. To return to the default mapping, call SetVer(2).

^BExample^B
r = SetVer(64)         && Device-dependent coordinates
r = SetGMode(260)      && Select a graphics mode
r = SetHiRes(0)
nXPixels = GetVideo(4) && Result: 1024
nYPixels = GetVideo(5) && Result:  768
.
.                      && Do hard stuff
.
r = SetVer(2)          && Default 1350 x 1000
r = SetHiRes(0)

!seealso: "GetVideo()" "SetGMode()" "SetHiRes()" 
'------------------------------------------------------------------------------



!short: SetVideo()      Suppress graphic output to the video display
'------------------------------------------------------------------------------
^BSyntax^B
SetVideo( <nOnOff> )

^BDescription^B
Suppresses or restores graphic output to the video display for a 
short time.

^BParameter^B
^U<nOnOff>^U
Desired state, on or off, of video drawing.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴
          0     Suppress video drawing.
          1     Restore video drawing.

^BRemarks^B
This function is intended for use with PlotOn() and VPOn(). 
Normally, output to the video display is simultaneous with 
output to a plotter or vector printer. This function provides a 
means to temporarily suppress video output.

^UNote^U   This function is intended only for temporary 
suppression of output to the screen. Moreover, you must not call 
SetHiRes() or SetVer() while video drawing is suppressed. If you 
do, the result will most likely not be whatever you intended to 
happen.

!seealso: "PlotOn()" "VPOn()" 
'------------------------------------------------------------------------------



!short: SetWin()        Define a window for statistical lines
'------------------------------------------------------------------------------
^BSyntax^B
SetWin( <nX0>, <nY0>, <nX1>, <nY1> )

^BDescription^B
Defines a window on screen within which the statistics 
functions may draw statistical lines. Mean, standard deviation, 
and best-fit lines will be clipped to appear in this window.

^BParameters^B
^U<nX0>^U
X coordinate for the bottom left corner of the window.

^U<nY0>^U
Y coordinate for the bottom left corner of the window.

^U<nX1>^U
X coordinate for the upper right corner of the window.

^U<nY1>^U
Y coordinate for the upper right corner of the window.

dGE's coordinate system is described under the entry for 
SetVer().

^BExample^B
*::::::::::::::::::::::::::::::::::::::::
*           CURVE.PRG
*::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN

SET CURSOR OFF

* Set screen into graphics mode
r = SetHiRes(0)

* Put title on screen
r = SayString(675, 950, 0, 0 + 8, 12, ;
    "This is a demonstration of curve-fitting")

* Reset DataStore array
r = DataReset()

* Store random data - minimum of one, maximum of 600
FOR pts = 1 to 21
   r = DataStore(RND(599) + 1, 0, 0, 0)
NEXT pts

* Draw graph
r = XYGraph(275, 100, 40, 1, 14)

* Draw axes
r = XYAxes(275, 100, 800, 600, 4, 10, 8 + 32, 7)

* Define stats window
r = SetWin(275, 100, 1075, 700)

FOR i = 1 to 10

   * Draw curve fit line
   r = CurveFit(0, i, 50, 2, 0, 15)

   * Draw subtitle indicating polynomial order
   r = SayString(675, 10, 0 + 16, 0 + 8, 14, ;
       "Polynomial order - " + ALLTRIM(STR(i)))

   * Wait
   r = INKEY(0)

   * XOR (erase) curve fit line
   r = CurveFit(0, i, 50, 2, 0, 15)

   * XOR (erase) subtitle indicating polynomial order
   r = SayString(675, 10, 0 + 16, 0 + 8, 14, ;
       "Polynomial order - " + ALLTRIM(STR(i)))

NEXT i


* Restore text mode
r = SetText()
QUIT

* Randomizer for Clipper
* For FoxPro, use the built-in random number function.
FUNCTION RND(nMax)
STATIC nSeed, m := 67110144, b := 31415927

   IF(nSeed == NIL, nSeed := SECONDS(), )
RETURN (nMax * ((nSeed := MOD(nSeed  * b + 1, m)) / m))

!seealso: "BestFit()" "CurveFit()" "MinMax()" "Stats()" 
'------------------------------------------------------------------------------



!short: Shade()         Fill the interior of an area bounded by lines
'------------------------------------------------------------------------------
^BSyntax^B
Shade( <nX>, <nY>, <nFill>, <nColor> )

^BDescription^B
Fills the interior of an area bounded by solid lines.

^UNote^U   Shade() uses a raster process that has no equivalent
in the instruction sets for vector printing devices. You cannot 
call VPOn() or PlotOn() to send output to a vector printer or 
plotter and then use Shade() to fill an area.

^BParameters^B
^U<nX>^U
X coordinate for an interior point.

^U<nY>^U
Y coordinate for an interior point.

dGE's coordinate system is described under the entry for 
SetVer().

^U<nFill>^U
Instructions for filling the space with a pattern. 

        Value    Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 19  Fill with one of the hatch patterns
                 illustrated at Appendix A.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^BRemarks^B
The function begins searching from point (nX, nY) and moves 
outward, looking for pixels in black (that is, pixels that have not 
been set). Wherever it finds an area with unset pixels, the 
function fills in with a pattern specified as nFill , using a 
foreground color passed as nColor. Gaps between the lines or 
dots of the pattern are left black.

^UNote^U   The Shade() function does not use the pattern 
background color set by calling SetBkFill().

If the area being filled is bounded by broken or incomplete lines, 
shading will escape beyond the boundary, possibly filling the 
entire screen or clipping window.

^UNote^U   In order to avoid overflowing the stack, the function 
will refuse to fill an unbounded area that is greater than the 
area of the screen or clipping window.

If you try to shade an area that is already filled with a pattern, 
your computer may appear to hang. Be patient. The function is 
most likely still executing, but changes appear very slowly as its 
algorithm recursively searches out unbounded space to fill.

A sparse fill, such as with pattern 4, takes a great deal of 
memory and may exhaust the stack if the shape being filled is 
complex. Solid fill with pattern 0 is attractive but slow. Best 
results are achieved with patterns 9, 10, 11, 12, 17, and 18.

^BExample^B
* Demonstrates the limits established by boundaries
* by drawing three overlapping circles and shading
* their interiors.

nFg = 15                  && Foreground color
nRadius = 100             && Radius of circles

* Specify coordinates
nOffset = nRadius * 3 / 4

nX1 = 575                 && For first circle
nY1 = 500

nX2 = nX1 + nOffset       && For second circle
nY2 = nY1 + nOffset

nX3 = nX2                 && For third circle
nY3 = nY1 - nOffset

nX4 = nX1 - (nRadius * 2) && For clipping window
nY4 = nY1 - (nRadius * 2)

* Draw three unfilled circles
r = DrawCircle(nX1, nY1, nRadius, 0, 360, 0, 0, nFg)
r = DrawCircle(nX2, nY2, nRadius, 0, 360, 0, 0, nFg)
r = DrawCircle(nX3, nY3, nRadius, 0, 360, 0, 0, nFg)

* Shade the interior of each, starting at center of circle
r = Shade(nX1, nY1, 9, nFg)
r = Shade(nX2, nY2, 10, nFg)
r = Shade(nX3, nY3, 11, nFg)

* Pause to admire
r = INKEY(0)

* Set a clipping window and bound it with a box
r = ClipWin(nX4, nY4, ;
            nX4 + (nRadius * 5), nX4 + (nRadius * 4))
r = BoxFill(nX4, nY4, ;
            nRadius * 5, nRadius * 4, 64, nFg)

* Pick a point inside the window but outside the circle.
* Shade it.
Shade(nX4 + 2, nY4 + 2, 0, nFg)  && Fills all unbounded,
                                 && uncolored area



!seealso: "BoxFill()" "Polygon()" 
'------------------------------------------------------------------------------



!short: SnapCopy()      Save an area of the screen to memory
'------------------------------------------------------------------------------
^BSyntax^B
nHandle = SnapCopy( <nX0>, <nY0>, <nX1>, <nY1>, <nMode> )

^BDescription^B
Copies a snapshot of a rectangular area of the screen to memory 
so that it can later be restored.

^UNote^U   This function is available only for Clipper. It stores 
images in virtual memory that is not available to FoxPro or C 
programmers. However, similar effects can be produced using 
the functions PicWrite() and PicRead(). In this case, we 
recommend the BMP format for its speed.

^BParameters^B
^U<nX0>^U
X coordinate for the lower left corner of the area to copy.

^U<nY0>^U
Y coordinate for the lower left corner.

^U<nX1>^U
X coordinate for the upper right corner.

^U<nY1>^U
Y coordinate for the upper right corner.

dGE's coordinate system is described under the entry for 
SetVer().

^U<nMode>^U
Indicates whether the area should be cleared after it is copied.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Do not clear the area after it is copied.

          1     Clear the area exactly as it is specified 
                by the coordinates nX0, nY0 to nX1, nY1.

          2     Clear the area to the nearest left and 
                right byte boundary in video RAM. See the 
                remarks below.

^BReturns^B
A numeric handle to the saved image. The handle can be used 
as an argument to SnapPaste() and SnapKill().

^BExample^B
*::::::::::::::::::::::::::::::::::::::::::::::::::::::
*                    SNAP.PRG
* This program uses SnapCopy() and SnapPaste to move a
* box around the screen without disturbing the background.
*::::::::::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN

SET CURSOR OFF
CLEAR

* Set screen in graphics mode
r = SetHiRes(0)

* Make a blue background
r = BoxFill(0, 0, 1350, 1000, 0, 1)
* Cover the screen with interlocking circles
FOR c = 100 TO 1300 STEP 100
   FOR i = 100 TO 900 STEP 100
      r = DrawCircle(c, i, 100, 0, 360, 0, 0, 5)
   NEXT i
NEXT c

* Take a 'snapshot' of the screen under where the box
* will go, and then draw the box. The region under the
* box is saved  to the variable 'nHandle'.
nX = 675
nY = 500
nHandle = SnapCopy(nX, nY, nX + 150, nY + 150, 0)
r = BoxFill(nX, nY, 150, 150, 0, 14)

* Loop. The ESC key stops the program.
* An arrow key moves the box.
lFlag = .T.
DO WHILE lFlag
  * Wait for a key.

  nKey = INKEY(0)
  * Restore the area under the box. 
  r = SnapPaste(nX, nY, nHandle)
  r = SnapKill(nHandle)

  * Increment the coordinates appropriately.
  DO CASE
    CASE nKey = 4 && Right arrow
      IF nX < 1150
        nX = MIN(nX + 20,  1150)
      ENDIF

    CASE nKey = 5 && Up arrow
      IF nY < 800
        nY = MIN(nY + 20, 800)
      ENDIF

    CASE nKey = 19 && Left arrow
      IF nX > 20
        nX = MAX(nX - 20,  20)
      ENDIF

    CASE nKey = 24 && Down arrow
      IF nY > 20
        nY = MAX(nY - 20, 20)
      ENDIF

    * This will exit the loop and the program
    CASE nKey = 27 && Escape
      lFlag = .F.
    ENDCASE

    * Take a new snapshot, then redraw the box.
    nHandle = SnapCopy(nX, nY, nX + 150, nY + 150, 0)
    r = BoxFill(nX, nY, 150, 150, 0, 14)
ENDDO

* Set text mode and exit.
r = SetText()
QUIT

!seealso: "PicRead()" "PicWrite()" "SnapKill" "SnapPaste()" 
'------------------------------------------------------------------------------



!short: SnapKill()      Destroy a saved image and release memory
'------------------------------------------------------------------------------
^BSyntax^B
SnapKill( <nHandle> )

^BDescription^B
Destroys a saved image and releases memory.

^UNote^U   This function is available only with Clipper.

^BParameter^B
^U<nHandle>^U
Numeric handle for the saved image. The handle is obtained as a
return value from SnapCopy().

!seealso: "SnapCopy()" 
'------------------------------------------------------------------------------



!short: SnapPaste()     Restore an area of the screen
'------------------------------------------------------------------------------
^BSyntax^B
SnapPaste( <nX0>, <nY0>, <nHandle> )

^BDescription^B
Restores an area of the screen previously saved with 
SnapCopy().

^UNote^U   This function is available only with Clipper.

^BParameters^B
^U<nX0>^U
X coordinate of the lower left corner for the screen location of 
the restored image.

^U<nY0>^U
Y coordinate of the lower left corner.

^U<nHandle>^U
Numeric handle for the saved image. The handle is obtained as a 
return value from SnapCopy().

!seealso: "SnapCopy()" 
'------------------------------------------------------------------------------



!short: Stats()         Draw mean and standard deviation lines
'------------------------------------------------------------------------------
^BSyntax^B
Stats( <nLength>, <nMode>, <nLineStyle>, <nColor> )

^BDescription^B
Draws lines representing the mean and standard deviation of 
the current data set or subset. The data must first have been 
graphed by the HLCGraph() or XYGraph() function.

^BParameters^B
^U<nLength>^U
Length, in screen units, of the statistical lines. The lines will 
extend in a positive direction from the X origin of the graph, and 
will be drawn parallel to the X axis.

If nLength is zero, dGE will draw the lines within a window 
previously defined by a call to SetWin().

^UNote^U   If your graph extends in the negative X direction, 
define a window by calling SetWin(). Then pass zero as nLength 
when you call Stats().

^U<nMode>^U
Selects the statistical lines to be drawn.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Mean only.
          1     Mean and standard deviation.

^U<nLineStyle>^U
Selects the type of line to be drawn.

        Value           Meaning
        컴컴컴컴컴      컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0             Solid line.

        > 0             Broken line with an interval of nStyle
                        pixels between segments.

        + (n * 128)     For plotters only. The value n is the 
                        plotter's line style index, which may be
                        used to select various mark/space
                        patterns. Refer to your plotter
                        documentation for details.

                       ^UNote^U   If n = 0, the default style is
                       2 (even mark/space). Style 0, a single
                       dot, is not available.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^BRemarks^B
The function calculates values for mean and standard deviation
from the first parameter of DataStore(). This has relevance to the
High, Low, Close graph drawn by HLCGraph(). See the entry for 
that function.

^BExample^B
r = Stats(100, ; && Length
            1, ; && Mean and standard deviation
            1, ; && Broken line, segments 1 pixel long
            4)   && Color

!seealso: "GetMean()" "GetSD()" "MinMax()" "SetWin()" "XYGraph()" 
'------------------------------------------------------------------------------



!short: TimeData()      Add a data point to a time-series graph
'------------------------------------------------------------------------------
^BSyntax^B
TimeData( <nAmp1>, <nAmp2>, <nAmp3>, <nAmp4> )

^BDescription^B
Adds a data point to a time-series graph drawn by the function 
TimeGraph().

^UNote^U   Unlike DataStore() and LogData(), this function is 
called after the graphing function.

^BParameters^B
^U<nAmp1> to <nAmp4>^U
Amplitude value for the channel.

The values for each channel are graphed only if the channel is 
enabled or if it is designated as an index. See the entry for 
TimeGraph().

If a channel has been designated as an index, the value of nAmp 
determines how the index line will be displayed.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
           0    No index mark. A solid horizontal line
                will be drawn along the X axis for a 
                length of nXInc (an argument passed to 
                the TimeGraph() function).

        <> 0    Draw an index mark. The value will be 
                graphed as a vertical line extending from 
                the X axis to a position nAmp screen 
                units above or, if the value is negative, 
                below the X axis. (A line will be drawn 
                for each data point.)

^BRemarks^B
Data may be scaled by calling DataPc() before the first call to 
TimeData(). However, DataRange() has no effect.

^UMemory Limitations^U
Each call to TimeData() stores a single data point with up to four 
values. The maximum number of data points that dGE can hold
in its internal array is 1024.

This does not mean, however, that you are limited to 1024 
successive calls to TimeData(). Instead, it means that you are 
limited to displaying 1024 points at once.

The reason for this is that dGE holds in memory only the data 
for the points currently on display. When you call TimeGraph(), 
one of the parameters you set is nXInc, which specifies the 
maximum number of data points that should be displayed at 
once. Each time you call TimeData(), a new point is added to the 
graph. However, once you reach the maximum number of 
displayable points, nXInc, the addition of a new data point forces 
the oldest point from memory.

Thus the number of calls you make to TimeData() is not limited 
in any way. But the number of data points on display cannot 
exceed 1024.

!seealso: "DataPc()" "DataReset()" "TimeGraph()" 
'------------------------------------------------------------------------------



!short: TimeGraph()     Draw a time-series graph 
'------------------------------------------------------------------------------
^BSyntax^B
TimeGraph( <nX>, <nY>, <nXInc>, <nXPoints>, <nCh1>, <nCh2>, <nCh3>, <nCh4> )
TimeData( <nAmp1>, <nAmp2>, <nAmp3>, <nAmp4> )

^BDescription^B
Displays a time-series graph from as many as four channels 
(individual data streams) of amplitude information. The data for 
each channel are, by default, connected with continuous lines. 
You have the option to use icons rather than lines.

^BData^B
This function differs significantly from the other dGE graphing 
functions in that TimeGraph() must be called before any data is 
stored.

Initially, no graph is drawn. The graph is built progressively over 
time by adding data points. Each call to TimeData() adds a new 
point, which is then graphed. The most recent data point is 
drawn at the X origin. As new points are added, previously 
graphed points scroll to the left. When the number of points 
exceeds a maximum that you specify, the oldest point, now at 
the extreme left of the graph, is discarded.

Any of the four channels may be designated as an index 
channel. For an explanation of indexes, see the entry for 
TimeData().

^BParameters^B

^UTimeGraph( <nX>, <nY>, <nXInc>, <nXPoints>, <nCh1>, <nCh2>, <nCh3>, <nCh4> )^U

^U<nX>^U
X coordinate for the origin of the graph.

^U<nY>^U
Y coordinate for the origin of the graph.

dGE's coordinate system is described under the entry for 
SetVer().

^U<nXInc>^U
X interval between points, in screen units.

^U<nXPoints>^U
Maximum number of data points to display. Acceptable values
range from 1 to 1024.

One call to TimeData() stores one data point with up to four
values. The maximum number of data points that may be stored
in dGE's internal array is 1024.

^U<nCh1> to <nCh4>^U
Instructions for graphing each channel of amplitude data.

         Value   Meaning
        컴컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
             0   Channel disabled.

       1 to 15   Color of graph or index line.

        +  128   Channel is an index.

        +  256   Superimpose mean.

        +  512   Superimpose standard deviation.

        + 1024   Draw the graph using icons rather than
                 lines. Icons will be drawn with the
                 raster operation XOR. See the remarks
                 below for an explanation of the icons
                 used.

        + 2048   Draw connecting lines using the raster
                 operation REPLACE.

                 The default is XOR, which has the
                 advantage that it does not disturb
                 underlying grids and axes. The
                 disadvantage of XOR is that the tracks of
                 solid lines will have gaps wherever they
                 cross the tracks of other channels. If
                 you are not using an underlying grid, you
                 may prefer to have lines drawn with
                 REPLACE.

^UTimeData( <nAmp1>, <nAmp2>, <nAmp3>, <nAmp4> )^U

^U<nAmp1> to <nAmp4>^U
Amplitude value for the channel.

The values for each channel are graphed only if the channel is
enabled or if it is designated as an index. See the entry for
TimeGraph().

If a channel has been designated as an index, the value
determines how the index line will be displayed.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
           0    No index mark. A solid horizontal line
                will be drawn along the X axis for a
                length of nXInc (an argument passed to
                the TimeGraph() function).

        <> 0    Draw an index mark. The value will be
                graphed as a vertical line extending from
                the X axis to a position nAmp screen
                units above or, if the value is negative,
                below the X axis.

^BRemarks^B
The data may be scaled by a call to DataPc(). However, it is not
possible to define a subset of the data; calling the function
DataRange() has no effect.

If you choose to have data points graphed by icons rather than 
lines, dGE will use icons from its internal library.

        Channel  Icon number
        컴컴컴  컴컴컴컴컴
           1         0
           2         1
           3         8
           4         9

^BExample^B
* Graph a Sine wave.
SET SCOREBOARD OFF
SET CURSOR OFF
CLEAR SCREEN
r = SetHiRes(0)
DO Wave
r = SetText()
QUIT

PROCEDURE Wave
   PRIVATE nX, nY, nXInc, nXPoints, nAngle, nSin

   * Define the origin, X increment, and number of points
   nXInc = 10
   nXPoints = 720 / nXInc
   nX = 1035
   nY = 500

   * Label X and Y axes
   r = LabelX(nX - 720, nY - 270, 90, 3, 1, 8 + 128, ;
              15, "720630540450360270180 90  0")
   r = LabelY(nX - 720, nY - 180, 180, 2, 1, 16, ;
              15, "-1 0+1")

   * Draw dotted X and Y grid, box around exterior.
   r = XYAxes(nX - 720, nY - 270, 720, 540, 8, 6, ;
              12 + 32 + 64, 7)

   * Clear the internal array.
   r = DataReset()
   * Scale the data 200%
   r = DataPc(200)

   * Define the graph. Channel 1 is enabled.
   r = TimeGraph(nX, nY, nXInc, nXPoints, ;
                 10 + 512, ; && Color hi-green + SD lines
                 0, 0, 0)    && Channels disabled

   * Send data until the escape key is pressed.
   DO WHILE INKEY() != 27

      * Loop through angles 0 to 360 degrees.
      FOR nAngle = 0 To 360 STEP nXInc
         * Sine of the angle goes to channel 1.
         nSin = 90 * GetSin(nAngle, 0)

         r =TimeData(nSin, 0, 0, 0)
      NEXT nAngle
   ENDDO
RETURN

!seealso: "DataReset()" "DataPc()" "LabelX()" "LabelY()" "TimeData()" 
'------------------------------------------------------------------------------



!short: UserIcon()      Redefine one of dGE's ten internal icons 
'------------------------------------------------------------------------------
^BSyntax^B
UserIcon( <nIcon>, <cDef> )

^BDescription^B
Redefines one of dGE's ten internal icons. The new icon can be
used in any subsequent call to a dGE function involving icons. It 
will remain available in dGE's internal buffer until the icon is 
again redefined or the program ends.

^BParameters^B
^U<nIcon>^U
Index number, 0 through 9, of the icon to redefine.

^U<cDef>^U
A 32-character string containing the new definition for the icon.

^BRemarks^B
User-defined icons occupy by a grid of 16 x 16 bits. Each row of 
the grid consists of two bytes, with the least significant bit on 
the left of each byte.

        Byte Value      Power of 2      Decimal
        컴컴컴컴컴      컴컴컴컴컴      컴컴컴
         10000000            0              1
         01000000            1              2
         00100000            2              4
         00010000            3              8
         00001000            4              6
         00000100            5             32
         00000010            6             64
         00000001            7            128

Thus if a single 16 bit row has only the outermost bits 
turned on, the binary representation of the two bytes for 
that row is:

            10000000 00000001

In decimal, the value of the left byte is 1 and the value of the  
right byte is 128. UserIcon() does not accept numeric values in 
an icon definition, so the values 1 and 128 must be passed as 
ASCII characters. The row would be concatenated as:

            CHR(1) + CHR(128)

An entire icon definition can be built by calculating the byte 
values for each row, starting at the top and working down 
through each of the 16 rows. As the value of each byte is 
calculated, it is added to the definition string as an ASCII value. 

The example program demonstrates how you might design the 
pattern for an icon and then use the pattern to build a definition 
string.

^BExample^B
*::::::::::::::::::::::::::::::::::::::::::::::::::::
*                  MAKEICON.PRG
* Creates a 32-byte string that can be passed to
* UserIcon(). The string is created from a 16 row 
* array. By filling the array with 0s and 1s, it is 
* easy to see how the icon will look as it is being 
* built. A zero denotes an "off" position in the icon;
* a one is "on." 
*::::::::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN

  SET CURSOR OFF
  CLEAR SCREEN
  r = SetGMode(18)
  r = SetHiRes(0)

  DECLARE aIcon[16]
  aIcon[ 1] = "0000001001000000"
  aIcon[ 2] = "0000001001000000"
  aIcon[ 3] = "0000001001000000"
  aIcon[ 4] = "0000001001000000"
  aIcon[ 5] = "0000001001000000"
  aIcon[ 6] = "0000001001000000"
  aIcon[ 7] = "1111111001111111"
  aIcon[ 8] = "0000000000000000"
  aIcon[ 9] = "1111111001111111"
  aIcon[10] = "0000001001000000"
  aIcon[11] = "0000001001000000"
  aIcon[12] = "0000001001000000"
  aIcon[13] = "0000001001000000"
  aIcon[14] = "0000001001000000"
  aIcon[15] = "0000001001000000"
  aIcon[16] = "0000001001000000"

  cIcon = ""
  FOR nRow = 1 TO 16
    nTemp1 = 0
    nTemp2 = 0
    FOR nBit = 1 TO 8
      * First byte
      IF SUBSTR(aIcon[nRow], nBit, 1) = "1"
        * If the bit is ON, add the bit value
        nTemp1 = nTemp1 +  2**(nBit -1 )
      ENDIF

      * Second byte
      IF SUBSTR(aIcon[nRow], nBit + 8, 1) = "1"
        * If the bit is ON, add the bit value
        nTemp2 = nTemp2 + 2**(nBit - 1)
      ENDIF
    
    NEXT nBit
    * Add two bytes to the string
    cIcon = cIcon + CHR(nTemp1) + CHR(nTemp2)
  NEXT nRow

  * Display original icon
  r = DrawIcon(500, 500, 0, 1, 7)

  * Redefine icon
  r = UserIcon(1, cIcon)

  * Display new icon
  r = DrawIcon(700, 500, 0, 1, 7)

  * Pause
  r = INKEY(0)
  r = SetText()
  Quit

!seealso: "DrawIcon()" 
'------------------------------------------------------------------------------



!short: VecString()     Position and display text at a vector
'------------------------------------------------------------------------------
^BSyntax^B
VecString( <nDistance>, <nAngle>, <nCSet>, <nMode>, <nColor>, <cString> )

^BDescription^B
Draws a text string at a vector position relative to the current 
position. The string may be drawn either horizontally or 
vertically (descending characters). By default, the string is left-
justified. You may optionally center the string or right-justify it.

^BParameters^B
^U<nDistance>^U
Distance from current position, in screen units.

^U<nAngle>^U
Angle from current position, in degrees. The angle may be either
positive or negative.

nDistance, nAngle are vector coordinates that locate a position
nDistance screen units away in a direction of nAngle degrees
from the current drawing position. By default, the current
drawing position is 0, 0 until a draw, move, or positioning
function is executed. See the entry for FixPos().

    ^UNote^U   VecString() does not update the drawing
                  position. It remains unchanged.

^U<nCSet>^U
Character set and raster options.

        Value   Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 1  Character set number. If no font has been
                loaded with LoadCSet(), 0 selects
                standard, and 1 selects small. If a font
                has been loaded, pass 0 as the argument.

        +  4    REPLACE

        +  8    OR

        + 16    XOR

        + 64    INVERSE

^U<nMode>^U
Alignment.

        Value    Meaning
        컴컴    컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
            0    Horizontal text.

            1    Vertical text.

        +   8    Horizontally center the text.

        +  16    Right-justify the text.

        +  64    Vertically center the text.

        + 128    The vector position locates the top line
                 of the characters.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^U<cString>^U
Text string.

^BExample^B
* Write a string twice at the same vector coordinates,
* the first time horizontally, the second vertically.

cString = "Hello, world!"
nDistance = 500
nAngle = 90

r = FixPos(675, 0)  && Set the current drawing position.
r = VecString(nDistance, nAngle, ; && Vector coordinates
                              4, ; && Replace
                              0, ; && Horizontal
                             15, ; && Color
                          cString)
r = VecString(nDistance, nAngle, ; && Same coordinates
                              4, ; 
                              1, ; && Vertical
                             15, ; 
                          cString)
r = INKEY(0)

!seealso: "SayString()" "FixPos()" "MoveVec()" 
'------------------------------------------------------------------------------



!short: VPOff()         End output to a PostScript or PCL 5 printer
'------------------------------------------------------------------------------
^BSyntax^B
VPOff( <nMode> )

^BDescription^B
Terminates output to a vector printer and automatically issues a 
command to print the page.

^BParameter^B
^U<nMode>^U
Printer options.

        Value   Meaning
        컴컴   컴컴컴컴컴
          0     Eject page.
          1     No eject.

^UPostScript^U
nMode 1 terminates output without sending the Postscript
showpage command. Thus further images or Postscript
commands can be sent to build the page before it is printed.

^UPCL 5^U
nMode 1 terminates output without sending the form-feed 
command.

!seealso: "VPOn()" 
'------------------------------------------------------------------------------



!short: VPOn()          Begin printing on Postscript or PCL 5 printer
'------------------------------------------------------------------------------
^BSyntax^B
VPOn( <nHOffset>, <nVOffset>, <nXLen>, <nUnits>,
      <nYScale>, <nOrient>, <nMode> )

^BDescription^B
Prints on a vector printing device that accepts either Postscript 
or PCL 5 commands, such as an HP LaserJet III or IV.

^BParameters^B
^U<nHOffset>^U
Horizontal offset (margin) from the left of the page.

^U<nVOffset>^U
Vertical offset (margin) from the bottom of the page.

The coordinate pair nHOffset, nVOffset locate the bottom right 
corner of the image on the page.

^U<nXLen>^U
Length of the image along the X axis (width).

^U<nUnits>^U
Unit of measurement for nHOffset, nVOffset, and nXLen.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴
          0     Millimeters (default)
          1     Points ( 1/72 inch)
          2     1/100 inch

^U<nYScale>^U
Scaling factor for the Y axis (height), as a percentage. The 
default is 100 percent, which preserves screen aspect ratio by 
calculating the height of the printed image at three-quarters of 
its width.

^U<nOrient>^U
Orientation angle, 0 to 90, in degrees, measured counter- 
clockwise. The origin of the angle is the bottom left of the 
screen, even when a clipping window is defined.

^U<nMode>^U
Printer options.

        Value   Meaning
        컴컴컴  컴컴컴컴컴컴컴컴컴컴컴컴컴
           0    Postscript output.
           1    PCL5 output for LaserJet.
        +  8    Print clipping window only.
        + 16    Postscript color output.
        + 32    Postscript pattern priority.
                컴 or 컴
                PCL5 gray scale.

^BRemarks^B
^UBitmapped vs. Vector Output^U
Bitmapped or raster devices receive complete images in the form 
of scanned binary data, typically taken directly from a video 
screen at a particular screen resolution. Bitmapped images have 
the advantage that their ability to represent detail is limited only 
by the resolution possible in the devices used to create and later 
render the image. Their disadvantage is that they do not 
reproduce well after scaling, they are not easily rotated, and 
they cannot readily be translated from the resolution of one 
output device, such as the screen, to the resolution of another 
output device, such as a printer.

Vector devices, in contrast, draw images in response to a 
sequence of commands defining the size and position of the 
lines, circles, text, and other graphical objects that make up the 
image. Vector images have the advantage that they are readily 
scaled, sized, and rotated. Thus vector devices are a more 
flexible target for printing graphic images.

^UVector Print Operations^U
Bitmapped printing in dGE requires that you first draw an
image, then print it. Vector printing works in just the opposite
way. First you enable printed output by calling VPOn(), then you
issue drawing commands. Each time you issue a drawing
command one or more commands are sent to the printer, where
the image is built up in memory. When output is terminated by
a call to VPOff(), the image is printed.

      ^UNote^U   Certain raster drawing operations have no
       equivalent in a vector device's instruction set. As a result, the
       boundary fill function Shade() is not available on any vector
       device. The background color for patterns, set with SetBkFill(),
       will not be rendered on color postscript printers. And three-
       dimensional objects such as those created by Pie3D() may not be
       outlined when you ask for outlining.

^USize and Position^U
Position an image on the page by specifying the location of its
bottom left corner with the arguments nHOffset and nVOffset.
By default these are in millimeters. If you prefer, you can specify
dimensions in points or in hundredths of an inch by passing the
appropriate value for nUnits.

The size of the image is determined by the argument for nXLen, 
which gives the width of the image on the page. dGE calculates 
the height of the image at three-quarters the width, thus 
preserving the aspect ratio of the screen.

You can alter the aspect ratio for vector printing by passing a 
value greater or less than 100 as the argument for nYPc. A value 
greater than 100 makes the image taller; a value less than 100 
shortens it.

^UPrinting a Window within the Screen^U
nMode + 8 directs dGE to print the active clipping window. By
default, the active clipping window is the entire screen. You can 
define a smaller window by calling ClipWin(). In this case the 
area defined as the clipping window will be scaled, positioned, 
and printed as if it were the entire screen. However, image 
rotation is treated differently. The true origin of the image 
remains at the bottom left of the screen, and this is the point 
about which the image is rotated by nOrient. It is important to 
make allowance for this when printing in landscape mode.

^UFonts^U
dGE does not download fonts to the printer. Instead, it selects 
the resident font that most closely matches the one displayed on 
screen. The dGE system screen fonts are rendered on the printer 
as identically sized fixed-pitch fonts. dGE SuperText and 
proportional screen fonts are rendered as proportionally spaced 
font but may vary appreciably in size. You can take greater 
advantage of fonts resident in your printer by calling PSFont() or 
PCLFont(). See the entries for those functions.

^UPrint Device^U
The default is LPT1. You can direct output to another parallel 
port, to a serial port, or to a file by calling PrnDev() or PrintFile().

^UPostScript Color^U
By default, the printer is assumed to be monochrome. nMode 
+16 prints in color if your hardware supports color. Color 0 is 
printed as white, color 15 as black.

^UPostScript Patterns^U
Postscript does not have a ready means for rendering a pattern 
when it is used to fill an area, such as a bar in a bar graph or a 
slice in a pie chart. On color devices, areas are filled with solid 
color. On monochrome devices, patterns are rendered by gray 
scales. By default the driver selects a gray scale that increases 
with the color index number. nMode +32 causes the driver to 
select a gray scale that increases with the fill pattern number. 
This may be more appropriate for programs written for 
monochrome monitors.

^UPCL 5 Gray Scale^U
By default, dGE fill patterns are reproduced as hatch patterns 
generated by the PCL driver. nMode +32 causes the driver to 
render the patterns as shades of gray; the higher the pattern 
number, the lighter the gray.

^UPCL 5 Icons^U
Bitmapped icons are not reproduced because the PCL language 
does not support continuous scaling of bit patterns.

!seealso: "PrintFile()" "PrnDev()" "PCLFont()" "PSFont()" "VPOff()" 
'------------------------------------------------------------------------------



!short: VScroll()       Scroll an area of the screen up or down
'------------------------------------------------------------------------------
^BSyntax^B
VScroll( <nX0>, <nY0>, <nX1>, <nY1>, <nYDistance>, <nColor> )

^BDescription^B
Scrolls a rectangular area of the screen up or down. After the 
move, the empty area of the screen may be left unpainted or 
filled with a solid color.

^BParameters^B
^U<nX0>^U
X coordinate for the lower left corner of the area to scroll.

^U<nY0>^U
Y coordinate for the lower left corner.

^U<nX1>^U
X coordinate for the upper right corner.

^U<nY1>^U
Y coordinate for the upper right corner.

dGE's coordinate system is described under the entry for 
SetVer().

^U<nYDistance>^U
Distance in screen units to move the designated image. A 
positive integer moves up. A negative integer moves down.

^UnColor>^U
Color to paint the area vacated after the move. The value may a 
an integer in the range 0 to (nColors - 1) where nColors is the 
value returned by GetVideo(6). See the entry for SetRGBPal().

Alternatively, passing -1 will leave the area unpainted.

^BRemarks^B
Clipper. In order to avoid a conflict with FUNCky, this function 
is named _VScroll() in the Clipper libraries. DGEDEFS.CH 
redefines the function as VScroll() but you must include this file 
to get the benefit of the #define. Otherwise, call it as _VScroll().

^BExample^B
*::::::::::::::::::::::::::::::::::::::::::::::::::::::::
*                    V_SCROLL.PRG
*         Shows how you might use VScroll()
*         to scroll credits up the screen.
*::::::::::::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN

SET CURSOR OFF
CLEAR

* Set screen in graphics mode
r = SetHiRes(0)

*
*  This section draws a background for the credits.
*

* Make a blue background.
r = BoxFill(0, 0, 1350, 1000, 0, 1)
* Cover the screen with interlocking circles.

FOR c = 100 TO 1300 STEP 100
   FOR i = 100 TO 900 STEP 100

      r = DrawCircle(c, i, 100, 0, 360, 0, 0, 2)
   NEXT i
NEXT c

* Clear a path for the list.
r = BoxFill(500, 0, 350, 1000, 0, 1)

*
* This section scrolls a list.
*
nCredits = 15  && Number of credits
nMove = 4      && Scroll speed

* Get the current font height 
nYInc = GetFontInf(1)

* Calculate the size of the box to scroll.
nHt = nYInc * nCredits ///* 1.5
nYBottom = (1000 - nHt) / 2
nYTop = nYBottom + nHt

* Scroll a list upwards, adding numbers to the bottom of
* the list every nYInc (height of the resident font).
FOR i = 1 TO nCredits

  * Scroll the rectangle up.
  FOR j = 1 TO nYInc STEP nMove
    r = VScroll(500, nYBottom, 850, nYTop, nMove, 1)
  NEXT j

  * Add a credit to the bottom of the list.
  r = SayString(675, nYBottom + 1, 0 + 4, 0 + 8, 15, ;
                'credits ' + ALLTRIM(STR(i)))
NEXT i

* Last credits are on screen. Scroll the list off screen.
FOR j= 1 TO nHt STEP nMove
  r = VScroll(500, nYBottom, 850, nYTop, nMove, 1)
NEXT j

* Set text mode and exit.
r = SetText()
QUIT

!seealso: "ClipWin()" "HScroll()" 
'------------------------------------------------------------------------------



!short: XORBlock()      XOR an area of the screen with a color
'------------------------------------------------------------------------------
^BSyntax^B
XORBlock( <nX>, <nY>, <nWidth>, <nHeight>, <nColor> )

^BDescription^B
XORs a rectangular area of the screen with a solid color. This 
has the effect of logically inverting the pixels.

^BParameters^B
^U<nX>^U
X coordinate for the bottom left corner of the block.

^U<nY>^U
Y coordinate for the bottom left corner of the block.

dGE's default coordinate system is described under the entry for
SetVer().

^U<nWidth>^U
Width of the block in screen units.

^U<nHeight>^U
Height of the block in screen units.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^BRemarks^B
You can use this function to highlight text. XOR a block once, 
and the area is highlighted. XOR it again, and the original 
coloring is restored.

^UNote^U   The function will not produce sensible results on a 
plotter, nor will it work with vector printing.

^BExample^B
*::::::::::::::::::::::::::::::::::::::::::::::::::
*                 MENUDEMO.PRG
*::::::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN

SET CURSOR OFF

* Put screen in graphics mode
r = SetGMode(18) && VGA
r = SetHiRes(0)

DECLARE aFruit[6]
aFruit[1] = " Apple "
aFruit[2] = " Orange "
aFruit[3] = " Grape "
aFruit[4] = " Lemon "
aFruit[5] = " Lime "
aFruit[6] = " Raspberry "
nOpt = GetChoice(450, 950, 1, aFruit) 
IF nOpt > 0
   r = SayString(450,500, 0, 0, 7, ;
                 "You selected" + aFruit[nOpt])
ELSE
   r = SayString(650,500, 0, 0, 7, "No choice")
ENDIF
r = INKEY(0)
r = ClrString()

* Set text mode
r = SetText()

SET CURSOR ON
QUIT

*::::::::::::::::: END OF MAIN :::::::::::::::::::::

*::::::::::::::::: GetChoice() :::::::::::::::::::::
* Parameters are coordinates for the top left corner
* of the menu, the color for the menu (0 to 6), and
* an array of menu items. Returns the number of the
* array element selected, or 0 if escape is pressed.
*:::::::::::::::::::::::::::::::::::::::::::::::::::

FUNCTION GetChoice
   PARAMETERS nX, nY, nColor, aItems
   PRIVATE i, nBarLen, nBarHt, nMenuWid, nMenuHt
   PRIVATE nTest, nXItem, nYItem, nSelection

   * Calculate length of moving bar from
   * length of longest string
   nBarLen = 0
   FOR i = 1 TO LEN(aItems)
      nTest = GetStrLen(aItems[i])
      IF nTest > nBarLen
         nBarLen = nTest
      ENDIF
   NEXT i

   * Calculate the width of the menu box
   nMenuWid = nBarLen + 50

   * Calculate the height of the bar from
   * the height of the font
   nBarHt = GetFontInf(1) * 1.5

   * Calculate the height of the box
   nMenuHt = nBarHt * (LEN(aItems) + 1)

   * Draw a filled box, and outline it
   * with an unfilled box
   r = BoxFill(nX, nY - nMenuHt, ;
               nMenuWid, nMenuHt,;
               0, nColor)
   r = BoxFill(nX, nY - nMenuHt, ;
               nMenuWid, nMenuHt,;
               0 + 64, nColor + 8)

   * Write the text for the menu options
   nXItem = nX + 25
   nYItem = nY - nBarHt
   FOR i = 1 TO LEN(aItems)
      r = SayString(nXItem, nYItem, ;
                    0 + 4, 0 + 64,  ;
                    7, aItems[i])
      nYItem = nYItem - nBarHt
   NEXT i

   * Calculate the first position of the bar
   nYItem = nY - (3 * nBarHt / 2)

   nKey = 0
   nSelection = 1
   * Loop until a selection is made or
   * escape is pressed
   DO WHILE nKey <> 27 .AND. nKey <> 13

      * XORBlock an area to highlight it
      r = XORBlock(nXItem, nYItem, ;
                   nBarLen, nBarHt, 8)

      * Get a key
      nKey = INKEY(0)

      * XOR again to unhighlight
      r = XORBlock(nXItem, nYItem, ;
                   nBarLen, nBarHt, 8)

      * Respond to the keypress
      DO CASE
      CASE nKey = 5  && Up
         nYItem = nYItem + nBarHt
         nSelection = nSelection - 1
         IF nSelection < 1
            nSelection = 1
            nYItem = nYItem - nBarHt
         ENDIF

      CASE nKey = 24 && Down
         nYItem = nYItem - nBarHt
         nSelection = nSelection + 1
         IF nSelection > LEN(aItems)
            nSelection = LEN(aItems)
            nYItem = nYItem + nBarHt
         ENDIF

      CASE nKey = 27 && Escape
         nSelection = 0
      ENDCASE
   ENDDO

   * Clear the area occupied by the menu
   r = ClrWin(nX, nY - nMenuHt, nX + nMenuWid, nY)

RETURN nSelection

!seealso: "BoxFill()" 
'------------------------------------------------------------------------------



!short: XYAxes()        Draw a set of XY axes
'------------------------------------------------------------------------------
^BSyntax^B
XYAxes( <nX>, <nY>, <nXLen>, <nYLen>, <nXDivs>, <nYDivs>, <nStyle>, <nColor> )

^BDescription^B
Draws a set of XY axes with scale marks at regular intervals. 
The axes may include negative extensions in the X and Y 
directions. Grids may be superimposed, drawn parallel to the X 
and Y axes, and the exterior may be framed by a box.

^BParameters^B
^U<nX>^U
X origin for the axes.

^U<nY>^U
Y origin for the axes.

The X, Y coordinate pair locate the origin; on a graph with no 
negative values, this is the bottom left corner. dGE's coordinate 
system is described under the entry for SetVer().

^U<nXLen>^U
Length of the X axis, in screen units.

^U<nYLen>^U
Length of the Y axis, in screen units.

^U<nXDivs>^U
Number of divisions for the X axis. A tick mark will be placed at 
the origin, and one will be drawn at the end of each division.

^U<nYDivs>^U
Number of divisions for the Y axis. A tick mark will be placed at 
the origin, and one will be drawn at the end of each division.

The length of either axis should be exactly divisible by the 
number of divisions specified for that axis. If not, the increment 
between tick marks may not be an integer number of screen 
units, and the positions of the ticks may move slightly out of 
registration with the data points.

^U<nStyle>^U
A value of zero selects a basic set of axes with tick marks.
Additional options are selected by adding these values:

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        +  1    Negative Y arm. The Y axis will be
                extended in the negative direction nYLen 
                screen units.
        +  2    Negative X arm. The X axis will be 
                extended in the negative direction nXLen 
                screen units.
        +  4    Solid Y grids.
        +  8    Dotted Y grids.
        + 12    Dashed Y grids. (4 + 8 = 12)
        + 16    Solid X grids.
        + 32    Dotted X grids.
        + 48    Dashed X grids. (16 + 32 = 48)
        + 64    Box around exterior.

When grid lines are drawn, ticks are omitted.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^BRemarks^B
You can create complex axes with major and minor grids by 
calling this function repeatedly with different arguments.

^BExample^B
* This example scales the axes and the data
* to fit desired dimensions of the graph.
* (We'll assume data has already been stored.)

* Set trial width and height of the graph.
* They will later be adjusted for rounding.
nWidth = 400
nHeight = 300

* Compute X axis scaling factor
nValues = 7
nXDivs = nValues - 1
nXInc = INT(nWidth / nXDivs)
nWidth = nXDivs * nXInc        && Account for rounding

* Center the graph horizontally.
nX = (1350 - nWidth) / 2       && Horizontal position

* Compute Y axis scaling factor. The axis will
* later be labeled in increments of 10 from
* zero to the maximum data value. See the example
* for LabelY().
nMax = GetMax()
IF nMax % 10 = 0
   nYDivs = nMax / 10
ELSE
   nYDivs = INT(nMax / 10) + 1
ENDIF
nMax = 10 * nYDivs
nYInc = INT(nHeight / nYDivs)
nHeight = nYInc * nYDivs       && Account for rounding
nYScale = nHeight / nMax * 100 && Scaling factor

* Scale the data.
r = DataPC(nYScale)

* Center the graph vertically.
nY = (1000 - nHeight) / 2      && Vertical position

* Draw the axes.
r = XYAxes(nX, nY, nWidth, nHeight, ;
           nXDivs, nYDivs, 0, 7)

!seealso: "LabelX()" "LabelY()" "XYGraph()" 
'------------------------------------------------------------------------------



!short: XYGraph()       Draw a line or log/lin graph
'------------------------------------------------------------------------------
^BSyntax^B
DataStore( <nAmplitude>, <nMark>, <XPosition>, 0 )
- or -
LogData( <nAmplitude>, <nMark>, <XPosition>, <nCycleHeight>, <nBaseValue> )

XYGraph( <nX>, <nY>, <XInc>, <nStyle>, <nColor> )

^BDescription^B
Draws a line or log/lin graph, depending on whether data is 
stored with DataStore() or LogData(). In both cases, data points 
can be connected by lines, marked with icons, or both. A fourth 
style draws a vertical line from each data point to the X axis. X 
axis positions can be in either fixed-increments or individually 
specified. 

The log/lin graph is a variation on the line graph that uses 
logarithmic scaling on one axis to amplify minor variations and
flatten larger fluctuations.

^BData^B
XYGraph() treats all data stored as a single group. If you choose 
to connect data points with lines, the connections will form a 
single line graph.

If you have multiple data groups to graph, you can produce a 
multiple line graph by storing the data in group order, and then 
using calls to DataRange() to point to each group followed by a 
call to XYGraph() to graph it, drawing each line graph on top of 
the one before it.

If you choose not to connect data points but instead mark them 
with icons, you can graph multiple data groups in a single call 
to XYGraph() by storing individual X position data and using 
different icons to distinguish between groups.

^BParameters^B

^UDataStore( <nAmplitude>, <nMark>, <XPosition>, 0 )^U
- or -

^ULogData( <nAmplitude>, <nMark>, <XPosition>, <nCycleHeight>, <nBaseValue> )^U

If you want a straight linear graph, store your data with 
DataStore(). If you want a log/lin graph, use LogData().

The first three parameters work in the same way for both 
functions.

^U<nAmplitude>^U
Amplitude value. The value may be either positive or negative for 
all styles of the standard line graph. Values for a log/lin graph 
must be greater than zero.

^U<nMark>^U
Selects a line style or icon. How dGE interprets the value 
depends on whether the nStyle argument to XYGraph() indicates 
that points should be marked with chained lines or with icons.

        ^UnStyle = 0 (Chained Lines)

        Value           Meaning
        컴컴컴컴컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
            0           Solid line.
          > 0           Broken line with an interval of nMark pixels.
        + 128 * nMark   Line index (for plotters only).

        ^UnStyle = 1 (Icons) or nStyle = 2 (Lines and Icons)

        Value           Meaning
        컴컴컴          컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0 to 9          Icon code. See Appendix A.
        +   16          Use a SuperIcon from a file.

^U<XPosition>^U
Position along the horizontal axis. dGE uses this value only if 
the value for nXInc passed to XYGraph() is zero.

LogData() accepts two additional parameters. They are described 
only briefly here. For additional information, see the entry for 
LogData().

^U<nCycleHeight>^U
The height in screen units of one cycle of data (the distance, for 
example, from 10 to 100).

^U<nBaseValue>^U
The base value at which the graph is origined, usually a power
of ten (1, 10, 100, 1000...).

^UNote^U   For C interface, the variables nCycleHeight and 
nBaseValue are floating point doubles.

^UXYGraph( <nX>, <nY>, <XInc>, <nStyle>, <nColor> )^U

^U<nX>^U
X origin for the graph.

^U<nY>^U
Y origin for the graph.

The X, Y coordinate pair locate the bottom left corner of the 
graph. dGE's coordinate system is described under the entry for 
SetVer().

^U<nXInc>^U
Selects either fixed or variable increments along the X axis.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        > 0     Points are spaced nXInc apart along the X
                axis.
          0     Points are drawn in scatter format.
                Positions along the X axis are variable, 
                each set by the third argument 
                (nXPosition) passed to DataStore().

^U<nStyle>^U
Graph style.

        Value   Meaning
        컴컴   컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
          0     Chained lines. The line style is
                determined by the value for nMark when
                the data was stored. Normally a graph
                will use a consistent line style, but it
                is not necessary that it does. If each
                point is stored with a different value
                for nMark, then that value determines the
                style of line drawn between the current
                and next point.

          1     Symbols. The icon used as a symbol is
                determined by the value for nMark when
                the data was stored. A different icon
                code may be stored for each data point.
                
          2     Chained lines and symbols. Lines are 
                solid. The icon used as a symbol is 
                determined by the value for nMark when 
                the data was stored.
                
          3     Vertical sticks. A solid line is drawn 
                from the X axis to the data point.
                
        + 4     Thick lines. The line connecting points 
                is by default one pixel wide. This option 
                doubles the thickness.
                
        + 8     Icons are XORed. This allows animation 
                since a graph can be successively deleted 
                and redrawn without destroying the 
                background.

^U<nColor>^U
Foreground color, 0 to (nColors - 1) where nColors is the value 
returned by GetVideo(6). See the entry for SetRGBPal().

^BRemarks^B
When nXInc is zero, the graph is drawn in scatter format, using 
variable X position data stored with each amplitude value. This 
makes possible a variety of specialized graph types, among them 
the Step graph. To draw a Step graph, simply store the same X 
position data with two successive points.

^BExample^B
*::::::::::::::::::::::::::::::::::::::::::::::::::::
*                  XY.PRG
* This example draws a normal X-Y graph and a log/lin
* graph from the same data. It also illustrates an
* occasion where a log/lin graph is probably more
* appropriate for the data.
*::::::::::::::::::::::::::::::::::::::::::::::::::::

PROCEDURE MAIN
  DECLARE aData[11], aLabels[11]

  SET SCOREBOARD OFF
  CLEAR SCREEN
  SET CURSOR OFF

  * Fill arrays with data.
  FOR i = 1 TO LEN(aData)
      aData[i] = 2**(i + 1)
      aLabels[i] = LTRIM(STR(i + 1))
  NEXT i

  * Set graphics mode
  r = SetHiRes(0)

  * Draw a normal X-Y graph.
  r = GraphXY(100, 300, 450, aData, aLabels)

  * Draw a log/lin graph.
  r = GraphLog(800, 300, 450, aData, aLabels)

  r = INKEY(0)

  * Set the screen back to text mode
  r = SetText()
  QUIT

*::::::::::::::::::: END OF MAIN ::::::::::::::::::::

FUNCTION GraphXY
      PARAMETERS nX0, nY0, nHeight, aXYData, aXLabels

      * Define style options
      nAxisClr = 15
      nAxisStyle = 40
      nLineClr = 12
      nLineStyle = 2

      * Store data in dGE's internal array.
      r = DataReset()
      nMin = aXYData[1]
      nMax = aXYData[1]

      FOR i = 1 TO LEN(aXYData)
         r = DataStore(aXYData[i], 1, 0, 0)
         * Capture the min and max values.
         IF aXYData[i] > nMax
            nMax = aXYData [i]
         ENDIF

         IF aXYData[i] < nMin
            nMin = aXYData[i]
         ENDIF
      NEXT i

      * X Axis
      nXLen = ROUND(nHeight * 1.14, 0)
      nXDivs = LEN(aXYData) - 1  && Number of divisions
      nXInc = nXLen / nXDivs     && Calculate interval

      * Y Axis

      * Calculate intervals.
      *-------------------------------------------
      * If the max value is 500 and the min is 100,
      * then ticks will be at intervals of 100.
      * If the max value is 500 and the min is 10,
      * then ticks will be at intervals of 10.
      * If the max valus is 500 and the min is 1,
      * then ticks will be at intervals of 100.
      *-------------------------------------------

      nMax10 = INT(GetLog10(nMax)) && Count powers of 10
      nMin10 = INT(GetLog10(nMin)) && Count powers of 10

      IF nMax10 = nMin10          && Calculate increment
         nYInc = INT(10**nMax10)
      ELSE
        nYInc = INT(10**(nMax10 - nMin10))
      ENDIF

      * Calculate number of divisions
      nYDivs = INT(nMax / nYInc) + 1

      * Scale data to fit height.
      nScale = INT(nHeight / (nYInc * nYDivs) * 100)
      r = DataPc(nScale)

      * Load labels for the Y axis in an array
      DECLARE  aYLabels[nYDivs + 1]
      FOR i = 1 TO nYDivs + 1
         aYLabels[i] = LTRIM(STR((i - 1) * nYInc))
      NEXT i

      * Draw the labels, axes, and the graph.
      r = LabelX(nX0, nY0, nXInc, 0, 1, 128, ;
                 nAxisClr, aXLabels)
      r = LabelY(nX0, nY0, nHeight / nYDivs, ;
                 0, 1, 16, nAxisClr, aYLabels)
      r = XYAxes(nX0, nY0, nXLen, nHeight, nXDivs, ;
                 nYDivs, nAxisStyle, nAxisClr)
      r = XYGraph(nX0, nY0, nXInc, nLineStyle, nLineClr)

RETURN 0

FUNCTION GraphLog
      PARAMETERS nX0, nY0, nHeight, aXYData, aXLabels

      * Define style options
      nAxisClr = 15
      nGridClr = 7
      nAxisStyle = 40
      nLineClr = 12
      nLineStyle = 2

      * X Axis
      nXLen = ROUND(nHeight * 1.14, 0)
      nXDivs = LEN(aXYData) - 1  && Number of divisions
      nXInc = nXLen / nXDivs     && Calculate interval

      * Y Axis

      * Find the min and max values.
      nMin = aXYData[1]
      nMax = aXYData[1]
      FOR i = 1 TO LEN(aXYData)
         IF aXYData[i] > nMax
            nMax = aXYData [i]
         ENDIF

         IF aXYData[i] < nMin
            nMin = aXYData[i]
         ENDIF
      NEXT i 

      * Calculate the base value.
      nBase10 = INT(GetLog10(nMin) + 1000) - 1000
      nBase = 10**nBase10

      * Calculate the number of cycles.
      nCycles = INT(GetLog10(nMax) - 1000) + ;
                1000 - GetLog10(nBase)

      * Calculate cycle height based on height of graph.
      nCycleHt = nHeight / nCycles

      * Store data in dGE's internal array.
      r = DataReset()
      FOR i = 1 TO LEN(aXYData)
         r = LogData(aXYData[i], 0, 0, nCycleHt, nBase)
      NEXT i 

      * Load labels for the Y axis in an array
      DECLARE  aYLabels[nCycles + 1]
      FOR i = 0 TO nCycles
         aYLabels[i + 1] = ;
            LTRIM(STR(INT(10**(nBase10 + i))))
      NEXT i

      * Draw the labels, grid, axes, and the graph.
      * (Labels first, to avoid overwriting tick marks.)
      r = LabelX(nX0, nY0, nXInc, 0, 1, 128,   ;
                nAxisClr, aXLabels)
      r = LabelY(nX0, nY0, nCycleHt, 0, 1, 16, ;
                 nAxisClr, aYLabels)

      r = LogGrid(nX0, nY0, nHeight, nXLen, nCycles, ; 
                  1, 1, nGridClr)
      r = XYAxes(nX0, nY0, nXLen, nHeight, nXDivs,   ;
                 1, 0, nAxisClr)

      r = LogAxis(nX0, nY0, nHeight, 10, nCycles,    ; 
                  1, 0, nAxisClr)
      r = XYGraph(nX0, nY0, nXInc, nLineStyle, nLineClr)

RETURN 0

!seealso: "LogData()" "LogAxis()" "XYAxes()" "LabelX()" "LabelY()" 
'------------------------------------------------------------------------------



