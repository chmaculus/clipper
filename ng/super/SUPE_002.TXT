!short:NBR2STR()             Correctly orders numerics where negative
'------------------------------------------------------------------------------
 FUNCTION NBR2STR()

  Short:
  ------
  NBR2STR() Correctly orders numerics where negative

  Returns:
  --------
  String

  Syntax:
  -------
  NBR2STR(nNumber)

  Description:
  ------------
  Ensure numeric fields are correctly ordered when
  converting to type character and when taking negatives into account.

  This is done by attaching CR, DB or CZ to the end of
  the number to overcome the placement of (-+) in the ASCII scale.

  Examples:
  ---------
   index on LASTNAME+NBR2STR(amount_due) to NEWINDEX

  Source:
  -------
  S_NBR2ST.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:NBR2STR()             Correctly orders numerics where negative
'------------------------------------------------------------------------------
 FUNCTION NBR2STR()

  Short:
  ------
  NBR2STR() Correctly orders numerics where negative

  Returns:
  --------
  String

  Syntax:
  -------
  NBR2STR(nNumber)

  Description:
  ------------
  Ensure numeric fields are correctly ordered when
  converting to type character and when taking negatives into account.

  This is done by attaching CR, DB or CZ to the end of
  the number to overcome the placement of (-+) in the ASCII scale.

  Examples:
  ---------
   index on LASTNAME+NBR2STR(amount_due) to NEWINDEX

  Source:
  -------
  S_NBR2ST.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:NKEY()                Gets key of an index file
'------------------------------------------------------------------------------
 FUNCTION NKEY()

  Short:
  ------
  NKEY() Gets key of an index file

  Returns:
  --------
  <cKey> => index key expression

  Syntax:
  -------
  NKEY(cIndex)

  Description:
  ------------
  Gets key expression of index <cIndex>. <cIndex> is
  the name of the index including extension. The function operates
  differently from .ntx to .ndx.

  Examples:
  ---------
   for i = 1 to nIndexes

       ?"Key for index: "+aInd[i]+" is "+NKEY(aInd[i])

   next

  Warnings:
  ----------
  Uses up a file handle temporarily. Opens up the index
  with low level file functions.

  Notes:
  -------
  NKEY() expects the full path of the index file and if
  no path is passed, will use SET DEFAULT setting

  Source:
  -------
  S_NKEY.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:NOZDIV()              Prevents divide-by-zero
'------------------------------------------------------------------------------
 FUNCTION NOZDIV()

  Short:
  ------
  NOZDIV() Prevents divide-by-zero

  Returns:
  --------
  <nNumber> => division result

  Syntax:
  -------
  NOZDIV(nNumber)

  Description:
  ------------
  Prevents divide-by-zero by converting a number to 1
  if it is zero, otherwise leaving it as-is.

  Not really needed in 5.01, but here for backward
  compatibility.

  Examples:
  ---------
   x = 5
   y = 0

   z = x/NOZDIV(y)

  Source:
  -------
  S_NOZDIV.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:OLD()          ^b(new)^n  On Line Documentation - TOPIC oriented help system
'------------------------------------------------------------------------------
 FUNCTION OLD()                                *new*

  Short:
  ------
  OLD()  On Line Documentation - TOPIC oriented help system

  Returns:
  --------
  NIL

  Syntax:
  -------
  OLD()

  Description:
  ------------
  This is ON LINE DOCUMENTATION , similiar to NG or Windows help.
  There are no parameters, but it has a couple of additional
  exported functions that allow TOPIC selection and DEVELOPMENT

  The documentation is stored in a DBF database, with one
  record per TOPIC. A TOPIC has a TITLE, stored in the TOPIC field,
  a variable length TEXT entry (can be as long as needed) stored in the
  TEXT field, and hotlinks stored in the KEYS field, which link the TOPIC
  to other topics via a (S)ee also button.

  The options available to the user are:

    (C)ontents   -- go to the CONTENTS screen, a sort of index or
                    table of contents to the topics in the database
    (S)ee also   -- select from related topics
    (O)ther      -- not yet used
    (B)ack       -- go to previous screen

  The DBF structure is TOPIC C 35
                       KEYS  M
                       TEXT  M


  Additional Exported Functions:

  OLD_DEV(bDevelopMent)
      Where bDevelopment is a proc called during development
      of the doc system. Always pass {||OLD_MOD()} to enable
      development, and NIL to disable development. When development
      is active, a prompt called (M)odify appears at the bottom
      of the screen, allowing CREATION, EDITING, DELETING and
      LINKING of topics.

      The options avaialable to the developer are:

       Add Topic                 - create a new TOPIC record
       Edit Topic                - edit the current TOPIC record
       Delete Topic              - delete the current TOPIC record
       Modify SEEALSOs           - add/delete See Also references
       Generate CONTENTS record  - generate the CONTENTS record
                                   either by tagging selected TOPICS
                                   or using ALL topics



  OLD_TOPIC(cTopic)
      This sets the current TOPIC for OLD(). For instance, on
      entry into QUERY(), you could call OLD_TOPIC("QUERY BY EXAMPLE").
      Presuming you had a TOPIC defined called "QUERY BY EXAMPLE",
      this is what would come up when OLD() was called or activated
      with a hotkey.

      Call OLD_TOPIC("") to clear the topic. The default topic is
      the CONTENTS page.

  Examples:
  ---------
  For development:
       OLD_DEV({||OLD_MOD()})
       OLD()
  For distribution, simply comment out the OLD_DEV() call.

  For hotkey activation:
      SETKEY(K_WHATEVER,{||OLD()}  )


  When in a particular part of the program:
       OLD_TOPIC("TOPIC NAME...")
  to activate a particulat topic.

  Notes:
  -------
  There's no reason this couldn't be used alongside of the
  traditional Clipper context sensitive 'field level' help.


  Source:
  -------
  S_OLD.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:ONE_READ()            Pop-up window with 1-4 Say/Get combinations
'------------------------------------------------------------------------------
 FUNCTION ONE_READ()

  Short:
  ------
  ONE_READ() Pop-up window with 1-4 Say/Get combinations

  Returns:
  --------
  Nothing

  Syntax:
  -------
  ONE_READ(cSay,cGetName,cPicture,...)

  Description:
  ------------
  For 1-4 iterations of <cSay..cPicture>, a popup
  window will display a Say <cSay>, do a Get on the variable named in
  <cGetNAme> with a Picture of <cPicture>. A read will then be
  issued.

  This is here for compatibility. POPREAD() provides a
  cleaner solution.

  NOTE: the variables named in <cGetName> CANNOT be
  local or static.

  Examples:
  ---------
   dDate := date()
   cTime := space(8)
   lFun  := .t.

   ONE_READ("Current Date","dDATE","@D",;
       "Current Time","cTIME","99:99:99",;
       "Having Fun ?","lFUN","Y")

  Notes:
  -------
  This is here only for compatibility with older
  versions. Next release, it will cease to be.

  See POPREAD() for a better implementation.

  Source:
  -------
  S_ONER.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:OPENIND()             Opens an array of indexes
'------------------------------------------------------------------------------
 FUNCTION OPENIND()

  Short:
  ------
  OPENIND() Opens an array of indexes

  Returns:
  --------
  Nothing

  Syntax:
  -------
  OPENIND(aIndexNames)

  Description:
  ------------
  Opens up the indexes named in <aIndexNames>

  Examples:
  ---------
   aIndexes := {"CUSTOMER","PRODUCT","PAYDATE"}

   OPENIND(aIndexes)

  Source:
  -------
  S_OPENIN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PARSALIAS()           Extracts the name of the alias from an expression
'------------------------------------------------------------------------------
 FUNCTION PARSALIAS()

  Short:
  ------
  PARSALIAS() Extracts the name of the alias from an expression

  Returns:
  --------
  <cAlias> => name of the alias

  Syntax:
  -------
  PARSALIAS(cExpress)

  Description:
  ------------
  Returns the ALIAS part of cExpress. If <cExpress> is
  not prefaced

  with an alias ( XXXX-> ) the current ALIAS() is
  returned.

  Examples:
  ---------
   cExpr := "CUSTOMER->LASTNAME"

   IF ISFIELD(cExpr)
     ?PARSALIAS(cExpr)  // displays CUSTOMER
     ?PARSFIELD(cExpr)  // displays LASTNAME
   ENDIF

  Warnings:
  ----------
  Does not verify if this is a valid field. Use
  ISFIELD().

  Source:
  -------
  S_FIELDS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PARSFIELD()           Extracts the name of the field from an expression
'------------------------------------------------------------------------------
 FUNCTION PARSFIELD()

  Short:
  ------
  PARSFIELD() Extracts the name of the field from an expression

  Returns:
  --------
  <cField> => name of the field

  Syntax:
  -------
  PARSFIELD(cExpress)

  Description:
  ------------
  Returns the field name part of cExpress

  Examples:
  ---------
   cExpr := "CUSTOMER->LASTNAME"

   IF ISFIELD(cExpr)
     ?PARSALIAS(cExpr)  // displays CUSTOMER
     ?PARSFIELD(cExpr)  // displays LASTNAME
   ENDIF

  Warnings:
  ----------
  Does not verify if this is a valid field. Use
  ISFIELD().

  Source:
  -------
  S_FIELDS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PICKNDX()             Allows user to select indexes to open
'------------------------------------------------------------------------------
 FUNCTION PICKNDX()

  Short:
  ------
  PICKNDX() Allows user to select indexes to open

  Returns:
  --------
  <nSelected> => number of indexes selected

  Syntax:
  -------
  PICKNDX(aIndexes)

  Description:
  ------------
  Allows the user to point and shoot index selection.

  [aIndexes] is an array to fill with index names. It
  can be of any size, including {}. It is set back to {}
  before selection

  Examples:
  ---------
   aIndexes := {}
   nPicked  := pickndx(aIndexes)

  Source:
  -------
  S_PICKND.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PICKREADER()          Creates specialized picklist reader block
'------------------------------------------------------------------------------
 FUNCTION PICKREADER()

  Short:
  ------
  PICKREADER() Creates specialized picklist reader block

  Returns:
  --------
  <bReader> => get reader block for GET

  Syntax:
  -------
  PICKREADER(aValues,[nTop,nLeft],[nBottom,nRight])

  Description:
  ------------
  Creates a get reader block that is a popup list from
  the array <aValues>.

  Implement by using the SEND keyword for your
  @Say..Get.. statements.

    i.e. @10,10 say blah get blahblah SEND reader:=PICKREADER(aValues)

  <aValues> is an array of values that are of the same
  type and length as the GET.

  [nTop,nLeft] optional top, left coordinates

  [nBottom,nRight] optional bottom/right coordinates

  Examples:
  ---------
   // while in the get V1, you will be presented with a picklist
   // of aValues.

   aValues := {"Section 1","Section 2","Section 3"}
   v1 := "Section 1"
   @10,10 get v1 send reader := pickreader(aValues,10,10)

   READ

  Source:
  -------
  S_READRS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PLSWAIT()             Pops up a 'Please Wait' window or removes it
'------------------------------------------------------------------------------
 FUNCTION PLSWAIT()

  Short:
  ------
  PLSWAIT() Pops up a 'Please Wait' window or removes it

  Returns:
  --------
  Nothing

  Syntax:
  -------
  PLSWAIT(lOnOff,[cMessage],[nTop,nLeft,nBottom,nRight])

  Description:
  ------------
  Pops up a window with a 'please wait' message or
  removes a previous 'please wait' window.

  <lOnOff> True means show popup window, False means
  remove window.

  [cMessage] - message. Default is 'Please wait...'

  [nTop,nLeft,nBottom,nRight] box coordinates. Defaults
  are 10,20,12,60.

  Examples:
  ---------
   PLSWAIT(.T.,"I'm thinking...")

   // code here

   PLSWAIT(.F.)   // remove plswait message

  Source:
  -------
  S_PLSW.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PMREADER()            Creates specialized PLUS/MINUS get reader block
'------------------------------------------------------------------------------
 FUNCTION PMREADER()

  Short:
  ------
  PMREADER() Creates specialized PLUS/MINUS get reader block

  Returns:
  --------
  <bReader> => get reader block for GET

  Syntax:
  -------
  PMREADER()

  Description:
  ------------
  Creates a get reader block that allows
  increment/decrement of date of numeric values with the plus or minus key.

  Implement by using the SEND keyword for your
  @Say..Get.. statements.

    i.e. @10,10 say blah get blahblah SEND reader:=PMREADER()

  Examples:
  ---------
   // while in the get V1, you will be able to use the +-  keys to
   // increase/decrease the value of V1

   v1 := 100
   @10,10 get v1 SEND reader := pmreader()
   READ

  Source:
  -------
  S_READRS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:POPCOLSEL()           Popup color grid for selecting a single color
'------------------------------------------------------------------------------
 FUNCTION POPCOLSEL()

  Short:
  ------
  POPCOLSEL() Popup color grid for selecting a single color

  Returns:
  --------
  <cColor> => selected color

  Syntax:
  -------
  POPCOLSEL([cStartCol])

  Description:
  ------------
  Pops up a grid for selecting a single color (W/N,
  +R/W, etc).

  If SETBLINK() is set to .f., high intensity
  background colors are available, otherwise not.

  [cStartCol] is an optional starting color, which
  defaults to setcolor().

  If ESCAPE is pressed, the starting color is returned.

  Examples:
  ---------
   setblink(.f.)
   initsup()
   cNewColor := popcolsel()

  Source:
  -------
  S_PCSEL.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:POPEX()               Pops up an achoice for a certain filespec
'------------------------------------------------------------------------------
 FUNCTION POPEX()

  Short:
  ------
  POPEX() Pops up an achoice for a certain filespec

  Returns:
  --------
  <cFileName> => file name or "" for none

  Syntax:
  -------
  POPEX(cSkel,[cTitle])

  Description:
  ------------
  Pops up a picklist for all files matching the
  skeleton given as <cSkel>. i.e. "*.dbf"

  If a path is passed, the path is returned as part of
  the filename.

  Optional title string [cTitle] - displays at top of
  box

  Examples:
  ---------
   cOpendbf := POPEX("*.DBF")
       // => will return DBF name

   opendbf = POPEX("C:\FILES\*.DBF")
       // => will return "C:\FILES\" plus DBF name

  Source:
  -------
  S_POPEX.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:POPMONTH()            Popup month selection
'------------------------------------------------------------------------------
 FUNCTION POPMONTH()

  Short:
  ------
  POPMONTH() Popup month selection

  Returns:
  --------
  <nMonth> => number of the month selected

  Syntax:
  -------
  POPMONTH([nStart])

  Description:
  ------------
  Popup a picklist of months January -
  December.[nStart] is a month 1 - 12

  Examples:
  ---------
   nMonth := POPMONTH()

  Source:
  -------
  S_DPOPS.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:POPREAD()             Pops up a box with 1-5 say-get combinations
'------------------------------------------------------------------------------
 FUNCTION POPREAD()

  Short:
  ------
  POPREAD() Pops up a box with 1-5 say-get combinations

  Returns:
  --------
  nothing

  Syntax:
  -------
  POPREAD(lStacked,[nTop,nLeft,cColor],cSay,@expGet,cPicture...)

  Description:
  ------------
  [lStacked]   .t. = GETS are displayed below SAYS,
               .f. = GETS are displayed beside SAYS (default)

  [next 3 params may be option params - see below]

  For 1-5 iterations of  [cSay,@expGet,cPicture]  a
  popup window will display a Say <cSay>, do a Get on the variable
  passed by reference in <@expGet> with a Picture of <cPicture>. A
  read will then be issued.

  If params 2,3 and 4 are passed as Numeric/Numeric/Chr
  then they are evaluated as the top,left and color for the popup
  box.

  [nTop] = top
  [nLeft] = left
  [cColor] = color string

  Examples:
  ---------
   dDate := date()
   cTime := space(8)
   lFun  := .t.

   POPREAD(.t.,"Current Date",@dDATE,"@D",;
       "Current Time",@cTIME,"99:99:99",;
       "Having Fun ?",@lFUN,"Y")

  Notes:
  -------
  This is an intelligent version of ONE_READ. 2nd param
  is passed by reference rather than by name - cutting down
  DRASTICALLY on the macro expansion and greatly simplifying the
  code. To pass by reference, preface the parameter with @.

  Source:
  -------
  S_POPR.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:POPUPDIR()            Popup of a given directory for file selection
'------------------------------------------------------------------------------
 FUNCTION POPUPDIR()

  Short:
  ------
  POPUPDIR() Popup of a given directory for file selection

  Returns:
  --------
  <cFileName> => name of the file selected

  Syntax:
  -------
  POPUPDIR([cSpec,cAttrib,cTitle,cColor,lAllowView])

  Description:
  ------------
  Displays a popup of the directory specified, for
  selection of a file.

  The name of the file selected is returned. You may
  indicate optional file viewing.

  [cSpec] specifies the drive, directory and file
  specification

  Wildcards are allowed. Default is "*.*", current
  drive, current dir.

  [cAttrib] is a string containing file attribute
  symbols for inclusion of special file types. The symbols are:

     H                     Include hidden files
     S                     Include system files
     D                     Include directories
     V                     Search for the DOS volume label and exclude
                           all other files

  [cTitle] a string to be displayed on the top of the
  popup box. Default is

  "Directory Viewer"

  [cColor] color of the box. Default is sls_normcol()

  [lAllowView]  if True, allows Alt-V to view the
  currently highlited file. A DBF is browsed, a text file is viewed with
  FILEREAD().

  Default is False.

  Examples:
  ---------
   cFileName := POPUPDIR("c:\windows\*.INI",nil,nil,nil,.t.)

  Source:
  -------
  S_POPDIR.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:POPUPKCLR()           Clears GET hotkey popups set up with POPUPKSET()
'------------------------------------------------------------------------------
 FUNCTION POPUPKCLR()

  Short:
  ------
  POPUPKCLR() Clears GET hotkey popups set up with POPUPKSET()

  Returns:
  --------
  Nil

  Syntax:
  -------
  POPUPKCLR()

  Description:
  ------------
  Clears GET hotkey popups set up with POPUPKSET()

  See POPUPKSET()

  Examples:
  ---------
   POPUPKCLR()

  Source:
  -------
  S_POPUPK.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:POPUPKSET()           Set a popup for hotkey access from a GET
'------------------------------------------------------------------------------
 FUNCTION POPUPKSET()

  Short:
  ------
  POPUPKSET() Set a popup for hotkey access from a GET

  Returns:
  --------
  Nil

  Syntax:
  -------
  POPUPKSET(nKey,cProc,cVar,bPopup)

  Description:
  ------------
  When key <nKey> is pressed while in proc or function
  <cProc> and in get/variable <cVar>, the block <bPopup> will be
  evaluated.

  If <bPopup> returns a value, it will be assigned to
  the current get.

  Be sure to clear popups with POPUPKCLR() after the
  READ.

  Examples:
  ---------
   #include "inkey.ch"

   proc test
   b1 := {||msg("Character value"),"Bert"}
   b2 := {||msg("Logical value"),.t.}
   b3 := {||msg("Date value"),date()+100}
   b4 := {||msg("Number value"),123}

   v1 := space(10)
   v2 := .f.
   v3 := ctod("  /  /  ")
   v4 := 0

   POPUPKSET(K_F1,"TEST","V1",b1)
   POPUPKSET(K_F2,"TEST","V2",b2)
   POPUPKSET(K_F3,"TEST","V3",b3)
   POPUPKSET(K_F4,"TEST","V4",b4)

   @14,10 get v1      // if F1 is pressed here, b1 will be evaluated
   @15,10 get v2      // if F2 is pressed here, b2 will be evaluated
   @16,10 get v3      // if F3 is pressed here, b3 will be evaluated
   @17,10 get v4      // if F4 is pressed here, b4 will be evaluated

   read

   POPUPKCLR()

  Source:
  -------
  S_POPUPK.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:POPUPVALID()          Allows use of a popup for a GET VALID clause
'------------------------------------------------------------------------------
 FUNCTION POPUPVALID()

  Short:
  ------
  POPUPVALID() Allows use of a popup for a GET VALID clause

  Returns:
  --------
  <lValid> => valid condition, get post-validation

  Syntax:
  -------
  POPUPVALID(bPopup,[bValid])

  Description:
  ------------
  This sets up a popup in <bPopup> for use in a GET
  VALID clause. (the post validation block). If a value is returned
  from the popup, it is assigned to the get.The popup function will pop
  up upon exit from the GET field.

  <bPopup> is a codeblock that is evaluated. It is
  passed the current value in the get as a parameter.

  [bValid]  - If you pass a validation codeblock, it
  will be checked first. If the GET is already valid, according to
  the codeblock, the popup will not be popped up. The codeblock
  must return a logical value.

  Examples:
  ---------

   // these are codeblocks that do a popup (in this case, a  simple
   //call to msg, and a return of a value)

   b1 := {||msg("Character value"),"Bert"}
   b2 := {||msg("Logical value"),.t.}
   b3 := {||msg("Date value"),date()+100}
   b4 := {||msg("Number value"),123}

   v1 := space(10)
   v2 := .f.
   v3 := ctod("  /  /  ")
   v4 := 0

   // these are added in as valid clauses to the gets. The <bValid>
   // param is a codeblock that checks for the value being empty.

   @14,10 get v1 valid POPUPVALID(b1,{||!empty(v1)})
   @15,10 get v2 valid POPUPVALID(b2,{||!empty(v2)})
   @16,10 get v3 valid POPUPVALID(b3,{||!empty(v3)})
   @17,10 get v4 valid POPUPVALID(b4,{||!empty(v4)})

   read

  Source:
  -------
  S_POPVW.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:POPUPWHEN()           Allows use of a popup for a GET WHEN clause
'------------------------------------------------------------------------------
 FUNCTION POPUPWHEN()

  Short:
  ------
  POPUPWHEN() Allows use of a popup for a GET WHEN clause

  Returns:
  --------
  <lWhen> => when condition, get pre-validation

  Syntax:
  -------
  POPUPWHEN(bPopup,[lShowonUp],[lReturn])

  Description:
  ------------
  This sets up a popup in <bPopup> for use in a GET
  WHEN clause. (the pre validation block). If a value is returned
  from the popup, it is assigned to the get.

  <bPopup> is a codeblock that is evaluated. It is
  passed the current value in the get as a parameter.

  The popup function will pop up upon entry into a GET
  field.

  [lShowOnUp] Normally you wouldn't want this WHEN to
  occur if the user is using the up arrow, and if <lShowOnUp> is
  .f. (the default) it does not occur (the GET is just skipped)

  [lReturn] If set to False (the default) the GET is
  never actually edited, as the WHEN will always return .f., but it is
  assigned the value returned by the popup. By setting it to True,
  the Calendar will pop up, and then the GET will also be put
  through the normal get editor.

  Examples:
  ---------
   // these are codeblocks that do a popup (in this case, a  simple
   //call to msg, and a return of a value)

   b1 := {||msg("Character value"),"Bert"}
   b2 := {||msg("Logical value"),.t.}
   b3 := {||msg("Date value"),date()+100}

   v1 := space(10)
   v2 := .f.
   v3 := ctod("  /  /  ")

   @10,10 get v1 when POPUPWHEN(b1,.f.,.t.)
   @11,10 get v2 when POPUPWHEN(b2,.f.,.t.)
   @12,10 get v3 when POPUPWHEN(b3,.f.,.t.)

   READ

  Source:
  -------
  S_POPVW.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:POPVDATE()            Pops up a picklist of virtual dates
'------------------------------------------------------------------------------
 FUNCTION POPVDATE()

  Short:
  ------
  POPVDATE() Pops up a picklist of virtual dates

  Returns:
  --------
  <dSelected> => selected date

  Syntax:
  -------
  POPVDATE([dStart],[lWords],[cTitle])

  Description:
  ------------
  Pops up a virtual picklist of dates, beginning with
  the current date. As user scrolls down, date increases. As user
  scrolls up, date decreases. Page up/Page down move by 30 day
  increments. Ctrl-Pgup/Ctrl-Pgdn move by 365 day increments. Home
  key returns to the starting date.

  [dStart] the starting date, today's date by default

  [lWords] show dates as words, False by default

  [cTitle] popup box title, none by default

  Examples:
  ---------
   dDate := POPVDATE(date(),.t.,"Pick a Date")

  Source:
  -------
  S_DPOPS.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:POPVYEAR()            Pops up a picklist of virtual years
'------------------------------------------------------------------------------
 FUNCTION POPVYEAR()

  Short:
  ------
  POPVYEAR() Pops up a picklist of virtual years

  Returns:
  --------
  <nSelected> => selected year

  Syntax:
  -------
  POPVYEAR([cTitle])

  Description:
  ------------
  Pops up a virtual picklist of years, beginning with
  the current year. As user scrolls down, year increases. As user
  scrolls up, year decreases. Home key returns to the starting
  year.

  [cTitle]  is a popup box title, none by default

  Examples:
  ---------
   nYear := POPVYEAR("Pick a Year")

  Source:
  -------
  S_DPOPS.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:PRNPORT()             Determine Printer Port to use
'------------------------------------------------------------------------------
 FUNCTION PRNPORT()

  Short:
  ------
  PRNPORT() Determine Printer Port to use

  Returns:
  --------
  <cPort> => port chosen

  Syntax:
  -------
  PRNPORT([cPort1],[cPort2]..[cPort9])

  Description:
  ------------
  Allows user to select printer port for SET PRINTER TO
  output. Printer is set to this port

  [cPort1-9] are valid SET PRINTER TO strings

  LPT1 LPT2 LPT3 COM1 COM2 COM3 COM4 <FILENAME>

  Default is "LPT1","LPT2","LPT3"

  Examples:
  ---------
   cTheport := PRNPORT("LPT1","COM1")

  Source:
  -------
  S_PRNPOR.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:PRNT()                Writes a string of a given color at row, column
'------------------------------------------------------------------------------
 FUNCTION PRNT()

  Short:
  ------
  PRNT() Writes a string of a given color at row, column

  Returns:
  --------
  Nothing

  Syntax:
  -------
  PRNT(nRow, nColumn, cString, nColor)

  Description:
  ------------
  <nRow>       row

  <nColumn>    column

  <cString>    string

  <nColor>     color attribute

  Examples:
  ---------
   PRNT(10,10,"Hello there",47)  // +W/G

  Notes:
  -------
  Here mainly for compatibility with older version. Was
  previously a C function.


  Source:
  -------
  S_PRNT.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PRNTFRML()            Prints a formletter created by formletr()
'------------------------------------------------------------------------------
 FUNCTION PRNTFRML()

  Short:
  ------
  PRNTFRML() Prints a formletter created by formletr()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  PRNTFRML(cForm,[nPageWidth],[nLeftMargin])

  Description:
  ------------
  Prints the form <cForm> from FORMS.DBF with a
  pagewidth of [nPageWidth] and a left margin of [nLeftMargin]

  <cForm> is normally the contents of the template stored in FORMS.DBF
  (previous documentation refered to this parameter as the NAME of the
  form, which is incorrect.

  Examples:
  ---------
  This is used internally by FORMLETR() and FASTFORM().
  Refer to its usage there.

  SELECT 0
  USE FORM
  locate for descript = "MY FORM LETTER" // find letter
  cForm = form->memo_orig      // load contents
  USE
  SELECT MYDBF
  PRNTFRML(cForm,79)


  Source:
  -------
  S_PRNTF.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PROGCOUNT()           Perform a count with a progress box
'------------------------------------------------------------------------------
 FUNCTION PROGCOUNT()

  Short:
  ------
  PROGCOUNT() Perform a count with a progress box

  Returns:
  --------
  Nil

  Syntax:
  -------
  PROGCOUNT(expCondit,[cMessage],[lPause])

  Description:
  ------------
  Pops up a progress bar box with PROGON().
  Performs a COUNT on the current DBF using
  <expCondit> as the FOR condition. (can be passed as a
  codeblock or a string).

  [cMessage] is an optional box title for the progress
  box

  [lPause] if True will pause before removing the box
  with PROGOFF()- default is False.

  Examples:
  ---------

   use customer

   ProgCount("[S]$LNAME")
   ProgCount({||"S"$LNAME},"Counting",.t.)

  Source:
  -------
  S_PROG.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PROGDISP()            Displays progress bar in box created with PROGON()
'------------------------------------------------------------------------------
 FUNCTION PROGDISP()

  Short:
  ------
  PROGDISP() Displays progress bar in box created with PROGON()

  <quick descrip>

  Returns:
  --------
  <expReturn> => determined by several things

  Syntax:
  -------
  PROGDISP(nCurrent,nTotal,[bMessage],[bReturn])

  Description:
  ------------
  Updates a progress bar created with PROGON().

  <nCurrent> is the current item/position. <nTotal> is
  the total items. What is displayed is the percentage <nCurrent>
  is of <nTotal>.

  [bMessage] is an optional message line block, which
  is displayed

  on the bottom inside line of the box [bReturn] is an
  optional return value, with the default being  True

  Examples:
  ---------
   //---------- this just shows progress from 1 - 1000
   initsup()
   ProgOn("Test")
   for i = 1 to 1000
     IF !ProgDisp(i,1000,{||alltrim(str(i))+" of 1000"},;
            {||inkey()#27} )
       exit
     endif
   next
   ProgOff()

   //--------- this show indexing progress
   use Customer
   ProgOn("Index")
   dbcreateindex("Eraseme","(LNAME)", ;
    {||ProgDisp( recno(),recc() ),LNAME},.f.)
   ProgOff()
   // note the use of parentheses around LNAME.
   // see also PROGINDEX()

   //--------- this shows a count progress
   nCounted := 0
   nMatches := 0
   bDisplay := {||alltrim(str(nMatches))+" matches of "+;
             alltrim(str(nCounted)) }
   ProgOn("Counting")
   count for "S"$LNAME to ;
      nMatches while ProgDisp(++nCounted,recc(),bDisplay )
   ProgOff()
   // see also PROGCOUNT()

  Source:
  -------
  S_PROG.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PROGEVAL()            Perform a Database DBEVAL() with a progress box
'------------------------------------------------------------------------------
 FUNCTION PROGEVAL()

  Short:
  ------
  PROGEVAL() Perform a Database DBEVAL() with a progress box

  Returns:
  --------
  Nil

  Syntax:
  -------
  PROGEVAL(bBlock,expCondit,[cMessage],[bMessage],[lPause])

  Description:
  ------------
  Pops up a progress bar box with PROGON().

  Performs a DBEVAL() using <bBlock> as the first
  parameter, and <expCondit> as the FOR condition. (can be
  passed as a codeblock or a string).

  [cMessage] is an optional box title for the progress
  box

  [bMessage] is a codeblock which returns a string
  which will be displayed on the bottom inside line of the progress
  box for each record processed.

  [lPause] if True will pause before removing the box
  with PROGOFF()- default is False.

  Examples:
  ---------

   // here is a counting example
   nCount   := 0
   nScanned := 0
   bDisplay := {||alltrim(str(nCount))+" matches of "+;
                  alltrim(str(nScanned++))+" scanned"}
   ProgEval({||++nCount},"[S]$LNAME","Counting",bDisplay,.t.)

   // OR
   ProgEval({||++nCount},{||"S"$LNAME},"Counting",bDisplay,.t.)

  Notes:
  -------
  Look up on DBEVAL() and note that this function is
  the same, except it uses only the first two parameters.

  Source:
  -------
  S_PROG.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PROGINDEX()           Perform an index with a progress box
'------------------------------------------------------------------------------
 FUNCTION PROGINDEX()

  Short:
  ------
  PROGINDEX() Perform an index with a progress box

  Returns:
  --------
  Nil

  Syntax:
  -------
  PROGINDEX(cName,cKey,[lUnique],[lShowCount],[lPause])

  Description:
  ------------
  Pops up a progress bar box with PROGON().

  Performs an index using <cName> as the index name,
  and <cKey> as the index key.

  [lUnique] for index UNIQUE (default False)

  [lShowCount] to show an index count as well as the
  progress bar - default False

  [lPause] if True will pause before removing the box
  with PROGOFF()- default is False.

  Examples:
  ---------

   use customer
   ProgIndex("Eraseme","LNAME",.f.,.t.,.t.)

  Source:
  -------
  S_PROG.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PROGOFF()             Removes a progress bar box created by PROGON()
'------------------------------------------------------------------------------
 FUNCTION PROGOFF()

  Short:
  ------
  PROGOFF() Removes a progress bar box created by PROGON()

  Returns:
  --------
  Nil

  Syntax:
  -------
  PROGOFF()

  Description:
  ------------
  Removes the progress box placed on the screen by
  PROGON()

  Examples:
  ---------

   //---------- this just shows progress from 1 - 1000
   initsup()
   ProgOn("Test")
   for i = 1 to 1000
     ProgDisp(i,1000,{||alltrim(str(i))+" of 1000"} )
   next
   ProgOff()

   //---------- this shows indexing progress
   use Customer
   ProgOn("Index")
   dbcreateindex("Eraseme","(LNAME)",  ;
    {||ProgDisp( recno(),recc() ),LNAME},.f.)
   ProgOff()

  Source:
  -------
  S_PROG.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PROGON()              Initialize and display a progress bar box
'------------------------------------------------------------------------------
 FUNCTION PROGON()

  Short:
  ------
  PROGON() Initialize and display a progress bar box

  Returns:
  --------
  Nil

  Syntax:
  -------
  PROGON([cMessage])

  Description:
  ------------
  Places a progress box on the screen for use by
  PROGDISP()

  [cMessage] is an optional box title

  Examples:
  ---------

   //--------- this just shows progress from 1 - 1000
   initsup()
   ProgOn("Test")
   for i = 1 to 1000
     ProgDisp(i,1000,{||alltrim(str(i))+" of 1000"} )
   next
   ProgOff()

   //-------- this show indexing progress
   use Customer
   ProgOn("Index")
   dbcreateindex("Eraseme","(LNAME)",  ;
    {||ProgDisp( recno(),recc() ),LNAME},.f.)
   ProgOff()

  Source:
  -------
  S_PROG.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PROPER()              Capitalizes first letters of string, lowers rest
'------------------------------------------------------------------------------
 FUNCTION PROPER()

  Short:
  ------
  PROPER() Capitalizes first letters of string, lowers rest

  Returns:
  --------
  <cProper> => string properized

  Syntax:
  -------
  PROPER(cTarget)

  Description:
  ------------
  Capitalizes all first letters of words in <cTarget>
  and converts the rest to lowercase

  Examples:
  ---------
   cString := "SUPER liBraRy"

   cString := PROPER(string)

   // (returns "Super Library"

  Notes:
  -------
  There are cases where this just won't work - for
  instance I.B.M. would be converted to I.b.m.

  Source:
  -------
  S_PROPER.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PSTABMENU()           Popup tabular (grid style) )menu
'------------------------------------------------------------------------------
 FUNCTION PSTABMENU()

  Short:
  ------
  PSTABMENU() Popup tabular (grid style) )menu

  Returns:
  --------
  <nSelection> => Number of menu option selected

  Syntax:
  -------
  PSTABMENU(nTop,nLeft,nBottom,nRight,aPrompts,[cTitle],[nStart])

  Description:
  ------------
  Pops up a tabular (grid) menu based on an array of
  prompts passed

  as <aPrompts>. Dimensions of the menu table will be
  inside of the <nTop,nLeft,nBottom,nRight> dimensions for the popup
  box. Number of menu rows is the number of rows inside the box.
  Number of menu columns is determined based on number of rows.
  Prompts are layed out in a snaking fashion :

     e.g. (for a 3 row table...)
       column 1, row 1  = 1st prompt
       column 1, row 2  = 2nd prompt
       column 1, row 3  = 3rd prompt
       column 2, row 1  = 4th prompt

  Pressing a character will move to the next matching
  prompt with that first letter. Left-right and up-down perform a
  snaking pattern

  Pressing ENTER causes selection to be made, and the
  number of the selection to be returned.

  Pressing ESCAPE returns 0.

  [cTitle]  is a itle for the popup box

  [nStart]  is an optional starting option. Default is 1.

  Examples:
  ---------
   nChoice := pstabmenu(10,10,14,70,{"One","two","three","four",;
                        "five","six","seven","eight",;
                         "nine","ten","eleven","twelve"},"Select:")

  Source:
  -------
  S_TABMEN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PULLDN()              Pulldown menu creator, handler
'------------------------------------------------------------------------------
 FUNCTION PULLDN()

  Short:
  ------
  PULLDN() Pulldown menu creator, handler

  Returns:
  --------
  <nSelection> => Selection in the form menu.prompt
  (i.e. 2.04)

  Syntax:
  -------
  PULLDN(nSelection,aOptions,[aAttributes],[aColumns])

  Description:
  ------------
  Draws a pulldown menu with up to 8 separate boxes.
  Selection process starts with <nSelection>.

  Each element of <aOptions> defines a menu.

  A menu definition is a delimited string in the form:

        "TITLE:prompt:prompt:prompt"

  with up to 99 prompts per string.

  When a selection is made, the number of the selection
  is returned, in the form BOX.OPTION . So option 2 in box 3 would
  come back as 3.02.

  [aAttributes] is a box definition array. It is 7
  elements long and defines the following:

  Element:          1. <lDraw>      Draw top bar box? T/F
                    2. <cBarColor>  Top bar color
                    3. <cBoxColor>  Menu Box color
                    4. <cBoxFrame>  Menu Box frame
                    5. <nShadowPos> Menu Box shadow position
                               (0,1,3,7,9)
                    6. <nShadowAtt> Menu Box shadow attribute
                    7. <nBarRow>    Row to start menu bar

  [aColumns] is an array of title column positions to
  override the internal 'figerin algorithm.

  Examples:
  ---------
   aOptions := { "Datafiles:Use Datafile",;
                 "Indices:Select Indices:Index order",;
                 "Editing:Replacement:Tabular Edit",;
                 "Reporting:Build Query:Print Lists",;
                 "Other:List file:Change Directory",;
                 "Quit" }

   aAttrib := { .t.,;               // draw the top bar box
                'W/B,GR/R,,,W/N',;  // top bar color
                'W/B,N/R,,,W/N',;   // drop box color
                cSingle_frame,;     // drop box frame
                3,;                 // drop box shadow position
                8,;                 // drop box shadow  attribute
                0 }                 // row # of menu bar

   nSel  := 1.01
   do while .t.
       nSel := PULLDN(nSel,aOptions,aAttrib)
       do case
       CASE nSel = 0  && TRAP 0
           nSel = 1.01
       case nSel = 1
       case nSel = 2
       case nSel = 3
       case nSel = 4
       endcase
   enddo

  Warnings:
  ----------
  It takes some work to start all options and titles
  with a first letter that is unique so that first letter selection may
  take place.

  Notes:
  -------
  First letter selection takes place on the following
  priority: next matching element first letter, next matching box
  title first letter.

  Passing a menu array element with title only will
  result in no menu box, with the title being the only selection
  and returning a selection value of <MENU>.1.
  (i.e. a 'Quit' box)

  Source:
  -------
  S_PULLDN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:PURGEM()              Deletes records
'------------------------------------------------------------------------------
 FUNCTION PURGEM()

  Short:
  ------
  PURGEM() Deletes records

  Returns:
  --------
  Nothing

  Syntax:
  -------
  PURGEM()

  Description:
  ------------
  Deletes records of the currently opened DBF.

  Examples:
  ---------
   if lClean_em_up
       select 0
       use QUERIES
       PURGEM()
   endif

  Notes:
  -------
  This is intended for those small system files created
  by QUERY(), FORMLETR(), LISTER() etc.

  No PACKING is done.

  Source:
  -------
  S_PURGEM.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:P_RDYDELAY()          Sets/returns p_ready() 'seconds' variable
'------------------------------------------------------------------------------
 FUNCTION P_RDYDELAY()

  Short:
  ------
  P_RDYDELAY() Sets/returns p_ready() 'seconds' variable

  Returns:
  --------
  <nSeconds> => p_ready() seconds variable

  Syntax:
  -------
  P_RDYDELAY([nSeconds])

  Description:
  ------------
  P_READY() tries for 5 seconds by default to check the printer
  for readiness. This function retrieves/sets the variable that
  controls the # of seconds to try for.

  Examples:
  ---------
  P_RDYDELAY(10)

  Source:
  -------
  S_PREAD.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:P_READY()             Determines if printer is ready, prompts user
'------------------------------------------------------------------------------
 FUNCTION P_READY()

  Short:
  ------
  P_READY() Determines if printer is ready, prompts user

  Returns:
  --------
  <lReady> => True if printer is ready

  Syntax:
  -------
  P_READY([cPort])

  Description:
  ------------
  Checks for printer ready, and prompts user to ready
  the printer until it is ready, or until user presses escape to
  abort printing.

  P_READY() first looks at SLS_PRNC(), and if the
  value is .f., does no printer check and returns .t.

  [cPort] - LPT1 LPT2 LPT3
  Default is LPT1

  Examples:
  ---------
   if P_READY("LPT2")
     REPORT FORM yayaya TO PRINT
   ENDIF

  Notes:
  -------
  To stop P_READY() from checking the printer port (as
  it is imbedded in many SuperLib functions), call SLS_PRNC() with
  False. This turns printer checking off. (i.e. on a network)

  Source:
  -------
  S_PREAD.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:QFLDSTYPE()           Count # of fields of a given type or types
'------------------------------------------------------------------------------
 FUNCTION QFLDSTYPE()

  Short:
  ------
  QFLDSTYPE() Count # of fields of a given type or types

  Returns:
  --------
  <nCount> => number of fields of the specified type(s)

  Syntax:
  -------
  QFLDSTYPE(cTypes)

  Description:
  ------------
  <cTypes> is a string containing one or more field
  type symbols

  Valid symbols are:

           C   character
           N   numeric
           L   logical
           D   date
           M   memo

  If no fields of the specified type(s) exist, 0 will
  be returned

  Examples:
  ---------
   nMemos := AFIELDSTYPE("M")   // number of memo fields
   nNums  := AFIELDSTYPE("N")   // number of numeric fields
   nNums  := AFIELDSTYPE("LD")  // number of date and logical fields

  Source:
  -------
  S_AFTYPE.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:QUERY()               Popup Interactive query by example condition
'------------------------------------------------------------------------------
 FUNCTION QUERY()

  Short:
  ------
  QUERY() Popup Interactive query by example condition
  builder

  Returns:
  --------
  <cQuery> => macro expandable logical condition
  expression

  Syntax:
  -------
  QUERY([aFields,aDesc,aTypes],[cQuitTo],[lUseBuildex])

  Description:
  ------------
  A point and shoot condition builder. Complex
  conditions are allowed with multiple .and./.or. Called without
  parameters, all fields in the current dbf are presented for condition
  building.

  [aFields,aDesc,aTypes] give field array, field
  description and field types.These, if passed will be used in
  place of the default of all dbf fields. (pass all or none)

  [cQuitTo] is a 'quit to' phrase. Default exit option
  is 'Quit'. 'Quit to' phrase will be tacked to the end of this .
  i.e. "Quit"+quit_to  [ Quit to Report Writer ]

  [lUseBuildex] determines whether BUILDEX() expression
  builder will be available from QUERY(). Default is not.

  Examples:
  ---------
   USE CUSTOMER

   aFields := {"fname", "lname",  "mi" }
   aFdesc  := {"First", "Last",  "Middle" }
   aTypes  := {"C","C","C"}
   cFilt   := QUERY(aFields,aFdesc,aTypes,nil,.t.)

   count for &cFilt  to nCount

   // or (preferably)
   count for eval( sls_bquery() ) to nCount

  Notes:
  -------
  Query always stores the current query with the
  function SLS_QUERY(). Calling SLS_QUERY() will return the
  currently stored query string. SLS_BQUERY() returns the query as
  a codeblock. Remember to clear sls_query()/sls_bquery() when
  changing DBFs.

  Source:
  -------
  S_QUERY.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:QUIKREPORT()          Runtime pre-defined report printing module
'------------------------------------------------------------------------------
 FUNCTION QUIKREPORT()

  Short:
  ------
  QUIKREPORT() Runtime pre-defined report printing module

  Returns:
  --------
  Nothing

  Syntax:
  -------
  QUIKREPORT([cReportName])

  Description:
  ------------
  Presents a picklist of pre-defined reports and prints
  the selected one.

  [cReportName] name of the report to run - picklist is
  bypassed. For batches.

  Examples:
  ---------
   QUIKREPORT('Quarterly Hog Count')

  Warnings:
  ----------
  Requires DBF and indexes to be open

  Source:
  -------
  R_QUIKR.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:RAT_ELBHD()           Determines if left mouse button is held down
'------------------------------------------------------------------------------
 FUNCTION RAT_ELBHD()

  Short:
  ------
  RAT_ELBHD() Determines if left mouse button is held down

  Returns:
  --------
  <lHeldDown> => is LMB held down

  Syntax:
  -------
  RAT_ELBHD([nSeconds])

  Description:
  ------------
  Determines if left mouse button is held down by
  calling the ASM function RAT_LBHD() for [nSeconds]. Default is .1
  seconds.

  If the left mouse button is held down during that
  time frame, True is returned, else False is returned.

  Note: the ASM function RAT_LBHD() returns a logical
  value if the left mouse button is depressed RIGHT NOW, but
  does not take a duration of [nSeconds] into account, which is needed
  to determine if it is depressed and HELD DOWN.

  [nSeconds]  is optional seconds to test for. Default
  is .1 seconds.

  Examples:
  ---------
   if rat_elbhd()

     ?"While you were out:"

     ?"Left button was depressed and held down at"

     ??rat_eqmrow(),rat_eqmcol()

   endif

  Source:
  -------
  S_MOOSE.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:RAT_EQMCOL()          Returns mouse column at last press
'------------------------------------------------------------------------------
 FUNCTION RAT_EQMCOL()

  Short:
  ------
  RAT_EQMCOL() Returns mouse column at last press

  Returns:
  --------
  <nRow> => mouse column at last button press (left or
  right)

  Syntax:
  -------
  RAT_EQMCOL()

  Description:
  ------------
  Returns mouse column at last press (LEFT OR RIGHT).
  S_MOOSE.PRG has two static variables, 'mouserow' and 'mousecol'.
  These are set each time RAT_EVENT() determines that the mouse
  has been depressed.

  Examples:
  ---------
   e := 0

   while e#27
      e := rat_event(30)
      do case
      case e == 0
        ? "Timed out after 30 seconds"
      case e < 400
        ? "Key press with inkey() value of :",e
      case e == 400
        ? "Left mouse button pressed at :"
        ?? "row-> ",rat_eqmrow()
        ?? "col-> ",rat_eqmcol()
      case e == 500
        ? "Right mouse button pressed at :"
        ?? "row-> ",rat_eqmrow()
        ?? "col-> ",rat_eqmcol()
      endcase
   end

  Source:
  -------
  S_MOOSE.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:RAT_EQMROW()          Returns mouse row at last press
'------------------------------------------------------------------------------
 FUNCTION RAT_EQMROW()

  Short:
  ------
  RAT_EQMROW() Returns mouse row at last press

  Returns:
  --------
  <nRow> => mouse row at last button press (left or
  right)

  Syntax:
  -------
  RAT_EQMROW()

  Description:
  ------------
  Returns mouse row at last press (LEFT OR RIGHT).
  S_MOOSE.PRG has two static variables, 'mouserow' and 'mousecol'.
  These are set each time RAT_EVENT() determines that the mouse
  has been depressed.

  Examples:
  ---------
   e := 0

   while e#27
      e := rat_event(30)
      do case
      case e == 0
        ? "Timed out after 30 seconds"
      case e < 400
        ? "Key press with inkey() value of :",e
      case e == 400
        ? "Left mouse button pressed at :"
        ?? "row-> ",rat_eqmrow()
        ?? "col-> ",rat_eqmcol()
      case e == 500
        ? "Right mouse button pressed at :"
        ?? "row-> ",rat_eqmrow()
        ?? "col-> ",rat_eqmcol()
      endcase
   end

  Source:
  -------
  S_MOOSE.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:RAT_ERBHD()           Determines if right mouse button is held down
'------------------------------------------------------------------------------
 FUNCTION RAT_ERBHD()

  Short:
  ------
  RAT_ERBHD() Determines if right mouse button is held down

  Returns:
  --------
  <lHeldDown> => is RMB held down

  Syntax:
  -------
  RAT_ERBHD([nSeconds])

  Description:
  ------------
  Determines if right mouse button is held down by
  calling the ASM function RAT_RBHD() for [nSeconds]. Default for
  [nSeconds] is .1 seconds. If the right mouse button is held down
  during that time frame, True is returned, else False is returned.

  [nSeconds]   is optional seconds to test for. Default
  is .1 seconds.

  This is different from the .ASM function RAT_RBHD().
  RAT_ERBHD(<n>) watches the mouse for <n> seconds, and if the
  mouse remains depressed for the full time, then it is considered
  to be HELD DOWN.  RAT_RBHD() on the other hand, only checks for
  the mouse button being depressed RIGHT NOW. RAT_ERBHD() calls
  RAT_RBHD() repetitively.

  Examples:
  ---------
   if rat_erbhd()

     ?"While you were out:"

     ?"Right button was depressed and held down at"

     ??rat_eqmrow(),rat_eqmcol()

   endif

  Source:
  -------
  S_MOOSE.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:RAT_EVENT()    ^b(diff)^n Event handler - inkey() with mouse awareness
'------------------------------------------------------------------------------
 FUNCTION RAT_EVENT()          *changed*

  Short:
  ------
  RAT_EVENT() Event handler - inkey() with mouse awareness

  Returns:
  --------
  <nEvent> => Event value - either inkey() value or
  mouse value

  Syntax:
  -------
  RAT_EVENT([nTimeout],[lClearkb])

  Description:
  ------------
  Event handler - inkey() with mouse awareness

  <nTimeout>   is the   # seconds to wait before
  timeout. Zero (0) means indefinately . If you don't pass
  anything, default is 0. Slight difference from inkey() there.

  Returns values are:

     If keystroke                                   inkey() value
     If left mouse button has been depressed        K_MOUSELEFT
     If right mouse button has been depressed       500
     If timeout                                      0


  [lClearkb]   optional clear keyboard True (default)
  or False. If a keystroke is gotten, and this is True, clear the
  keyboard with:
                     while inkey()#0
                     end

  Examples:
  ---------
   e := 0

   while  e#27
      e := rat_event(30)
      do case
      case e == 0
        ? "Timed out after 30 seconds"
      case e < 400
        ? "Key press with inkey() value of :",e
      case e == 400
        ? "Left mouse button pressed at :"
        ?? "row-> ",rat_eqmrow(),  "col-> ",rat_eqmcol()
      case e == 500
        ? "Right mouse button pressed at :"
        ?? "row-> ",rat_eqmrow(),  "col-> ",rat_eqmcol()
      endcase
   end

  Source:
  -------
  S_MOOSE.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:RAT_ISMOUSE()         Determines mouse usage by RAT_EVENT()
'------------------------------------------------------------------------------
 FUNCTION RAT_ISMOUSE()

  Short:
  ------
  RAT_ISMOUSE() Determines mouse usage by RAT_EVENT()

  Returns:
  --------
  <lIsMouse> => is there a mouse

  Syntax:
  -------
  RAT_ISMOUSE([lIsMouse])

  Description:
  ------------
  Determines mouse usage by RAT_EVENT(). Default is
  determined by a call to the ASM function RAT_EXIST(). However,
  you may want to shut down mouse usage even if a mouse is
  present. If so, call this function with False, to override.

  [lIsMouse]  S_MOOSE.PRG contains a static variable
  called 'lIsMouse'. This is determined initially by a call to
  RAT_EXIST(), but may be overridden by calling RAT_ISMOUSE(.f.).

  Examples:
  ---------
   RAT_ISMOUSE(.f.).

  Source:
  -------
  S_MOOSE.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:RAT_LASTEV()   ^b(new)^n  Returns the last event recorded by RAT_EVENT()
'------------------------------------------------------------------------------
 FUNCTION RAT_LASTEV()          *new*

  Short:
  ------
  RAT_LASTEV() Returns the last event recorded by RAT_EVENT()

  Returns:
  --------
  <nEvent> => last recorded RAT_EVENT() event

  Syntax:
  -------
  RAT_LASTEV()

  Description:
  ------------
  Every once in a while, some other function will be responsible
  for doing the RAT_EVENT() call, but your function still wants
  to know what the last event was. This function can be used to
  retrieve that value.

  Examples:
  ---------
   RAT_LASTEV()

  Source:
  -------
  S_MOOSE.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:RAT_MENU2()    ^b(diff)^n Mouseable MENU TO emulation
'------------------------------------------------------------------------------
 FUNCTION RAT_MENU2()                          *changed*

  Short:
  ------
  RAT_MENU2() Mouseable MENU TO emulation

  Returns:
  --------
  <nSelected> => selected menu option, 0 for none

  Syntax:
  -------
  RAT_MENU2(aOptions,[nStart],[lImmediate],[bMouse])

  Description:
  ------------
  You must pass an array of arrays, with each element
  being an array in the form {nRow,nColumn,cPrompt} which
  correspond to      [ @nRow,nCol PROMPT cPrompt. ]

  [nStart] is an optional starting prompt, with the
  default being 1

  [lImmediate] refers to the action taken when a first
  letter or a mouse click changes options. The default is to have
  immediate action - select and return. By passing False, it
  becomes a 2 step  process, requiring click-click or
  firstletter-firstletter to select and return.

  [bMouse] is an optional codeblock for mouse clicks. If the
  mouse click does not satisfy RAT_MENU2(), and there is a
  [bMouse] codeblock, it will be evaluated as follows:

               eval(bMouse,mouserow, mousecol)


  Examples:
  ---------
   local aOptions := { ;
                      {23,2 ,  'Add'},;
                      {23,9 ,  'Open'},;
                      {23,17 , 'Delete'},;
                      {23,27 , 'Change Date'},;
                      {23,42 , 'Output list'},;
                      {23,57 , 'Purge '},;
                      {23,74 , 'Quit'}}

   nSelected := RAT_MENU2(aOptions,4,.f.,{|r,c| checkmouse(r,c) })

  Source:
  -------
  S_RMENU2.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:RAT_READ()     ^b(diff)^n Mouseable read
'------------------------------------------------------------------------------
 FUNCTION RAT_READ()                *changed*

  Short:
  ------
  RAT_READ() Mouseable read

  Returns:
  --------
  Nil

  Syntax:
  -------
  RAT_READ(aGetlist,[nStart],[lWrap],[nRmKey],[bLmouse],[aLmKeys])

  Description:
  ------------
  Set up your gets as normal, with @SAY...GET
  statements.

  The only limitation is that you cannot use a
  user-defined READER block, as RAT_READ() installs a
  user-defined reader block for each get.

  After setting up your @SAY...GET statements, instead
  of issuing a READ, issue a RAT_READ(getlist,...).

  [nStart] is an optional starting get number, which
  defaults to 1.

  [lWrap] determines if going past top or bottom get
  exits the read. Default is True. By sending false, going past top
  will put you at bottom, and going past bottom will put you at top,
  with only CTRL-W exiting the read.

  [nRmKey] is an inkey value that tells RAT_READ() how
  it should interpret a right mouse button click. Default is ESCAPE.

  [bLmouse] (new in 3.5) is a codeblock that is evaluated when there
  is a mouse click and it is not meaningful to RAT_READ().
  It is evaluated as :  eval(bLMouse,mouserow, mousecolumn)

  [aLmKeys] is an array of hot mouse coordinate sub-arrays and their
  key equivalents. For instance, if you have the following for hot
  keys: @24,0 say "[F10=save] [ESC=Cancel]", and you wanted these as
  hot mouse areas, the array would be:
        {   {24,0,24,9,K_F10},  {24,11,24,22,K_ESC}   }
  Clicking the mouse within 24,0,24,9 would be interpreted as pressing
  the F10 key.
  The structure of each sub-array is {nTop,nLeft,nBottom,nRight,nKeyValue}



  Examples:
  ---------
   v1 := space(10)
   v2 := space(10)
   v3 := space(10)
   @10,10 get v1
   @11,10 get v2
   @12,10 get v3

   RAT_READ(getlist,2,.T.,27)

   // read, starting at get # 2, wrapping, and interpreting the right
   // mouse button as chr(27) (escape).

  Notes:
  -------
  This does not replace GETSYS.PRG, but rather parallels it.

  The Clipper GET system, contained in GetSys.Prg and accessed via
  READ contains several exported functions which obtain /handle
  information about the current GET and the current READ.

  In order to implement mouse-aware reads, a modification of
  GetSys.Prg was needed. However....

  I didn't want SuperLib to replace the Clipper Get system
  willy-nilly, as that would presume that you always wanted
  to use _only_ the SuperLib version. So I had to rename all
  of the exported functions in the SuperLib mouseable get
  system. The names are as follows:

   Clipper Get System    SuperLib GetSystem
   ------------------    ------------------
   ReadModal()           Rat_Read()
   GetReader()           RatReader()
   GetApplyKey()         RatApplyKey()
   GetDoSetKey()         RatDoSetKey()
   GetPostValidate()     RatPostValidate()
   GetPreValidate()      RatPreValidate()
   GetActive()           RatActive() ---or--- GetActive()
   ReadKill()            RatKill()
   ReadUpdated()         RatSetUpdated()
   Updated()             RatUpdated()

  So you can call either READ or READMODAL() which accesses the
  Clipper Get System, or call RAT_READ(), which access the
  SuperLib mouseable get system, and they will not tromp on
  one another.

  There still remained one problem, however. Some of the SuperLib
  functions access the above named exported functions, such as
  GetActive(), and of course user-defined get readers need to
  access GetPostValidate(), GetPreValidate(), GetApplyKey() and
  GetDoSetKey(), and possibly others.

  By calling R_ISRATREAD(), you can determine if the current
  read is a RAT_READ or not, and call the regular exported
  read/get functions, or call their equivalent RAT* functions
  as listed above.

  An exception is GETACTIVE(), which may be called while using
  either get system, as RAT_READ() calls GETACTIVE() to update
  the current get, and also saves and restores the active get
  in case there is a prior READ active.

  This R_ISRATREAD() function returns TRUE/FALSE for 'is the current
  read a RAT_READ or a READMODAL (normal) read'. Essentially it tells
  you which GetSystem you are in.

  Thus you can have both RAT_READ() mouse aware reads, and standard
  READMODAL() Clipper reads in the same system, and tell the
  difference between the two.

  User defined readers attached to GETS passed to RAT_READ can
  return a numeric value indicating which get to jump to.


  Source:
  -------
  S_RREAD.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:REPORTER()            Create, modify, execute reports
'------------------------------------------------------------------------------
 FUNCTION REPORTER()

  Short:
  ------
  REPORTER() Create, modify, execute reports

  Returns:
  --------
  Nothing

  Syntax:
  -------
  REPORTER([aFieldNames,aFieldTypes,aFieldLengths])

  Description:
  ------------
  Build/modify reports based on fields in database.
  Fields in database may be specified in arrays 1-3 which are
  [aFieldNames] field names [aFieldTypes] field types and
  [aFieldLengths] field lengths. All fields are used by default.

  Reporter allows a MAJOR and MINOR group, using the
  indexes currently available and open.

  Examples:
  ---------
   example 1:

   Use Customer
   REPORTER()

   example 2:
   USE Customer
   aFieldNames := {"fname","lname","mi"}
   aFieldTypes := {"C","C","C"}
   aFieldLens  := {15,35,1}
   REPORTER(aFieldNames,aFieldTypes,aFieldLens)

  Notes:
  -------
  Reporter() reports are stored in a DBF file. See the
  index for file structures. See SLSF_REPORT() for further info on
  the name and location of this file.

  Upgrade note:
  The look and feel have changed to one more uniform
  with other SuperLib functions.

  Source:
  -------
  R_REPORT.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:RESTSETKEYS()         Restores  set keys saved with SAVESETKEYS()
'------------------------------------------------------------------------------
 FUNCTION RESTSETKEYS()

  Short:
  ------
  RESTSETKEYS() Restores  set keys saved with SAVESETKEYS()

  Returns:
  --------
  Nil

  Syntax:
  -------
  RESTSETKEYS(aSaved)

  Description:
  ------------
  SAVESETKEYS() saves the inkey codes and codeblocks
  associated with all active setkeys to an array. RESTSETKEYS()
  takes the saved array and restores the setkeys back.

  Examples:
  ---------
   aSaved := SAVESETKEYS(.t.)

   * do stuff

   RESTSETKEYS(aSaved)

  Source:
  -------
  S_SETKEY.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:RJUST()               Right justifies a string
'------------------------------------------------------------------------------
 FUNCTION RJUST()

  Short:
  ------
  RJUST() Right justifies a string

  Returns:
  --------
  <cJustified> => string right justified

  Syntax:
  -------
  RJUST(cTarget)

  Description:
  ------------
  Right justifies <cTarget>

  Examples:
  ---------
   string        := "Superfunction      "

   string        := RJUST(string)

   // (returns       "      Superfunction"

  Source:
  -------
  S_RJUST.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:RRJUMP2()      ^b(new)^n  Jump to a new get in a RAT_READ()
'------------------------------------------------------------------------------
 FUNCTION RRJUMP2()                 *new*

  Short:
  ------
  RRJUMP2()  Jump to a new get in a RAT_READ()

  Returns:
  --------
  NIL

  Syntax:
  -------
  RRJUMP2(nNew)

  Description:
  ------------
  While in a RAT_READ(), causes the jump flag to be set to <nNew>, and
  and the current get's exitstate variable to be set to GE_ENTER. This
  causes an exit from the current get, and a jump to get <nNew>.

  Examples:
  ---------
   // in this example, pressing or clicking F3 causes a jump to
   // get # 1, while pressing or clicking F4 causes a jump to
   // get # 5.

   #include "inkey.ch"

   v1 := space(10)
   v2 := space(10)
   v3 := space(10)
   v4 := space(10)
   v5 := space(10)

   setkey(K_F4,{||rrjump2(5)} )
   setkey(K_F3,{||rrjump2(1)} )

   @24,0 say "[F3-Go to First Get]  [F4-Go to Last Get]"

   ahot := {{24,0,24,20,K_F3},{24,23,24,41,K_F4} }

   @10,10 get v1
   @11,10 get v2
   @12,10 get v3
   @13,10 get v4
   @14,10 get v5

   RAT_READ(getlist,1,.T.,27,nil,aHot)

  Notes:
  -------

  Source:
  -------
  S_RREAD.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:RRLASTKEY()    ^b(new)^n  Retrieve the last key handled by ratapplykey()
'------------------------------------------------------------------------------
 FUNCTION RRLASTKEY()                 *new*

  Short:
  ------
  RRLASTKEY()  Retrieve the last key handled by ratapplykey()

  Returns:
  --------
  <nLastKey> => last key handled by ratapplykey()

  Syntax:
  -------
  RRLASTKEY()

  Description:
  ------------
  Returns the last key - including pseudo keys - handled by
  RatApplyKey().

  The [nRmKey]  and [aLmKeys] parameters of RAT_READ() allow
  emulation of keypresses. The [nRmKey] determines what key is
  emulated when the right mouse button is pressed. The [aLmKeys]
  array contains key emulations to be used for a set of screen
  hot areas for left mouse button clicks. In both cases, the
  ascii key code is passed to RatApplyKey() to handle. However,
  the keys ARE NOT STUFFED INTO THE KEYBOARD, and thus are not
  retrievable through LASTKEY(). The reason, by the way, that they
  are not stuffed into the keyboard, is that some keys cannot be
  stuffed with the KEYBOARD command  ( i.e. ALT-F10 or -39 )

  After a number of requests to be able to tell what key was
  pressed last when exiting a read, even when it is an interpreted
  key based on a mouse click, I've added this function. It will return
  the last key handled by RatApplyKey(), even if the key is based on
  a mouse click. If the last event is a mouse event that does not
  translate into a key value, it will return either K_MOUSELEFT for left
  mouse click, or K_MOUSERIGHT for right mouse click.


  Examples:
  ---------
  RAT_READ(getlist,...)
  if RRLASTKEY()==27
    * escape was pressed or mouse right button was pressed

  endif

  Notes:
  -------

  Source:
  -------
  S_RREAD.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:R_ISRATREAD()  ^b(new)^n  Determines if RAT_READ() is current get system
'------------------------------------------------------------------------------
 FUNCTION R_ISRATREAD()                 *new*

  Short:
  ------
  R_ISRATREAD() Determines if RAT_READ() is current get system

  Returns:
  --------
  <lIsRatRead> => True if RAT_READ() is current get system

  Syntax:
  -------
  R_ISRATREAD()

  Description:
  ------------

  By calling R_ISRATREAD(), you can determine if the current
  read is a RAT_READ or not, and call the regular exported
  read/get functions, or call their equivalent RAT* functions
  as listed in RAT_READ().

  An exception is GETACTIVE(), which may be called while using
  either get system, as RAT_READ() calls GETACTIVE() to update
  the current get, and also saves and restores the active get
  in case there is a prior READ active.

  This R_ISRATREAD() function returns TRUE/FALSE for 'is the current
  read a RAT_READ or a READMODAL (normal) read'. Essentially it tells
  you which GetSystem you are in.

  Thus you can have both RAT_READ() mouse aware reads, and standard
  READMODAL() Clipper reads in the same system, and tell the
  difference between the two.

  Examples:
  ---------
  IF R_ISRATREAD()
     ...
  ENDIF

  Notes:
  -------

  Source:
  -------
  S_RREAD.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:S1LABEL()             Prints a single label
'------------------------------------------------------------------------------
 FUNCTION S1LABEL()

  Short:
  ------
  S1LABEL() Prints a single label

  Returns:
  --------
  Nothing

  Syntax:
  -------
  S1LABEL(cLblfile)

  Description:
  ------------
  Prints a single label (1 or more copies) for the
  current record, based on the dimensions and contents definitions in
  .LBL file name <cLblfile>. The dimensions and contents are
  figured, and then presented for printing and/or editing.

  Examples:
  ---------
   setkey(K_F10,{||S1LABEL("MAILING.LBL")} )
                      // sets key F10 to call this
                     // as a popup

  Source:
  -------
  S_1LABEL.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SACHOICE()     ^b(diff)^n Achoice replacement, uses TBROWSE, codeblock
'------------------------------------------------------------------------------
 FUNCTION SACHOICE()                          *changed*

  Short:
  ------
  SACHOICE() Achoice replacement, uses TBROWSE, codeblock

  Returns:
  --------
  <nSelection> => selection, 0 if none

  Syntax:
  -------
  SACHOICE(nTop,nLeft,nBottom,nRight,aOptions,[bKeyBlock],[nStart],[@nRow],;
           [nMRow, nMCol],[bMouse])

  Description:
  ------------
  This semi-replaces ACHOICE() by using TBROWSE
  instead, and by accepting an exception codeblock instead of a user
  defined function.

  <nTop,nLeft,nBottom,nRight> are the dimensions.

  <aOptions> is the array. It need not be of type
  Character.

  First-letter presses go to the next matching letter
  of the next character-type element.
  Up/down/home/end/pageup/pagedown are used to position the
  cursor. ENTER returns the current selection. Escape returns 0.

  The screen is not saved and restored. This is a
  building block function, like ACHOICE(), so save and restore the
  screen, draw a box around it, etc, as you would ACHOICE().

  [bKeyBlock] a codeblock which will be executed if an
  exception key is received (any key not otherwise meaningful). The
  codeblock will be evaluated and will be passed:

           1. current element #
           2. exception key value
           3. the tbrowse object

  as parameters.

  [nStart] is an optional starting element. Default is 1.
  [@nRow] is an optional starting row. Default is 1. Pass by reference
  to retain value between calls.


  [nMRow, nMCol]  (new in 3.5) Directs sachoice() to draw
  the "[][]" for mouse up/down at nMrow, nMCol, and to be aware of mouse
  clicks on these buttons. (the screen under the arrows is saved/restored)


  [bMouse] is a codeblock to evaluate mouse clicks other than those
  meaningful to sachoice(). The codeblock is evaluated as follows:
            eval(bMouse,mouserow, mousecolumn)



  Examples:
  ---------
   USE CUSTOMER

   aFlds       := afieldsx()
   bExcept     := {|e,k|msg("You pressed ",str(k))}
   ?SACHOICE(10,10,20,12,aFlds,bExcept)

   //to retain element and position between calls
   nSelect := 1
   nRow    := 1
   aMeals   := {"Pizza","Chicken","Chinese"}
   while nSelect > 0
     nSelect  := sachoice(10,10,20,20,aMeals,nil,nSelect,@nRow)
     // code
   endif



  Notes:
  -------
  This will be a lot easier to mouse-ize than ACHOICE.
  (or is that RAT-ify..)

  Source:
  -------
  S_ACHOI.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SADD_REC()            Attempts to append a blank record
'------------------------------------------------------------------------------
 FUNCTION SADD_REC()

  Short:
  ------
  SADD_REC() Attempts to append a blank record

  Returns:
  --------
  <lSuccess> => success

  Syntax:
  -------
  SADD_REC([nTries],[lAskMore],[cAskMessage])

  Description:
  ------------
  Attempts to append a blank record. Tries [nTries]
  times and then allows user to retry or not if [lAskMore] by
  giving message [cAskMessage] and asking YES/NO.

  Examples:
  ---------
   IF SADD_REC(5,.T.,"Unable to ADD,Try again?")

       IF SREC_LOCK(5,.T.,"Unable to lock, Try again?")
         REPLACE XXX WITH YYY, ZZZ WITH BBB
         UNLOCK
       ENDIF
   ENDIF

  Source:
  -------
  S_SADDR.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SAPPOINT()            Appointments manager - uses popup calendar.
'------------------------------------------------------------------------------
 FUNCTION SAPPOINT()

  Short:
  ------
  SAPPOINT() Appointments manager - uses popup calendar.

  Returns:
  --------
  nil

  Syntax:
  -------
  SAPPOINT()

  Description:
  ------------
  Presents a menu driven appointment manager, including
  the ability to print the day's appointments.

  Examples:
  ---------
   SAPPOINT()

  Notes:
  -------
  see SLSF_APPOINT() for setting the default
  APPOINTMENTS dbf to another location/name. Default is "APPOINT".

  Source:
  -------
  S_APPT.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SATTCOLOR()           Sets up color vars for color monitor
'------------------------------------------------------------------------------
 FUNCTION SATTCOLOR()

  Short:
  ------
  SATTCOLOR() Sets up color vars for color monitor

  Returns:
  --------
  Nil

  Syntax:
  -------
  SATTCOLOR()

  Description:
  ------------
  This sets up the system color and interface variables
  described in SLS_*() for color monitor defaults.

  If  COLORS.DBF is present, the color set named
  "DEFAULT" is retrieved, otherwise a default set is used.

  Examples:
  ---------
   IF ISCOLOR()
     SATTCOLOR()
   ELSE
     SATTMONO()
   ENDIF

  Source:
  -------
  S_CLRFUN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SATTDIRECT()          Sets up the the color vars directly
'------------------------------------------------------------------------------
 FUNCTION SATTDIRECT()

  Short:
  ------
  SATTDIRECT() Sets up the the color vars directly

  Returns:
  --------
  Nil

  Syntax:
  -------
  SATTDIRECT([cNormCol],[cNormMenu],[cPopCol],[cPopMenu],[cFrame],;
        [nShadAtt],[nShadPos],[lExplode])

  Description:
  ------------
  This sets up the system color and interface variables
  described in SLS_*() all in one shot, rather than with individual
  calls.

  Examples:
  ---------
   To restore from an old COLORS.MEM:

   restore from colors.mem additive
   SATTDIRECT(c_normcol,c_normmenu,c_popcol , ;
                  c_popmenu,c_frame,c_shadatt,;
                         c_shadpos, c_xplode)

  Source:
  -------
  S_CLRFUN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SATTGET()             Sets up SuperLib color vars from COLORS.DBF
'------------------------------------------------------------------------------
 FUNCTION SATTGET()

  Short:
  ------
  SATTGET() Sets up SuperLib color vars from COLORS.DBF

  Returns:
  --------
  <lSuccess> => Success, True of False

  Syntax:
  -------
  SATTGET([cSetName])

  Description:
  ------------
  This sets up the system color and interface variables
  described in SLS_*() by grabbing them from the COLORS.DBF file, as
  described in SLSF_COLOR().

  [cSetName] is an optional name of a previously saved
  color set.

  If none is passed, the color set named "DEFAULT" is
  used.

  Examples:
  ---------
   SATTGET("THE BLUE SET")

  Notes:
  -------
  SATTPUT() and SETCOLORS() allow store of color sets.

  Source:
  -------
  S_CLRFUN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SATTGETMEM()          Sets up SuperLib color vars from old COLORS.MEM
'------------------------------------------------------------------------------
 FUNCTION SATTGETMEM()

  Short:
  ------
  SATTGETMEM() Sets up SuperLib color vars from old COLORS.MEM

  Returns:
  --------
  Nil

  Syntax:
  -------
  SATTGETMEM(cFileName)

  Description:
  ------------
  This sets up the system color and interface variables
  described in SLS_*() by restoring from an old stype COLORS.MEM

  <cFileName> is the name (and path) of the file.

  The COLORS.MEM vars are NOT made public.

  Examples:
  ---------
   SATTGETMEM("COLORS.MEM")
    // GRAB FROM OLD COLORS.MEM

   SATTPUT("OLD COLORS.MEM SETTINGS")
   // store them in COLORS.DBF

  Source:
  -------
  S_CLRFUN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SATTMONO()            Sets up color vars for mono monitor
'------------------------------------------------------------------------------
 FUNCTION SATTMONO()

  Short:
  ------
  SATTMONO() Sets up color vars for mono monitor

  Returns:
  --------
  Nil

  Syntax:
  -------
  SATTMONO()

  Description:
  ------------
  This sets up the system color and interface variables
  described in SLS_*() for MONOCHROME monitor defaults.

  Examples:
  ---------
   IF ISCOLOR()
     SATTCOLOR()
   ELSE
     SATTMONO()
   ENDIF

  Source:
  -------
  S_CLRFUN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SATTPICK()            Sets up SuperLib color vars by selecting from DBF
'------------------------------------------------------------------------------
 FUNCTION SATTPICK()

  Short:
  ------
  SATTPICK() Sets up SuperLib color vars by selecting from DBF

  Returns:
  --------
  Nil

  Syntax:
  -------
  SATTPICK()

  Description:
  ------------
  This sets up the system color and interface variables
  described in SLS_*() by allowing a picklist of them from the
  colors dbf defined in SLSF_COLOR().

  Examples:
  ---------
   SATTPICK()

  Notes:
  -------
  SATTPUT() and SETCOLORS() allow storage of color sets
  to disk. SETCOLORS() makes use of SATTPICK().

  Source:
  -------
  S_CLRFUN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SATTPICKDEL()         Picklist deletion of stored color var sets
'------------------------------------------------------------------------------
 FUNCTION SATTPICKDEL()

  Short:
  ------
  SATTPICKDEL() Picklist deletion of stored color var sets

  Returns:
  --------
  Nil

  Syntax:
  -------
  SATTPICKDEL()

  Description:
  ------------
  A Picklist of color sets, stored in the colors dbf
  file described in SLSF_COLOR(), is presented. Selected color set is
  deleted.

  Examples:
  ---------
   If MESSYN("Want to delete a stored color set?")
     SATTPICKDEL()
   Endif

  Source:
  -------
  S_CLRFUN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SATTPICKPUT()         Stores SuperLib color vars to selected record
'------------------------------------------------------------------------------
 FUNCTION SATTPICKPUT()

  Short:
  ------
  SATTPICKPUT() Stores SuperLib color vars to selected record

  Returns:
  --------
  Nil

  Syntax:
  -------
  SATTPICKPUT()

  Description:
  ------------
  This writes the current system color and interface
  variables described in SLS_*() by selecting either an existing
  set name (contained in the colors dbf file described in
  SLSF_COLOR() ) to overwrite, or allowing a new set to be stored.

  Examples:
  ---------
   SATTPICKPUT()

  Notes:
  -------
  SATTPUT() and SETCOLORS() allow storage of color sets
  to disk.

  SATTPICKPUT() attempts to re-use deleted records.

  Source:
  -------
  S_CLRFUN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SATTPOP()             Pops previously pushed SuperLib color vars
'------------------------------------------------------------------------------
 FUNCTION SATTPOP()

  Short:
  ------
  SATTPOP() Pops previously pushed SuperLib color vars

  Returns:
  --------
  Nil

  Syntax:
  -------
  SATTPOP()

  Description:
  ------------
  This pops a previously pushed set of SuperLib system
  interface

  variables described in SLS_*().

  Examples:
  ---------
   SATTPUSH()
   SATTGET("THE BLUE SET")
   //...some code
   SATTPOP()  // restore the prior color set

  Source:
  -------
  S_CLRFUN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SATTPUSH()            Pushes the current SuperLib color vars
'------------------------------------------------------------------------------
 FUNCTION SATTPUSH()

  Short:
  ------
  SATTPUSH() Pushes the current SuperLib color vars

  Returns:
  --------
  Nil

  Syntax:
  -------
  SATTPUSH()

  Description:
  ------------
  This pushes the current system color and interface
  variables described in SLS_*() onto a stack, for later retrieval
  with SATTPOP().

  Examples:
  ---------
   SATTPUSH()
   SATTGET("THE BLUE SET")
   //...some code
   SATTPOP()  // restore the prior color set

  Source:
  -------
  S_CLRFUN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SATTPUT()             Stores current SuperLib color vars to COLORS.DBF
'------------------------------------------------------------------------------
 FUNCTION SATTPUT()

  Short:
  ------
  SATTPUT() Stores current SuperLib color vars to COLORS.DBF

  Returns:
  --------
  <lSuccess> => Success, True of False

  Syntax:
  -------
  SATTPUT([cSetName])

  Description:
  ------------
  This stores the system color and interface variables
  described in SLS_*() in the colors dbf defined by SLSF_COLOR().

  [cSetName] is an optional name of a previously saved
  color set.

  If none is passed, the color set named "DEFAULT" is
  used.

  Examples:
  ---------
   SATTGET("THE BLUE SET")        // restore a previous definition
   SLS_POPCOL("+GR/N,+W/R,,,W/R")
                              // changes the sls_popcol() setting
   SATTPUT("THE BLUE SET # 2")    // stores the revised set in the dbf

  Notes:
  -------
  SETCOLORS() also allows storage of color sets.

  SATTPUT() attempts to re-used deleted records.

  Source:
  -------
  S_CLRFUN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SAVESETKEYS()         Saves active set keys to an array
'------------------------------------------------------------------------------
 FUNCTION SAVESETKEYS()

  Short:
  ------
  SAVESETKEYS() Saves active set keys to an array

  Returns:
  --------
  <aSaved> => setkey setting saved to an array

  Syntax:
  -------
  SAVESETKEYS([lClear])

  Description:
  ------------
  Saves the inkey codes and codeblocks associated with
  all active setkeys to an array.

  [lClear] If True, clear any active setkeys (set to NIL)

  Examples:
  ---------
   aSaved := SAVESETKEYS(.t.)

   * do stuff

   RESTSETKEYS(aSaved)

  Source:
  -------
  S_SETKEY.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SBCENTER()            Centers box coordinates
'------------------------------------------------------------------------------
 FUNCTION SBCENTER()

  Short:
  ------
  SBCENTER() Centers box coordinates

  Returns:
  --------
  Nil

  Syntax:
  -------
  SBCENTER(@nTop,@nLeft,@nBottom,@nRight)

  Description:
  ------------
  Dimensions nTop,nLeft,nBottom,nRight are passed by
  reference.

  They are changed by SBCENTER to dimensions that are
  centered on the screen.

  Examples:
  ---------

   nTop    := 0
   nLeft   := 0
   nBottom := nRows+2
   nRight  := nMaxwidth+2

   SBCENTER(@nTop,@nLeft,@nBottom,@nRight)
                  // center the coordinates

   cBox := makebox(nTop,nLeft,nBottom,nRight)

  Source:
  -------
  S_BOXES.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SBCOLS()              Determine number of columns in a box
'------------------------------------------------------------------------------
 FUNCTION SBCOLS()

  Short:
  ------
  SBCOLS() Determine number of columns in a box

  Returns:
  --------
  <nCols> => columns in the box

  Syntax:
  -------
  SBCOLS(nLeft,nRight,[lIncludeFrame])

  Description:
  ------------
  The number of columns of a box with left of <nLeft>
  and right of <nRight> is returned. By default, the frame is
  included (the left and the right)

  [lIncludeFrame] by default is True - and all columns
  are counted. If passed as False, only the inside columns are
  counted.

  Examples:
  ---------
   // this example fills a box with "X"'s

   nRows := SBROWS(nTop,nBottom,.f.)
   nCols := SBCOLS(nLeft,nRight,.f.)
   for i = nTop to nRows
     @nTop+i,nLeft say repl("X",nCols)
   next

  Source:
  -------
  S_BOXES.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SBREADER()            Creates specialized spacebar spinner get reader
'------------------------------------------------------------------------------
 FUNCTION SBREADER()

  Short:
  ------
  SBREADER() Creates specialized spacebar spinner get reader
  block

  Returns:
  --------
  <bReader> => get reader block for GET

  Syntax:
  -------
  SBREADER(aValues)

  Description:
  ------------
  Creates a get reader block that allows space bar to
  rotate values from an array into the current get.

  Implement by using the SEND keyword for your
  @Say..Get.. statements.

  i.e. @10,10 say blah get blahblah SEND ;
                      reader:=SBREADER(aValues)

  <aValues> is an array of values that are of the same
  type and length as the GET.

  Examples:
  ---------
   // while in the get V1, you will be able to use the spacebar to
   // rotate values from the array

   aValues := {"Section 1","Section 2","Section 3"}
   v1 := "Section 1"
   @10,10 get v1 send reader := sbreader(aValues)
   READ

  Source:
  -------
  S_READRS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SBROWS()              Determine number of rows in a box
'------------------------------------------------------------------------------
 FUNCTION SBROWS()

  Short:
  ------
  SBROWS() Determine number of rows in a box

  Returns:
  --------
  <nRows> => rows in the box

  Syntax:
  -------
  SBROWS(nTop,nBottom,[lIncludeFrame])

  Description:
  ------------
  The number of rows of a box with top of <nTop> and
  bottom of <nBottom> is returned. By default, the frame is
  included (the top and the bottom)

  [lIncludeFrame] by default is True - and all rows are
  counted. If passed as False, only the inside rows are counted.

  Examples:
  ---------
   nRows := SBROWS(nTop,nBottom,.f.)
   for i = nTop to nRows
     @nTop+i,nLeft say i
   next

  Source:
  -------
  S_BOXES.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SBSHADOW()            Draw a shadow around a box
'------------------------------------------------------------------------------
 FUNCTION SBSHADOW()

  Short:
  ------
  SBSHADOW() Draw a shadow around a box

  Returns:
  --------
  <aSaved> => an array containing the two saved screen
  sections

  Syntax:
  -------
  SBSHADOW(nTop,nLeft,nBottom,nRight,nShadowPos,nShadowAtt)

  Description:
  ------------
  Draws a shadow for box described in coordinates
  <nTop,nLeft,nBotton,nRight>

  The shadow is of color <nShadowAtt> and is at
  position <nShadowPos>, which is one of the following:

      LOWER LEFT    1
      LOWER RIGHT   3
      UPPER LEFT    7
      UPPER RIGHT   9

  Returns an array with the saved screens for each side
  of the shadow.

  This array can be passed to SBUNSHADOW() for
  restoring the previous screen.

  Examples:
  ---------
   Dispbox(10,10,20,20)
   aSaved := sbshadow(10,10,20,20,3,8)
              // draws a shadow in the lower right
              // of color gray on black
   sbunshadow(aSaved)         // restore old screen

  ^Notes


  Source:
  -------
  S_BOXES.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SBUNSHADOW()          Removes shadow drawn with SBSHADOW()
'------------------------------------------------------------------------------
 FUNCTION SBUNSHADOW()

  Short:
  ------
  SBUNSHADOW() Removes shadow drawn with SBSHADOW()

  Returns:
  --------
  Nil

  Syntax:
  -------
  SBUNSHADOW(aSaved)

  Description:
  ------------
  Removes a shadow around a box created with
  SBSHADOW(). SBSHADOW() returns an array containing the
  coordinates and saved screens for each side of the shadow.
  SBUNSHADOW uses this array to restore the previous screens.

  Examples:
  ---------
   Dispbox(10,10,20,20)
   aSaved := sbshadow(10,10,20,20,3,8)
             // draws a shadow in the lower right
                              // of color gray on black
   sbunshadow(aSaved)         // restore old screen

  Source:
  -------
  S_BOXES.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SCMOD()               Maintains scroller.dbf - see scroller()
'------------------------------------------------------------------------------
 FUNCTION SCMOD()

  Short:
  ------
  SCMOD() Maintains scroller.dbf - see scroller()

  Returns:
  --------
  nothing

  Syntax:
  -------
  SET KEY xxx to SCMOD

  Description:
  ------------
  SCMOD() is a tool for online building and modifying
  of the SCROLLER.DBF used for SCROLLER() lookup tables.

  When called by a SET KEY, it recieves the PROCEDURE
  and VARIABLE parameters from the calling PROCEDURE. It then
  determines if there exists a matching record in the SCROLLER.DBF.

  If so, the lookup definition may be modified.
  Otherwise, a new lookup definition may be created.

  Examples:
  ---------
   EXTERNAL SCMOD
   SET KEY -31 TO SCMOD  && ALT-F2

  Notes:
  -------
  Be sure to declare SCMOD external.

  SCMOD() will create SCROLLER.DBF if it doesn't exist.

  Source:
  -------
  S_SCMOD.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SCONVDELIM()          Convert a delimited file to a DBF
'------------------------------------------------------------------------------
 FUNCTION SCONVDELIM()

  Short:
  ------
  SCONVDELIM() Convert a delimited file to a DBF

  Returns:
  --------
  None

  Syntax:
  -------
  SCONVDELIM()

  Description:
  ------------
  This allows the user to create a DBF file from a
  delimited file.

  Several options for defining the delimited file are
  available.

  Examples:
  ---------
   use CUSTOMER

   SCONVDELIM()

  Source:
  -------
  S_CVTDEL.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SCROLLER()            Hotkey lookup tables with dbf storage
'------------------------------------------------------------------------------
 FUNCTION SCROLLER()

  Short:
  ------
  SCROLLER() Hotkey lookup tables with dbf storage

  Returns:
  --------
  nothing

  Syntax:
  -------
  SET KEY xxx TO SCROLLER

  Description:
  ------------
  Scroller is a hotkey lookup table engine.

  Scroller is data-driven , meaning it operates on data
  stored external to

  the EXE in SCROLLER.DBF.

  SCROLLER() is called via a SET KEY. When called, it
  receives the parameters <cProc> and <cVar> from Clipper, telling
  it the proc and variable the user was sitting on when he pressed
  the hotkey.

  The actual parameters rec'd are <cProc> (proc name),
  <cLine> (line #) and <cVar> (variable name) .<cLine> is ignored,
  but it is included as the 2nd parameter because it is passed by
  Clipper's setkey routines.

  SCROLLER() attempts to find a corresponding record in
  SCROLLER.DBF (which contains fields for proc name and variable).
  SCROLLER.DBF is a storage place for lookup definitions.

  If SCROLLER does not find a matching record, it
  simply closes SCROLLER.DBF and returns to the previous area. It
  then displays a 'lookup table not found' message.

  If SCROLLER finds a matching record, it loads the
  values into memory and closes SCROLLER.DBF. It then opens the
  DBF [and index] of the lookup dbf in the next available area. If
  it is unable to open the dbf, it displays an error message and
  goes back to the previously selected area.

  SCROLLER then draws a box, using the DESCRIPTION
  field as the title, initializes a 1 element array composed of
  the SSTRING (see structure)  expression and calls SMALLS() .

  While in the SMALLS(), first letter searches can be
  done if the dbf is indexed  with a character index. Pressing
  ENTER will KEYBOARD the expression in SRETURN (unless its
  empty), close up the current area and return to the old area.
  Pressing escape just closes things up and returns to the old
  area.

  The KEYBOARD then takes over, feeding the SRETURN
  expression into the keyboard and into the current GET or GETS.

  Examples:
  ---------
   EXTERNAL SCROLLER

   SET KEY -1 TO SCROLLER  && F2

  Notes:
  -------
  BIG NOTE:

  This is really for managing dynamic lookup tables
  that will change frequently as to lookup params. Because of this, it
  is quite complex in nature.

  If you know what the lookup is going to be, and it
  will not change between compiles, look at SMALLS(), SMALLKSET(),
  SMALLVALID() and SMALLWHEN() and use one of these as
  appropriate, instead of SCROLLER().

  Source:
  -------
  S_SCROLL.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SEARCHME()            Search a DBF with user-specified criteria
'------------------------------------------------------------------------------
 FUNCTION SEARCHME()

  Short:
  ------
  SEARCHME() Search a DBF with user-specified criteria

  Returns:
  --------
  <bSearch> -> The code block used to do the search

  Syntax:
  -------
  SEARCHME([aField,aFieldTypes,aFieldLengths],[aFieldDesc])

  Description:
  ------------
  Searches the current dbf with criteria given

  by the user.

       for :    Field Contents Match
                Query match  --->> calls QUERY()
                End of file
                Beginning of File
                Deleted Records
                Memo contents

  On subsequent calls, if the previous search resulted
  in a FOUND(), a box asking "Continue..", "New Search" will pop up.
  If CONTINUE is selected, a continuation of the last search is
  done.

  Three arrays may be passed for FIELDS [aFields],
  FIELD TYPES [aFieldTypes], and FIELD LENGTHS [aFieldLengths].

  An additional (optional) array of field descriptions may be passed

  Default is all fields, field names as descriptions.

  Searchme() actually returns the code block used to do the
  search. Normally you would want to ignore this. I use it in
  TAGIT() - if the code block is not NIL, then I can 'tag all
  matching' with it.


  Examples:
  ---------
  SEARCHME()

  Source:
  -------
  S_SEARCH.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SEARCHMFND()   ^b(new)^n  Set/return last found() status from SEARCHME()
'------------------------------------------------------------------------------
 FUNCTION SEARCHMFND()                      *new*

  Short:
  ------
  SEARCHMFND() Set/return last found() status from SEARCHME()

  Returns:
  --------
  <lFound> -> Last searchme found() status

  Syntax:
  -------
  SEARCHMFND([lSet])

  Description:
  ------------
  Sets/retrieves the last found() setting for SEARCHME()
  [lSet] optionally sets the found() flag.

  For instance, to find out what the last result of SEARCHME() was
  so you can take an action or not based on something being found,
  use SEARCHMFND() to retrieve the last result.

  Examples:
  ---------
  SEARCHMFND(.f.)

  Source:
  -------
  S_SEARCH.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SEARCHMRS()    ^b(new)^n  Resets all SEARCHME() settings
'------------------------------------------------------------------------------
 FUNCTION SEARCHMRS()                      *new*

  Short:
  ------
  SEARCHMRS() Resets all SEARCHME() settings

  Returns:
  --------
  NIL

  Syntax:
  -------
  SEARCHMRS([)

  Description:
  ------------
  Resets all SEARCHME() static variables
    - sets found() flag to FALSE
    - sets locate block to nil
    - sets continue flag to .f.
    - sets ALIAS to nil

  For instance, if you change datafiles - you need to reset
  SEARCHME() with SEARMRS()

  Examples:
  ---------
  SEARCHMRS()

  Source:
  -------
  S_SEARCH.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SETCENT()             Determines if century is on/off
'------------------------------------------------------------------------------
 FUNCTION SETCENT()

  Short:
  ------
  SETCENT() Determines if century is on/off

  Returns:
  --------
  <lCentury> => Century is on/off

  Syntax:
  -------
  SETCENT([lCentury])

  Description:
  ------------
  Returns current SET CENTURY setting and optionally
  sets century on/off

  [lCentury]  True = ON False = OFF

  Examples:
  ---------
   lOldcentury := SETCENT(.f.)   //  SET CENTURY OFF

   // code

   SETCENT(lOldcentury)

  Source:
  -------
  S_SETCEN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SETCOLORS()           Interactive color setting interface
'------------------------------------------------------------------------------
 FUNCTION SETCOLORS()

  Short:
  ------
  SETCOLORS() Interactive color setting interface

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SETCOLORS()

  Description:
  ------------
  This is a development tool for finding nice
  combinations of colors for the global superfunction colors. I would
  not give this to an end user, as it is just TOO MANY CHOICES! I
  normally select 10-15 nice combinations of the colors and give
  the user a selection of those, giving them such names as
  'Hawaiian Blue' or 'Royal Red'. In fact, see COLPIK() for just
  such a function.

  If SETBLINK() is set to False (.f.), the high
  intensity colors will be available - if your monitor supports them.

  Examples:
  ---------
   SETCOLORS()

  Notes:
  -------
  First, a word on the Superfunction color scheme:

  This is not the perfect color scheme. It is the one
  on which this library runs. (hey - I hadda pick something) I
  also realize full well that color selection is more art than it
  is technical, and it is difficult to get two people to agree on
  a color scheme.

  Several global color settings are used, and they are
  recorded and accessed via the functions:

     sls_normcol([cNew])    -  For normal input/output
     sls_normmenu([cNew])   -  For normal 'menu to' operations
     sls_popcol([cNew])     -  For popup box colors
     sls_popmenu([cNew])    -  For popup box menus
     sls_frame([cNew])      -  Frame string
     sls_shadatt([nNew])    -  Shadow color attribute
                              (numeric)
     sls_shadpos([nNew])    -  Shadow position (0,1,3,7,9)
     sls_xplode([lNew])     -  Logical - explode windows?

     (All of the colors are of the format "f/b,f/b,,,f/b"
      where f=foreground b=background)

  SETCOLORS() allows interactive setting of these
  colors. The settings can stored as color sets in COLORS.DBF -
  which is created if needed by SETCOLORS().

  If COLORS.DBF is not present, SuperLib will use a
  default set of colors.

  See the SATT*() functons, and the SLS_*() functions
  for more info.

  See the appendix for more general colors info.

  See the upgrade notes for more info on upgrading from
  older SuperLibs, which used a public variable scheme.

  Source:
  -------
  S_SETCOL.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SETEXACT()            Determines if exact is on/off
'------------------------------------------------------------------------------
 FUNCTION SETEXACT()

  Short:
  ------
  SETEXACT() Determines if exact is on/off

  Returns:
  --------
  <lExact> => Exact is on/off

  Syntax:
  -------
  SETEXACT([lNew])

  Description:
  ------------
  Returns current SET EXACT setting and optionally sets
  exact on/off with [lNew]  .t. = ON .f. = OFF

  Examples:
  ---------
   nOldexact = SETEXACT(.f.) // SET EXACT OFF

   * code

   SETEXACT(nOldexact)

  Source:
  -------
  S_SETEX.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SET_DATE()            Sets and restores date format
'------------------------------------------------------------------------------
 FUNCTION SET_DATE()

  Short:
  ------
  SET_DATE() Sets and restores date format

  Returns:
  --------
  <nFormat> => previous SET DATE format 1-5

  Syntax:
  -------
  SET_DATE([nFormatNew])

  Description:
  ------------
  Return current SET DATE setting <nFormat> and
  optionally set to new format [nFormatNew]

  [nFormatNew] =    1  American
                    2  British/French
                    3  German
                    4  ANSI
                    5  Italian

  Examples:
  ---------
   nOldformat := SET_DATE(5)

   ** SET TO ITALIAN

   * code

   * more code

   SET_DATE(nOldformat)   // restore to prior setting

  Source:
  -------
  S_SETDAT.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SEXPORT()             Export DBF to delimited or SDF files
'------------------------------------------------------------------------------
 FUNCTION SEXPORT()

  Short:
  ------
  SEXPORT() Export DBF to delimited or SDF files

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SEXPORT([<aFields>,<aDesc>,<aTypes>,<aLens>,<aDeci>])

  Description:
  ------------
  This metafunction allows the user to select certain
  fields and, based on a condition or not, export them to a
  delimited or SDF file.

  [<aFields>,<aDesc>,<aTypes>,<aLens>,<aDeci>]

  Pass all or none. Array of field names, descriptions,
  types, lengths and decimals.

  Examples:
  ---------
   use CUSTOMER

   SEXPORT()

  Source:
  -------
  S_EXPORT.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SFIL_LOCK()           Attempts to lock a file
'------------------------------------------------------------------------------
 FUNCTION SFIL_LOCK()

  Short:
  ------
  SFIL_LOCK() Attempts to lock a file

  Returns:
  --------
  <lSuccess> success

  Syntax:
  -------
  SFIL_LOCK(nTries,lInteract,[cMoreMessage])

  Description:
  ------------
  Attempts to lock entire DBF file. Tries <nTries>
  times and then allows user to retry or not <lInteract> by giving
  message [cMoreMessage] and asking YES/NO.

  Examples:
  ---------
   IF SFIL_LOCK(5,.F.)
       count for "S"$LNAME
       UNLOCK
   ELSE
       LOOP
   ENDIF

  Source:
  -------
  S_SFILOK.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SFIL_LOCK()           Attempts to lock a file
'------------------------------------------------------------------------------
 FUNCTION SFIL_LOCK()

  Short:
  ------
  SFIL_LOCK() Attempts to lock a file

  Returns:
  --------
  <lSuccess> success

  Syntax:
  -------
  SFIL_LOCK(nTries,lInteract,[cMoreMessage])

  Description:
  ------------
  Attempts to lock entire DBF file. Tries <nTries>
  times and then allows user to retry or not <lInteract> by giving
  message [cMoreMessage] and asking YES/NO.

  Examples:
  ---------
   IF SFIL_LOCK(5,.F.)
       count for "S"$LNAME
       UNLOCK
   ELSE
       LOOP
   ENDIF

  Source:
  -------
  S_SFILOK.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SFREADLINE()          Reads in text up to the next CRLF in a text file
'------------------------------------------------------------------------------
 FUNCTION SFREADLINE()

  Short:
  ------
  SFREADLINE() Reads in text up to the next CRLF in a text file

  Returns:
  --------
  <cLine> => line read in

  Syntax:
  -------
  SFREADLINE(nHandle)

  Description:
  ------------
  Reads in text up to the next CRLF in a text file. The
  pointer is moved back to the starting position when done. To move to a
  new line, use  FMOVE2PRIOR() or FMOVE2NEXT().

  Examples:
  ---------
   nHandle := fopen("Report.doc")

   ?sfreadline(handle)
   while fmove2next(handle)
     ?sfreadline(handle)
   end

  Source:
  -------
  S_FREADL.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SFRR_HCODE()          Output report definition to .PRG code
'------------------------------------------------------------------------------
 FUNCTION SFRR_HCODE()

  Short:
  ------
  SFRR_HCODE() Output report definition to .PRG code

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SFRR_HCODE()

  Description:
  ------------
  SFRR_HCODE will present you with a menu-driven
  interface to allow selection of output options for a hard-coded
  .PRG file for a given saved report.

  You will be presented options for :
     SOURCE Report Definition and
     OUTPUT .PRG file name (you choose)

  Once these are selected, you may do a translation
  into .PRG code. The .PRG will do all of the setup needed to call
  SFRR_PMAIN() - the main print routine called by both REPORT()
  and QUICKREPORT().

  The .PRG will no longer require the SFREPORT.DBF in
  order to produce the report.

  This has been written as a function, so you may
  incorporate it easily.

  To produce a stand-alone .EXE to generate report
  .PRGs, you could do the following:

     initsup()

     USE SFREPORT

     sfrr_hcode()

  The resulting .PRGs must be called with DO <prgname>
  If you like, you could make them into a function by issuing a
  by issuing a FUNCTION <function name> at the top.


  Examples:
  ---------
   initsup()
   USE SFREPORT
   sfrr_hcode()

  Source:
  -------
  R_HCODE.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SGETMANY()     ^b(diff)^n Virtual (scrolling)  gets in a popup box
'------------------------------------------------------------------------------
 FUNCTION SGETMANY()                           *changed*

  Short:
  ------
  SGETMANY()    Virtual (scrolling)  gets in a popup box

  Returns:
  --------
  <lSave> => False if ESC pressed, true otherwise

  Syntax:
  -------
  SGETMANY(aGets,aDesc,nTop,nLeft,nBottom,nRight,[cTitle],[cFoot],[nPadding])

  Description:
  ------------
  READs a series of GETs in a popup box, with the
  ability to scroll the GETs up/down when there are more GETs than fit in
  the box.

  <aGets> is an array of get objects. There are two
  ways to create this:

      1.    Use GETNEW() (the Clipper function) to create each
            individual get object. Get row and column do not
            matter - they will be adjusted.

            GET postblock and preblock (valid and when)
            may be assigned as normal. As each new GET object is created,
            add it to an array.

            Pass this array as <aGets>.

      2.    Use the normal @row,col GET... commands, but to a
            location off the screen - otherwise the gets will DISPLAY
            as you are assigning them.

            @MAXROW()+1,MAXCOL()+1 GET... works for me.

  Using @...GET automatically places new get
  objects in the global array GETLIST. Pass GETLIST as <aGets>.

  <aDesc> this is an array of descriptions for each
  get. (the SAY portion). These will be displayed to the left of
  the get.

  <nTop,nLeft,nBottom,nRight> are the dimensions of the
  popup box. The Editing area will be the inside dimensions of this
  box. Make sure there's room!

  [cTitle] is a string to be used for the title.
  Displayed at <nTop>,<nLeft>+1

  [cFoot] is now ignored. This parameter used to be the footer. It
  is now just a placeholder for downward compatibility.

  [nPadding] is for the number of spaces of padding
  between the box frame and the editing area. The default is 0,
  which places the editing area at
  nTop+1,nLeft+1,nBottom-1,nRight-1. A [nPadding] of 1 would place
  the editing area at nTop+2,nLeft+2,nBottom-2,nRight-2 etc.

  Examples:
  ---------

   local i
   local aDesc := {}
   local aGets
   USE CUSTOMER
   aGets := dbf2array()

   for i = 1 to len(aGets)
     @maxrow()+1,maxcol()+1 get aGets[i]
     aadd(aDesc,field(i))
   next

   SGETMANY(getlist,aDesc,10,10,17,50,;
         "Editing","ESC quits, F10 saves",1)

  NOTES:
  -------
  Do not pass a 0 length string as a GET

  Source:
  -------
  S_GETMANY.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SLOTUSMENU()          1-2-3 style menu
'------------------------------------------------------------------------------
 FUNCTION SLOTUSMENU()

  Short:
  ------
  SLOTUSMENU() 1-2-3 style menu

  Returns:
  --------
  <expReturn> => depends on several factors

  Syntax:
  -------
  SLOTUSMENU(nTop,nLeft,nBottom,nRight,aOptions,[lBox],;
        [lSaveRest],[lReset])

  Description:
  ------------
  Draws a 1-2-3 style menu from <nTop>,<nLeft> to
  <nTop+1>,<nRight>.

  <nTop> is the menu option line. <nTop+1> is the
  message line.

  <aOptions> is an array of arrays in the format:

  {  {cOption,cMessage,expAction},
  {cOption,cMessage,expAction},... }

  where <cOption> is the option prompt, <cMessage> is
  the option message, and <expAction> is the option action.

  <expAction> may be of three types:

      1.    a codeblock, in which case it is executed on
            ENTER

      2.    a submenu array of the form:

         {  {cOption,cMessage,expAction},  ;
             {cOption,cMessage,expAction},... }
            which is displayed on ENTER. Pressing ESCAPE
            from the submenu returns to the prior menu.

            The submenu <expaction> may be a codeblock,
            another subarray, or any other value, etc.
            Thus nesting can go as deep as you like.

      3.    any other value, which is returned to the
            calling program on ENTER.

  Pressing ESCAPE from the main menu returns 0

  [lBox]  If True, the menu is drawn inside of a popup
  box. Actual dimensions of the menu area then become
  <nTop>+1,<nLeft>+1 to <nTop>+2,<nRight>-1. Default is False - no box.

  [lSaveRest] If True, the underlying screen is saved
  and restored on entrance/exit. Default is False - no restore.

  [lReset] If True, the menu is reset to first option
  on exit. Default is False - menu remembers where it was.

  SLOTUSCLEAR() resets the menu.

  Examples:
  ---------

   proc test
   local nReturn := 0
   local aMain := {}
   local aSub1 := {{"Pizza",     "Eat Pizza", {||pizza()}},;
                   {"Spaghetti", "Eat Spaghetti", {||spagett()}},;
                   {"Tortellini","Eat Tortellini", {||tortellini()}} }

   local aSub2 := {{"Steak",     "Eat Steak", {||steak()}},;
                   {"Hamburger", "Eat Hamburger",  {||burgers()}},;
                   {"Chili Dog", "Eat Chili Dog",  {||burntwice()}}  }

   aadd(aMain,{"Italian","Eat Italian food",aSub1})
   aadd(aMain,{"American","Eat American food",aSub2})
   aadd(aMain,{"Quit","Just not hungry - Quit",0})
   aadd(aMain,{"Relief","Already ate - need Alka Seltzer",{||alka()} })

   SLOTUSMENU(0,0,0,79,aMain,.t.,.t.,.t.)

   SLOTUSCLEAR()  // !! always use this to clear the menu

  Notes:
  -------

  Always use SLOTUSCLEAR() after calling SLOTUSMENU()

  Source:
  -------
  S_LOTMEN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SLSF_APPT()           Sets and retrieves the file name and path for the
'------------------------------------------------------------------------------
 FUNCTION SLSF_APPT()

  Short:
  ------
 SLSF_APPT() Sets and retrieves the file name and path for the
 SAPPOINT() DBF files

 Returns
 <cFileSpec>  => File path and name less extension

 Syntax
 SLSF_APPT([cNew])

 Description

 [cNew] optionally sets the path and/or filename.

 If [cNew] is passed, this is the value returned as well.

 Examples
  USE (SLSF_APPT() )                    // open the file

  SLSF_APPT("c:\hidden\XYZ123")         // sets the filespec
                                          // to XYZ123.DBF in
                                          // c:\HIDDEN

 Source: S_PATHS.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLSF_COLOR()          Sets and retrieves the file name and path for the
'------------------------------------------------------------------------------
 FUNCTION SLSF_COLOR()

  Short:
  ------
 SLSF_COLOR() Sets and retrieves the file name and path for the
 COLOR SET DBF file

 Returns
 <cFileSpec>  => File path and name less extension

 Syntax
 SLSF_COLOR([cNew])

 Description

 [cNew] optionally sets the path and/or filename.

 If [cNew] is passed, this is the value returned as well.

 Examples
  USE (SLSF_COLOR() )                    // open the file

  SLSF_COLOR("c:\hidden\XYZ123")         // sets the filespec
                                          // to XYZ123.DBF in
                                          // c:\HIDDEN

 Source: S_PATHS.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLSF_FORM()           Sets and retrieves the file name and path for the
'------------------------------------------------------------------------------
 FUNCTION SLSF_FORM()

  Short:
  ------
 SLSF_FORM() Sets and retrieves the file name and path for the
 FORMLETR() DBF file

 Returns
 <cFileSpec>  => File path and name less extension

 Syntax
 SLSF_FORM([cNew])

 Description

 [cNew] optionally sets the path and/or filename.

 If [cNew] is passed, this is the value returned as well.

 Examples
  USE (SLSF_FORM() )                    // open the file

  SLSF_FORM("c:\hidden\XYZ123")         // sets the filespec
                                          // to XYZ123.DBF in
                                          // c:\HIDDEN

 Source: S_PATHS.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLSF_HELP()           Sets and retrieves the file name and path for the
'------------------------------------------------------------------------------
 FUNCTION SLSF_HELP()

  Short:
  ------
 SLSF_HELP() Sets and retrieves the file name and path for the
 HELP() DBF file

 Returns
 <cFileSpec>  => File path and name less extension

 Syntax
 SLSF_HELP([cNew])

 Description

 [cNew] optionally sets the path and/or filename.

 If [cNew] is passed, this is the value returned as well.

 Examples
  USE (SLSF_HELP() )                    // open the file

  SLSF_HELP("c:\hidden\XYZ123")         // sets the filespec
                                          // to XYZ123.DBF in
                                          // c:\HIDDEN

 Source: S_PATHS.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLSF_LABEL()          Sets and retrieves the file name and path for the
'------------------------------------------------------------------------------
 FUNCTION SLSF_LABEL()

  Short:
  ------
 SLSF_LABEL() Sets and retrieves the file name and path for the
 CLABEL() label files

 Returns
 <cFileSpec>  => File path and name less extension

 Syntax
 SLSF_LABEL([cNew])

 Description

 [cNew] optionally sets the path and/or filename.

 If [cNew] is passed, this is the value returned as
 well.

 Examples
  USE (slsf_label() )                    // open the file

  SLSF_LABEL("c:\hidden\XYZ123")         // sets the filespec
                                          // to XYZ123.DBF in
                                          // c:\HIDDEN

 Source: S_PATHS.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLSF_LIST()           Sets and retrieves the file name and path for the
'------------------------------------------------------------------------------
 FUNCTION SLSF_LIST()

  Short:
  ------
 SLSF_LIST() Sets and retrieves the file name and path for the
 LISTER() DBF file

 Returns
 <cFileSpec>  => File path and name less extension

 Syntax
 SLSF_LIST([cNew])

 Description

 [cNew] optionally sets the path and/or filename.

 If [cNew] is passed, this is the value returned as well.

 Examples
  USE (SLSF_LIST() )                    // open the file

  SLSF_LIST("c:\hidden\XYZ123")         // sets the filespec
                                          // to XYZ123.DBF in
                                          // c:\HIDDEN

 Source: S_PATHS.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLSF_OLD()            Sets and retrieves the file name and path for the
'------------------------------------------------------------------------------
 FUNCTION SLSF_OLD()

  Short:
  ------
 SLSF_OLD() Sets and retrieves the file name and path for the
 OLD() help files

 Returns
 <cFileSpec>  => File path and name less extension

 Syntax
 SLSF_OLD([cNew])

 Description

 [cNew] optionally sets the path and/or filename.

 If [cNew] is passed, this is the value returned as
 well.

 Examples
  USE (SLSF_OLD() )                    // open the file

  SLSF_OLD("c:\hidden\XYZ123")            // sets the filespec
                                          // to XYZ123.DBF in
                                          // c:\HIDDEN

 Source: S_PATHS.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLSF_QUERY()          Sets and retrieves the file name and path for the
'------------------------------------------------------------------------------
 FUNCTION SLSF_QUERY()

  Short:
  ------
 SLSF_QUERY() Sets and retrieves the file name and path for the
 QUERY() DBF file

 Returns
 <cFileSpec>  => File path and name less extension

 Syntax
 SLSF_QUERY([cNew])

 Description

 [cNew] optionally sets the path and/or filename.

 If [cNew] is passed, this is the value returned as well.

 Examples
  USE (SLSF_QUERY() )                    // open the file

  SLSF_QUERY("c:\hidden\XYZ123")         // sets the filespec
                                          // to XYZ123.DBF in
                                          // c:\HIDDEN

 Source: S_PATHS.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLSF_REPORT()         Sets and retrieves the file name and path for the
'------------------------------------------------------------------------------
 FUNCTION SLSF_REPORT()

  Short:
  ------
 SLSF_REPORT() Sets and retrieves the file name and path for the
 REPORTER() DBF file

 Returns
 <cFileSpec>  => File path and name less extension

 Syntax
 SLSF_REPORT([cNew])

 Description

 [cNew] optionally sets the path and/or filename.

 If [cNew] is passed, this is the value returned as well.

 Examples
  USE (SLSF_REPORT() )                    // open the file

  SLSF_REPORT("c:\hidden\XYZ123")         // sets the filespec
                                          // to XYZ123.DBF in
                                          // c:\HIDDEN

 Source: S_PATHS.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLSF_SCROLL()         Sets and retrieves the file name and path for the
'------------------------------------------------------------------------------
 FUNCTION SLSF_SCROLL()

  Short:
  ------
 SLSF_SCROLL() Sets and retrieves the file name and path for the
 SCROLLER() DBF file

 Returns
 <cFileSpec>  => File path and name less extension

 Syntax
 SLSF_SCROLL([cNew])

 Description

 [cNew] optionally sets the path and/or filename.

 If [cNew] is passed, this is the value returned as well.

 Examples
  USE (SLSF_SCROLL() )                    // open the file

  SLSF_SCROLL("c:\hidden\XYZ123")         // sets the filespec
                                          // to XYZ123.DBF in
                                          // c:\HIDDEN

 Source: S_PATHS.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLSF_TODO()           Sets and retrieves the file name and path for the
'------------------------------------------------------------------------------
 FUNCTION SLSF_TODO()

  Short:
  ------
 SLSF_TODO() Sets and retrieves the file name and path for the
 TODOLIST() DBF files

 Returns
 <cFileSpec>  => File path and name less extension

 Syntax
 SLSF_TODO([cNew])
 SLSF_TDN1([cNew])
 SLSF_TDN2([cNew])
 SLSF_TDN3([cNew])

 Description

 [cNew] optionally sets the path and/or filename.

 If [cNew] is passed, this is the value returned as well.

 Examples
  USE (SLSF_TODO() ) index SLSF_TDN1(),SLSF_TDN2(),SLSF_TDN3()
                                          // open the files

  SLSF_TODO("c:\hidden\XYZ123")         // sets the filespec
                                          // to XYZ123.DBF in
                                          // c:\HIDDEN

 Source: S_PATHS.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLS_BQUERY()          Sets SuperLib global query block
'------------------------------------------------------------------------------
 FUNCTION SLS_BQUERY()

  Short:
  ------
 SLS_BQUERY() Sets SuperLib global query block

 Returns
 <bSetting> => Current value of the setting

 Syntax
 SLS_BQUERY([bNew])

 Function                   Setting                     Default
 --------------------------------------------------------------
 SLS_BQUERY([bNew])         Query codeblock            {||.t.}
                            set by QUERY()

 [bNew] sets the setting to a new setting
 If [bNew] is passed, the setting is changed and the
 new setting is returned.

 THIS IS MAINLY FOR INTERNAL USE BY SUPERLIB

 Examples

  SLS_BQUERY({||"R"$lname})


 Source: S_GLOBAL.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLS_BQZAP()           Resets SuperLib's global query block
'------------------------------------------------------------------------------
 FUNCTION SLS_BQZAP()

  Short:
  ------
 SLS_BQZAP() Resets SuperLib's global query block

 Returns
 nil

 Syntax
 SLS_BQZAP()

 SLS_BQZAP() Resets SuperLib's global query block which is {||.t.}

 THIS IS MAINLY FOR INTERNAL USE BY SUPERLIB

 Examples

 SLS_BQZAP()

 Notes:

 Source: S_GLOBAL.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLS_FRAME()           A Superlib box setting function
'------------------------------------------------------------------------------
 FUNCTION SLS_FRAME()

  Short:
  ------
 SLS_FRAME() A Superlib box setting function

 Returns
 <cSetting> => Current value of the setting

 Syntax
 SLS_FRAME([cNew])

 Function                   Setting                     Default
 --------------------------------------------------------------
 SLS_FRAME([cNew])          Box frames                   single

 [cNew] sets the setting to a new setting
 If [cNew] is passed, the setting is changed and the
 new setting is returned.


 Examples
  #include "Box.ch"
  sls_FRAME(B_SINGLE+" ")

 Notes:

 Source: S_GLOBAL.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLS_ISCOLOR()         Tells SuperLib if this is a color monitor
'------------------------------------------------------------------------------
 FUNCTION SLS_ISCOLOR()

  Short:
  ------
 SLS_ISCOLOR() Tells SuperLib if this is a color monitor

 Returns
 <expSetting> => Current value of the setting

 Syntax

 SLS_ISCOLOR([lNew])        Is this a color monitor (useful for overriding
                            Clipper's ISCOLOR() )

 [lNew] optionally overrides the default

 Examples

  SLS_ISCOLOR(.F.)                // override ISCOLOR()

 Notes:

 Source: S_GLOBAL.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLS_NORMCOL()         A Superlib color setting function
'------------------------------------------------------------------------------
 FUNCTION SLS_NORMCOL()

  Short:
  ------
 SLS_NORMCOL() A Superlib color setting function

 Returns
 <cSetting> => Current value of the setting

 Syntax
 SLS_NORMCOL([cNew])

 Function                   Setting                     Default
 --------------------------------------------------------------
 SLS_NORMCOL([cNew])        Normal screen output        'W/N,N/W,,,+W/N'

 [cNew] sets the setting to a new setting
 If [cNew] is passed, the setting is changed and the
 new setting is returned.


 Examples

  SETCOLOR(sls_normcol()  )        // use to setcolor()

 Notes:

 Source: S_GLOBAL.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLS_NORMMENU()        A Superlib color setting function
'------------------------------------------------------------------------------
 FUNCTION SLS_NORMMENU()

  Short:
  ------
 SLS_NORMMENU() A Superlib color setting function

 Returns
 <cSetting> => Current value of the setting

 Syntax
 SLS_NORMMENU([cNew])

 Function                   Setting                     Default
 --------------------------------------------------------------
 SLS_NORMMENU([cNew])       Normal MENU color           'W/N,N/W,,,+W/N'

 [cNew] sets the setting to a new setting
 If [cNew] is passed, the setting is changed and the
 new setting is returned.


 Examples

  SETCOLOR(sls_NORMMENU()  )        // use to setcolor()

 Notes:

 Source: S_GLOBAL.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLS_POPCOL()          A Superlib color setting function
'------------------------------------------------------------------------------
 FUNCTION SLS_POPCOL()

  Short:
  ------
 SLS_POPCOL() A Superlib color setting function

 Returns
 <cSetting> => Current value of the setting

 Syntax
 SLS_POPCOL([cNew])

 Function                   Setting                     Default
 --------------------------------------------------------------
 SLS_POPCOL([cNew])         Popup screen output         'N/W,+W/N,,,W/N'

 [cNew] sets the setting to a new setting
 If [cNew] is passed, the setting is changed and the
 new setting is returned.


 Examples

  SETCOLOR(sls_POPCOL()  )        // use to setcolor()

 Notes:

 Source: S_GLOBAL.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLS_POPMENU()         A Superlib color setting function
'------------------------------------------------------------------------------
 FUNCTION SLS_POPMENU()

  Short:
  ------
 SLS_POPMENU() A Superlib color setting function

 Returns
 <cSetting> => Current value of the setting

 Syntax
 SLS_POPMENU([cNew])

 Function                   Setting                     Default
 --------------------------------------------------------------
 SLS_POPMENU([cNew])        Popup MENU color            'N/W,W/N,,,+W/N'

 [cNew] sets the setting to a new setting
 If [cNew] is passed, the setting is changed and the
 new setting is returned.


 Examples

  SETCOLOR(sls_POPMENU()  )        // use to setcolor()

 Notes:

 Source: S_GLOBAL.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLS_PRN()             A Superlib printer setting function
'------------------------------------------------------------------------------
 FUNCTION SLS_PRN()

  Short:
  ------
 SLS_PRN() A Superlib printer setting function

 Returns
 <cSetting> => Current value of the setting

 Syntax
 SLS_PRN([cNew])

 Function                   Setting                     Default
 --------------------------------------------------------------
 SLS_PRN([cNew])            Default printer             'LPT1'

 [cNew] sets the setting to a new setting
 If [cNew] is passed, the setting is changed and the
 new setting is returned.


 Examples

  SLS_PRN("LPT2")
  SET PRINTER TO (SLS_PRN())

 Notes:

 Source: S_GLOBAL.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLS_PRNC()            A Superlib printer setting function
'------------------------------------------------------------------------------
 FUNCTION SLS_PRNC()

  Short:
  ------
 SLS_PRNC() A Superlib printer setting function

 Returns
 <lSetting> => Current value of the setting

 Syntax
 SLS_PRNC([lNew])

 Function                   Setting                     Default
 --------------------------------------------------------------
 SLS_PRNC([lNew])           Check printer ready         .T.
                            (set to .f. on
                            a network)
 [lNew] sets the setting to a new setting
 If [lNew] is passed, the setting is changed and the
 new setting is returned.


 Examples

  SLS_PRNC(.f.)        //  DO NOT DO A HARDWARE PRINTER READY CHECK

 Notes:

 Source: S_GLOBAL.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLS_QUERY()           Sets SuperLib global query string
'------------------------------------------------------------------------------
 FUNCTION SLS_QUERY()

  Short:
  ------
 SLS_QUERY() Sets SuperLib global query string

 Returns
 <cSetting> => Current value of the setting

 Syntax
 SLS_QUERY([cNew])

 Function                   Setting                     Default
 --------------------------------------------------------------
 SLS_QUERY([cNew])          Query string                ''
                            set by QUERY()

 [cNew] sets the setting to a new setting
 If [cNew] is passed, the setting is changed and the
 new setting is returned.

 THIS IS MAINLY FOR INTERNAL USE BY SUPERLIB

 Examples

  SLS_QUERY({||"R"$lname})

 When using SLS_QUERY(), be sure to reset it to ""
 when changing DBFs.

 Source: S_GLOBAL.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLS_SHADATT()         A Superlib color setting function
'------------------------------------------------------------------------------
 FUNCTION SLS_SHADATT()

  Short:
  ------
 SLS_SHADATT() A Superlib color setting function

 Returns
 <nSetting> => Current value of the setting

 Syntax
 SLS_SHADATT([nNew])

 Function                   Setting                     Default
 --------------------------------------------------------------
 SLS_SHADATT([nNew])        Shadow attribute            8  (+N/N)

 [nNew] sets the setting to a new setting
 If [nNew] is passed, the setting is changed and the
 new setting is returned.

 Values are numeric color settings (see color chart)

 Examples

  SLS_SHADATT(127)        // shadow of +w/w

 Notes:

 Source: S_GLOBAL.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLS_SHADPOS()         A Superlib color setting function
'------------------------------------------------------------------------------
 FUNCTION SLS_SHADPOS()

  Short:
  ------
 SLS_SHADPOS() A Superlib color setting function

 Returns
 <nSetting> => Current value of the setting

 Syntax
 SLS_SHADPOS([nNew])

 Function                   Setting                     Default
 --------------------------------------------------------------
 SLS_SHADPOS([nNew])        Shadow position             1  (lower left)
                            (uses numeric keypad
                            as guide)
                              7 upper left
                              1 lower left
                              3 lower right
                              9 upper right
                              0 none

 [nNew] sets the setting to a new setting
 If [nNew] is passed, the setting is changed and the
 new setting is returned.


 Examples

  SLS_SHADPOS(0)        //  NO SHADOW

 Notes:

 Source: S_GLOBAL.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SLS_XPLODE()          A Superlib box setting function
'------------------------------------------------------------------------------
 FUNCTION SLS_XPLODE()

  Short:
  ------
 SLS_XPLODE() A Superlib box setting function

 Returns
 <lSetting> => Current value of the setting

 Syntax
 SLS_XPLODE([lNew])

 Function                   Setting                     Default
 --------------------------------------------------------------
 SLS_XPLODE([lNew])         Explode/implode popups      .T.

 [lNew] sets the setting to a new setting
 If [lNew] is passed, the setting is changed and the
 new setting is returned.


 Examples

  SLS_XPLODE(.f.)        //  NO EXPLODING BOXES

 Notes:

 Source: S_GLOBAL.PRG
!seealso: 
'------------------------------------------------------------------------------



!short:SL_BOLD()             Sets font stroke weight to BOLD (ultra black)
'------------------------------------------------------------------------------
 FUNCTION SL_BOLD()

  Short:
  ------
  SL_BOLD() Sets font stroke weight to BOLD (ultra black)

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_BOLD()

  Description:
  ------------
  Sets font stroke weight to BOLD (ultra black)

  Examples:
  ---------
   ?"Now I am "+SL_BOLD()+"REALLY"+SL_NORMAL()+" mad!"

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_BOX()              Draws a box line from row,col to endrow,endcol
'------------------------------------------------------------------------------
 FUNCTION SL_BOX()

  Short:
  ------
  SL_BOX() Draws a box line from row,col to endrow,endcol

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_BOX(nTop,nLeft,nBottom,nRight,[cShade],[nDPIThick],[nCpi],[nLpi])

  Description:
  ------------
  Draws a box from nTop,nLeft to nBottom,nRight. Based
  on rows and columns.

  [cShade] refers to the density of the line.

  The shading percentages are (default "100" - black) :

         "1 thru 2" = 2% shade
        "3 thru 10" = 10% shade
       "11 thru 20" = 20% shade
       "21 thru 35" = 30% shade
       "36 thru 55" = 45% shade
       "56 thru 80" = 70% shade
       "81 thru 99" = 90% shade
              "100" = 100% shade

  [nDPIThick] is the thickness in DotsPerInch of the
  line. Default is 2.

  [nCpi] is the characters per inch, and defaults to 10.

  [nLpi] is the lines per inch, and defaults to 6.

  Examples:
  ---------
   SL_BOX(10,10,20,20,"50",10)
                     // draws a box 10,10 to 20 20 with 50%
                        //shading and 10 DPI thick

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_COPIES()           Sets the laserjet to print n copies of each page
'------------------------------------------------------------------------------
 FUNCTION SL_COPIES()

  Short:
  ------
  SL_COPIES() Sets the laserjet to print n copies of each page

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_COPIES(nCopies)

  Description:
  ------------
  Sets the laserjet to print <nCopies> copies of each
  page.

  Examples:
  ---------
   cCode := SL_COPIES(2)  // prints 2 or each page

   ?cCode

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_DOWNROW()          Move the printer cursor up/down by # rows,
'------------------------------------------------------------------------------
 FUNCTION SL_DOWNROW()

  Short:
  ------
  SL_DOWNROW() Move the printer cursor up/down by # rows,
  relative to position

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_DOWNROW(nRows)

  Description:
  ------------
  Move print head down <nRows>. A negative number means
  move UP.

  Actual end position will depend on both LINES PER
  INCH settings.

  Examples:
  ---------
   ?SL_DOWNROW(10)

   ??"Hello world"

   ?SL_DOWNROW(-1)    // moves to prior row

   ?SL_OVERCOL(-11)   // and back to starting column

   ??"Attention:"

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_EJECT()            Ejects the current page
'------------------------------------------------------------------------------
 FUNCTION SL_EJECT()

  Short:
  ------
  SL_EJECT() Ejects the current page

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_EJECT()

  Description:
  ------------
  Ejects the current page

  Examples:
  ---------
   ?SL_EJECT()

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_FILL()             Fills a rectangle with shading or a pattern.
'------------------------------------------------------------------------------
 FUNCTION SL_FILL()

  Short:
  ------
  SL_FILL() Fills a rectangle with shading or a pattern.

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_FILL(nTop,nLeft,nBottom,nRight,[cShade],[cFill],[nCpi],[nLpi])

  Description:
  ------------
  Fills a rectangle based on rows and columns at
  <nTop,nLeft> to <nBottom,nRight>. The area may be shaded
  [cShade] or filled with a pattern [cFill] :

  The shading percentages are (default "20") :

         "1 thru 2" = 2% shade
        "3 thru 10" = 10% shade
       "11 thru 20" = 20% shade
       "21 thru 35" = 30% shade
       "36 thru 55" = 45% shade
       "56 thru 80" = 70% shade
       "81 thru 99" = 90% shade
              "100" = 100% shade

  The pattern fills are (default "6"):

       "1" = horizontal lines
       "2" = vertical lines
       "3" = diagonal lines top right to bottom left
       "4" = diagonal lines top left to bottom right
       "5" = #1 and # 2 combined
       "6" = #3 and # 4 combined

  <nCpi> is the characters per inch, and defaults to
  10. <nLpi> is the lines per inch, and defaults to 6.

  Examples:
  ---------
   SL_FILL(10,10,20,20,"50")
    // fills from 10,10 to 20 20 with 50% shading

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_GOTO()             Move the printer cursor to row/col
'------------------------------------------------------------------------------
 FUNCTION SL_GOTO()

  Short:
  ------
  SL_GOTO() Move the printer cursor to row/col

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_GOTO(nRow,nCol)

  Description:
  ------------
  Move print head to row <nRow> and column <nCol>.
  Actual end position will depend on both LINES PER INCH and
  CHARACTERS PER INCH settings.

  Examples:
  ---------
   ?SL_GOTO(10,10)

   ??"Hello world"

   ?SL_GOTO(9,10)

   ??"Attention:"

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_HLINE()            Draws a horizontal line from row,col to row,endcol
'------------------------------------------------------------------------------
 FUNCTION SL_HLINE()

  Short:
  ------
  SL_HLINE() Draws a horizontal line from row,col to row,endcol

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_HLINE(nTop,nLeft,nBottom,nRight,[cShade],[nDPIThick],[nCpi])

  Description:
  ------------
  Draws a horizontal line from <nTop,nLeft> to
  <nBottom,nRight>. Based on rows and columns.

  [cShade] refers to the density of the line.

  The shading percentages are (default "100" - black) :

         "1 thru 2" = 2% shade
        "3 thru 10" = 10% shade
       "11 thru 20" = 20% shade
       "21 thru 35" = 30% shade
       "36 thru 55" = 45% shade
       "56 thru 80" = 70% shade
       "81 thru 99" = 90% shade
              "100" = 100% shade

  [nDPIThick] is the thickness in DotsPerInch of the
  line. Default is 2.

  [nCpi] is the characters per inch, and defaults to 10.

  Examples:
  ---------
   ??SL_HLINE(10,10,10,20,"50")  // draws a line 10,10 to 20,20 with
                                 //50%  shading

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_ITALIC()           Sets font style to italic
'------------------------------------------------------------------------------
 FUNCTION SL_ITALIC()

  Short:
  ------
  SL_ITALIC() Sets font style to italic

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_ITALIC()

  Description:
  ------------
  Sets font style to italic

  Examples:
  ---------
   ?"Now I am "+SL_ITALIC()+"REALLY"+SL_ITALICOFF()+" mad!"

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_ITALICOFF()        Sets font style to upright (non italic)
'------------------------------------------------------------------------------
 FUNCTION SL_ITALICOFF()

  Short:
  ------
  SL_ITALICOFF() Sets font style to upright (non italic)

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_ITALICOFF()

  Description:
  ------------
  Sets font style to upright( non italic)

  Examples:
  ---------
   ?"Now I am "+SL_ITALIC()+"REALLY"+SL_ITALICOFF()+" mad!"

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_LANDS()            Sets laserjet orientation to LANDSCAPE
'------------------------------------------------------------------------------
 FUNCTION SL_LANDS()

  Short:
  ------
  SL_LANDS() Sets laserjet orientation to LANDSCAPE

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_LANDS()

  Description:
  ------------
  Sets laserjet orientation to LANDSCAPE

  Examples:
  ---------
   ?SL_LANDS()

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_LEFTMARG()         Sets the left margin to the left edge of the
'------------------------------------------------------------------------------
 FUNCTION SL_LEFTMARG()

  Short:
  ------
  SL_LEFTMARG() Sets the left margin to the left edge of the
  specified column

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_LEFTMARG(nColumn)

  Description:
  ------------
  Sets the left margin to the left edge of the
  specified column in <nColumn>.

  Examples:
  ---------
   ?SL_LEFTMARG(3) // sets left margin to column3

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_NORMAL()           Sets font stroke weight to NORMAL (non bold)
'------------------------------------------------------------------------------
 FUNCTION SL_NORMAL()

  Short:
  ------
  SL_NORMAL() Sets font stroke weight to NORMAL (non bold)

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_NORMAL()

  Description:
  ------------
  Sets font stroke weight to NORMAL (non bold)

  Examples:
  ---------
   ?"Now I am "+SL_NORMAL()+"REALLY"+SL_NORMAL()+" mad!"

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_OVERCOL()          Move the printer cursor right/left # columns
'------------------------------------------------------------------------------
 FUNCTION SL_OVERCOL()

  Short:
  ------
  SL_OVERCOL() Move the printer cursor right/left # columns
  relative to position

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_OVERCOL(nColumns)

  Description:
  ------------
  Move print head left/right <nColumns>. A negative
  number means move left, a positive number means move right.

  Actual end position will depend on CHARACTERS PER
  INCH settings.

  Examples:
  ---------
   ?SL_OVERCOL(10)

   ??"Hello world"

   ?SL_DOWNROW(-1)    // moves to prior row

   ?SL_OVERCOL(-11)   // and back to starting column

   ??"Attention:"

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_PAGESIZE()         Sets the page size on the laserjet
'------------------------------------------------------------------------------
 FUNCTION SL_PAGESIZE()

  Short:
  ------
  SL_PAGESIZE() Sets the page size on the laserjet

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_PAGESIZE(nSize)

  Description:
  ------------
  Sets the page size on the laserjet where <nSize> is
  one of the following:

       1 Executive          (7.25" x 10.5")
       2 Letter                 (8.5" x 11")
       3 Legal                  (8.5" x 14")
      26 A4                     (210mm x 297mm)
      80 Monarch Envelope   (3 7/8" x 7 1/2")
      90 COM-10 Envelope    (4 1/8" x 8 1/2")
      91 International C5   (162mm  x 229mm)

  Examples:
  ---------
   cCode := SL_PAGESIZE(2)  // letter size
   ?cCode
   cCode := SL_PAGESIZE(3)  // legal  size
   ?cCode
   cCode := SL_PAGESIZE(26)  // A4 size
   ?cCode

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_POPCURS()          Pops the printer cursor position for later popping
'------------------------------------------------------------------------------
 FUNCTION SL_POPCURS()

  Short:
  ------
  SL_POPCURS() Pops the printer cursor position for later popping

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_POPCURS()

  Description:
  ------------
  Pops the current printer cursor position pushed by
  with SL_PUSHCURS(). Up to 20 positions may be POPed.

  Examples:
  ---------
   ?SL_POPCURS()

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_PORT()             Sets the laserjet orientation to PORTRAIT
'------------------------------------------------------------------------------
 FUNCTION SL_PORT()

  Short:
  ------
  SL_PORT() Sets the laserjet orientation to PORTRAIT

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_PORT()

  Description:
  ------------
  Sets the laserject orientation to PORTRAIT

  Examples:
  ---------
   cSetup := SL_PORT()

   ?cSetup

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_PUSHCURS()         Pushes the printer cursor position for later
'------------------------------------------------------------------------------
 FUNCTION SL_PUSHCURS()

  Short:
  ------
  SL_PUSHCURS() Pushes the printer cursor position for later
  popping

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_PUSHCURS()

  Description:
  ------------
  Pushes the current printer cursor position for later
  retrieval (popping) with SL_POPCURS(). Up to 20 positions may be pushed.

  Examples:
  ---------
   ?SL_PUSHCURS()

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_RESET()            Resets the printer to user defaults
'------------------------------------------------------------------------------
 FUNCTION SL_RESET()

  Short:
  ------
  SL_RESET() Resets the printer to user defaults

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_RESET()

  Description:
  ------------
  Resets the printer to user defaults

  Examples:
  ---------
   ?SL_RESET()

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_RIGHTMARG()        Sets the right margin to the right edge of the
'------------------------------------------------------------------------------
 FUNCTION SL_RIGHTMARG()

  Short:
  ------
  SL_RIGHTMARG() Sets the right margin to the right edge of the
  specified column

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_RIGHTMARG(nCol)

  Description:
  ------------
  Sets the right margin to the right edge of the
  specified column <nCol>

  Examples:
  ---------
   ?SL_RIGHTMARG(70) // sets right margin to 70

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_SETCPI()           Sets characters per inch
'------------------------------------------------------------------------------
 FUNCTION SL_SETCPI()

  Short:
  ------
  SL_SETCPI() Sets characters per inch

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_SETCPI(nCPI)

  Description:
  ------------
  Sets characters per inch to <nCpi>  - valid to 2
  decimal places. Current font must support this CPI.

  Examples:
  ---------
   ?SL_SETCPI(16.66)   // sets to compressed

   ?SL_SETCPI(12)     // sets to 12 cpi

   ?SL_SETCPI(10)     // sets to 10 cpi  (default)

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_SETLPI()           Sets the lines per inch for the laserjet
'------------------------------------------------------------------------------
 FUNCTION SL_SETLPI()

  Short:
  ------
  SL_SETLPI() Sets the lines per inch for the laserjet

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_SETLPI(nLPI)

  Description:
  ------------
  Sets the lines per inch for the laserjet to <nLpi>
  which  can be:

  1 - 1 line/inch
  2 - 2 line/inch
  3 - 3 line/inch
  4 - 4 line/inch
  6 - 6 line/inch
  8 - 8 line/inch
  12-12 line/inch
  16-16 line/inch
  24-24 line/inch
  48-48 line/inch

  Examples:
  ---------
   cCode := SL_SETLPI(6)     // sets LPI to 6 - the default

   ?cCode

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_TOPMARG()          Designates the number of lines of top margin
'------------------------------------------------------------------------------
 FUNCTION SL_TOPMARG()

  Short:
  ------
  SL_TOPMARG() Designates the number of lines of top margin

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_TOPMARG(nLines)

  Description:
  ------------
  Designates the number of lines of top margin <nLines>

  Examples:
  ---------
   ?SL_TOPMARG(3) // sets top margin to 3

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_UNDER()            Sets automatic text underlining on
'------------------------------------------------------------------------------
 FUNCTION SL_UNDER()

  Short:
  ------
  SL_UNDER() Sets automatic text underlining on

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_UNDER()

  Description:
  ------------
  Sets automatic text underlining on

  Examples:
  ---------
   ?"Now I am "+SL_UNDER()+"REALLY"+SL_UNDEROFF()+" mad!"

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_UNDEROFF()         Sets automatic text underlining off
'------------------------------------------------------------------------------
 FUNCTION SL_UNDEROFF()

  Short:
  ------
  SL_UNDEROFF() Sets automatic text underlining off

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_UNDEROFF()

  Description:
  ------------
  Sets automatic text underlining off

  Examples:
  ---------
   ?"Now I am "+SL_UNDER()+"REALLY"+SL_UNDEROFF()+" mad!"

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_VLINE()            Draws a vertical line from row,col to endrow,col
'------------------------------------------------------------------------------
 FUNCTION SL_VLINE()

  Short:
  ------
  SL_VLINE() Draws a vertical line from row,col to endrow,col

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_VLINE(nTop,nLeft,nBottom,nRight,[cShade],[nDPIThick],[nLpi])

  Description:
  ------------
  Draws a vertical line from <nTop,nLeft> to <nBottom,nRight>. Based
  on rows and columns.

  [cShade] refers to the density of the line.

  The shading percentages are (default "100" - black) :

         "1 thru 2" = 2% shade
        "3 thru 10" = 10% shade
       "11 thru 20" = 20% shade
       "21 thru 35" = 30% shade
       "36 thru 55" = 45% shade
       "56 thru 80" = 70% shade
       "81 thru 99" = 90% shade
              "100" = 100% shade

  [nDPIThick] is the thickness in DotsPerInch of the
  line. Default is 2.

  [nLpi] is the lines per inch, and defaults to 6.

  Examples:
  ---------
   ??SL_VLINE(10,20,10,10,"50")  // draws a line 10,10 to 20,10 with
                                          // 50% shading

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SL_WRAP()             Sets line wrapping on or off
'------------------------------------------------------------------------------
 FUNCTION SL_WRAP()

  Short:
  ------
  SL_WRAP() Sets line wrapping on or off

  Returns:
  --------
  cCode => control string to send to the printer

  Syntax:
  -------
  SL_WRAP(lSet)

  Description:
  ------------
  Sets line wrapping on (.t.) or off (.f.) with <lSet>

  Examples:
  ---------
   ?SL_WRAP(.T.)  // set line wrapping on

  Notes:
  -------
  Does not send anything to the printer - instead
  returns a control string that you send to the printer. String can be
  sent with ? or ?? or  QOUT() or QQOUT().

  For HP and compatible(PCL) Laserjet printers.

  Source:
  -------
  S_HPLAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SMAILMERGE()          Creates mailmerge files for WordPerfect & MS Word
'------------------------------------------------------------------------------
 FUNCTION SMAILMERGE()

  Short:
  ------
  SMAILMERGE() Creates mailmerge files for WordPerfect & MS Word

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SMAILMERGE([<aFields>,<aDesc>,<aTypes>,<aLens>,<aDeci>])

  Description:
  ------------
  This is a menu driven metafunction for creating
  mailmerge files for WordPerfect and MS Word. Merge files can be created
  with selected fields and for selected conditions.

  [<aFields>,<aDesc>,<aTypes>,<aLens>,<aDeci>] are
  optional arrays of fieldnames, field descriptions, field types,
  field lengths, field decimals. Pass all or none. Default is all
  fields.

  Examples:
  ---------
   use CUSTOMER

   SMAILMERGE()

  Source:
  -------
  S_MAILM.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SMALLKCLR()           Clears get lookup combinations set up with SMALLKSET()
'------------------------------------------------------------------------------
 FUNCTION SMALLKCLR()

  Short:
  ------
  SMALLKCLR() Clears get lookup combinations set up with SMALLKSET()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SMALLKCLR()

  Description:
  ------------
  Clears the static lookup definitions stored with
  SMALLKSET(). See SMALLKSET().

  Examples:
  ---------
   SMALLKSET(K_F2,  ;
         "EDITCUST","mAgent",{||agent},"Agent",5,"AGENT")

   SMALLKCLR()

  Source:
  -------
  S_SMALK.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SMALLKSET()           Sets up GET-HOTKEY lookup combinations using smalls()
'------------------------------------------------------------------------------
 FUNCTION SMALLKSET()

  Short:
  ------
  SMALLKSET() Sets up GET-HOTKEY lookup combinations using smalls()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SMALLKSET(nKey,cProc,cVar,expDisplayString,[cTitle],;
  [expAlias],expReturn,[expStartRange,expEndRange],[bException])

  Description:
  ------------
  Sets key <nKey> to popup SMALLS() with parameters
  <expDisplayString> through [bException] when pressed on
  proc/function <cProc> and var/get <cVar>

  See SMALLS() for description of parameters
  <expDisplayString> through [bException] This actually sets key
  <nKey> to an internal function called SMALLKEY(), and stores the
  lookup definition in a static array. SMALLKEY() recieves
  proc,line,variable and determines lastkey(), and checks the
  static array for that set. If found, smalls() is called with the
  stored parameters.

  Examples:
  ---------

   bOldF2 := SETKEY(K_F2)  // save F2 setting
   // set up some var/lookup definitions keyed to F2

   SMALLKSET(K_F2,"EDITCUST","mState",  ;
         {||state},"State",5,"STATE")

   SMALLKSET(K_F2,"EDITCUST","mZone",  ;
         {||zone},"Zone",5,"ZONE")

   SMALLKSET(K_F2,"EDITCUST","mAgent",  ;
         {||agent},"Agent",5,"AGENT")

   //...code...

   SMALLKCLR()   // be sure to clear out the definitions

  Notes:
  -------
  Save and restore the values to any keys used with
  Clipper's  SETKEY(). Use SMALLKCLR() to clear out the SMALLKEY()
  stored definitions.

  Source:
  -------
  S_SMALK.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SMALLS()              Lookup tables on dbf with optional hotkeys, code block
'------------------------------------------------------------------------------
 FUNCTION SMALLS()

  Short:
  ------
  SMALLS() Lookup tables on dbf with optional hotkeys, code block

  Returns:
  --------
  lReturn   => True if CR pressed, False otherwise

  Syntax:
  -------
  Smalls(expDisplayString,[cTitle],[expAlias],[expReturn],;
      [expStartRange,expEndRange],[bException],[lForceCaps])

  Description:
  ------------
  Popup windowed lookup tables. Many options.

  The up/down/home/end/pgup/pgdn keys are active. If
  there is an controlling index key and the user types alphanumeric
  characters, it is assumed a keysearch is wanted. A read pops up
  allowing the user to complete the search key, and a seek is then
  done.

  Pressing ENTER or ESCAPE exits the lookup and closes
  the window.

  Depending on values contained in the optional
  parameters, values may be KEYBOARDED or ASSIGNED at that time.

  Other keys may be assigned actions, depending on the
  last parameter, described below.

  <expDisplayString>  is what appears for each row in
     the lookup table.

     Think of it as a column definition for Tbrowse.
       It can be either:

       1. A Characters string like
          "LAST+MI+LEFT(FIRST,1)"
          In which case it is macro expanded and made
          into a code block to display this expression

       2. A Codeblock like
          {||LAST+MI+LEFT(FIRST,1)}

       The resulting codeblock is then used as a
       Tbrowse column definition.

  [cTitle]    is an optional lookup box title string

  [expAlias]  Determines the area/dbf/ntx to use, can be
     (expC) alias name             or
     (expN) numeric work area      or
     (expC) dbf/ndx in the format
            "%dbfname%ndxname"

     If left as nil, the current DBF/NTX are
     used and left open when done at the last record
     pointer position.

  [expReturn] This determines what happens when CR is
     pressed. It need not be anything, but it can be:

     (expC) a character expression which is
            macro expanded and KEYBOARDed. Any valid character
            expression will do.

            (Bear in mind that it must be
              character. If you want to keyboard a value into a DATE
              field, for instance, your keyboard expression could be
              "DTOC(entrydate)"

     (expB) a code block which is simply
            evaluated. this can do
            anything you wish. It could assign
            multiple values
            from the lookup file into active
            gets, for instance.

  [expStartRange-expEndRange]
     These are valid for indexed files, and
     determine the beginning and ending key ranges. The
     values must match the type of the controlling index.

  [bException]
     If this codeblock is passed, any keys
     except up/down/enter/pgup/pgdn/home/end/escape  (and
     alphanumeric keys if indexed )  will cause the block to be
     evaluated like so:

       eval(block,lastkey())

     Some interesting ideas for this would be
     to assign a key to an update routine for updating the
     lookup dbf while doing a lookup. (yikes - you didn't hear
     that from me!)

  [lForceCaps]

     Means force capital letters when user is typing in a
     lookup key.  Allows case-insensitive search when index is on
     upper(field)

  Examples:
  ---------
   // lookup on "LNAME+' '+FNAME" in current area
   smalls("LNAME+' '+FNAME")

   // lookup on "LNAME+' '+FNAME" in current area
   // use "Name" as box title
   smalls("LNAME+' '+FNAME","Name")

   // lookup on "LNAME+' '+FNAME" in current area
   // use "Name" as box title
   // go to area 5 for the lookup
   // send LNAME to the keyboard if CR pressed
   smalls({||LNAME+''+FNAME},"Name",5,"LNAME")

   // lookup on "LNAME+' '+FNAME" in current area
   // use "Name" as box title
   // go to alias CUSTOMER for the lookup
   smalls("LNAME+''+FNAME","Name","CUSTOMER")

   // open customer.dbf and do a lookup on it
   // lookup on "LNAME+' '+FNAME"
   // use "Name" as box title
   smalls("LNAME+''+FNAME","Name","%CUSTOMER")

   // open customer.dbf and do a lookup on it
   // lookup on "LNAME+' '+FNAME"
   // use "Name" as box title
   // limit lookup to between "SMITH" and "ZEBRA"
   smalls("LNAME+''+FNAME","Name","%CUSTOMER%NAME",  ;
         "SMITH","ZEBRA")

   // open CUSTOMER.DBF with ENTRYDATE.NDX and do a lookup
   // lookup on "LNAME+' '+FNAME"
   // use "Name" as box title
   // limit lookup to the last year
   smalls("LNAME+''+FNAME","Name",  ;
         "%CUSTOMER%ENTRYDATE",date()365, date())

  Notes:
  -------
  see SMALLVALID(), SMALLWHEN() and SMALLKSET() for
  various get system interfaces to SMALLS().

  Source:
  -------
  S_SMAL.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SMALLVALID()          Uses SMALLS() lookups in a VALID condition for a GET
'------------------------------------------------------------------------------
 FUNCTION SMALLVALID()

  Short:
  ------
  SMALLVALID() Uses SMALLS() lookups in a VALID condition for a GET

  Returns:
  --------
  lValid  => logical value

  Syntax:
  -------
  SMALLVALID([bValid],expDisplayString,[cTitle],;
     [expAlias],expReturn,[expStartRange,expEndRange],[bException])

  Description:
  ------------
  Uses SMALLS() in a VALID condition for a GET. See
  SMALLS() for description of parameters <expDisplayString>
  through [bException]

  If the user selects a value from the SMALLS() lookup,
  a value of True is returned, allowing the next GET to be made
  active. Otherwise, a False is returned. The return value is also
  determined by [bValid]

  [bValid]  -  This is a code block that determines if
  the current get is already valid. If this is passed, it is first
  evaluated, and, only if the current get is NOT ALREADY VALID,
  SMALLS() is called with the SMALLS() parameters given. If this
  is not passed, SMALLS() is called automatically. IF this is
  passed and the GET is valid, a True is returned, allowing the
  next GET to be 'gotten'.

  Examples:
  ---------
   @3,0 GET V3 VALID  ;
       SMALLVALID({||!EMPTY(V3)},"LASTNAME",nil,5,"LASTNAME")

   // This will pop up a smalls() lookup table when attempting to exit
   // the get 'V3' where 'V3' is empty. A SMALLS() lookup is  called, with
   // smalls() parameters provided, and, if CR is pressed, the GET is fed
   // or assigned the lookup value. (depends on value of <expReturn>)
   // If 'V3' is already valid, a True is returned, and the next GET is made
   // active. If SMALLS() is called and CR is pressed while in SMALLS(),
   // a True is returned. Otherwise a False is returned.

  Notes:
  -------
  See Smalls() for a complete parameter description.

  Source:
  -------
  S_SMGETS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SMALLWHEN()           Uses SMALLS() in a WHEN condition for a GET
'------------------------------------------------------------------------------
 FUNCTION SMALLWHEN()

  Short:
  ------
  SMALLWHEN() Uses SMALLS() in a WHEN condition for a GET

  Returns:
  --------
  lValid  => logical value

  Syntax:
  -------
  SMALLWHEN([lShowOnUp],[lReturn],expDisplayString,[cTitle],;
       [expAlias],expReturn,[expStartRange,expEndRange],[bException])

  Description:
  ------------
  Uses SMALLS() in a WHEN condition for a GET. See
  SMALLS() for description of parameters <expDisplayString>
  through [bException]

  [lShowOnUp] If False (the default), smalls is not
  called when going backwards through the read (up arrow, etc), only when
  going forward.

  [lReturn]   This is simply the value to return. The
  default is False, which means the get is never 'edited'. A value
  of True means the smalls() lookup is done, and then the get is edited.

  Examples:
  ---------
   @3,0 GET V3 WHEN ;
       SMALLWHEN(.f.,.f.,"LASTNAME",nil,5,"LASTNAME")

   // This will pop up a smalls() lookup table when going forward
   // through the gets. If RETURN is pressed, the current GET is fed
   // or assigned the lookup value. (depends on value of <expReturn>)
   // A False is returned, so the GET is not actually edited. The new
   // value is displayed, and the next get is made active.

  Notes:
  -------
  See Smalls() for a complete parameter description.

  Source:
  -------
  S_SMGETS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SNET_USE()            Attempts to  open a DBF
'------------------------------------------------------------------------------
 FUNCTION SNET_USE()

  Short:
  ------
  SNET_USE() Attempts to  open a DBF

  Returns:
  --------
  <lSuccess> => for success

  Syntax:
  -------
  SNET_USE(cDbfName,cAlias,lExclusive,nTries,lAskMore,cMoreMsg )

  Description:
  ------------
  Attempts to open a DBF file <cDbfName> with alias of
  <cAlias>, opening EXCLUSIVE or NOT based on <lExclusive>. Tries
  <nTries> times and then allows user to retry or not based on
  <lAskMore> by giving message <cMoreMsg> and asking YES/NO.

  Examples:
  ---------
   IF SNET_USE("CUSTOMER.DBF","CUSTOMER",.F.,5,.T.,;
     "Unable to open CUSTOMER.DBF. Try again?")
       SET INDEX TO CUSTOMER,ACCTNO
   ELSE
       MSG("Unable to proceed, returning to menu")
       loop
   ENDIF

  Source:
  -------
  S_SNETU.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SPOPORDER()           Popup allows user to change viewing (index) order
'------------------------------------------------------------------------------
 FUNCTION SPOPORDER()

  Short:
  ------
  SPOPORDER() Popup allows user to change viewing (index) order

  Returns:
  --------
  <nOrder> => current index order

  Syntax:
  -------
  SPOPORDER()

  Description:
  ------------
  Pops up a list of current index keys, with first
  option being <Natural (record) order>. If an index order is
  selected, index order is set to that order. Current index order (after
  selection and change) is returned.

  Examples:
  ---------
   nIndexOrd := spoporder()

  Source:
  -------
  S_POPORD.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SPOPSEEK()            Popup seek based on present index keys
'------------------------------------------------------------------------------
 FUNCTION SPOPSEEK()

  Short:
  ------
  SPOPSEEK() Popup seek based on present index keys

  Returns:
  --------
  <lFound> => seek succesful or not

  Syntax:
  -------
  SPOPSEEK([aKeys])

  Description:
  ------------
  Pops up first a box asking for which index selection,
  and when the index key is selected, asks for a value to be
  entered to seek on. Performs a seek and returns <lFound>
  success. The index order is saved and restored.

  [aKeys] is an optional array of current index keys.

  Examples:
  ---------
   IF choice = POP_SEEK
      if SPOPSEEK()
        redrawscreen()
      endif
   ENDIF

  Source:
  -------
  S_PSEEK.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SREC_LOCK()           Attempts to lock a record
'------------------------------------------------------------------------------
 FUNCTION SREC_LOCK()

  Short:
  ------
  SREC_LOCK() Attempts to lock a record

  Returns:
  --------
  <lSuccess> => success

  Syntax:
  -------
  SREC_LOCK(nTries,lAskMore,cMoreMessage)

  Description:
  ------------
  Attempts to lock current record. Tries <nTries> times
  and then allows user to retry or not based on <lAskMore> by
  giving message <cMoreMessage> and asking YES/NO.

  Examples:
  ---------
   IF SREC_LOCK(5,.T.,"Unable to lock record. Try again?")
       REPLACE XXX WITH YYY, ZZZ WITH BBB
       UNLOCK
   ELSE
       LOOP
   ENDIF

  Source:
  -------
  S_SRECLO.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SREC_LOCK()           Attempts to lock a record
'------------------------------------------------------------------------------
 FUNCTION SREC_LOCK()

  Short:
  ------
  SREC_LOCK() Attempts to lock a record

  Returns:
  --------
  <lSuccess> => success

  Syntax:
  -------
  SREC_LOCK(nTries,lAskMore,cMoreMessage)

  Description:
  ------------
  Attempts to lock current record. Tries <nTries> times
  and then allows user to retry or not based on <lAskMore> by
  giving message <cMoreMessage> and asking YES/NO.

  Examples:
  ---------
   IF SREC_LOCK(5,.T.,"Unable to lock record. Try again?")
       REPLACE XXX WITH YYY, ZZZ WITH BBB
       UNLOCK
   ELSE
       LOOP
   ENDIF

  Source:
  -------
  S_SRECLO.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SS_CLOSEH()           Restores screen in a horizontal close fashion.
'------------------------------------------------------------------------------
 FUNCTION SS_CLOSEH()

  Short:
  ------
  SS_CLOSEH() Restores screen in a horizontal close fashion.
  Alternative to restscreen()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SS_CLOSEH(nTop,nLeft,nBottom,nRight,cInScreen,[nDelay])

  Description:
  ------------
  Restores screen <cInScreen> in a close from top and
  bottom fashion.

  <cInscreen> is a screen saved with SAVESCREEN().
  <nTop>,<nLeft>,<nBottom>, <nRight> are the screen coordinates.

  [nDelay]  is a delay factor. Default is 100. (Smaller
  # is faster)

  Relative to the speed of the machine.

  Examples:
  ---------
   MainScreen := savescreen(0,0,24,79)
   DOSOMESCREENSTUFF()
   DOMORESCREENSTUFF()
   SS_CLOSEH(0,0,24,79,MainScreen)

  Source:
  -------
  S_SCREENS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SS_CLOSEV()           Restores screen in a vertical close fashion.
'------------------------------------------------------------------------------
 FUNCTION SS_CLOSEV()

  Short:
  ------
  SS_CLOSEV() Restores screen in a vertical close fashion.
  Alternative to restscreen()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SS_CLOSEV(nTop,nLeft,nBottom,nRight,cInScreen,[nDelay])

  Description:
  ------------
  Restores screen <cInScreen> in a close from left and
  right fashion.

  <cInscreen> is a screen saved with SAVESCREEN().
  <nTop>,<nLeft>,<nBottom>, <nRight> are the screen coordinates.

  [nDelay]  delay factor. Default is 50. (Smaller # is
  faster)

  Relative to the speed of the machine.

  Examples:
  ---------
   MainScreen := savescreen(0,0,24,79)
   DOSOMESCREENSTUFF()
   DOMORESCREENSTUFF()
   SS_CLOSEV(0,0,24,79,MainScreen)

  Source:
  -------
  S_SCREENS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SS_FADE()             Restores screen in a fadeaway fashion.
'------------------------------------------------------------------------------
 FUNCTION SS_FADE()

  Short:
  ------
  SS_FADE() Restores screen in a fadeaway fashion.
  Alternative to restscreen()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SS_FADE(nTop,nLeft,nBottom,nRight,cInScreen)

  Description:
  ------------
  Restores screen <cInScreen> in a fadeaway fashion.
  <cInscreen>

  is a screen saved with SAVESCREEN().
  <nTop>,<nLeft>,<nBottom>,<nRight> are the screen coordinates.

  Examples:
  ---------
   MainScreen := savescreen(0,0,24,79)

   DOSOMESCREENSTUFF()

   DOMORESCREENSTUFF()

   SS_FADE(0,0,24,79,MainScreen)

  Source:
  -------
  S_SCREENS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SS_FALL()             Restores screen in a fall from top fashion.
'------------------------------------------------------------------------------
 FUNCTION SS_FALL()

  Short:
  ------
  SS_FALL() Restores screen in a fall from top fashion.
  Alternative to restscreen()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SS_FALL(nTop,nLeft,nBottom,nRight,cInScreen,[nDelay])

  Description:
  ------------
  Restores screen <cInScreen> in a fall from top
  fashion. <cInscreen>

  is a screen saved with SAVESCREEN().
  <nTop>,<nLeft>,<nBottom>,<nRight> are the screen coordinates.

  [nDelay]  delay factor. Default is 100. (Smaller # is
  faster)

  Relative to the speed of the machine.

  Examples:
  ---------
   MainScreen := savescreen(0,0,24,79)

   DOSOMESCREENSTUFF()

   DOMORESCREENSTUFF()

   SS_FALL(0,0,24,79,MainScreen)

  Source:
  -------
  S_SCREENS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SS_FOLD()             Restores screen in a fold to middle fashion.
'------------------------------------------------------------------------------
 FUNCTION SS_FOLD()

  Short:
  ------
  SS_FOLD() Restores screen in a fold to middle fashion.
  Alternative to restscreen()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SS_FOLD(nTop,nLeft,nBottom,nRight,cInScreen,[nDelay])

  Description:
  ------------
  Restores screen <cInScreen> in a fold to middle
  fashion. <cInscreen>

  is a screen saved with SAVESCREEN(). <nTop>,
  <nLeft>,<nBottom>,<nRight> are the screen coordinates.

  [nDelay]  delay factor. Default is 3. (Larger # is
  faster)

  Relative to the speed of the machine.

  Examples:
  ---------
   MainScreen := savescreen(0,0,24,79)

   DOSOMESCREENSTUFF()

   DOMORESCREENSTUFF()

   SS_FOLD(0,0,24,79,MainScreen)

  Source:
  -------
  S_SCREENS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SS_HBLINDS()          Restores screen in a horizontal blind fashion.
'------------------------------------------------------------------------------
 FUNCTION SS_HBLINDS()

  Short:
  ------
  SS_HBLINDS() Restores screen in a horizontal blind fashion.
  Alternative to restscreen()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SS_HBLINDS(nTop,nLeft,nBottom,nRight,cInScreen,[nDelay])

  Description:
  ------------
  Restores screen <cInScreen> in a horizontal blind
  fashion.

  <cInscreen> is a screen saved with SAVESCREEN().
  <nTop>,<nLeft>,<nBottom>,<nRight> are the screen coordinates.

  [nDelay]  delay factor. Default is 100. Higher number
  makes a slower

  screen restore. Lower number makes a faster screen
  restore. Relative to the speed of the machine.

  Examples:
  ---------
   MainScreen := savescreen(0,0,24,79)

   DOSOMESCREENSTUFF()

   DOMORESCREENSTUFF()

   ss_hblinds(0,0,24,79,MainScreen)

  Source:
  -------
  S_SCREENS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SS_IMPLODE()          Restores screen in an imploding fashion.
'------------------------------------------------------------------------------
 FUNCTION SS_IMPLODE()

  Short:
  ------
  SS_IMPLODE() Restores screen in an imploding fashion.
  Alternative to restscreen()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SS_IMPLODE(nTop,nLeft,nBottom,nRight,cInScreen,[nDelay])

  Description:
  ------------
  Restores screen <cInScreen> in an imploding fashion.

  <cInscreen> is a screen saved with SAVESCREEN().
  <nTop>,<nLeft>,<nBottom>, <nRight> are the screen coordinates.

  [nDelay]  delay factor. Default is 100. (Smaller # is
  faster)

  Relative to the speed of the machine.

  Examples:
  ---------
   MainScreen := savescreen(0,0,24,79)

   DOSOMESCREENSTUFF()

   DOMORESCREENSTUFF()

   SS_IMPLODE(0,0,24,79,MainScreen)

  Source:
  -------
  S_SCREENS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SS_RISE()             Restores screen in a rise from bottom fashion.
'------------------------------------------------------------------------------
 FUNCTION SS_RISE()

  Short:
  ------
  SS_RISE() Restores screen in a rise from bottom fashion.
  Alternative to restscreen()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SS_RISE(nTop,nLeft,nBottom,nRight,cInScreen,[nDelay])

  Description:
  ------------
  Restores screen <cInScreen> in a rise from bottom
  fashion. <cInscreen>

  is a screen saved with SAVESCREEN().
  <nTop>,<nLeft>,<nBottom>,<nRight> are the screen coordinates.

  [nDelay]  is a delay factor. Default is 100. (Smaller
  # is faster)

  Relative to the speed of the machine.

  Examples:
  ---------
   MainScreen := savescreen(0,0,24,79)

   DOSOMESCREENSTUFF()

   DOMORESCREENSTUFF()

   SS_RISE(0,0,24,79,MainScreen)

  Source:
  -------
  S_SCREENS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SS_SLICE()            Restores screen in a slicing fashion. Alternative
'------------------------------------------------------------------------------
 FUNCTION SS_SLICE()

  Short:
  ------
  SS_SLICE() Restores screen in a slicing fashion. Alternative
  to restscreen()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SS_SLICE(nTop,nLeft,nBottom,nRight,cInScreen,[nDelay])

  Description:
  ------------
  Restores screen <cInScreen> in a slicing fashion.
  <cInscreen>

  is a screen saved with SAVESCREEN().
  <nTop>,<nLeft>,<nBottom>,<nRight> are the screen coordinates.

  [nDelay]  is a delay factor. Default is 8. (Larger #
  is faster)

  Relative to the speed of the machine.

  Examples:
  ---------
   MainScreen := savescreen(0,0,24,79)

   DOSOMESCREENSTUFF()

   DOMORESCREENSTUFF()

   SS_SLICE(0,0,24,79,MainScreen)

  Source:
  -------
  S_SCREENS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SS_SLIDELEFT()        Restores screen in a slide left fashion.
'------------------------------------------------------------------------------
 FUNCTION SS_SLIDELEFT()

  Short:
  ------
  SS_SLIDELEFT() Restores screen in a slide left fashion.
  Alternative to restscreen()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SS_SLIDELEFT(nTop,nLeft,nBottom,nRight,cInScreen)

  Description:
  ------------
  Restores screen <cInScreen> in a slide left fashion.

  <cInscreen> is a screen saved with SAVESCREEN().
  <nTop>,<nLeft>,<nBottom>,<nRight> are the screen coordinates.

  Examples:
  ---------
   MainScreen := savescreen(0,0,24,79)

   DOSOMESCREENSTUFF()

   DOMORESCREENSTUFF()

   SS_SLIDELEFT(0,0,24,79,MainScreen)

  Source:
  -------
  S_SCREENS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SS_SPLIT()            Restores screen in a split from middle fashion.
'------------------------------------------------------------------------------
 FUNCTION SS_SPLIT()

  Short:
  ------
  SS_SPLIT() Restores screen in a split from middle fashion.
  Alternative to restscreen()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SS_SPLIT(nTop,nLeft,nBottom,nRight,cInScreen,[nDelay])

  Description:
  ------------
  Restores screen <cInScreen> in a split from middle
  fashion. <cInscreen> is a screen saved with SAVESCREEN().
  <nTop>,<nLeft>,<nBottom>,<nRight> are the screen coordinates.

  [nDelay]  is a delay factor. Default is 5. (Larger #
  is faster)

  Relative to the speed of the machine.

  Examples:
  ---------
   MainScreen := savescreen(0,0,24,79)

   DOSOMESCREENSTUFF()

   DOMORESCREENSTUFF()

   SS_SPLIT(0,0,24,79,MainScreen)

  Source:
  -------
  S_SCREENS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SS_VBLINDS()          Restores screen in a vertical blind fashion.
'------------------------------------------------------------------------------
 FUNCTION SS_VBLINDS()

  Short:
  ------
  SS_VBLINDS() Restores screen in a vertical blind fashion.
  Alternative to restscreen()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SS_VBLINDS(nTop,nLeft,nBottom,nRight,cInScreen,[nDelay])

  Description:
  ------------
  Restores screen <cInScreen> in a horizontal blind
  fashion.

  <cInscreen>is a screen saved with SAVESCREEN().
  <nTop>,<nLeft>,<nBottom>,<nRight> are the screen coordinates.

  [nDelay]  delay factor. Default is 100. Higher number
  makes a slower

  screen restore. Lower number makes a faster screen
  restore. Relative to the speed of the machine.

  Examples:
  ---------
   MainScreen := savescreen(0,0,24,79)

   DOSOMESCREENSTUFF()

   DOMORESCREENSTUFF()

   ss_vblinds(0,0,24,79,MainScreen)

  Source:
  -------
  S_SCREENS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SS_WIPEH()            Restores screen in a wipe from left fashion.
'------------------------------------------------------------------------------
 FUNCTION SS_WIPEH()

  Short:
  ------
  SS_WIPEH() Restores screen in a wipe from left fashion.
  Alternative to restscreen()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SS_WIPEH(nTop,nLeft,nBottom,nRight,cInScreen,[nDelay])

  Description:
  ------------
  Restores screen <cInScreen> in a wipe fromleft
  fashion.

  <cInscreen> is a screen saved with SAVESCREEN().
  <nTop>,<nLeft>,<nBottom>, <nRight> are the screen coordinates.

  [nDelay]  delay factor. Default is 100. (Smaller # is
  faster)

  Relative to the speed of the machine.

  Examples:
  ---------
   MainScreen := savescreen(0,0,24,79)

   DOSOMESCREENSTUFF()

   DOMORESCREENSTUFF()

   SS_WIPEH(0,0,24,79,MainScreen)

  Source:
  -------
  S_SCREENS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SS_WIPEV()            Restores screen in a wipe from top fashion.
'------------------------------------------------------------------------------
 FUNCTION SS_WIPEV()

  Short:
  ------
  SS_WIPEV() Restores screen in a wipe from top fashion.
  Alternative to restscreen()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SS_WIPEV(nTop,nLeft,nBottom,nRight,cInScreen,[nDelay])

  Description:
  ------------
  Restores screen <cInScreen> in a wipe from top
  fashion.

  <cInscreen> is a screen saved with SAVESCREEN().
  <nTop>,<nLeft>,<nBottom>, <nRight> are the screen coordinates.

  [nDelay]  is a delay factor. Default is 50. (Smaller
  # is faster)

  Relative to the speed of the machine.

  Examples:
  ---------
   MainScreen := savescreen(0,0,24,79)

   DOSOMESCREENSTUFF()

   DOMORESCREENSTUFF()

   SS_WIPEV(0,0,24,79,MainScreen)

  Source:
  -------
  S_SCREENS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:STABMENU()            Tabular (grid style) menu
'------------------------------------------------------------------------------
 FUNCTION STABMENU()

  Short:
  ------
  STABMENU() Tabular (grid style) menu

  Returns:
  --------
  <nSelection> => Number of menu option selected

  Syntax:
  -------
  STABMENU(nTop,nLeft,nBottom,nRight,aPrompts,[nStart])

  Description:
  ------------
  Does a tabular (grid) menu based on an array of
  prompts passed as <aPrompts>. Dimensions of the menu table will be
  <nTop,nLeft,nBottom,nRight>. Number of menu rows is
  the number of rows Number of menu columns is determined based on
  number of rows. Prompts are layed out in a snaking fashion :

     e.g. (for a 3 row table...)

       column 1, row 1  = 1st prompt
       column 1, row 2  = 2nd prompt
       column 1, row 3  = 3rd prompt
       column 2, row 1  = 4th prompt

  Pressing a character will move to the next matching
  prompt with that first letter. Left-right and up-down perform a
  snaking pattern

  Pressing ENTER causes selection to be made, and the
  number of the selection to be returned.

  Pressing ESCAPE returns 0.

  [nStart] Optional starting options. Default is 1.

  Examples:
  ---------
   nChoice := ;
          stabmenu(10,10,14,70,{"One","two","three","four",;
                        "five","six","seven","eight",;
                        "nine","ten","eleven","twelve"}, 5)

  Notes:
  -------
  This is a non-popup version of PSTABMENU(), and will
  remain on the screen when done.

  Source:
  -------
  S_TABMEN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:STAGFIELDS()          Tag fields
'------------------------------------------------------------------------------
 FUNCTION STAGFIELDS()

  Short:
  ------
  STAGFIELDS() Tag fields

  Returns:
  --------
  aTagged => an array of element #'s of the tagged items

  Syntax:
  -------
  STAGFIELDS([aFieldnames],[cTitle],[cMark])

  Description:
  ------------
  Tags selected items in an array of fields, returning
  an array of element #'s of tagged items in the array of fields.

  [aFieldNames] - an array of field names. Default -
  all fields

  [cTitle]      - title for the popup. Default none

  [cMark]       - character used to mark as tagged.

                          Default is checkmark chr(251)

  Examples:
  ---------
   aTagged := STAGFIELDS()

   for i = 1 to len(aTagged)

     ?field(aTagged[i])   // fieldname

   next

  Source:
  -------
  S_TAGF.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:STANDARD()            Returns color integer for standard setting
'------------------------------------------------------------------------------
 FUNCTION STANDARD()

  Short:
  ------
  STANDARD() Returns color integer for standard setting

  Returns:
  --------
  <nColor> => color integer for standard color setting

  Syntax:
  -------
  STANDARD()

  Description:
  ------------
  Returns numeric color integer for use with functions
  which require it like ATT(), PRNT().

  Examples:
  ---------
   nStan := standard()+128   && blinking

   PRNT(10,10,"Waiting...",nStan)


  Source:
  -------
  S_STAN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:STARTSW()             Determines if a string starts with another string
'------------------------------------------------------------------------------
 FUNCTION STARTSW()

  Short:
  ------
  STARTSW() Determines if a string starts with another string

  Returns:
  --------
  <lStartsWith> => String 1 starts with string 2

  Syntax:
  -------
  STARTSW(cTarget,cStarts)

  Description:
  ------------
  Determines if string 1 <cTarget> starts with string 2
  <cStarts>

  Examples:
  ---------
   cStr1    := "SUPERFUNCTION"

   cStr2    := "SUPER"

   cStr3    := "SOUP"

   STARTSW(cStr1,cStr2)    //returns .t.

   STARTSW(cStr1,cStr3)    //returns .f.

  Source:
  -------
  S_STARTS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:STOD()                Returns date from string in the form YYYYMMDD
'------------------------------------------------------------------------------
 FUNCTION STOD()

  Short:
  ------
  STOD() Returns date from string in the form YYYYMMDD

  Returns:
  --------
  <dDate> => date from string

  Syntax:
  -------
  STOD(cStringDate)

  Description:
  ------------
  Returns date from string of the form YYYYMMDD
  <cStringDate>

  Examples:
  ---------
   cStrdate := "19890102"

   dNewdate := STOD(cStrdate)

   // (returns 01/02/89 type date)

  Source:
  -------
  S_STOD.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:STRETCH()             Imbeds characters in a string
'------------------------------------------------------------------------------
 FUNCTION STRETCH()

  Short:
  ------
  STRETCH() Imbeds characters in a string

  Returns:
  --------
  <cStretched> => string with characters imbedded

  Syntax:
  -------
  STRETCH(cSource,cFill,nEvery)

  Description:
  ------------
  Imbeds character <cFill> in string <cSource> every
  <nEvery> character

  Examples:
  ---------
   cString := "SUPERFUNCTION"

   cString := STRETCH(cString,' ',1)

   // (returns "S U P E R F U N C T I O N")

  Notes:
  -------
  This hombre might be called EXPAND in other parts

  Source:
  -------
  S_STRETC.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:STRIP_PATH()          Strip path and optionally extension from a
'------------------------------------------------------------------------------
 FUNCTION STRIP_PATH()

  Short:
  ------
  STRIP_PATH() Strip path and optionally extension from a
  filespec

  Returns:
  --------
  <cFile> => file name with path and optionally
  extension stripped

  Syntax:
  -------
  STRIP_PATH(cInSpec, [lStripExt])

  Description:
  ------------
  Returns <cInSpec>, the name of a file with its path
  stripped.

  [lStripExt] if True will strip the extension as well.
  Default is false.

  Examples:
  ---------
   ?STRIP_PATH("C:\HAIRY\CRITTERS\MONKEY.DBF")
   //  => returns "MONKEY.DBF"

   ?STRIP_PATH("C:\HAIRY\CRITTERS\MONKEY.DBF",.T.)
   //  => returns "MONKEY"

  Source:
  -------
  S_STRPAT.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:STRPULL()             Extract text between 2 characters in a string
'------------------------------------------------------------------------------
 FUNCTION STRPULL()

  Short:
  ------
  STRPULL() Extract text between 2 characters in a string

  Returns:
  --------
  <cExtract> => text extracted

  Syntax:
  -------
  STRPULL(cSource,cDelim1,cDelim2)

  Description:
  ------------
  Extracts text from <cSource> between characters
  <cDelim1> and <cDelim2>.

  If <cDelim1> is empty, uses beginning of <cSource>.

  If <cDelim2> is empty, uses end of <cSource>.

  Examples:
  ---------
   cString := "SUPERFUNCTION"

   cString := STRPULL(cString,'E','C')

   // (returns "RFUN")

  Source:
  -------
  S_STRPUL.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SUBPLUS()             Returns multiple substrings
'------------------------------------------------------------------------------
 FUNCTION SUBPLUS()

  Short:
  ------
  SUBPLUS() Returns multiple substrings

  Returns:
  --------
  <cSubs> => new string from multiple substrings

  Syntax:
  -------
  SUBPLUS(cSource,<nStart1,nCount1>,...[nStart8,nCount8])

  Description:
  ------------
  Extracts from string <cSource> from position
  <nStart1> for <nCount1>

  characters, and repeats for sets
  [nStart2-nCount2...nStart8-nCount8]

  Examples:
  ---------
   cString := "PREFONTAINE"

   cGarble := SUBPLUS(cString,6,1,5,1,1,1,3,1)

   // garble  =  "NOPE"

  Source:
  -------
  S_SUBPLU.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:SUM_AVE()             Interactive sum or average on a dbf field
'------------------------------------------------------------------------------
 FUNCTION SUM_AVE()

  Short:
  ------
  SUM_AVE() Interactive sum or average on a dbf field

  Returns:
  --------
  Nothing

  Syntax:
  -------
  SUM_AVE([cSumAve])

  Description:
  ------------
  Does a SUM or AVERAGE on a selected numeric field

  [csumAve] = "SUM" or "AVE". Default is "SUM"

  Examples:
  ---------
   case nChoice = 3  && sum

     SUM_AVE("SUM")

   case nChoice = 4  && average

     SUM_AVE("AVE")

  Notes:
  -------
  If sls_query() is not empty, an  optional SUM or
  AVERAGE for QUERY can be done.

  Source:
  -------
  S_SUMAV.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:TAGARRAY()            Tag selected elements of an array
'------------------------------------------------------------------------------
 FUNCTION TAGARRAY()

  Short:
  ------
  TAGARRAY() Tag selected elements of an array

  Returns:
  --------
  An array containing the element numbers of the tagged
  items

  Syntax:
  -------
  TAGARRAY(aArray,[cTitle],[cMark])

  Description:
  ------------
  Tag items in <aArray>

  Optional title [cTitle] . Optional mark [cMark].

  Default title is none. Default mark is chr(251) - the
  checkmark.

  Examples:
  ---------
   aArr := {1,2,3,4,5,6,7}

   aSel := TAGARRAY(aArr,"Which Items","X")
   for i = 1 to len(aSel)
     DO_SOMETHING_WITH( aArr[ aSel[i] ] )
   next

  Source:
  -------
  S_TAGA.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:TAGIT()               Tag records in a dbf for later action
'------------------------------------------------------------------------------
 FUNCTION TAGIT()

  Short:
  ------
  TAGIT() Tag records in a dbf for later action

  Returns:
  --------
  <aTagged> => An array of tagged record numbers

  Syntax:
  -------
  TAGIT(aTagged,[aFields,aFieldDesc],[cTitle])

  Description:
  ------------
  <aTagged> is an array. To start, it is an empty array. It is both
  modified by reference and returned as a parameter. It
  is filled with the record numbers of tagged records. If it is not
  empty when passed in, it is presumed to be filled with already tagged
  record numbers.

  <aTagged> is always 'packed' on entry, so any empty()
  or nil elements are removed, and the length adjusted.

  [aFields,aFieldDesc] are optional arrays of field
  names and field descriptions.

  [cTitle] is an optional title for the tag popup.

  Examples:
  ---------
   aTag := {}
   tagit(aTag,nil,nil,"Tag records to copy")
   copy to temp for (ascan(aTag,recno()) > 0)

  Notes:
  -------
  There are slight differences in behavior from
  previous versions.

  Previous versions required an array of fixed length,
  and only allowed tagging up to that length. This version grows or
  shrinks the array as needed. This version will also shrink an empty
  array down to zero on startup.

  Source:
  -------
  S_TAG.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:TAGMARRAY()           Tag elements in muti-dimensioned array
'------------------------------------------------------------------------------
 FUNCTION TAGMARRAY()

  Short:
  ------
  TAGMARRAY() Tag elements in muti-dimensioned array

  Returns:
  --------
  <aTagged> => an array of numbers representing the
  tagged elements

  Syntax:
  -------
  TAGMARRAY(aArray,[cTitle],[cMark],[aTags],[aHeads])

  Description:
  ------------
  A popup which allows tagging/untagging of elements in
  <aArray>, which is a multi-dimmed array of the format
  {array(n),array(n)} such as is returned by DIRECTORY() or DBSTRUCT().

    SPACE   = Tag/Untag
    F10     = Done
    ESC     = Abort
    ALT-A   = Tag All
    ALT-U   = Untag All
    ALT-S   = Swap Tagged/untagged

  The return value <aTagged> is an array of integer
  values representing the offsets into the original array <aArray> which
  were tagged.

  [cTitle] is a string to be used as the box title

  [cMark]  is the tag character. Default is chr(251) - checkmark

  [aTags]  is an array of logicals the same length as
  <aArray>. This allows pre-tagging. You may also use this
  array on return from the function. The (.T.) elements
  correspond to the tagged elements in <aArray>.

  [aHeads] is an array for the column titles for each
  subarray element in <aArray>, and needs to be the same length
  as a subarray of <aArray>

  Examples:
  ---------
   aDir  := directory()

   aCols := {"File","Size","Date","Time","Attribute"}

   aCopy := tagmarray(aDir,"Select Files for copying",nil,nil,aCols)

   for i = 1 to len(aCopy)

     COPY FILE (aDir[aCopy[i],1 ]) TO (cDestination)

   next

  Notes:
  -------
  Coded by Matthew Maier - thanks.

  Source:
  -------
  S_TAGAM.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:TIMEPER()             Time Period (date sensitive) DBF analysis
'------------------------------------------------------------------------------
 FUNCTION TIMEPER()

  Short:
  ------
  TIMEPER() Time Period (date sensitive) DBF analysis

  Returns:
  --------
  Nothing

  Syntax:
  -------
  TIMEPER([aFields,aDescript],[aIndexes])

  Description:
  ------------
  Does a menu-driven time/date sensitive analysis of a
  DBF based on DATE type fields in the DBF, by sorting data into
  time periods

  Time periods can be:

       A By Week
       B Week to Date
       C By Month
       D Month to Date
       E By Year
       F Year to date
       G User defined

  Additional numeric fields may be tallied within each
  time period.

  [aFields]   array of field names

  [aDescript] array of field descriptions

  [aIndexes]  array of currently open indexes for
  re-opening on exit

  Examples:
  ---------
   TIMEPER(aFields,aDesc,aIndexes)

  Warnings:
  ----------
  Restore your indexes after using this function, as it
  creates a new index and you will lose the SET INDEX...unless you
  pass the third param as an array of open indexes

  Source:
  -------
  S_TIME.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:TODOLIST()            Simple todo list manager
'------------------------------------------------------------------------------
 FUNCTION TODOLIST()

  Short:
  ------
  TODOLIST() Simple todo list manager

  Returns:
  --------
  Nothing

  Syntax:
  -------
  TODOLIST()

  Description:
  ------------
  Pops up a simple TODO list interface,allowing the
  user to enter in things 'To do' by Description,Category
  ,Priority and Date Due. These categories may be sorted, filtered
  and printed.

  Examples:
  ---------
   TODOLIST()

  Source:
  -------
  S_TODO.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:TRUEVAL()             Returns val of ALL numerics in a string
'------------------------------------------------------------------------------
 FUNCTION TRUEVAL()

  Short:
  ------
  TRUEVAL() Returns val of ALL numerics in a string

  Returns:
  --------
  <nValue> => all numerics value

  Syntax:
  -------
  TRUEVAL(cString)

  Description:
  ------------
  Removes all non-numeric characters from a <cString>,
  and then converts it to numeric.

  Examples:
  ---------
   cString := "SUPERFUNCTION Library version 3.00"

   cNumber := TRUEVAL(cString)

   // (returns 3.0)

  Source:
  -------
  S_TRUEVA.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:UNBOX()               Removes a box created by makebox()
'------------------------------------------------------------------------------
 FUNCTION UNBOX()

  Short:
  ------
  UNBOX() Removes a box created by makebox()

  Returns:
  --------
  Nothing

  Syntax:
  -------
  Unbox([cMakeBox],[nTop,nLeft,nBottom,nRight],[expRestScreen] )

  Description:
  ------------
  UNBOX restores the screen <cMakeBox> saved by
  MAKEBOX(). MAKEBOX() stores the dimensions and color in the
  returned string, so it is not necessary to pass these to
  UNBOX(). If the dimensions are passed, UNBOX() assumes these are
  not part of the saved string, and assumes the string is a
  savescreen() string. If the string and any other single param
  are passed, UNBOX() assumes it is a full screen (0,0,24,79)
  restore and does so.

  [nTop,nLeft,nBottom,nRight] - the dimensions of the box.

  Use these to UNBOX() a screen saved with SAVESCREEN().

  [bcRestScreen] This is a block which can override the
  default screen restore mechanism. If passed, this screen restore
  is used instead of the default. To set back to default, pass
  this parameter as an empty string "". If passing this parameter,
  pass all other parameters as NIL. What this does, basically, is
  set up a static variable which holds the screen restore block.
  Default is {|t,l,b,r,s|restscreen(t,l,b,r,s)} or if sls_xplode()
  is (.t.), {|t,l,b,r,s|bxx_imbox(t,l,b,r,s)} (an internal
  function within S_UNBOX.PRG) .

  Examples:
  ---------
   cMsgBox := MAKEBOX(10,40,12,60,'W/R,+GR/R')

   @11,42 SAY "What's up, Doc ?"

   inkey(0)

   UNBOX(cMsgBox)

   // to set up the alternate screen restore method:
  unbox(nil,nil,nil,nil,nil,{|t,l,b,r,s| ss_fade(t,l,b,r,s)})
  unbox(nil,nil,nil,nil,nil,{|t,l,b,r,s| ss_fall(t,l,b,r,s,100)} )

   // to set screen restore back to the default
  unbox(nil,nil,nil,nil,nil,"")

  Source:
  -------
  S_UNBOX.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:UNIQFNAME()           Creates a unique file name
'------------------------------------------------------------------------------
 FUNCTION UNIQFNAME()

  Short:
  ------
  UNIQFNAME() Creates a unique file name

  Returns:
  --------
  <cUniqueName> => unique file name

  Syntax:
  -------
  UNIQFNAME(cExtension,[cPath],[cPrefix])

  Description:
  ------------
  Attempts to create a unique file name using
  <cExtension> extension for file.

  [cPath]     path to check

  [cPrefix]   prefix (first letter) of file name
  (defaults to U)

  Examples:
  ---------
   cTempfile := UNIQFNAME("DBF")

   cTempfile := UNIQFNAME("NTX","C:\local\")

  Source:
  -------
  S_UNIQF.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:UNSELECTED()          Returns color integer for UNSELECTED setting
'------------------------------------------------------------------------------
 FUNCTION UNSELECTED()

  Short:
  ------
  UNSELECTED() Returns color integer for UNSELECTED setting

  Returns:
  --------
  <nColor> => numeric color integer for unselected
  color setting

  Syntax:
  -------
  UNSELECTED()

  Description:
  ------------
  Returns numeric color integer for use with functions
  which require it

  like ATT(), PRNT().

  Examples:
  ---------
   nUnsel = UNSELECTED()

   PRNT(10,10,"Waiting...",nUnsel)

  Notes:
  -------

  Source:
  -------
  S_UNSEL.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:VAR2CHAR()            Converts any type variable to character type
'------------------------------------------------------------------------------
 FUNCTION VAR2CHAR()

  Short:
  ------
  VAR2CHAR() Converts any type variable to character type

  Returns:
  --------
  <cCharVal> => value as character

  Syntax:
  -------
  Var2char(expX)

  Description:
  ------------
  Converts variable in <expX> to type character

  Examples:
  ---------
   dtype := ctod("01/01/80")

   ntype := 128.45

   ltype := .t.

   VAR2CHAR(dtype)   // returns "01/01/80"

   VAR2CHAR(ntype)   // returns "128.45"

   VAR2CHAR(ltype)       //returns ".t."

  Warnings:
  ----------
  Numerics will be returned with a length of 10 minimum

  You may wish to trim this.

  Notes:
  -------
  Returns memo types as ""

  PREVIOUSLY ACCEPTED THE 'NAME' OF THE VARIABLE. NOW
  THE VALUE IS PASSED IN DIRECTLY.

  Source:
  -------
  S_VAR2.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:VARLEN()              Returns length of a variable  of any type
'------------------------------------------------------------------------------
 FUNCTION VARLEN()

  Short:
  ------
  VARLEN() Returns length of a variable  of any type

  Returns:
  --------
  <nLength> => Length of variable

  Syntax:
  -------
  Varlength(expX)

  Description:
  ------------
  Converts expX to character with VAR2CHAR() and then
  returns its length

  Examples:
  ---------
   VARLEN(123.45)    //returns 6

   VARLEN(.F.)       //returns 3

   VARLEN(DATE())  //returns 8

  Source:
  -------
  S_VARLEN.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:VERTVIEW()            Pops up a vertical view of the current record
'------------------------------------------------------------------------------
 FUNCTION VERTVIEW()

  Short:
  ------
  VERTVIEW() Pops up a vertical view of the current record

  Returns:
  --------
  Nil

  Syntax:
  -------
  VERTVIEW([aFields,aFDescr],[cColor],[cTitle],[cFooter])

  Description:
  ------------
  Pops up a vertical view of the current record's
  values. Memos are displayed as "(memo - Enter to View)" and pressing CR
  will view them.

  Pressing ESCAPE exits.

  The popup box is displayed centered on the screen. If
  all fields do not fit into the box, scrolling is allowed with the
  arrow keys.

  [aFields] and [aFDescr] are optional fields and field
  descriptions.

  Default is all fields, with field names as
  descriptions.

  [cColor] is the optional box color. Default is
  sls_popcol()

  [cTitle] is an optional title string displayed at
  top,left+1

  [cFooter] is a footer displayed at bottom,left+1.
  Default footer is "ESCAPE to quit"

  Examples:
  ---------
   if nLastkey = K_ALT_V
     VERTVIEW()
   endif

  Source:
  -------
  S_VVIEW.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:VIEWMEMOS()    ^b(diff)^n Popup viewing (non-edit mode) of memos
'------------------------------------------------------------------------------
 FUNCTION VIEWMEMOS()                          *changed*

  Short:
  ------
  VIEWMEMOS() Popup viewing (non-edit mode) of memos

  Returns:
  --------
  Nil

  Syntax:
  -------
  VIEWMEMOS([nTop,nLeft,nBottom,nRight],[cColor],[cMemoName])

  Description:
  ------------
  VIEWMEMOS() will determine first off if there are any
  memo fields to view. If there are not, it will display a message
  to that effect and exit.

  If there is only one memo, it will be immediately
  viewed.

  If there are more than one memo, a picklist of memos
  will be popped up for selection. The memo selected will be viewed.

  [nTop,nLeft,nBottom,nRight] are the dimensions of the
  popup box.

  Default is 2,15,22,65. (Just numbers off the top of
  my head.)

  [cColor] is an optional color string. Default is
  sls_popcol().

  [cMemoName] (new to 3.5) allows you to pass in a memo name and
  bypass the "Which memo?" screen.

  Examples:
  ---------
   USE CUSTOMER

   if qfldstype("M") > 0  // qfldstyp() is a superlib function
      VIEWMEMOS()
   endif

  Source:
  -------
  S_VMEMO.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:VIEWPORT()            Multi-optional data entry engine
'------------------------------------------------------------------------------
 FUNCTION VIEWPORT()

  Short:
  ------
  VIEWPORT() Multi-optional data entry engine

  Returns:
  --------
  Nothing

  Syntax:
  -------
  VIEWPORT([lModify],[aFields,aDesc],[aPict],[aVal],[aLook],;
            [aOther],[aEdit],[lCarry],[cTitle])

  Description:
  ------------
  Presents a generic data entry screen with multiple
  movement, search, view and editing capabilities.

  [lModify] Logical - this is (.T.) if you want to give
  the user Add,Edit,Delete, and (.F.) if not. Defaults to (.T.)

  Arrays 1-5 and array 7 must have the same # of
  elements.
  (default is # of fields in DBF). You may pass a nil
  to bypass and activate the default for any of these arrays.

  [aFields]    An array of field names. Defaults to all
  fields in DBF.

  [aDesc]   An array of field descriptions. Defaults to
  field names. You must pass [aFields] if you wish to pass
  [aDesc]

  [aPict]  is an array of PICTURES as Character
  expressions to correspond with the [aFields] array. Default is
  pictures as derived by ED_G_PIC(). If you pass this array,
  each element must contain  at least a "".

  [aVal] is an array of VALID clauses and messages
  to correspond with the [aFields] array. Each is in the form

         "{valid clause};{valid message}"

  The FIELD is represented as a token "@@"
  in the valid clause which is replaced with the current edited
  value at edit time. Note: Field values are loaded into an
  array when editing, so field names in the valid are not
  meaningful. Field name FIRST might be aValues[12]. At edit
  time, the "@@ " will be  replaced with "aValues[12]".

         i.e.
          "!empty(@@);Must not be empty"

  If you pass this array, each element must
  contain at least a "".

  [aLook]  is an array of Lookup definitions
  corresponding to the [aFields] array.
  These are delimited strings with 1-4
  component parts matching the first four parameters of SMALLS().
  Delimiter is a semicolon (;). As an example, to make a lookup
  definition corresponding to the COMPANY field in the
  [aFields] array, which will lookup on the field CORPNAME in
  the database INSTIT, titling the box "Company" and KEYBOARDing
  the contents of CORPNAME if CR pressed

             "CORPNAME;Company;%INSTIT;CORPNAME".

  If you realize that these 4 components are
  parsed and sent as parameters to SMALLS(), you will get the
  idea.

  If you pass this array, each element must
  contain at least a "".

  [aOther]  [1-9 elements] Each of elements 1-9 is a
  delimited string in the format

         "{option};{action}"

  where option is a displayed menu option and action
  is a proc to be executed. i.e.:

          "Form Letters;FORMLETR()"
          "List Myfile;FILEREAD(2,2,22,78,'FMYFILE.TXT')"

  Pass 1-9 option/proc combinations. These
  will be presented as an 'Other' menu.

  THESE PROCS MUST BE DECLARED EXTERNAL!!!

  [aEdit] an array of logicals matches the FIELDS
  array and defines which fields may be edited (.t.) and which
  are display only (.f.)  If you pass this array, each element
  must be of TYPE Logical.

  [lCarry]     Pop up 'Carry Forward' message when adding?
  True/False. Default is True.

  [cTitle]     Optional title. Default is
               "  VIEW  PORT  for file: "+TRIM(ALIAS())+' '



  Examples:
  ---------
   local aFlds[fcount()]
   local aFdes[fcount()]
   local aFval[fcount()]
   local aFloo[fcount()]
   local aFedit[fcount()]
   afields(aFlds)
   afields(aFdes)
   afill(aFval,"")
   afill(aFloo,"")
   afill(aFedit,.t.)

   // valids for fields 5 and 6
   aFval[5]:="!empty(@@);Cannot be empty"
   aFval[6]:="!empty(@@);Cannot be empty"

   // lookups for fields 5 and 6
   aFloo[5] := "First;First Name;%user%;trim(first)"
   aFloo[6] := "Last;Last Name;%user%;trim(Last)"

   // 'other' menu array

   aOther := { "Read PRG;FILEREAD(1,1,23,79,'s_viewp.prg')",;
               "Do Form Letters ;FORMLETR()",;
               "Frequency Analysis;FREQANAL()" }

   VIEWPORT(.t.,aFlds,aFdes,nil,aFval,aFloo,aOther)

  Source:
  -------
  S_VIEWP.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:WGT_MEAS()            A Weights and Measures conversion metafunction
'------------------------------------------------------------------------------
 FUNCTION WGT_MEAS()

  Short:
  ------
  WGT_MEAS() A Weights and Measures conversion metafunction

  Returns:
  --------
  Nothing

  Syntax:
  -------
  WGT_MEAS()

  Description:
  ------------
  WGT_MEAS() is a menu driven Weights and Measure
  conversion utility, which supports many types of conversions.

  Examples:
  ---------
   WGT_MEAS()

  Source:
  -------
  S_MEAS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:WOMONTH()             Calculates week of the month (# of 7 day periods)
'------------------------------------------------------------------------------
 FUNCTION WOMONTH()

  Short:
  ------
  WOMONTH() Calculates week of the month (# of 7 day periods)

  Returns:
  --------
  <nWeek> => week of the month

  Syntax:
  -------
  WOMONTH(dDate)

  Description:
  ------------
  Calculates current number of 7 day periods for the
  month from <dDate>

  Examples:
  ---------
   dDate := ctod("10/15/90")

   nDom  := WOMONTH(dDate)

   // (returns 3)

  Source:
  -------
  S_WOMON.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:WORKBLOCK()           Returns a set-get block for field named in an
'------------------------------------------------------------------------------
 FUNCTION WORKBLOCK()

  Short:
  ------
  WORKBLOCK() Returns a set-get block for field named in an
  expression

  Returns:
  --------
  <bBlock> => a set-get block

  Syntax:
  -------
  WORKBLOCK(cExpress)

  Description:
  ------------
  Determines the work area and field name in <cExpress>
  and returns a FIELDWBLOCK() created block for it.

  Examples:
  ---------
   cExpr := "CUSTOMER->LNAME"

   bExpr := WORKBLOCK(cExpr)

   ?eval(bExpr)              // displays value

   ?eval(bExpr,"SMITH")    // sets new value

  Source:
  -------
  S_FIELDS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:WOYEAR()              Calculates week of the year (# of 7 day periods)
'------------------------------------------------------------------------------
 FUNCTION WOYEAR()

  Short:
  ------
  WOYEAR() Calculates week of the year (# of 7 day periods)

  Returns:
  --------
  <nWeek> => week of the year of date

  Syntax:
  -------
  WOYEAR(dDate)

  Description:
  ------------
  Calculates number of 7 day periods passed for the
  year from <dDate>

  Examples:
  ---------
   dDate    := ctod("10/15/90")

   nWoYear  := WOYEAR(dDate)

   // (returns 40)

  Source:
  -------
  S_WOYEAR.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:WRITEFILE()           Writes a line or lines  to a text file
'------------------------------------------------------------------------------
 FUNCTION WRITEFILE()

  Short:
  ------
  WRITEFILE() Writes a line or lines  to a text file

  Returns:
  --------
  nothing

  Syntax:
  -------
  Writefile(cFileName|n|FileHandle,cText|aText)

  Description:
  ------------
  Writes line(s) of text with CR LF to a file
  referenced either as a file handle <nFileHandle> or a file
  name <cFileName>.

  Writes either a single line contained in <cText> or all of the
  contents of array <aText> to the file.

  Examples:
  ---------
   1. WRITEFILE('ERROR.TXT','THERE WAS AN ERROR')

   2. aErrors := array(3)
      aErrors[1] = 'There was an error'
      aErrors[2] = 'Error # 61765  '
      aErrors[3] = dtoc(date)
      writefile('ERROR.TXT',aErrors)

   3. nHandle := fopen("error.txt",1)
      aErrors := array(3)
      aErrors[1] = 'There was an error'
      aErrors[2] = 'Error # 61765  '
      aErrors[3] = dtoc(date)
      writefile(nHandle,aErrors)

  Notes:
  -------
  If a filename is passed, the file is opened and
  closed by the function.

  If a file handle is passed, the file is left open. If
  the file does not exist, it is created.

  PREVIOUSLY AN ARRAY NAME WAS PASSED. THIS MUST NOW BE
  AN ARRAY.

  Source:
  -------
  S_WRITEF.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:XBXX()                Draws an exploding box on the screen of a given color
'------------------------------------------------------------------------------
 FUNCTION XBXX()

  Short:
  ------
  XBXX() Draws an exploding box on the screen of a given color

  Returns:
  --------
  Nothing

  Syntax:
  -------
  XBxx(nTop,nLeft,nBottom,nRight,[nColor],[nShadow];
                      [nShadowColor],[cFrame])

  Description:
  ------------
  <nTop >      - top row
  <nLeft>      - left col
  <nBottom>    - bottom row
  <nRight>     - right column
  [nColor]     - attribute to box default setcolor()
  [nShadow]    - numeric shadow type  (default 0)
                    follow numeric keypad
                        7 = upper left
                        1 = lower left
                        3 = lower right
                        9 = upper right
                        0 = no shadow

  [nShadowColor]   - shadow attribute (default 7 - grey on black)

  [cFrame ]    - frame string - MUST be 9 characters - default single line

  Examples:
  ---------
   XBXX(10,10,20,20,47,9,8)

  Notes:
  -------
  Previously a 'C' function, now Clipper 5.01.



  Source:
  -------
  S_XBXX.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:YNREADER()            Creates specialized Yes/No get reader block
'------------------------------------------------------------------------------
 FUNCTION YNREADER()

  Short:
  ------
  YNREADER() Creates specialized Yes/No get reader block

  Returns:
  --------
  <bReader> => get reader block for logical GET

  Syntax:
  -------
  YNREADER()

  Description:
  ------------
  Creates a reader block that pops up a Yes/No window
  to get the logical value for the current get.

  Implement by using the SEND keyword for your
  @Say..Get.. statements.

  i.e. @10,10 say blah get blahblah SEND reader:=YNREADER()

  Use this on a LOGICAL get only.

  Examples:
  ---------
   // while in the get V1, a Yes/No window pops up for
  logical selection

   v1 := .f.

   @10,10 get v1 send reader := ynreader()

   READ

  Source:
  -------
  S_READRS.PRG

!seealso: 
'------------------------------------------------------------------------------



!short:_WILDCARD()           Wild Card String Compare
'------------------------------------------------------------------------------
 FUNCTION _WILDCARD()

  Short:
  ------
  _WILDCARD() Wild Card String Compare

  Returns:
  --------
  <lMatched> => match

  Syntax:
  -------
  _wildcard(<cPattern>,<cTarget>)

  Description:
  ------------
  <cPattern> is a model/wildcard pattern to search for
  and <cTarget> is a string to compare with model/pattern in
  <cPattern>.

  Like DOS wildcards, but for a string.

  <cPattern> is a string of wild cards interspersed
  with literal text to compare against the contents of <cTarget>.
  The following conventions for wild cards are followed:

    1. "*"     stands for any group of characters.

                W*r     gives fields beginning with
                     "W", ending with "r".
                *w*r    gives fields having "w"
                    before last character "r".

    2. "?"     stands for any single character.
                J?n?s   gives Janes, Janus, Jones, and so
                on.

  Examples:
  ---------
   _wildcard("Pr?fon*e", "Prefontaine" )
   // returns -> True

   _wildcard("Pr?on*e", "Prefontaine" )
   // returns -> False

   _wildcard("Stei*er","Prefontaine")
   // returns -> False

  Notes:
  -------
  This was a C function in previous SuperLibs. Now 5.01
  Clipper source code, and more reliable.

  Source:
  -------
  S_WILD.PRG

!seealso: 
'------------------------------------------------------------------------------



