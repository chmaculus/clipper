!Short: AADD()          Add a new element to the end of an array
 ^bAADD()^b
 Add a new element to the end of an array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bAADD(<aTarget>, <expValue>) --> Value

 ^bArguments^b

     ^b<aTarget>^b is the array to which a new element is to be added.

     ^b<expValue>^b is the value assigned to the new element.

 ^bReturns^b

     AADD() evaluates <expValue> and returns its value.  If <expValue> is not
     specified, AADD() returns NIL.

 ^bDescription^b

     AADD() is an array function that increases the actual length of the
     target array by one.  The newly created array element is assigned the
     value specified by <expValue>.

     AADD() is used to dynamically grow an array.  It is useful for building
     dynamic lists or queues.  A good example of this is the GetList array
     used by the Get system to hold Get objects.  After a READ or CLEAR GETS,
     GetList becomes an empty array.  Each time you execute an @...GET
     command, the Get system uses AADD() to add a new element to the end of
     the GetList array, and then assigns a new Get object to the new element.

     AADD() is similar to ASIZE() but only adds one element at a time;
     ASIZE() can grow or shrink an array to a specified size.  AADD(),
     however, has the advantage that it can assign a value to the new
     element, while ASIZE() cannot.  AADD() may also seem similar to AINS(),
     but they are different:  AINS() moves elements within an array, but it
     does not change the array's length.

     ^bNote: ^b If <expValue> is another array, the new element in the target
     array will contain a reference to the array specified by <expValue>.

 ^bExamples^b

     ^b^CFE^b  These examples demonstrate the effects of multiple invocations
        of AADD() to an array:

        aArray := {}                  // Result: aArray is an empty array
        AADD(aArray, 5)               // Result: aArray is { 5 }
        AADD(aArray, 10)              // Result: aArray is { 5, 10 }
        AADD(aArray, { 12, 10 })      // Result: aArray is
                                      // { 5, 10, { 12, 10 } }

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"AINS()"  "ASIZE()"  
!Short: ABS()           Return the absolute value of a numeric expression
 ^bABS()^b
 Return the absolute value of a numeric expression
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bABS(<nExp>) --> nPositive

 ^bArguments^b

     ^b<nExp>^b is the numeric expression to be evaluated.

 ^bReturns^b

     ABS() returns a number representing the absolute value of its argument.
     The return value is a positive number or zero.

 ^bDescription^b

     ABS() is a numeric function that determines the magnitude of a numeric
     value independent of its sign.  It lets you, for example, obtain the
     difference between two numbers as a positive value without knowing in
     advance which of the two is larger.

     As a formalism, ABS(x) is defined in terms of its argument, x, as
     follows: if x >= 0, ABS(x) returns x; otherwise, ABS(x) returns the
     negation of x.

 ^bExamples^b

     ^b^CFE^b  These examples show typical results from ABS():

        nNum1 := 100
        nNum2 := 150
        ? nNum1 - nNum2                  // Result: -50
        ? ABS(nNum1 - nNum2)             // Result: 50
        ? ABS(nNum2 - nNum1)             // Result: 50
        ? ABS(-12)                       // Result: 12
        ? ABS(0)                         // Result: 0

 ^bFiles^b   Library is CLIPPER.LIB.

!Short: ACHOICE()       Execute a pop-up menu
 ^bACHOICE()^b
 Execute a pop-up menu
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bACHOICE(<nTop>, <nLeft>, <nBottom>, <nRight>,
     ^b   <acMenuItems>,
     ^b   [<alSelectableItems> | <lSelectableItems>],
     ^b   [<cUserFunction>],
     ^b   [<nInitialItem>],
     ^b   [<nWindowRow>]) --> nPosition

 ^bArguments^b

     ^b<nTop>^b, ^b<nLeft>^b and ^b<nBottom>^b, ^b<nRight>^b are the upper-
     left and lower-right window coordinates.  Row values can range from zero
     to MAXROW() and column values can range from zero to MAXCOL().

     ^b<acMenuItems>^b is an array of character strings to display as the
     menu items.  The individual menu items are later identified by their
     numeric positions in this array.

     ^b<alSelectableItems>^b is a parallel array of logical values--one
     element for each item in <acMenuItems>--that specify the selectable menu
     items.  Elements can be logical values or character strings.  ACHOICE()
     will not permit a null string and stops displaying if it encounters one.
     If the element is a character string, it is evaluated as a macro
     expression which should evaluate to a logical data type.  In either
     case, a value of false (.F.) means that the corresponding menu item is
     not available, and a value of true (.T.) means that it is available.  If
     you specify <lSelectableItems> instead of an array, false (.F.) makes
     all menu items unavailable and true (.T.) makes all menu items
     available.  By default, all menu items are available for selection.

     ^b<cUserFunction>^b is the name of a user-defined function that executes
     when an unrecognizable key is pressed.  Specify the function name as a
     character expression without parentheses or arguments.  Note that the
     behavior of ACHOICE() is affected by the presence of this argument.
     Refer to the discussion below for further information.

     ^b<nInitialItem>^b is the position in the <acMenuItems> array of the
     item that will be highlighted when the menu is initially displayed.  If
     you specify an unavailable menu item or no argument at all, the initial
     menu item is the first selectable item in the array.

     ^b<nWindowRow>^b is the number of the window row on which the initial
     menu item will appear.  Row numbering begins with zero.  By default, the
     initial menu item appears as close to the top of the window as possible,
     without leaving any empty rows at the bottom.  Thus, if there are enough
     menu items following the initial one to fill up the window, the initial
     form will appear on the first row (row zero) of the menu.  This function
     argument is used to control the initial menu appearance when there are
     more menu items than will fit in the window.

     As with all functions, optional arguments are omitted by using a comma
     instead of the actual argument.

 ^bReturns^b

     ACHOICE() returns the numeric position in the <acMenuItems> array of the
     menu item selected.  If the selection process is aborted, ACHOICE()
     returns zero.

 ^bDescription^b

     ACHOICE() is a user interface function that can create various kinds of
     pop-up menus.  Each menu uses an array of character strings as menu
     items and a parallel array of logical values to determine whether items
     are selectable.  When you invoke ACHOICE(), the list of menu items is
     displayed within the specified window coordinates.  When the user
     presses Return, the current item is selected, and ACHOICE() returns the
     position of the menu item in <acMenuItems>.  When the user presses Esc,
     ACHOICE() aborts and returns zero.

     The menu items scroll if the number of items in <acMenuItems> exceeds
     the number of rows in the menu window, and the user attempts to move the
     highlight beyond the top or bottom of the menu window.  Note that the
     highlight does not wrap when you reach the top or bottom of the list of
     items.  Pressing the first letter does, however, wrap the highlight
     within the set of items whose first letter matches the key you press.

     ^b^CFE  Navigating the menu: ^b ACHOICE() has two modes depending on
        whether the <cUserFunction> argument is specified.  If it is not
        specified the following navigation keys are active:

        ^bACHOICE() Keys (No User Function)^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bKey            Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        Up arrow       Go to previous item
        Down arrow     Go to next item
        Home           Go to first item in menu
        End            Go to last item in menu
        Ctrl+Home      Go to first item in window
        Ctrl+End       Go to last item in window
        PgUp           Go to previous page
        PgDn           Go to next page
        Ctrl+PgUp      Go to the first item in menu
        Ctrl+PgDn      Go to last item in menu
        Return         Select current item
        Esc            Abort selection
        Left arrow     Abort selection
        Right arrow    Abort selection
        First Letter   Go to next item beginning with first letter
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^b^CFE  Color: ^b Menu items are displayed in standard color, the
        highlight in enhanced color, and the unavailable items in the
        unselected color.  For example, the following color statement

        SETCOLOR("W+/N, BG+/B, , , W/N")

        displays a menu that is bright white on black, the highlight is
        bright cyan on blue, and the unavailable menu items are dim white on
        black.

     ^b^CFE  User function:^b Like the other user interface functions,
        ACHOICE() supports a user function.  The user function is specified
        when you want to nest ACHOICE() invocations to create hierarchical
        menus or to redefine keys.

        When a user function is specified, ACHOICE() processes only a limited
        set of keys automatically.  These are listed in the following table.
        All other keys generate a key exception which passes control to the
        user function for handling.  Control is also passed to the user
        function when ACHOICE() goes idle (i.e., when there are no more keys
        to process).

        ^bACHOICE() Keys (User Function Specified)^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bKey          Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        Uparrow      Go to previous item
        Dnarrow      Go to next item
        Ctrl+Home    Go to first item in window
        Ctrl+End     Go to last item in window
        PgUp         Go to previous page
        PgDn         Go to next page
        Ctrl+PgUp    Go to the first item in menu
        Ctrl+PgDn    Go to last item in menu
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

        When ACHOICE() executes the user function, it automatically passes
        the following three parameters:

        ^b-^b  The current ACHOICE() mode

        ^b-^b  The current element in the array of items

        ^b-^b  The relative row position within the menu window

        The mode indicates the current state of ACHOICE() depending on the
        key pressed and the action taken by ACHOICE() prior to executing the
        user function.  The mode parameter has the following possible values:

        ^bACHOICE() Modes^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bMode    Achoice.ch     Description^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0       AC_IDLE        Idle
        1       AC_HITTOP      Attempt to cursor past top of list
        2       AC_HITBOTTOM   Attempt to cursor past bottom of list
        3       AC_EXCEPT      Keystroke exceptions
        4       AC_NOITEM      No selectable items
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

        After the user function has performed whatever operations are
        appropriate to the ACHOICE() mode or LASTKEY(), it must RETURN a
        value requesting ACHOICE() to perform an operation from the following
        set of actions:

        ^bACHOICE() User Function Return Values^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bValue   Achoice.ch     Action^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        0       AC_ABORT       Abort selection
        1       AC_SELECT      Make selection
        2       AC_CONT        Continue ACHOICE()
        3       AC_GOTO        Go to the next item whose first character
                               matches the key pressed
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bExamples^b

     ^b^CFE^b  This example uses two literal arrays to specify the menu items
        and selection criteria.  After the menu is displayed and the user
        makes a selection, the name of the selected menu item is displayed:

        acMenuItems := {"One", "Two", "-------", "Three"}
        alSelectableItems := {.T., .T., .F., .T.}
        nPosition := ACHOICE(10, 10, 12, 15, acMenuItems,;
                                 alSelectableItems)
        ? acMenuItems[nPosition]

     ^b^CFE^b  This example declares an array of menu items and supplies a
        user-defined function which displays a message with each highlighted
        choice:

        #include "achoice.ch"
        #include "inkey.ch"

        PROCEDURE Main()

           LOCAL acMenuItems[4], cUserFunction, nRetVal
           LOCAL nKey, nPos

           acMenuItems[1] := "Add"
           acMenuItems[2] := "Edit"
           acMenuItems[3] := "Delete"
           acMenuItems[4] := "Update"

           CLS

           nPos := ACHOICE( 10, 10, 13, 15, acMenuItems,;
                          .T., "cUserFunction" )
           DO CASE
           CASE nPos == 1
              //  Put ADD routine here
           CASE nPos == 2
              //  Put EDIT routine here
           CASE nPos == 3
              //  Put DELETE routine here
           CASE nPos ==4
              //  Put UPDATE routine here
           ENDCASE

        RETURN


        FUNCTION cUserFunction( nMode, nCurElement, nRowPos )

           LOCAL nRetVal := AC_CONT     // Default, Continue
           LOCAL nKey := LASTKEY()

           DO CASE
        // After all pending keys are processed, display message
           CASE nMode == AC_IDLE
           DO CASE
              CASE nCurElement == 1
                 @ 22, 5 SAY " Adding   "
              CASE nCurElement == 2
                 @ 22, 5 SAY " Editing  "
              CASE nCurElement ==  3
                 @ 22, 5 SAY " Deleting "
              CASE nCurElement ==  4
                 @ 22, 5 SAY " Updating "
           ENDCASE

              nRetVal := AC_CONT            // Continue ACHOICE()

           CASE nMode == AC_HITTOP          // Attempt to go past Top
              TONE( 100, 3 )
           CASE nMode == AC_HITBOTTOM       // Attempt to go past
                                            // Bottom
              TONE( 100, 3 )

           CASE nMode == AC_EXCEPT          // Key Exception
              DO CASE
              CASE nKey == K_RETURN         // If RETURN key, select
                 nRetVal := AC_SELECT
              CASE nKey == K_ESC            // If ESCAPE key, abort
                 nRetVal := AC_ABORT
              OTHERWISE
                    nRetVal := AC_GOTO      // Otherwise, go to item
              ENDCASE
           ENDCASE

        RETURN nRetVal

     ^b^CFE^b  The next example declares the arrays, specifies a selection
        condition for one of the menu items, and supplies a user function:

        EXTERNAL UPDATED
        //
        FUNCTION MyMenu
           LOCAL acMenuItems[4], alSelectableItems[4],;
                  cUserFunction := "DoIt"
           //
           acMenuItems[1] := "Add Record"
           acMenuItems[2] := "Edit Record"
           acMenuItems[3] := "Delete Record"
           acMenuItems[4] := "Update Record"
           //
           alSelectableItems[1] := .T.
           alSelectableItems[2] := .T.
           alSelectableItems[3] := .T.
           alSelectableItems[4] := "!UPDATED()"
           // Selection condition

           RETURN ACHOICE(10, 10, 12, 15, acMenuItems,;
              alSelectableItems, cUserFunction)

     ^b^CFE^b  This example uses two arrays to specify menu items and
        corresponding action blocks.  After the menu is displayed and the
        user makes a selection, the ACHOICE() return value is used to
        determine which action block of the aActionItems array is evaluated:

        PROCEDURE Main()
           LOCAL nChoice
           LOCAL aMenuItems := { "Add Record   ", ;
                                    "Edit Record  ", ;
                                    "Delete Record", ;
                                    "Update Record"   }

           LOCAL aActionItems := { {|| AddFunc()  }, ;
                                    {|| EditFunc() }, ;
                                    {|| DelFunc()  }, ;
                                    {|| UpdFunc()  }  }

           nChoice := ACHOICE( 10, 10, 13, 22, aMenuItems )

           IF nChoice == 0
              QUIT      // ESCAPE was pressed
           ENDIF

           EVAL( aActionItems[nChoice] )

        RETURN

 ^bFiles^b   Library is EXTEND.LIB, header files are Achoice.ch and Inkey.ch.

!Seealso:C53G999.NGO:"MENU TO"  C53G999.NGO:"SET COLOR*"  
!Short: ACLONE()        Duplicate a nested or multidimensional array
 ^bACLONE()^b
 Duplicate a nested or multidimensional array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bACLONE(<aSource>) --> aDuplicate

 ^bArguments^b

     ^b<aSource>^b is the array to be duplicated.

 ^bReturns^b

     ACLONE() returns a duplicate of <aSource>.

 ^bDescription^b

     ACLONE() is an array function that creates a complete duplicate of the
     <aSource> array.  If <aSource> contains subarrays, ACLONE() creates
     matching subarrays and fills them with copies of the values in the
     <aSource> subarrays.  ACLONE() is similar to ACOPY(), but ACOPY() does
     not duplicate nested arrays.

 ^bExamples^b

     ^b^CFE^b  This example creates an array then duplicates it using
        ACLONE().  The first array is then altered, but the duplicate copy is
        unaffected:

        LOCAL aOne, aTwo
        aOne := { 1, 2, 3 }         // Result: aOne is {1, 2, 3}
        aTwo := ACLONE(aOne)        // Result: aTwo is {1, 2, 3}
        aOne[1] := 99               // Result: aOne is {99, 2, 3}
                                   // aTwo is still {1, 2, 3}

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"ACOPY()"  "ADEL()"  "AINS()"  "ASIZE()"  
!Short: ACOPY()         Copy elements from one array to another
 ^bACOPY()^b
 Copy elements from one array to another
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bACOPY(<aSource>, <aTarget>,
     ^b   [<nStart>], [<nCount>], [<nTargetPos>]) --> aTarget

 ^bArguments^b

     ^b<aSource>^b is the array to copy elements from.

     ^b<aTarget>^b is the array to copy elements to.

     ^b<nStart>^b is the starting element position in the <aSource> array.
     If not specified, the default value is one.

     ^b<nCount>^b is the number of elements to copy from the <aSource> array
     beginning at the <nStart> position.  If <nCount> is not specified, all
     elements in <aSource> beginning with the starting element are copied.

     ^b<nTargetPos>^b is the starting element position in the <aTarget> array
     to receive elements from <aSource>.  If not specified, the default value
     is one.

 ^bReturns^b

     ACOPY() returns a reference to the target array, <aTarget>.

 ^bDescription^b

     ACOPY() is an array function that copies elements from the <aSource>
     array to the <aTarget> array.  The <aTarget> array must already exist
     and be large enough to hold the copied elements.  If the <aSource> array
     has more elements, some elements will not be copied.

     ACOPY() copies values of all data types including NIL and code blocks.
     If an element of the <aSource> array is a subarray, the corresponding
     element in the <aTarget> array will contain a reference to the subarray.
     Thus, ACOPY() will not create a complete duplicate of a multidimensional
     array.  To do this, use the ACLONE() function.

 ^bExamples^b

     ^b^CFE^b  This example creates two arrays, each filled with a value.
        The first two elements from the source array are then copied into the
        target array:

        LOCAL nCount := 2, nStart := 1, aOne, aTwo
        aOne := { 1, 1, 1 }
        aTwo := { 2, 2, 2 }
        ACOPY(aOne, aTwo, nStart, nCount)
        // Result: aTwo is now { 1, 1, 2 }

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"ACLONE()"  "ADEL()"  "AEVAL()"  "AFILL()"  "AINS()"  "ASORT()"  
!Short: ADEL()          Delete an array element
 ^bADEL()^b
 Delete an array element
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bADEL(<aTarget>, <nPosition>) --> aTarget

 ^bArguments^b

     ^b<aTarget>^b is the array to delete an element from.

     ^b<nPosition>^b is the position of the target array element to be
     deleted.

 ^bReturns^b

     ADEL() returns a reference to the target array, <aTarget>.

 ^bDescription^b

     ADEL() is an array function that deletes an element from an array.  The
     contents of the specified array element is lost, and all elements from
     that position to the end of the array are shifted up one element.  The
     last element in the array becomes NIL.

     ^bWarning! ^b CA-Clipper implements multidimensional arrays by nesting
     arrays within other arrays.  If the <aTarget> array is a
     multidimensional array, ADEL() can delete an entire subarray specified
     by <nPosition>, causing <aTarget> to describe an array with a different
     structure than the original.

 ^bExamples^b

     ^b^CFE^b  This example creates a constant array of three elements, and
        then deletes the second element.  The third element is moved up one
        position, and the new third element is assigned a NIL:

        LOCAL aArray
        aArray := { 1, 2, 3 }      // Result: aArray is
                                   // now { 1, 2, 3 }
        ADEL(aArray, 2)            // Result: aArray is
                                   // now { 1, 3, NIL }

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"ACOPY()"  "AFILL()"  "AINS()"  
!Short: ADIR()*         Fill a series of arrays with directory information
 ^bADIR()*^b
 Fill a series of arrays with directory information
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bADIR([<cFilespec>],
     ^b   [<aFilenames>],
     ^b   [<aSizes>],
     ^b   [<aDates>],
     ^b   [<aTimes>],
     ^b   [<aAttributes>]) --> nFiles

 ^bArguments^b

     ^b<cFilespec>^b is the path specification of files to include in the
     scan of the DEFAULT directory.  It is a standard file specification that
     can include the wildcard characters * and ?, as well as a drive and path
     reference.  If omitted, the default specification is *.*.

     ^b<aFilenames>^b is the array to fill with the file names matching
     <cFilespec>.  Each element contains the file name and extension as a
     character string in all uppercase letters.

     ^b<aSizes>^b is the array to fill with the sizes of the corresponding
     files in the <aFilenames> array.  Each element is a numeric data type.

     ^b<aDates>^b is the array to fill with the dates of the corresponding
     files in the <aFilenames> array.  Each element is a date data type.

     ^b<aTimes>^b is the array to fill with the times of the corresponding
     files in the <aFilenames> array.  Each element filled contains a
     character string of the form: hh:mm:ss.

     ^b<aAttributes>^b is the array to fill with attributes of the
     corresponding files in the <aFilenames> array.  Each element is a
     character string.  If <aAttributes> is specified, hidden, system, and
     directory files are included as well as normal files.  If <aAttributes>
     is not specified, only normal files are included.

 ^bReturns^b

     ADIR() returns the number of files matching the directory skeleton
     described in <cFilespec>.

 ^bDescription^b

     ADIR() is an array function that performs two basic operations.  First,
     it returns the number of files matching the file specification.  Second,
     it fills a series of arrays with file names, sizes, dates, times, and
     attributes.

     ADIR() is a compatibility function and therefore not recommended.  It is
     superseded by the DIRECTORY() function which returns all file
     information in a multidimensional array.

 ^bNotes^b

     ^b^CFE  Directories: ^b If you specify the <aAttributes> argument and
        <cFilespec> is *.*, directories will be included in <aFilenames>.  In
        the <aAttributes> array, directories are indicated with an attribute
        value of "D".  If ADIR() is executed within a subdirectory, the first
        two entries of the <aFilenames> array are "." and "..", the parent
        and current directory aliases.  The date and time of last update are
        reported for directories, but the size of a directory is always zero.

 ^bExamples^b

     ^b^CFE^b  This example creates an array to hold the names of all .txt
        files in the current DEFAULT directory, then uses AEVAL() to list
        them to the console:

        LOCAL aFiles[ADIR("*.TXT")]
        ADIR("*.TXT", aFiles)
        AEVAL(aFiles, { |element| QOUT(element) })

 ^bFiles^b   Library is EXTEND.LIB.

!Seealso:"ACHOICE()"  "AEVAL()"  "ASCAN()"  "ASORT()"  "DIRECTORY()"  
!Short: AEVAL()         Execute a code block for each element in an array
 ^bAEVAL()^b
 Execute a code block for each element in an array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bAEVAL(<aArray>, <bBlock>,
     ^b   [<nStart>], [<nCount>]) --> aArray

 ^bArguments^b

     ^b<aArray>^b is the array to traverse.

     ^b<bBlock>^b is a code block to execute for each element encountered.

     ^b<nStart>^b is the starting element.  If not specified, the default is
     element one.

     ^b<nCount>^b is the number of elements to process from <nStart>.  If not
     specified, the default is all elements to the end of the array.

 ^bReturns^b

     AEVAL() returns a reference to <aArray>.

 ^bDescription^b

     AEVAL() is an array function that evaluates a code block once for each
     element of an array, passing the element value and the element index as
     block parameters.  The return value of the block is ignored.  All
     elements in <aArray> are processed unless either the <nStart> or the
     <nCount> argument is specified.

     AEVAL() makes no assumptions about the contents of the array elements it
     is passing to the block.  It is assumed that the supplied block knows
     what type of data will be in each element.

     AEVAL() is similar to DBEVAL() which applies a block to each record of a
     database file.  Like DBEVAL(), AEVAL() can be used as a primitive for
     the construction of iteration commands for both simple and complex array
     structures.

     Refer to the Code Blocks section in the "Basic Concepts" chapter of the
     Programming and Utilities Guide for more information on the theory and
     syntax of code blocks.

 ^bExamples^b

     ^b^CFE^b  This example uses AEVAL() to display an array of file names
        and file sizes returned from the DIRECTORY() function:

        #include "Directry.ch"
        //
        LOCAL aFiles := DIRECTORY("*.dbf"), nTotal := 0
        AEVAL(aFiles,;
           { | aDbfFile |;
              QOUT(PADR(aDbfFile[F_NAME], 10), aDbfFile[F_SIZE]),;
              nTotal += aDbfFile[F_SIZE]);
           } )
        //
        ?
        ? "Total Bytes:", nTotal

     ^b^CFE^b  This example uses AEVAL() to build a list consisting of
        selected items from a multidimensional array:

        #include "Directry.ch"
        //
        LOCAL aFiles := DIRECTORY("*.dbf"), aNames := {}
        AEVAL(aFiles,;
           { | file | AADD(aNames, file[F_NAME]) };
           )

     ^b^CFE^b  This example changes the contents of the array element
        depending on a condition.  Notice the use of the codeblock
        parameters:

        LOCAL aArray[6]
        AFILL(aArray,"old")
        AEVAL(aArray,;
        {|cValue,nIndex| IF(cValue == "old",;
                          aArray[nIndex] := "new",)})

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBEVAL()"  "EVAL()"  C53G999.NGO:"QOUT()"  
!Short: AFIELDS()*      Fill arrays with the structure of the current database file
 ^bAFIELDS()*^b
 Fill arrays with the structure of the current database file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bAFIELDS([<aFieldNames>], [<aTypes>],
     ^b   [<aWidths>], [<aDecimals>]) --> nFields

 ^bArguments^b

     ^b<aFieldNames>^b is the array to fill with field names.  Each element
     is a character string.

     ^b<aTypes>^b is the array to fill with the type of fields in
     <aFieldNames>.  Each element is a character string.

     ^b<aWidths>^b is the array to fill with the widths of fields in
     <aFieldNames>.  Each element is numeric data type.

     ^b<aDecimals>^b is the array to fill with the number of decimals defined
     for fields in <aFieldNames>.  Each element is numeric data type.  If the
     field type is not numeric, the <aDecimals> element is zero.

 ^bReturns^b

     AFIELDS() returns the number of fields or the length of the shortest
     array argument, whichever is less.  If no arguments are specified, or if
     there is no file in USE in the current work area, AFIELDS() returns
     zero.

 ^bDescription^b

     AFIELDS() is an array function that fills a series of arrays (structure
     attribute arrays) with the structure of the database file currently
     open, one element in each array per field.  AFIELDS() works like ADIR(),
     filling a series of existing arrays with information.  To use AFIELDS(),
     you must first create the arrays to hold the database structure
     information, each with the same number of elements as the number of
     fields (i.e. FCOUNT()).  Once the structure attribute arrays are
     created, you can then invoke AFIELDS() to fill the structure arrays with
     information about each field.

     By default, AFIELDS() operates on the currently selected work area.  It
     can  operate on an unselected work area if you specify it within an
     aliased expression (see example below).

     AFIELDS() is a compatibility function and therefore is not recommended.
     It is superseded by DBSTRUCT(), which does not require the existence of
     any arrays prior to invocation and returns a multidimensional array
     containing the current database file structure.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates how AFIELDS() and ACHOICE() can be
        used together to create a fields picklist:

        USE Sales NEW
        PRIVATE aFieldNames[FCOUNT()]
        AFIELDS(aFieldNames)
        @ 1, 0 TO 10, 10 DOUBLE
        nChoice := ACHOICE(2, 1, 9, 9, aFieldNames)
        @ 12, 0 SAY IF(nChoice != 0, aFieldNames[nChoice],;
                        "None selected")
        RETURN

     ^b^CFE^b  This example uses AFIELDS() with an aliased expression to fill
        arrays with the structure of Sales.dbf, open in an unselected work
        area:

        LOCAL aFieldNames, aTypes, aWidths, aDecimals
        USE Sales NEW
        USE Customer NEW
        //
        aFieldNames := Sales->(ARRAY(FCOUNT()))
        aTypes := Sales->(ARRAY(FCOUNT()))
        aWidths := Sales->(ARRAY(FCOUNT()))
        aDecimals := Sales->(ARRAY(FCOUNT()))
        //
        Sales->(AFIELDS(aFieldNames, aTypes, ;
                 aWidths, aDecimals))

 ^bFiles^b   Library is EXTEND.LIB.

!Seealso:"ACHOICE()"  "ADIR()*"  "AEVAL()"  "ASCAN()"  "DBCREATE()"  
!Short: AFILL()         Fill an array with a specified value
 ^bAFILL()^b
 Fill an array with a specified value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bAFILL(<aTarget>, <expValue>,
     ^b   [<nStart>], [<nCount>]) --> aTarget

 ^bArguments^b

     ^b<aTarget>^b is the array to be filled.

     ^b<expValue>^b is the value to be placed in each array element.  It can
     be an expression of any valid data type.

     ^b<nStart>^b is the position of the first element to be filled.  If this
     argument is omitted, the default value is one.

     ^b<nCount>^b is the number of elements to be filled starting with
     element <nStart>.  If this argument is omitted, elements are filled from
     the starting element position to the end of the array.

 ^bReturns^b

     AFILL() returns a reference to <aTarget>.

 ^bDescription^b

     AFILL() is an array function that fills the specified array with a
     single value of any data type (including an array, code block, or NIL)
     by assigning <expValue> to each array element in the specified range.

     ^bWarning! ^b AFILL() cannot be used to fill multidimensional arrays.
     CA-Clipper implements multidimensional arrays by nesting arrays within
     other arrays.  Using AFILL() with a multidimensional array will
     overwrite subarrays used for the other dimensions of the array.

 ^bExamples^b

     ^b^CFE^b  This example, creates a three-element array.  The array is
        then filled with the logical value, (.F.).  Finally, elements in
        positions two and three are assigned the new value of true (.T.):

        LOCAL aLogic[3]
        // Result: aLogic is { NIL, NIL, NIL }

        AFILL(aLogic, .F.)
        // Result: aLogic is { .F., .F., .F. }

        AFILL(aLogic, .T., 2, 2)
        // Result: aLogic is { .F., .T., .T. }

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"AADD()"  "AEVAL()"  "DBSTRUCT()"  "DIRECTORY()"  
!Short: AINS()          Insert a NIL element into an array
 ^bAINS()^b
 Insert a NIL element into an array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bAINS(<aTarget>, <nPosition>) --> aTarget

 ^bArguments^b

     ^b<aTarget>^b is the array into which a new element will be inserted.

     ^b<nPosition>^b is the position at which the new element will be
     inserted.

 ^bReturns^b

     AINS() returns a reference to the target array, <aTarget>.

 ^bDescription^b

     AINS() is an array function that inserts a new element into a specified
     array.  The newly inserted element is NIL data type until a new value is
     assigned to it.  After the insertion, the last element in the array is
     discarded, and all elements after the new element are shifted down one
     position.

     ^bWarning! ^b AINS() must be used carefully with multidimensional
     arrays.  Multidimensional arrays in CA-Clipper are implemented by
     nesting arrays within other arrays.  Using AINS() in a multidimensional
     array discards the last element in the specified target array which, if
     it is an array element, will cause one or more dimensions to be lost.
     To insert a new dimension into an array, first add a new element to the
     end of the array using AADD() or ASIZE() before using AINS().

 ^bExamples^b

     ^b^CFE^b  This example demonstrates the effect of using AINS() on an
        array:

        LOCAL aArray
        aArray := { 1, 2, 3 }      // Result: aArray is
                                   // now { 1, 2, 3 }
        AINS(aArray, 2)            // Result: aArray is
                                   // now { 1, NIL, 2 }

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"AADD()"  "ACOPY()"  "ADEL()"  "AEVAL()"  "AFILL()"  "ASIZE()"  
!Short: ALERT()         Display a simple modal dialog box
 ^bALERT()^b
 Display a simple modal dialog box
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bALERT( <cMessage>, [<aOptions>] ) --> nChoice

 ^bArguments^b

     ^b<cMessage>^b is the message text displayed and centered in the alert
     box.  If the message contains one or more semicolons, the text after the
     semicolons is centered on succeeding lines in the dialog box.

     ^b<aOptions>^b defines a list of up to 4 possible responses to the
     dialog box.

 ^bReturns^b

     ALERT() returns a numeric value indicating which option was chosen.  If
     the Esc key is pressed, the value returned is zero.

 ^bDescription^b

     The ALERT() function creates a simple modal dialog.  It is useful in
     error handlers and other "pause" functions.  The user can respond by
     moving a highlight bar and pressing the Return or SpaceBar keys, or by
     pressing the key corresponding to the first letter of the option.  If
     <aOptions> is not supplied, a single "Ok" option is presented.

     ALERT() is sensitive to the presence or absence of the CA-Clipper
     full-screen I/O system.  If the full-screen system is not present,
     ALERT() uses standard I/O to display the message and options tty-style
     (i.e., 80-column, without word wrap, each line ended with carriage
     return/linefeed).

 ^bExamples^b

     ^b^CFE^b  This example demonstrates use of an alert dialog box.  First,
        the array of options is defined, the ALERT() function gets the user's
        selection, and finally, the user's choice is handled with a DO
        CASE...ENDCASE control structure:

        #define AL_SAVE         1
        #define AL_CANCEL      2
        #define AL_CONT         3

        // Define an array of options
        aOptions := {"Save", "Don't Save", "Continue"}

        // Display the dialog box and get the user's selection
        nChoice  := ALERT("File has changed...", aOptions)

        // Handle the user's request
        DO CASE
        CASE nChoice == AL_SAVE
           ? "Save"
        CASE nChoice == AL_CANCEL
           ? "Don't Save"
        CASE nChoice == AL_CONT
           ? "Continue"
        OTHERWISE
           ? "Escape"
        ENDCASE
        //
        RETURN

 ^bFiles^b   Library is LLIBG.LIB.

!Seealso:C53G999.NGO:"@...PROMPT"  C53G999.NGO:"MENU TO"  
!Short: ALIAS()         Return a specified work area alias
 ^bALIAS()^b
 Return a specified work area alias
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bALIAS([<nWorkArea>]) --> cAlias

 ^bArguments^b

     ^b<nWorkArea>^b is any work area number.

 ^bReturns^b

     ALIAS() returns the alias of the specified work area as a character
     string in uppercase.  If <nWorkArea> is not specified, the alias of the
     current work area is returned.  If there is no database file in USE for
     the specified work area, ALIAS() returns a null string ("").

 ^bDescription^b

     ALIAS() is a database function that determines the alias of a specified
     work area.  An alias is the name assigned to a work area when a database
     file is USEd.  The actual name assigned is either the name of the
     database file, or a name explicitly assigned with the ALIAS clause of
     the USE command.

     ALIAS() is the inverse of the SELECT() function.  ALIAS() returns the
     alias name given the work area number, and SELECT() returns the work
     area number given the alias name.

     ^b^CFE^b  This example returns the name of the previously selected work
        area:

        USE File1 NEW ALIAS Test1
        nOldArea := SELECT()
        USE File2 NEW ALIAS Test2
        ? ALIAS( nOldArea )            // Returns Test1

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"SELECT"  C53G999.NGO:"SELECT()"  C53G999.NGO:"USE"  
!Short: ALLTRIM()       Remove leading and trailing spaces from a character string
 ^bALLTRIM()^b
 Remove leading and trailing spaces from a character string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bALLTRIM(<cString>) --> cTrimString

 ^bArguments^b

     ^b<cString>^b is the character expression to be trimmed.

 ^bReturns^b

     ALLTRIM() returns a character string with leading and trailing spaces
     removed.

 ^bDescription^b

     ALLTRIM() is a character function that removes both leading and trailing
     spaces from a string.  It is related to LTRIM() and RTRIM() which remove
     leading and trailing spaces, respectively.  The inverse of ALLTRIM(),
     LTRIM(), and RTRIM() are the PADC(), PADL(), and PADR() functions which
     center, left-justify, or right-justify character strings by padding them
     with fill characters.

 ^bNotes^b

     ^b^CFE  Space characters: ^b The ALLTRIM() function treats carriage
        returns, line feeds, and tabs as space characters and removes these
        as well.

 ^bExamples^b

     ^b^CFE^b  This example creates a string with both leading and trailing
        spaces, and then trims them with ALLTRIM():

        cString := SPACE(10) + "string" + SPACE(10)
        ? LEN(cString)                     // Result: 26
        ? LEN(ALLTRIM(cString))            // Result: 6

 ^bFiles^b   Library is EXTEND.LIB.

!Seealso:C53G999.NGO:"LTRIM()"  C53G999.NGO:"PAD()"  C53G999.NGO:"RTRIM()"  C53G999.NGO:"TRIM()"  
!Short: ALTD()          Invoke the CA-Clipper debugger
 ^bALTD()^b
 Invoke the CA-Clipper debugger
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bALTD([<nAction>]) --> NIL

 ^bArguments^b

     ^b<nAction>^b defines what action ALTD() performs when invoked.  The
     following is a complete list of <nAction> values and their actions:

     ^bALTD() Actions^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bArgument     Action^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     None         Invokes the debugger if it is enabled
     0            Disables Alt+D
     1            Enables Alt+D
     Other        No action
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bReturns^b

     ALTD() always returns NIL.

 ^bDescription^b

     ALTD() performs differently depending on its argument as shown in the
     table above.  For more information on using the debugger, refer to
     "CA-Clipper Debugger-CLD.LIB" chapter in the Programming and Utilities
     Guide.  Also refer to the "Debugging Your Applications" chapter in the
     Workbench User Guide.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a series of manifest constants that
        can be used as arguments for ALTD() before invoking the debugger
        programmatically:

        #define ALTD_DISABLE      0
        #define ALTD_ENABLE      1
        //
        ALTD(ALTD_ENABLE)

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"SET ESCAPE"  C53G999.NGO:"SETCANCEL()"  
!Short: ARRAY()         Create an uninitialized array of specified length
 ^bARRAY()^b
 Create an uninitialized array of specified length
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bARRAY(<nElements> [, <nElements>...]) aArray

 ^bArguments^b

     ^b<nElements>^b is the number of elements in the specified dimension.
     The maximum number of elements in a dimension is 4096.  Arrays in
     CA-Clipper can have an unlimited number of dimensions.

 ^bReturns^b

     ARRAY() returns an array of specified dimensions.

 ^bDescription^b

     ARRAY() is an array function that returns an uninitialized array with
     the specified number of elements and dimensions.  If more than one
     <nElements> argument is specified, a multidimensional array is created
     with the number of dimensions equal to the number of <nElements>
     arguments specified.  Any <nElements> that is itself an array creates a
     nested array.

     In CA-Clipper, there are several ways to create an array.  You can
     declare an array using a declaration statement such as LOCAL or STATIC;
     you can create an array using a PRIVATE or PUBLIC statement; you can
     assign a literal array to an existing variable; or you can use the
     ARRAY() function.  ARRAY() has the advantage that it can create arrays
     within expressions or code blocks.

 ^bExamples^b

     ^b^CFE^b  This example creates a one-dimensional array of five elements
        using the ARRAY() function, and then shows the equivalent action by
        assigning a literal array of NIL values:

        aArray := ARRAY(5)
        aArray := { NIL, NIL, NIL, NIL, NIL }

     ^b^CFE^b  This example shows three different statements which create the
        same multidimensional array:

        aArray := ARRAY(3, 2)
        aArray := { {NIL, NIL}, {NIL, NIL}, {NIL, NIL} }
        aArray := { ARRAY(2), ARRAY(2), ARRAY(2) }

     ^b^CFE^b  This example creates a nested, multidimensional array:

        aArray := ARRAY(3, {NIL,NIL})

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"AADD()"  "ACLONE()"  "ACOPY()"  "ADEL()"  "AEVAL()"  "AFILL()"  
!Short: ASC()           Convert a character to its ASCII value
 ^bASC()^b
 Convert a character to its ASCII value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bASC(<cExp>) --> nCode

 ^bArguments^b

     ^b<cExp>^b is the character expression to be converted to a number.

 ^bReturns^b

     ASC() returns an integer numeric value in the range of zero to 255,
     representing the ASCII value of <cExp>.

 ^bDescription^b

     ASC() is a character conversion function that returns the ASCII value of the
     leftmost character in a character string.  ASC() is used primarily on
     expressions requiring numeric calculations on the ASCII value of a
     character.  CHR() and ASC() are inverse functions.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate various results of ASC():

        ? ASC("A")                     // Result: 65
        ? ASC("Apple")                 // Result: 65
        ? ASC("a")                     // Result: 97
        ? ASC("Z") - ASC("A")          // Result: 25
        ? ASC("")                      // Result: 0

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"CHR()"  C53G999.NGO:"INKEY()"  C53G999.NGO:"STR()"  C53G999.NGO:"VAL()"  
!Short: ASCAN()         Scan an array for a value or until a block returns true (.T.)
 ^bASCAN()^b
 Scan an array for a value or until a block returns true (.T.)
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bASCAN(<aTarget>, <expSearch>,
     ^b   [<nStart>], [<nCount>]) --> nStoppedAt

 ^bArguments^b

     ^b<aTarget>^b is the array to be scanned.

     ^b<expSearch>^b is either a simple value to scan for, or a code block.
     If <expSearch> is a simple value it can be character, date, logical, or
     numeric type.

     ^b<nStart>^b is the starting element of the scan.  If this argument is
     not specified, the default starting position is one.

     ^b<nCount>^b is the number of elements to scan from the starting
     position.  If this argument is not specified, all elements from the
     starting element to the end of the array are scanned.

 ^bReturns^b

     ASCAN() returns a numeric value representing the array position of the
     last element scanned.  If <expSearch> is a simple value, ASCAN() returns
     the position of the first matching element, or zero if a match is not
     found.  If <expSearch> is a code block, ASCAN() returns the position of
     the element where the block returned true (.T.).

 ^bDescription^b

     ASCAN() is an array function that scans an array for a specified value
     and operates like SEEK when searching for a simple value.  The
     <expSearch> value is compared to the target array element beginning with
     the leftmost character in the target element and proceeding until there
     are no more characters left in <expSearch>.  If there is no match,
     ASCAN() proceeds to the next element in the array.

     Since ASCAN() uses the equal operator (=) for comparisons, it is
     sensitive to the status of EXACT.  If EXACT is ON, the target array
     element must be exactly equal to the result of <expSearch> to match.

     If the <expSearch> argument is a code block, ASCAN() scans the <aTarget>
     array executing the block for each element accessed.  As each element is
     encountered, ASCAN() passes the element's value as an argument to the
     code block, and then performs an EVAL() on the block.  The scanning
     operation stops when the code block returns true (.T.), or ASCAN()
     reaches the last element in the array.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates scanning a three-element array using
        simple values and a code block as search criteria.  The code block
        criteria shows how to perform a case-insensitive search:

        aArray := { "Tom", "Mary", "Sue" }
        ? ASCAN(aArray, "Mary")               // Result: 2
        ? ASCAN(aArray, "mary")               // Result: 0
        //
        ? ASCAN(aArray, { |x| UPPER(x) ;
              == "MARY" })                    // Result: 2

     ^b^CFE^b  This example demonstrates scanning for multiple instances of a
        search argument after a match is found:

        LOCAL aArray := { "Tom", "Mary", "Sue",;
                           "Mary" }, nStart := 1
        //
        // Get last array element position
        nAtEnd := LEN(aArray)
        DO WHILE (nPos := ASCAN(aArray, "Mary", ;
                     nStart)) > 0
           ? nPos, aArray[nPos]
           //
           // Get new starting position and test
           // boundary condition
           IF (nStart := ++nPos) > nAtEnd
              EXIT
           ENDIF
        ENDDO

     ^b^CFE^b  This example scans a two-dimensional array using a code block.
        Note that the parameter aVal in the code block is an array:

        LOCAL aArr:={}
        CLS
        AADD(aArr,{"one","two"})
        AADD(aArr,{"three","four"})
        AADD(aArr,{"five","six"})
        ? ASCAN(aArr, {|aVal| aVal[2] == "four"})         // Returns 2

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"AEVAL()"  "EVAL()"  
!Short: ASIZE()         Grow or shrink an array
 ^bASIZE()^b
 Grow or shrink an array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bASIZE(<aTarget>, <nLength>) --> aTarget

 ^bArguments^b

     ^b<aTarget>^b is the array to grow or shrink.

     ^b<nLength>^b is the new size of the array.

 ^bReturns^b

     ASIZE() returns a reference to the target array, <aTarget>.

 ^bDescription^b

     ASIZE() is an array function that changes the actual length of the
     <aTarget> array.  The array is shortened or lengthened to match the
     specified length.  If the array is shortened, elements at the end of the
     array are lost.  If the array is lengthened, new elements are added to
     the end of the array and assigned NIL.

     ASIZE() is similar to AADD() which adds a single new element to the end
     of an array and optionally assigns a new value at the same time.  Note
     that ASIZE() is different from AINS() and ADEL(), which do not actually
     change the array's length.

     ^bNote: ^b ASIZE() only supports single-dimensional arrays.

 ^bExamples^b

     ^b^CFE^b  These examples demonstrate adding new elements and deleting
        existing elements:

        aArray := { 1 }          // Result: aArray is { 1 }
        ASIZE(aArray, 3)         // Result: aArray is { 1, NIL, NIL }
        ASIZE(aArray, 1)         // Result: aArray is { 1 }

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"AADD()"  "ADEL()"  "AFILL()"  "AINS()"  
!Short: ASORT()         Sort an array
 ^bASORT()^b
 Sort an array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bASORT(<aTarget>, [<nStart>],
     ^b   [<nCount>], [<bOrder>]) --> aTarget

 ^bArguments^b

     ^b<aTarget>^b is the array to be sorted.

     ^b<nStart>^b is the first element of the sort.  If not specified, the
     default starting position is one.

     ^b<nCount>^b is the number of elements to be sorted.  If not specified,
     all elements in the array beginning with the starting element are
     sorted.

     ^b<bOrder>^b is an optional code block used to determine sorting order.
     If not specified, the default order is ascending.

 ^bReturns^b

     ASORT() returns a reference to the <aTarget> array.

 ^bDescription^b

     ASORT() is an array function that sorts all or part of an array
     containing elements of a single data type.  Data types that can be
     sorted include character, date, logical, and numeric.

     If the <bOrder> argument is not specified, the default order is
     ascending.  Elements with low values are sorted toward the top of the
     array (first element), while elements with high values are sorted toward
     the bottom of the array (last element).

     If the <bOrder> block argument is specified, it is used to determine the
     sorting order.  Each time the block is evaluated, two elements from the
     target array are passed as block parameters.  The block must return true
     (.T.) if the elements are in sorted order.  This facility can be used to
     create a descending or dictionary order sort.  See the examples below.

     When sorted, character strings are ordered in ASCII sequence; logical
     values are sorted with false (.F.) as the low value; date values are
     sorted chronologically; and numeric values are sorted by magnitude.

 ^bNotes^b

     ^b^CFE^b  ASORT() is only guaranteed to produce sorted output (as
        defined by the block), not to preserve any existing natural order in
        the process.

     ^b^CFE^b  Because CA-Clipper implements multidimensional arrays by
        nesting subarrays within other arrays, ASORT() will not directly sort
        a multidimensional array.  To sort a nested array, you must supply a
        code block which properly handles the subarrays.

 ^bExamples^b

     ^b^CFE^b  This example creates an array of five unsorted elements, sorts
        the array in ascending order, then sorts the array in descending
        order using a code block:

        aArray := { 3, 5, 1, 2, 4 }
        ASORT(aArray)
        // Result: { 1, 2, 3, 4, 5 }

        ASORT(aArray,,, { |x, y| x > y })
        // Result: { 5, 4, 3, 2, 1 }


     ^b^CFE^b  This example sorts an array of character strings in ascending
        order, independent of case.  It does this by using a code block that
        converts the elements to uppercase before they are compared:

        aArray := { "Fred", Kate", "ALVIN", "friend" }
        ASORT(aArray,,, { |x, y| UPPER(x) < UPPER(y) })

     ^b^CFE^b  This example sorts a nested array using the second element of
        each subarray:

        aKids := { {"Mary", 14}, {"Joe", 23}, {"Art", 16} }
        aSortKids := ASORT(aKids,,, { |x, y| x[2] < y[2] })

        Result:

        { {"Mary", 14}, {"Art", 16}, {"Joe", 23} }

 ^bFiles^b   Library is EXTEND.LIB.

!Seealso:"ASCAN()"  "EVAL()"  C53G999.NGO:"SORT"  
!Short: AT()            Return the position of a substring within a character string
 ^bAT()^b
 Return the position of a substring within a character string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bAT(<cSearch>, <cTarget>) --> nPosition

 ^bArguments^b

     ^b<cSearch>^b is the character substring to be searched for.

     ^b<cTarget>^b is the character string to be searched.

 ^bReturns^b

     AT() returns the position of the first instance of <cSearch> within
     <cTarget> as an integer numeric value.  If <cSearch> is not found, AT()
     returns zero.

 ^bDescription^b

     AT() is a character function used to determine the position of the first
     occurrence of a character substring within another string.  If you only
     need to know whether a substring exists within another string, use the $
     operator.  To find the last instance of a substring within a string, use
     RAT().

 ^bExamples^b

     ^b^CFE^b  These examples show typical use of AT():

        ? AT("a", "abcde")                  // Result: 1
        ? AT("bcd", "abcde")                // Result: 2
        ? AT("a", "bcde")                   // Result: 0

     ^b^CFE^b  This example splits a character string based on the position
        of a comma within the target string:

        cTarget := "Langtree, Lilly"
        ? SUBSTR(cTarget, 1, AT(",", cTarget) - 1)
        // Result: Langtree

        ? SUBSTR(cTarget, AT(",", cTarget) + 2)
        // Result: Lilly

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"RAT()"  C53G999.NGO:"STRTRAN()"  C53G999.NGO:"SUBSTR()"  
!Short: ATAIL()         Return the highest numbered element of an array
 ^bATAIL()^b
 Return the highest numbered element of an array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bATAIL(<aArray>) --> Element

 ^bArguments^b

     ^b<aArray>^b is the array.

 ^bReturns^b

     ATAIL() returns either a value or a reference to an array or object.
     The array is not changed.

 ^bDescription^b

     ATAIL() is an array function that returns the highest numbered element
     of an array.  It can be used in applications as shorthand for
     <aArray>[LEN(<aArray>)] when you need to obtain the last element of an
     array.

 ^bExamples^b

     ^b^CFE^b  The following example creates a literal array and returns that
        last element of the array:

        aArray := {"a", "b", "c", "d"}
        ? ATAIL(aArray)                     // Result: d

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"LEN()"  
!Short: BIN2I()         Convert a 16-bit signed integer to a numeric value
 ^bBIN2I()^b
 Convert a 16-bit signed integer to a numeric value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBIN2I(<cSignedInt>) --> nNumber

 ^bArguments^b

     ^b<cSignedInt>^b is a character string in the form of a 16-bit signed
     integer number--least significant byte first.  Only the first two
     characters are used by the function; all others are ignored.

 ^bReturns^b

     BIN2I() returns an integer numeric value.

 ^bDescription^b

     BIN2I() is a low-level file function that is used with FREAD() to
     convert a two-byte character string formatted as a signed integer to a
     CA-Clipper numeric data type.  This is most useful when you are reading
     foreign file types and want to read numeric data in its native format.

 ^bExamples^b

     ^b^CFE^b  This example opens a database file using low-level file
        functions and reads the date of last update (bytes 1-3).  The result
        is the same as with LUPDATE():

        #include "Fileio.ch"
        //
        nHandle := FOPEN("Sales.dbf", FO_READ)
        //
        // Point to byte 1 in the file
        FSEEK(nHandle, 1, FS_SET)
        //
        // Read date of last update
        nYear := BIN2I(FREADSTR(nHandle, 1) + CHR(0))
        nMonth := BIN2I(FREADSTR(nHandle, 1) + CHR(0))
        nDay := BIN2I(FREADSTR(nHandle, 1) + CHR(0))
        //
        ? LTRIM(STR(nMonth)), LTRIM(STR(nDay)), LTRIM(STR(nYear))
        FCLOSE(nHandle)

 ^bFiles^b   Library is EXTEND.LIB, source file is SOURCE\SAMPLE\EXAMPLEA.ASM

!Seealso:"BIN2L()"  "BIN2W()"  C53G999.NGO:"FREAD()"  C53G999.NGO:"FREADSTR()"  C53G999.NGO:"I2BIN()"  C53G999.NGO:"L2BIN()"  
!Short: BIN2L()         Convert a 32-bit signed integer to a numeric value
 ^bBIN2L()^b
 Convert a 32-bit signed integer to a numeric value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBIN2L(<cSignedInt>) --> nNumber

 ^bArguments^b

     ^b<cSignedInt>^b is a character string in the form of a 32-bit signed
     integer number--least significant byte first.  Only the first four
     characters are used by the function; all others are ignored.

 ^bReturns^b

     BIN2L() returns an integer numeric value.

 ^bDescription^b

     BIN2L() is a low-level file function that is used with FREAD() to
     convert a four-byte character string formatted as a signed integer to a
     CA-Clipper numeric data type.  This is most useful when you are reading
     foreign file types and want to read numeric data in its native format.

 ^bExamples^b

     ^b^CFE^b  This example opens a database file using low-level file
        functions and reads the number of records (bytes 4-7).  The result is
        the same as with LASTREC():

        #include "Fileio.ch"
        //
        nHandle := FOPEN("Sales.dbf", FO_READ)
        // Note:  Sales.dbf contains 84 records
        //
        // Point to byte 4
        FSEEK(nHandle, 4, FS_SET)
        //
        // Read the number of records
        cRecords := SPACE(4)
        FREAD(nHandle, @cRecords, 4)
        //
        ? LTRIM(STR(BIN2L(cRecords)))         // Result: 84
        FCLOSE(nHandle)

 ^bFiles^b   Library is EXTEND.LIB, source file is SOURCE\SAMPLE\EXAMPLEA.ASM

!Seealso:"BIN2I()"  "BIN2W()"  C53G999.NGO:"FREAD()"  C53G999.NGO:"FREADSTR()"  C53G999.NGO:"I2BIN()"  C53G999.NGO:"L2BIN()"  
!Short: BIN2W()         Convert a 16-bit unsigned integer to a numeric value
 ^bBIN2W()^b
 Convert a 16-bit unsigned integer to a numeric value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBIN2W(<cUnsignedInt>) --> nNumber

 ^bArguments^b

     ^b<cUnsignedInt>^b is a character string in the form of a 16-bit
     unsigned integer number--least significant byte first.  Only the first
     two characters are used by the function; all others are ignored.

 ^bReturns^b

     BIN2W() returns an integer numeric value.

 ^bDescription^b

     BIN2W() is a low-level file function that is used with FREAD() to
     convert a two-byte character string formatted as an unsigned integer to
     a CA-Clipper numeric data type.  This is most useful when you are
     reading from a binary file and want to read data in its native format.

 ^bExamples^b

     ^b^CFE^b  This example opens a database file using low-level file
        functions and reads the number of bytes per record (bytes 10-11).
        The result is the same as with RECSIZE():

        #include "Fileio.ch"
        //
        nHandle := FOPEN("Sales.dbf", FO_READ)
        // Note:  The length of a record in Sales.dbf is 124
        //
        // Point to byte 10, the first record size byte
        FSEEK(nHandle, 10, FS_SET)
        //
        // Read record size
        cRecSize := SPACE(2)
        FREAD(nHandle, @cRecSize, 2)
        //
        ? LTRIM(STR(BIN2W(cRecSize)))            // Result: 124
        FCLOSE(nHandle)

 ^bFiles^b   Library is EXTEND.LIB, source file is SOURCE\SAMPLE\EXAMPLEA.ASM

!Seealso:"BIN2I()"  "BIN2L()"  C53G999.NGO:"FREAD()"  C53G999.NGO:"FREADSTR()"  C53G999.NGO:"I2BIN()"  C53G999.NGO:"L2BIN()"  
!Short: BLOBDIRECTEXP() Export the contents of a BLOB pointer to a file
 ^bBLOBDIRECTEXPORT()^b
 Export the contents of a binary large object (BLOB) pointer to a file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bNote: ^b A BLOB file (.dbv or .fpt) is used for storing memo field
     information as an alternative to the standard .dbt file mechanism
     supported by some RDDs.  It is a more powerful and efficient mechanism
     for storing and retrieving large amounts of data than using .dbt files.
     CA-Clipper supplies the DBFCDX driver, which uses the BLOB file storage
     mechanism by default, and the DBFMEMO driver, which you can use as a
     driver with a named super RDD (see MEMOSETSUPER()).  Refer to the RDD
     Features in the "Replaceable Database Driver Architecture" chapter of
     the Drivers Guide for further information on using this
     driver.BLOB:definitionBLOB:drivers supporting

 ^bSyntax^b

     ^bBLOBDirectExport(<nPointer>, <cTargetFile>, [<nMode>])
     ^b   --> lSuccess

 ^bArguments^b

     ^b<nPointer>^b is a pointer to the BLOB data.  This pointer can be
     obtained using BLOBDIRECTPUT(), BLOBDIRECTEXPORT(), or
     DBFIELDINFO(DBS_BLOB_POINTER, <nFieldPos>).

     ^b<cTargetFile>^b is the name of the target file where the BLOB data
     will be written, including an optional drive, directory, and extension.
     See SETDEFAULT() and SETPATH() for file searching and creation rules.
     No default extension is assumed.

     If <cTargetFile> does not exist, it is created.  If it exists, this
     function attempts to open the file in exclusive mode and, if successful,
     the file is written to without warning or error.  If access is denied
     because another process is using the file, for example, NETERR() is set
     to true (.T.).  Concurrency control:and BLOBDIRECTEXPORT()

     ^b<nMode>^b is a constant defining the copy mode, as shown in the table
     below:

     ^bCopy Mode Constants^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bConstant                 Description^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     BLOB_EXPORT_APPEND       Appends to the file
     BLOB_EXPORT_OVERWRITE    Overwrites the file (this is the default)
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bReturns^b

     BLOBDIRECTEXPORT() returns true (.T.) if successful; otherwise, it
     returns false (.F.).

 ^bDescription^b

     By default, BLOBDIRECTEXPORT() operates on the currently selected work
     area.  It can be made to operate on an unselected work area by
     specifying it within an aliased expression.

 ^bExamples^b

     ^b^CFE^b  This example extracts an array of pointers from the BLOB
        file's root area, then uses one of the pointers to export a picture
        to a file:

        FUNCTION PUTPIX()
           LOCAL cPixFile
           LOCAL nPointer
           LOCAL aBLOBPtrs


           cPixFile := "picture.gif"

           // Customer database with a picture of
           // each customer stored in a field called Pix
           USE Customer NEW VIA "DBFCDX"

           // Assumes that the program previously
           // stored an array of direct BLOB pointers
           // into the root area of the BLOB file.
           // The picture that we want is assumed to
           // be the second array element.
           aBLOBPtrs := BLOBROOTGET()
           nPointer := aBLOBPtrs[2]

           // Export picture pointed to by nPointer to a file
           IF !BLOBDirectExport(nPointer, cPixFile, ;
              BLOB_EXPORT_OVERWRITE)
                 Alert("Export of picture " + cPixFile + ";
                    failed!")
           ELSE
              // Code for displaying picture would go here
           ENDIF

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"BLOBDIRECTIMP()"  "BLOBEXPORT()"  
!Short: BLOBDIRECTGET() Retrieve data from a BLOB file without referencing a field
 ^bBLOBDIRECTGET()^b
 Retrieve data stored in a BLOB file without referencing a specific field
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBLOBDIRECTGET(<nPointer>,   [<nStart>],   [<nCount>])
     ^b    --> expBLOB

 ^bArguments^b

     ^b<nPointer>^b is a pointer to the BLOB data.  This pointer can be
     obtained using BLOBDIRECTPUT(), BLOBDIRECTIMPORT(), or
     DBFIELDINFO(DBS_BLOB_POINTER, <nFieldPos>).

     ^b<nStart>^b is the starting position in <nPointer>.  If <nStart> is
     positive, the starting position is relative to the leftmost character in
     <nPointer>.  If <nStart> is negative, it is relative to the rightmost
     character in <nPointer>.  If <nStart> is omitted, it is assumed to be 1.

     ^b<nCount>^b is the number of bytes of data to retrieve beginning at
     <nStart>.  If <nCount> is larger than the amount of data stored, excess
     data is ignored.  If omitted, BLOBDIRECTGET() retrieves to the end of
     the data.

     ^bNote: ^b <nStart> and <nCount> apply to string data only.  They are
     ignored for any other data types.

 ^bReturns^b

     BLOBDIRECTGET() returns the data retrieved from the BLOB file.  The data
     type of the return value depends on the actual data stored.  Use
     VALTYPE() to determine the data type.

 ^bDescription^b

     BLOBDIRECTGET() retrieves data stored in a BLOB file without the need to
     reference a particular field in the database file.  It is particularly
     useful when accessing data that is larger than 64 KB (such as memo
     fields created with the BLOBIMPORT() function).

     By default, this function operates on the currently selected work area.
     It can be made to operate on an unselected work area by specifying it
     within an aliased expression.

 ^bExamples^b

     ^b^CFE^b  This example illustrates storing setup information in a BLOB
        file, then selectively retrieving the stored information:

        FUNCTION PutSettings(aColors,;
                       aPaths, ;
                       aPassWords)

           LOCAL aSettings

           RDDSETDEFAULT ( "DBFCDX" )
           MEMOSETSUPER ( "DBFCDX" )

           USE Setup NEW via "DBFMEMO"

           aSettings := {}
           AADD(aSettings, BLOBDIRECTPUT(0, aColors))
           AADD(aSettings, BLOBDIRECTPUT(0, aPaths))
           AADD(aSettings, BLOBDIRECTPUT(0, aPassWords))

           BLOBROOTPUT(aSettings)

           CLOSE

        FUNCTION GETCOLORS()
           LOCAL aSettings
           LOCAL aColors

           USE Setup NEW VIA "DBFMEMO"

           aSettings := BLOBROOTGET()
           aColors := BLOBDIRECTGET(aSettings[1])

           CLOSE


           RETURN aColors

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"BLOBDIRECTPUT()"  "BLOBGET()"  "BLOBIMPORT()"  "DBFIELDINFO()"  
!Short: BLOBDIRECTIMP() Import a file into a BLOB file and return pointer to the data
 ^bBLOBDIRECTIMPORT()^b
 Import a file into a BLOB file and return a pointer to the data
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBLOBDIRECTIMPORT(<nOldPointer>, <cSourceFile>)
     ^b    --> nNewPointer

 ^bArguments^b

     ^b<nOldPointer>^b is a pointer to the BLOB data which will be released
     after the import.  This pointer can be obtained using BLOBDIRECTPUT(),
     BLOBDIRECTIMPORT(), or DBFIELDINFO(DBS_BLOB_POINTER, <nFieldPos>).
     Passing zero (0) disables the release of data.

     ^bImportant! ^b If specified, BLOBDIRECTIMPORT() releases the space
     associated with <nOldPointer> for reuse by other data.  Therefore, it is
     illegal to use <nOldPointer> with any of the BLOB functions after
     passing it as an argument to this function.  Use the function's return
     value to refer to the newly stored data.

     ^b<cSourceFile>^b is the name of the file from which to read the BLOB
     data, including an optional drive, directory, and extension.  See
     SETDEFAULT() and SETPATH() for file searching and creation rules.  No
     default extension is assumed.

     This function attempts to open <cSourceFile> in shared mode.  If the
     file does not exist, a runtime error is raised.  If the file is
     successfully opened, the operation proceeds.  If access is denied
     because another process has exclusive use of the file, for example,
     NETERR() is set to true (.T.).  Concurrency control:and
     BLOBDIRECTIMPORT()

     ^bNote: ^b There are no restrictions on the size of <cSourceFile> except
     that you must have enough disk space to make the copy.

 ^bReturns^b

     BLOBDIRECTIMPORT() returns a numeric pointer to the BLOB image stored in
     <cSourceFile>.

 ^bDescription^b

     BLOBDIRECTIMPORT() provides a mechanism for copying the contents of a
     file into a BLOB file.  By default, this function operates on the
     currently selected work area.  It can be made to operate on an
     unselected work area by specifying it within an aliased expression.

     BLOBDIRECTIMPORT() is used in conjunction with BLOBDIRECTEXPORT() to
     transfer data back and forth between external files and BLOB files.  You
     can use BLOBDIRECTIMPORT() with a variety of file types, including
     graphic images, word processor files, and printer fonts.  These two
     functions are excellent for creating databases for documents, graphics,
     sounds, etc.

     ^bImportant! ^b After importing a file with BLOBDIRECTIMPORT(),
     nNewPointer, the return value, is the only way to access the data from
     the BLOB file.  It is up to you to provide permanent storage for this
     reference (see example below).

     ^bNote: ^b DBFIELDINFO(DBS_BLOB_TYPE, <nFieldPos>) will return "C"
     (string) for any memo field created using BLOBDIRECTIMPORT().

 ^bExamples^b

     ^b^CFE^b  This example imports a bitmap (.bmp) file to be part of an
        array of startup data.  The data, stored in the root area of the BLOB
        file, could then be used to display the application's startup screen:

        FUNCTION PUTPIX()
           LOCAL cBMPFile
           LOCAL aSettings

           cBMPFile := "logo.bmp"
           aSettings := {}

           // Customer database where startup parameters
           // are stored for convenience
           USE Customer NEW VIA "DBFMEMO"

           // Get default path settings
           AADD(aSettings, STARTPATHS())

           // Get default color settings
           AADD(aSettings, DEFAULTCOLORS())

           // Get company logo for display at startup.
           // There is nothing to free because this
           // is the first time importing.
           nPointer := BLOBDIRECTIMPORT(0, cBMPFile)
           AADD(aSettings, nPointer)

           // Store the settings in the root area of
           // the customer.fpt file

           BLOBROOTPUT(aSettings)

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"BLOBDIRECTEXP()"  "BLOBIMPORT()"  
!Short: BLOBDIRECTPUT() Put data in a BLOB file without referencing a specific field
 ^bBLOBDIRECTPUT()^b
 Put data in a BLOB file without referencing a specific field
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBLOBDIRECTPUT(<nOldPointer>, <uBLOB>) --> nNewPointer

 ^bArguments^b

     ^b<nOldPointer>^b is a reference to previously stored BLOB data.  This
     reference can be obtained using BLOBDIRECTPUT(), BLOBDIRECTIMPORT(), or
     DBFIELDINFO(DBS_BLOB_POINTER, <nFieldPos>).  If other than zero (0), the
     data referenced by <nOldPointer> is replaced by <uBLOB>; otherwise,
     <uBLOB> is added to the current contents of the BLOB file.

     ^bImportant! ^b If specified, BLOBDIRECTPUT() releases the space
     associated with <nOldPointer> for reuse by other data.  Therefore, it is
     illegal to use <nOldPointer> with any of the BLOB functions after
     passing it as an argument to this function.  Use the function's return
     value to refer to the newly stored data.

     ^b<uBLOB>^b is the data you want to put into the BLOB file.  <uBLOB> can
     be any CA-Clipper data type except code block or an object.

 ^bReturns^b

     BLOBDIRECTPUT() returns a numeric pointer to the <uBLOB> data.

 ^bDescription^b

     BLOBDIRECTPUT() stores variable length BLOB data without creating a link
     with a particular memo field in a database file.  After adding data to a
     BLOB file using BLOBDIRECTPUT(), you should store the function's return
     value, as this is the only way to access the data from the BLOB file.
     It is up to you, the developer, to provide permanent storage for this
     reference (see BLOBROOTPUT()).

     By default, this function operates on the currently selected work area.
     It can be made to operate on an unselected work area by specifying it
     within an aliased expression.

 ^bExamples^b

     ^b^CFE^b  This example illustrates storing setup information in a BLOB
        file, then selectively retrieving the stored information:

        FUNCTION PutSettings(aColors,;
           aPaths, aPassWords)

           LOCAL aSettings

           USE Setup NEW VIA "DBFMEMO"

           aSettings := {}
           AADD(aSettings, BLOBDIRECTPUT(0, aColors))

           AADD(aSettings, BLOBDIRECTPUT(0, aPaths))
           AADD(aSettings, BLOBDIRECTPUT(0, aPassWords))

           BLOBROOTPUT(aSettings)

           CLOSE

        FUNCTION GETCOLORS()
           LOCAL aSettings
           LOCAL aColors

           USE Setup NEW VIA "DBFMEMO"

           aSettings := BLOBROOTGET()
           aColors := BLOBDIRECTGET(aSettings[1])

           CLOSE

           RETURN aColors

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"BLOBDIRECTGET()"  "BLOBEXPORT()"  "BLOBGET()"  "BLOBIMPORT()"  
!Short: BLOBEXPORT()    Copy the contents of a memo field number to a BLOB file
 ^bBLOBEXPORT()^b
 Copy the contents of a BLOB, identified by its memo field number, to a file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBLOBEXPORT(<nFieldPos>, <cTargetFile>, [<nMode>])
     ^b    --> lSuccess

 ^bArguments^b

     ^b<nFieldPos>^b is the position of the field in the database file
     structure.

     ^b<cTargetFile>^b is the name of the target file where the BLOB data
     will be written, including an optional drive, directory, and extension.
     See SETDEFAULT() and SETPATH() for file searching and creation rules.
     No default extension is assumed.

     If <cTargetFile> does not exist, it is created.  If it exists, this
     function attempts to open the file in exclusive mode and, if successful,
     the file is written to without warning or error.  If access is denied
     because another process is using the file, for example, NETERR() is set
     to true (.T.).  Concurrency control:and BLOBEXPORT()

     ^b<nMode>^b is a constant defining the copy mode, as shown in the table
     below:

     ^bField Information Type Constants^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bConstant                 Description^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     BLOB_EXPORT_APPEND       Number of decimal places for the field
     BLOB_EXPORT_OVERWRITE    Length of the field
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bReturns^b

     BLOBEXPORT() returns true (.T.) if successful; otherwise, it returns
     false (.F.).

 ^bDescription^b

     By default, this function operates on the currently selected work area.
     It can be made to operate on an unselected work area by specifying it
     within an aliased expression.

 ^bExamples^b

     ^b^CFE^b  This example exports the contents of a field that stores a
        picture to a graphic interchange format (.gif) file, so that the file
        can be programmatically displayed:

        FUNCTION SHOWPIX()
           LOCAL cPixFile := "Picture.gif"
           LOCAL nPos

           // Customer database with a picture of each
           // customer stored in a field called Pix
           USE Customer NEW VIA "DBFCDX"
           nPos := FIELDPOS("Pix")

           // Export the BLOB file's data
           // for the current Pix field
           IF !BLOBEXPORT(nPos, cPixFile,;
              BLOB_EXPORT_OVERWRITE)
                 ALERT("Export of picture " + cPixFile + ";
                    failed!")
           ELSE
              // Code for displaying picture would go here
           ENDIF

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"BLOBDIRECTEXP()"  "BLOBIMPORT()"  
!Short: BLOBGET()       Get the contents of a BLOB, identified by memo field number
 ^bBLOBGET()^b
 Get the contents of a BLOB, identified by its memo field number
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBLOBGet(<nFieldPos>, [<nStart>], [<nCount>]) --> uBLOB

 ^bArguments^b

     ^b<nFieldPos>^b is the position of the field in the database file
     structure.

     ^b<nStart>^b is the starting position in the memo field of the BLOB
     data.  If <nStart> is positive, the starting position is relative to the
     leftmost character in <nFieldPos>.  If <nStart> is negative, it is
     relative to the rightmost character in <nFieldPos>.  If <nStart> is
     omitted, it is assumed to be 1.

     ^b<nCount>^b is the number of bytes of data to retrieve beginning at
     <nStart>.  If <nCount> is larger than the amount of data stored, excess
     data is ignored.  If omitted, BLOBGET() retrieves to the end of the
     data.

     ^bNote: ^b <nStart> and <nCount> apply to string data only.  They are
     ignored for any other data types.

 ^bReturns^b

     BLOBGET() returns the BLOB data retrieved from the memo field.  The data
     type of the return value depends on the actual data stored.  Use
     VALTYPE() to determine the data type.  If the indicated field is not a
     memo field, BLOBGET() returns NIL.

 ^bDescription^b

     BLOBGET() is very similar to FIELDGET().  However, because string type
     variables cannot be larger than 64 KB, FIELDGET() will raise a runtime
     error when attempting to retrieve memo fields of this magnitude or
     greater.

     BLOBGET() will also raise an error if you attempt to retrieve a field
     greater than this magnitude; however, you can retrieve any subset of the
     BLOB data by using an <nCount> less than 64 KB.

     ^bNote: ^b BLOB data less than 64 KB can be retrieved from a memo field
     using standard means (for example, referring to the field by name in an
     expression or using the FIELDGET() function).

     By default, this function operates on the currently selected work area.
     It can be made to operate on an unselected work area by specifying it
     within an aliased expression.

 ^bExamples^b

     ^b^CFE^b  This example imports information from a word processing
        document into a field, then uses BLOBGET() to extract the first 25
        characters of the field:

        FUNCTION GETFIRST25()
           LOCAL nPos
           LOCAL cStr

           USE customer NEW VIA "DBFCDX"

           // Field that contains word processor
           // documentation
           nPos := FieldPos("WP_DOC")

           // Import a file (can be larger than 64 KB), then
           // obtain the first 25 characters to show to the
           // user
           IF BLOBImport(nPos, "c:\application\temp.doc")
              cStr := BLOBGet(nPos, 1, 25)
           ELSE
              cStr := "Error: could not import file!"
           ENDIF

        CLOSE

        RETURN cStr

!Seealso:"BLOBDIRECTGET()"  "BLOBDIRECTPUT()"  "BLOBIMPORT()"  
!Short: BLOBIMPORT()    Read the contents of a BLOB file into a memo field
 ^bBLOBIMPORT()^b
 Read the contents of a file as a BLOB, identified by a memo field number
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBLOBImport(<nFieldPos>, <cSourceFile>) --> lSuccess

 ^bArguments^b

     ^b<nFieldPos>^b is the position of the field in the database file
     structure.

     ^b<cSourceFile>^b is the name of the file from which to read the BLOB
     data, including an optional drive, directory, and extension.  See
     SETDEFAULT() and SETPATH() for file searching and creation rules.  No
     default extension is assumed.

     This function attempts to open <cSourceFile> in shared mode.  If the
     file does not exist, a runtime error is raised.  If the file is
     successfully opened, the operation proceeds.  If access is denied
     because another process has exclusive use of the file, for example,
     NETERR() is set to true (.T.).  Concurrency control:and BLOBIMPORT()

     ^bNote: ^b There are no restrictions on the size of <cSourceFile> except
     that you must have enough disk space to make the copy.

 ^bReturns^b

     BLOBIMPORT() returns true (.T.) if successful; otherwise, it returns
     false (.F.).

 ^bDescription^b

     BLOBIMPORT() provides a mechanism for copying the contents of a file
     into a memo field as BLOB data.  By default, this function operates on
     the currently selected work area.  It can be made to operate on an
     unselected work area by specifying it within an aliased expression.

     BLOBIMPORT() is used in conjunction with BLOBEXPORT() to transfer BLOB
     data back and forth between files and memo fields.  You can use
     BLOBIMPORT() with a variety of file types, including graphic images,
     word processor files, and printer fonts.  These two functions are
     excellent for creating databases for documents, graphics, sounds, etc.

     ^bNote: ^b DBFieldInfo(DBS_BLOB_TYPE, <nFieldPos>) will return "C"
     (string) for any memo field created using BLOBIMPORT().

 ^bExamples^b

     ^b^CFE^b  This example imports information from a word processing
        document into a field, and then uses BLOBGET() to extract the first
        25 characters of the field:

        FUNCTION POPULATE()
           USE customer NEW VIA "DBFCDX"

           // Construct unique file name based on last
           // name and id
           DO WHILE .NOT. EOF()
              GetPix("Pix", Substr(LastName, 1, 4) + CustID)
              Customer->DBSKIP()
           ENDDO
        FUNCTION GetPix(cPixField, cPixFile)
           LOCAL nPos

           nPos := FieldPos(cPixField)

           // Import the picture file into indicated field
           IF !BLOBImport(nPos, cPixFile)
              Alert("Import of picture " + cPixFile + ";
              failed!")
           ENDIF

!Seealso:"BLOBEXPORT()"  "DBFIELDINFO()"  
!Short: BLOBROOTGET()   Retrieve the data from the root area of a BLOB file
 ^bBLOBROOTGET()^b
 Retrieve the data from the root area of a BLOB file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBLOBROOTGET() --> uBLOB

 ^bReturns^b

     BLOBROOTGET() returns the data retrieved from the root of the BLOB file.
     The data type of the return value depends on the actual data stored.
     Use VALTYPE() or USUALTYPE() to determine the data type.  Note that
     BLOBROOTGET() returns NIL if the root reference has never been written
     to with BLOBROOTPUT().

 ^bDescription^b

     BLOBROOTGET() allows the retrieval of a BLOB from the root of a BLOB
     file in a work area.  By default, this function operates on the
     currently selected work area.  It can be made to operate on an
     unselected work area by specifying it within an aliased expression.

     ^bNote: ^b Because the root data does not reference a particular record
     in the database file, the DBRLOCK() will not protect this root storage
     reference.  Therefore, if the database file is opened in shared mode,
     you should use BLOBROOTLOCK() before calling BLOBROOTGET().

 ^bExamples^b

     ^b^CFE^b  This example uses BLOBROOTGET() to read system settings from a
        BLOB file into an array, and then demonstrates how to allow the user
        to modify the settings and restore them in the BLOB file:

        FUNCTION UPDATESETTINGS()
           LOCAL aSettings

           USE customer NEW SHARED VIA "DBFCDX"

           IF BLOBROOTLOCK()
              // Get any existing settings
              aSettings := BLOBROOTGET()

              IF Empty(aSettings)
                 // This function would populate aSettings
                 // with default data
                 aSettings := GETDEFAULTSETTINGS()
              ENDIF

              // This function would allow the user to
              // modify the settings.
              IF ModifySettings(aSettings)
                 // Finally, store the settings
                 BLOBRootPut(aSettings)
              ENDIF
              BLOBROOTUNLOCK()
           ELSE
              aSettings := {}
              Alert("Could not obtain a lock on the root;
                 area")
           ENDIF

           CLOSE

           RETURN aSettings

!Seealso:"BLOBROOTLOCK()"  "BLOBROOTPUT()"  "DBRLOCK()"  "DBUSEAREA()"  
!Short: BLOBROOTLOCK()  Obtain a lock on the root area of a BLOB file
 ^bBLOBROOTLOCK()^b
 Obtain a lock on the root area of a BLOB file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBLOBROOTLOCK() --> lSuccess

 ^bReturns^b

     BLOBROOTLOCK() returns true (.T.) if successful; otherwise, it returns
     false (.F.).

 ^bDescription^b

     Use BLOBROOTLOCK() when accessing the database file in shared mode to
     obtain a lock on the root area of a BLOB file for reading from or
     writing to the root area.

     By default, this function operates on the currently selected work area.
     It can be made to operate on an unselected work area by specifying it
     within an aliased expression.

 ^bExamples^b

     ^b^CFE^b  This example illustrates how to properly lock and unlock the
        root area of a BLOB file for a database file opened in shared mode:

        FUNCTION GETSETTINGS()
        LOCAL aCustSettings

        // Open a customer file in shared mode
        USE customer NEW SHARED DBFCDX

        IF BLOBROOTLOCK()
           aCustSettings := BLOBROOTGET()
           BLOBROOTUNLOCK()
        ELSE
           Alert("Could not obtain root lock of Customer;
              file")
        ENDIF

        CLOSE

        RETURN aCustSettings

!Seealso:"BLOBROOTGET()"  "BLOBROOTPUT()"  "BLOBROOTUNLOC()"  
!Short: BLOBROOTPUT()   Store data in the root area of a BLOB file
 ^bBLOBROOTPUT()^b
 Store data in the root area of a BLOB file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBLOBRootPut(<uBLOB>) --> lSuccess

 ^bArguments^b

     ^b<uBLOB>^b is the data you want to put into the BLOB file's root area.
     <uBLOB> can be any CA-Clipper usual data type except code block and
     object.

 ^bReturns^b

     BLOBROOTPUT() returns true (.T.) if successful; otherwise, it returns
     false (.F.).

 ^bDescription^b

     BLOBROOTPUT() allows the storage of one--and only one--piece of data to
     a BLOB file's root area (there is no size limitation on this one piece
     of data).  After storing the new data, BLOBROOTPUT() releases the space
     associated with any data previously stored in the BLOB file's root area.

     By default, this function operates on the currently selected work area.
     It can be made to operate on an unselected work area by specifying it
     within an aliased expression.

     ^bNote: ^b Because the root data does not reference a particular record
     in the database file, the DBRLOCK() will not protect this root storage
     reference.  Therefore, if the database file is opened in shared mode,
     you should use BLOBROOTLOCK() before calling BLOBROOTPUT().

 ^bExamples^b

     ^b^CFE^b  This example uses BLOBROOTPUT() to store system settings to a
        BLOB file after modification:

        FUNCTION UPDATESETTINGS()
           LOCAL aSettings

           USE customer NEW SHARED VIA "DBFCDX"

           IF BLOBROOTLOCK()
              // Get any existing settings
              aSettings := BLOBROOTGET()

              IF Empty(aSettings)
                 // This function would populate aSettings
                 // with default data
                 aSettings := GETDEFAULTSETTINGS()
              ENDIF

              // This function would allow the user to
              // modify the settings.
              IF ModifySettings(aSettings)
                 // Finally, store the settings
                 BLOBRootPut(aSettings)
              ENDIF
              BLOBROOTUNLOCK()
           ELSE
              aSettings := {}

              Alert("Could not obtain a lock on the root;
                 area")
           ENDIF

           CLOSE

           RETURN aSettings

!Seealso:"BLOBROOTGET()"  "BLOBROOTLOCK()"  
!Short: BLOBROOTUNLOC() Release the lock on a BLOB file's root area
 ^bBLOBROOTUNLOCK()^b
 Release the lock on a BLOB file's root area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBLOBROOTUNLOCK() --> NIL

 ^bDescription^b

     Use BLOBROOTUNLOCK() to release a lock previously obtained using
     BLOBROOTLOCK().

     By default, this function operates on the currently selected work area.
     It can be made to operate on an unselected work area by specifying it
     within an aliased expression.

     ^bNote: ^b The only functions that require the use of BLOBROOTLOCK() or
     BLOBROOTUNLOCK() are BLOBROOTGET() and BLOBROOTPUT().

 ^bExamples^b

     ^b^CFE^b  This example illustrates how to properly lock and unlock the
        root area of a BLOB file for a database file opened in shared mode:

        FUNCTION GETSETTINGS()
           LOCAL aCustSettings

           // Open a customer file in shared mode
           USE customer NEW SHARED VIA DBFCDX

           IF BLOBROOTLOCK()
              aCustSettings := BLOBROOTGET()
              BLOBROOTUNLOCK()
           ELSE
              Alert("Could not obtain root lock of Customer;
                 file")
           ENDIF

           CLOSE

           RETURN aCustSettings

!Seealso:"BLOBROOTLOCK()"  
!Short: BOF()           Determine when beginning of file is encountered
 ^bBOF()^b
 Determine when beginning of file is encountered
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBOF() --> lBoundary

 ^bReturns^b

     BOF() returns true (.T.) after an attempt to SKIP backward beyond the
     first logical record in a database file; otherwise, it returns false
     (.F.).  If there is no database file open in the current work area,
     BOF() returns false (.F.).  If the current database file contains no
     records, BOF() returns true (.T.).

 ^bDescription^b

     BOF() is a database function used to test for a boundary condition when
     you are moving the record pointer backward through a database file using
     the SKIP command.  A simple usage example is a descending order record
     list with an ascending order index file.  A more sophisticated example
     is a screen paging routine that pages forward or backward through the
     current database file based on the key the user presses.  When the user
     attempts to page backward, you would use BOF() to test for a beginning
     of file condition before using the SKIP command to move the record
     pointer and repaint the screen.

     Once BOF() is set to true (.T.), it retains its value until there is
     another attempt to move the record pointer.

     By default, BOF() operates on the currently selected work area.  It can
     be made to operate on an unselected work area by specifying it within an
     aliased expression (see example below).

     The SKIP command is the only record movement command that can set BOF()
     to true (.T.).

 ^bExamples^b

     ^b^CFE^b  This example demonstrates BOF() by attempting to move the
        record pointer before the first record:

        USE Sales NEW
        ? RECNO(), BOF()               // Result: 1 .F.
        SKIP -1
        ? RECNO(), BOF()               // Result: 1 .T.

     ^b^CFE^b  This example uses aliased expressions to query the value of
        BOF() in unselected work areas:

        USE Sales NEW
        USE Customer NEW
        USE Invoices NEW

        ? Sales->(BOF()), Customer->(BOF())

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"EOF()"  C53G999.NGO:"SKIP"  
!Short: BREAK()         Branch out of a BEGIN SEQUENCE...END construct
 ^bBREAK()^b
 Branch out of a BEGIN SEQUENCE...END construct
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBREAK(<exp>) --> NIL

 ^bArguments^b

     ^b<exp>^b is the value passed to the RECOVER clause, if any.  Note that
     <exp> is not optional.  NIL may be specified if there is no break value.

 ^bReturns^b

     BREAK() always returns NIL.

 ^bDescription^b

     The BREAK() function is identical in functionality to the BREAK
     statement.  The function must be executed during a SEQUENCE.  BREAK()
     has the advantage that, as an expression, it can be executed from a code
     block.

 ^bExamples^b

     ^b^CFE^b  This example illustrates exiting a SEQUENCE from a code block:

        bSave := ERRORBLOCK( {|x| BREAK(x)} )

        BEGIN SEQUENCE
           .
           .
           .
        RECOVER USING objError
           .
           .
           .
        END

        ERRORBLOCK(bSave)

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"BEGIN SEQUENCE"  
!Short: BROWSE()*       Browse records within a window
 ^bBROWSE()*^b
 Browse records within a window
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bBROWSE([<nTop>], [<nLeft>],
     ^b   [<nBottom>], [<nRight>]) lSuccess

 ^bArguments^b

     ^b<nTop>^b, ^b<nLeft>^b, ^b<nBottom>^b, and ^b<nRight>^b define the
     window coordinates.  If not specified, the default window coordinates
     are 1, 0 to MAXROW(), and MAXCOL().

 ^bReturns^b

     BROWSE() returns false (.F.) if there is no database file in use;
     otherwise, it returns true (.T.).

 ^bDescription^b

     BROWSE() is a user interface function that invokes a general purpose
     table-oriented browser and editor for records in the current work area.
     For a list of the navigation keys which are used by BROWSE(), refer to
     the DBEDIT() function.  Note that Browse() is a compatibility function.
     DBEDIT() should be used in its place.  For a more complicated BROWSE(),
     TBROWSE() should be used.

 ^bNotes^b

     ^b^CFE  Status line:^b BROWSE() supports a status line in the upper
        right corner of the browse window indicating one of the following:

        ^bBROWSE() Status Line Messages^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        ^bMessage   Meaning^b
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
        <new>     Append mode
        <bof>     Top of file
        <delete>  Current record is deleted
        Record    Record number display
        컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^b^CFE^b  BROWSE() has the following three modes:

        ^b-  Browsing:^b This is the default mode of BROWSE().  Pressing any
           DBEDIT() navigation key moves the highlight to a new column or
           row.

        ^b-  Field edit:^b Pressing Return on any field enters field edit
           using a GET.  Pressing Return terminates the edit mode, saving the
           changes.  Esc terminates without saving changes.  Since the field
           edit mode uses GET, all navigation and editing keys are READ keys.

        ^b-  Append:^b GOing BOTTOM with Ctrl+PgDn and then pressing Down
           arrow enters append mode with the indicating message "<new>" on
           the status line.  A new blank record is then inserted.  Pressing
           Up arrow terminates the append mode, saving the new record if data
           has been entered.  If no data has been entered, the new record is
           not saved.

 ^bExamples^b

     ^b^CFE^b  This is an example of browsing a file:

        USE File1 NEW
        BROWSE()

 ^bFiles^b   Library is EXTEND.LIB, source file is SOURCE\SAMPLE\BROWSE.PRG

!Seealso:"DBEDIT()"  
!Short: CDOW()          Convert a date value to a character day of the week
 ^bCDOW()^b
 Convert a date value to a character day of the week
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCDOW(<dExp>) --> cDayName

 ^bArguments^b

     ^b<dExp>^b is the date value to convert.

 ^bReturns^b

     CDOW() returns the name of the day of the week as a character string.
     The first letter is uppercase and the rest of the string is lowercase.
     For a null date value, CDOW() returns a null string ("").

 ^bDescription^b

     CDOW() is a date conversion function used in formatting date displays
     for reports, labels, and screens.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate CDOW():

        ? DATE()                      // Result: 09/01/90
        ? CDOW(DATE())                // Result: Friday
        ? CDOW(DATE() + 7)            // Result: Friday
        ? CDOW(CTOD("06/12/90"))      // Result: Tuesday

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"CTOD()"  "DATE()"  "DAY()"  "DOW()"  
!Short: CHR()           Convert an ASCII code to a character value
 ^bCHR()^b
 Convert an ASCII code to a character value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCHR(<nCode>) --> cChar

 ^bArguments^b

     ^b<nCode>^b is an ASCII code in the range of zero to 255.

 ^bReturns^b

     CHR() returns a single character value whose ASCII code is specified by
     <nCode>.

 ^bDescription^b

     CHR() is a numeric conversion function that converts an ASCII code to a
     character.  It is the inverse of ASC().  CHR() serves a number of common
     tasks including:

     ^b^CFE^b  Sending control codes and graphics characters to the screen or
        printer

     ^b^CFE^b  Ringing the bell

     ^b^CFE^b  Converting INKEY() return values to characters

     ^b^CFE^b  Stuffing the keyboard buffer

 ^bNotes^b

     ^b^CFE  The null character:^b CHR(0) has a length of one (1) and is
        treated like any other character.  This lets you send it to any
        device or file, including a database file.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate CHR() with various arguments:

        ? CHR(72)                    // Result: H
        ? CHR(ASC("A") + 32)         // Result: a
        ? CHR(7)                     // Result: bell sounds

     ^b^CFE^b  These lines of code show the difference between a null string
        and the null character:

        ? LEN("")                   // Result: 0
        ? LEN(CHR(0))               // Result: 1

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"ASC()"  C53G999.NGO:"INKEY()"  
!Short: CMONTH()        Convert a date to a character month name
 ^bCMONTH()^b
 Convert a date to a character month name
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCMONTH(<dDate>) --> cMonth

 ^bArguments^b

     ^b<dDate>^b is the date value to convert.

 ^bReturns^b

     CMONTH() returns the name of the month as a character string from a date
     value with the first letter uppercase and the rest of the string
     lowercase.  For a null date value, CMONTH() returns a null string ("").

 ^bDescription^b

     CMONTH() is a date conversion function useful for creating formatted
     date strings that can be used in reports, labels, or screens.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate CMONTH():

        ? CMONTH(DATE())                     // Result: September
        ? CMONTH(DATE() + 45)                // Result: October
        ? CMONTH(CTOD("12/01/94"))           // Result: December
        ? SUBSTR(CMONTH(DATE()), 1, 3) +;
           STR(DAY(DATE()))                  // Result: Sep 1

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"CDOW()"  "DATE()"  "DAY()"  C53G999.NGO:"MONTH()"  C53G999.NGO:"YEAR()"  
!Short: COL()           Return the screen cursor column position
 ^bCOL()^b
 Return the screen cursor column position
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCOL() --> nCol

 ^bReturns^b

     COL() returns an integer numeric value.  The range of the return value
     is zero to MAXCOL().

 ^bDescription^b

     COL() is a screen function that returns the current column position of
     the cursor.  The value of COL() changes whenever the cursor position
     changes on the screen.  Both console and full-screen commands can change
     the cursor position.  In addition, COL() is automatically set to zero
     whenever a CLEAR, CLEAR SCREEN, or CLS command is executed.

     Use COL() to position the cursor to a column relative to the current
     column.  It is generally used in combination with ROW() and all
     variations of the @ command.  In particular, use COL() and ROW() to
     create screen position-independent procedures or functions that pass the
     upper-left row and column as parameters.

     If DEVICE is SET TO PRINTER, all the output of @...SAY commands is
     directed to the printer and PROW() and PCOL() are updated instead of
     ROW() and COL().  Use these functions when you need to determine the
     position of the printhead.

 ^bExamples^b

     ^b^CFE^b  This example displays a Customer name beginning at column 10.
        The customer's account status is then displayed to the right of the
        last character of the customer name using COL():

     USE Sales NEW

        CLS
        @ 1, 10 SAY "Customer Name: " + TRIM(Customer)
        @ ROW(), COL() + 1 SAY "Account status: " + Status

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"@...CLEAR"  C53G999.NGO:"@...GET"  C53G999.NGO:"@...SAY"  C53G999.NGO:"CLEAR"  C53G999.NGO:"MAXCOL()"  C53G999.NGO:"PCOL()"  
!Short: COLORSELECT()   Activate attribute in current color settings
 ^bCOLORSELECT()^b
 Activate attribute in current color settings
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCOLORSELECT(<nColorIndex>) --> NIL

 ^bReturns^b

     Always returns NIL.

 ^bArguments^b

     ^b<nColorIndex>^b is a number corresponding to the ordinal positions in
     the current list of color attributes, as set by SETCOLOR().

 ^bDescription^b

     COLORSELECT() activates the specified color pair from the current list
     of color attributes (established by SETCOLOR()).  Manifest constants for
     <nColorIndex> are defined in Color.ch.

     ^bColor.ch constants^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bConstant          Value^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     CLR_STANDARD      0
     CLR_ENHANCED      1
     CLR_BORDER        2
     CLR_BACKGROUND    3
     CLR_UNSELECTED    4
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     COLORSELECT() does not alter the current SET Color setting.

     This table describes the scope of the CA-Clipper color settings affected
     by SETCOLOR():

     ^bColor settings^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bSetting        Scope^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Standard       All screen output commands and functions
     Enhanced       GETs and selection highlights
     Border         Screen border (not supported on EGA and VGA monitors)
     Background     Not supported
     Unselected     Unselected GETs
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bExamples^b

     ^b^CFE^b  This example demonstrates use of COLORSELECT() with the
        Color.ch manifest constants:

        USE Sales NEW
        ? SETCOLOR()                   // displays "W/B,N/B,W/N,W/N,W/N"
                                       // in white on blue

        COLORSELECT(CLR_ENHANCED)      // enhanced is active color pair
        ? "I'm black and blue"         // displayed in black on blue
        COLORSELECT(CLR_STANDARD)      // restore standard color

 ^bFiles^b   Library is CLIPPER.LIB, header file is Color.ch.

!Seealso:C53G999.NGO:"SETCOLOR()"  C53G999.NGO:"SET COLOR*"  
!Short: CTOD()          Convert a date string to a date value
 ^bCTOD()^b
 Convert a date string to a date value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCTOD(<cDate>) --> dDate

 ^bArguments^b

     ^b<cDate>^b is a character string consisting of numbers representing the
     month, day, and year separated by any character other than a number.
     The month, day, and year digits must be specified in accordance with the
     SET DATE format.  If the century digits are not specified, the century
     is determined by the rules of SET EPOCH.

 ^bReturns^b

     CTOD() returns a date value.  If <cDate> is not a valid date, CTOD()
     returns an empty date.

 ^bDescription^b

     CTOD() is a character conversion function that converts a character
     string to a date.  To initialize an empty date for date entry, specify
     <cDate> as a null string (""), SPACE(8), or "  /  /  ".

     CTOD() is used whenever you need a literal date value.  Some examples
     are:

     ^b^CFE^b  Initializing a variable to a date value

     ^b^CFE^b  Specifying a literal date string as an argument of a RANGE
        clause of @...GET

     ^b^CFE^b  Specifying a literal date string in order to perform date
        arithmetic

     ^b^CFE^b  Comparing the result of a date expression to a literal date
        string

     ^b^CFE^b  REPLACEing a date field with a literal date string

     CTOD() is the inverse of DTOC() which converts a date value to a
     character string in the format specified by SET DATE and SET CENTURY.
     DTOS() also converts a date value to a character string in the form
     yyyymmdd.

 ^bExamples^b

     ^b^CFE^b  This example uses CTOD() to initialize two date variables,
        using one as a GET and the other for RANGE validation:

        SET CENTURY ON
        dBegin := CTOD("01-26-1876")
        dCurrent := CTOD("")
        @ 10, 10 SAY "Enter date:" GET dCurrent ;
              RANGE dBegin, DATE()
        READ

     ^b^CFE^b  This example uses CTOD() to create a date value within a FOR
        condition:

        USE Inventory NEW
        REPLACE ALL Inventory->Price WITH ;
           Inventory->Price * 1.1 FOR ;
           Inventory->InvDate < CTOD("10/10/90")

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DATE()"  "DTOC()"  "DTOS()"  C53G999.NGO:"SET CENTURY"  C53G999.NGO:"SET DATE"  
!Short: CURDIR()        Return the current DOS directory
 ^bCURDIR()^b
 Return the current DOS directory
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bCURDIR([<cDrivespec>]) --> cDirectory

 ^bArguments^b

     ^b<cDrivespec>^b specifies the letter of the disk drive to query.  If
     not specified, the default is the current DOS drive.

 ^bReturns^b

     CURDIR() returns the current DOS directory of the drive specified by
     <cDrivespec> as a character string without either leading or trailing
     backslash (\) characters.

     If an error occurs, or the current directory of the specified drive is
     the root directory, CURDIR() returns a null string ("").

 ^bDescription^b

     CURDIR() is an environment function that gives you the name of the
     current DOS directory, ignoring the SET DEFAULT and SET PATH settings.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate various CURDIR() results:

        ? CURDIR("E:")     // Result: null string--root directory
        ? CURDIR("C")      // Result: CLIP53\SOURCE
        ? CURDIR("C:")     // Result: CLIP53\SOURCE
        ? CURDIR()         // Result: null string--root directory
        ? CURDIR("A")      // Result: null string--drive not ready

     ^b^CFE^b  This example changes the current DOS directory to a new value
        if it does not match a specified directory:

        IF CURDIR("C:") != "CLIP53\SOURCE"
           RUN CD \CLIP53\SOURCE
        ENDIF

 ^bFiles^b   Library is EXTEND.LIB, source file is SOURCE\SAMPLE\EXAMPLEA.ASM

!Seealso:"FILE()"  
!Short: DATE()          Return the system date as a date value
 ^bDATE() ^b
 Return the system date as a date value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDATE() --> dSystem

 ^bReturns^b

     DATE() returns the system date as a date value.

 ^bDescription^b

     DATE() is a date function that provides a means of initializing memory
     variables to the current date, comparing other date values to the
     current date, and performing date arithmetic relative to the current
     date.

     The display format for dates is controlled by the SET DATE command.  The
     default format is mm/dd/yy.

 ^bExamples^b

     ^b^CFE^b  These examples show the DATE() function used in various ways:

        ? DATE()                 // Result: 09/01/90
        ? DATE() + 30            // Result: 10/01/90
        ? DATE() - 30            // Result: 08/02/90
        dDate := DATE()
        ? CMONTH(dDate)          // Result: September

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"CTOD()"  "DTOC()"  "DTOS()"  C53G999.NGO:"SET CENTURY"  C53G999.NGO:"SET DATE"  
!Short: DAY()           Return the day of the month as a numeric value
 ^bDAY()^b
 Return the day of the month as a numeric value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDAY(<dDate>) --> nDay

 ^bArguments^b

     ^b<dDate>^b is a date value to convert.

 ^bReturns^b

     DAY() returns a number in the range of zero to 31 as an integer numeric
     value.  If the month is February, leap years are considered.  If the
     date argument is February 29 and the year is not a leap year, DAY()
     returns zero.  If the date argument is empty, DAY() returns zero.

 ^bDescription^b

     DAY() is a date conversion function used to convert a date value to the
     day of a month.  This function is used in combination with CMONTH() and
     YEAR() to format dates.  In addition, it is often used in various date
     calculations.

 ^bExamples^b

     ^b^CFE^b  These examples show the DAY() function used several ways:

        ? DATE()                             // Result: 09/01/90
        ? DAY(DATE())                        // Result: 1
        ? DAY(DATE()) + 1                    // Result: 2
        ? DAY(CTOD("12/01/94"))              // Result: 1

     ^b^CFE^b  This example uses DAY() in combination with CMONTH() and
        YEAR() to format a date value:

        ? CMONTH(DATE()) + STR(DAY(DATE())) +;
           "," + STR(YEAR(DATE()))      // Result: June 15, 1990

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"CDOW()"  "CMONTH()"  "DOW()"  C53G999.NGO:"MONTH()"  C53G999.NGO:"STR()"  C53G999.NGO:"YEAR()"  
!Short: DBAPPEND()      Append a new record to the database in the current work area
 ^bDBAPPEND()^b
 Append a new record to the database open in the current work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBAPPEND([<lReleaseRecLocks>]) --> NIL

 ^bArguments^b

     ^b<lReleaseRecLocks>^b  is a logical data type that if  true (.T.),
     clears all pending record locks, then appends the next record.  If
     <lReleaseRecLocks> is false (.F.), all pending record locks are
     maintained and the new record is added to the end of the Lock List.  The
     default value of <lReleaseRecLocks> is true (.T.).

 ^bReturns^b

     DBAPPEND() always returns NIL.

 ^bDescription^b

     DBAPPEND() is a database function that lets you add records to the
     current database.  The enhancement to this function lets you maintain
     multiple record locks during an append.

     DBAPPEND() without a parameter as in earlier versions of CA-Clipper,
     clears all pending record locks prior to an append.  This is the same as
     DBAPPEND(.T.).

 ^bExamples^b

     ^b^CFE^b  This example appends a blank record to the database, Sales,
        without releasing the record locks in the current Lock List, and then
        checks for a network error:

        USE Sales NEW
        SET INDEX TO Sales
        DBAPPEND(.F.)
        IF NETERR()
           ? "A network error has occurred!"
        ENDIF

!Seealso:C53G999.NGO:"APPEND BLANK"  
!Short: DBCLEARFIL()    Clear a filter condition
 ^bDBCLEARFILTER()^b
 Clear a filter condition
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCLEARFILTER() --> NIL

 ^bReturns^b

     DBCLEARFILTER() always returns NIL.

 ^bDescription^b

     DBCLEARFILTER() clears the logical filter condition, if any, for the
     current work area.

     DBCLEARFILTER() performs the same function as the standard SET FILTER
     command with no expression specified.  For more information, refer to
     the SET FILTER command.

 ^bNotes^b

     ^b^CFE  Logical records:^b DBCLEARFILTER() affects the logical
        visibility of records in the current work area.  For more
        information, refer to DBSETFILTER() and the SET FILTER command.

 ^bExamples^b

     ^b^CFE^b  The following example sets a filter, lists data as filtered,
        and then clears the filter:

        USE Employee NEW
        DBSETFILTER( {|| Age < 40}, "Age < 40" )
        LIST Employee->Name
        DBCLEARFILTER()


 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBFILTER()"  "DBSETFILTER()"  C53G999.NGO:"SET DELETED"  C53G999.NGO:"SET FILTER"  
!Short: DBCLEARIND()    Close all indexes for the current work area
 ^bDBCLEARINDEX()^b
 Close all indexes for the current work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCLEARINDEX() --> NIL

 ^bReturns^b

     DBCLEARINDEX() always returns NIL.

 ^bDescription^b

     DBCLEARINDEX() closes any active indexes for the current work area.  Any
     pending index updates are written and the index files are closed.

     DBCLEARINDEX() performs the same function as the standard SET INDEX
     command with no indexes specified.  For more information, refer to the
     SET INDEX command.

 ^bExamples^b

     ^b^CFE^b  The following example clears index files if any are set:

        cFirst := "Winston"
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "FIRSTNAM" )
        DBSETINDEX( "LASTNAME" )
        //
        IF INDEXORD() > 0               // is there an index?
           DBCLEARINDEX()               // clear index files
        ELSE
           COPY TO FILE TEMP SDF      // copy to SDF in natural
        ENDIF                           // order

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBCREATEIND()"  "DBREINDEX()"  "DBSETINDEX()"  "DBSETORDER()"  
!Short: DBCLEARREL()    Clear active relations
 ^bDBCLEARRELATION()^b
 Clear active relations
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCLEARRELATION() --> NIL

 ^bReturns^b

     DBCLEARRELATION() always returns NIL.

 ^bDescription^b

     DBCLEARRELATION() clears any active relations for the current work area.

     DBCLEARRELATION() performs the same function as the standard SET
     RELATION TO command with no clauses specified.  For more information,
     refer to the SET RELATION command.

 ^bExamples^b

     ^b^CFE^b  The following example sets a relation, lists data, and then
        clears the relation:

        USE Employee NEW
        USE Department NEW INDEX Dept
        //
        SELECT Employee
        DBSETRELATION("Department", ;
           {|| Employee->Dept}, "Employee->Dept")
        LIST Employee->Name, Department->Name
        DBCLEARRELATION()

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBSETRELAT()"  C53G999.NGO:"SET RELATION"  
!Short: DBCLOSEALL()    Close all occupied work areas
 ^bDBCLOSEALL()^b
 Close all occupied work areas
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCLOSEALL() --> NIL

 ^bReturns^b

     DBCLOSEALL() always returns NIL.

 ^bDescription^b

     DBCLOSEALL() releases all occupied work areas from use.  It is
     equivalent to calling DBCLOSEAREA() on every occupied work area.
     DBCLOSEALL() has the same effect as the standard CLOSE DATABASES
     command.  For more information, refer to the USE and CLOSE commands.

 ^bExamples^b

     ^b^CFE^b  The following example closes all work areas:

        cLast := "Winston"
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "SALEFNAM" )
        DBSETINDEX( "SALELNAM" )
        //
        DBUSEAREA( .T., "DBFNTX", "Colls", "Colls", .T. )
        DBSETINDEX( "COLLFNAM" )
        DBSETINDEX( "COLLLNAM" )
        //
        DBSELECTAREA( "Sales" )      // select "Sales" work area
        //

        IF ( Sales->(DBSEEK(cLast)) )
           IF Sales->( DELETED() )
              IF RLOCK()
                 Sales->( DBRECALL() )
                 ? "Record deleted: ", Sales( DELETED() )
              ENDIF
           ENDIF
        ELSE
           ? "Not found"
        ENDIF
        DBCLOSEALL()                  // close all work areas

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"CLOSE"  "DBCLOSEAREA()"  "DBUSEAREA()"  C53G999.NGO:"SELECT"  C53G999.NGO:"USE"  
!Short: DBCLOSEAREA()   Close a work area
 ^bDBCLOSEAREA()^b
 Close a work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCLOSEAREA() --> NIL

 ^bReturns^b

     DBCLOSEAREA() always returns NIL.

 ^bDescription^b

     DBCLOSEAREA() releases the current work area from use.  Pending updates
     are written, pending locks are released, and any resources associated
     with the work area are closed or released.  DBCLOSEAREA() is equivalent
     to the standard CLOSE command or the USE command with no clauses.  For
     more information, refer to the USE and CLOSE commands.

 ^bExamples^b

     ^b^CFE^b  The following example closes a work area via an alias
        reference:

        cLast := "Winston"
        //
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "SALEFNAM" )
        DBSETINDEX( "SALELNAM" )
        //
        DBUSEAREA( .T., "DBFNTX", "Colls", "Colls", .T. )
        DBSETINDEX( "COLLFNAM" )
        DBSETINDEX( "COLLLNAM" )
        //
        DBSELECTAREA( "Sales" )      // select "Sales" work area
        //
        IF ( Sales->(DBSEEK(cLast)) )

           IF Sales->( DELETED() ) .AND. Sales->( RLOCK() )
              Sales->( DBRECALL() )
              ? "Record deleted: ", Sales( DELETED() )
           ENDIF
        ELSE
           ? "Not found"
           Colls->( DBCLOSEAREA() )
        ENDIF

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"CLOSE"  "DBCLOSEALL()"  "DBCOMMIT()"  "DBUSEAREA()"  C53G999.NGO:"USE"  
!Short: DBCOMMIT()      Flush pending updates
 ^bDBCOMMIT()^b
 Flush pending updates
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCOMMIT() --> NIL

 ^bReturns^b

     DBCOMMIT() always returns NIL.

 ^bDescription^b

     DBCOMMIT() causes all updates to the current work area to be written to
     disk.  All updated database and index buffers are written to DOS and a
     DOS COMMIT request is issued for the database (.dbf) file and any index
     files associated with the work area.

     DBCOMMIT() performs the same function as the standard COMMIT command
     except that it operates only on the current work area.  For more
     information, refer to the COMMIT command.

 ^bNotes^b

     ^b^CFE  Network environment:^b DBCOMMIT() makes database updates visible
        to other processes.  To insure data integrity, issue DBCOMMIT()
        before an UNLOCK operation.  For more information, refer to the
        "Network Programming" chapter in the Programming and Utilities Guide.

     ^b^CFE^b  DBCOMMIT() uses DOS interrupt 21h function 68h to perform the
        solid-disk write.  It is up to the network operating system to
        properly implement this request.  Check with the network vendor to
        see if this is supported.

 ^bExamples^b

     ^b^CFE^b  In this example, COMMIT is used to force a write to disk after
        a series of memory variables are assigned to field variables:

        USE Sales EXCLUSIVE NEW
        MEMVAR->Name := Sales->Name

        MEMVAR->Amount := Sales->Amount
        //
        @ 10, 10 GET MEMVAR->Name
        @ 11, 10 GET MEMVAR->Amount
        READ
        //
        IF UPDATED()
           APPEND BLANK
           REPLACE Sales->Name WITH MEMVAR->Name
           REPLACE Sales->Amount WITH MEMVAR->Amount
           Sales->( DBCOMMIT() )
        ENDIF

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"CLOSE"  C53G999.NGO:"COMMIT"  "DBCLOSEALL()"  "DBCOMMITALL()"  "DBUNLOCK()"  
!Short: DBCOMMITALL()   Flush pending updates in all work areas
 ^bDBCOMMITALL()^b
 Flush pending updates in all work areas
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCOMMITALL() --> NIL

 ^bReturns^b

     DBCOMMITALL() always returns NIL.

 ^bDescription^b

     DBCOMMITALL() causes all pending updates to all work areas to be written
     to disk.  It is equivalent to calling DBCOMMIT() for every occupied work
     area.

     For more information, refer to DBCOMMIT() and the COMMIT command.

 ^bNotes^b

     ^b^CFE^b  DBCOMMITALL() uses DOS interrupt 21h function 68h to perform
        the solid-disk write.  It is up to the network operating system to
        properly implement this request.  Check with the network vendor to
        see if this is supported.

 ^bExamples^b

     ^b^CFE^b  The following example writes all pending updates to disk:

        cLast := "Winston"
        //
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "SALEFNAM" )
        DBSETINDEX( "SALELNAM" )
        //

        DBUSEAREA( .T., "DBFNTX", "Colls", "Colls", .T. )
        DBSETINDEX( "COLLFNAM" )
        DBSETINDEX( "COLLLNAM" )

        DBSELECTAREA( "Sales" )      // select "Sales" work area

        IF ( Sales->(DBSEEK(cLast)) )
           IF Sales->( DELETED() ) .AND. Sales( RLOCK() )
              Sales->( DBRECALL() )
              ? "Deleted record has been recalled."
           ENDIF
        ELSE
           ? "Not found"
        ENDIF
        //
        // processing done, write updates to disk and close
        DBCOMMITALL()
        DBCLOSEALL()
        QUIT

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"CLOSE"  C53G999.NGO:"COMMIT"  "DBCLOSEALL()"  "DBCOMMIT()"  "DBUNLOCK()"  
!Short: DBCREATE()      Create a database file from a database structure array
 ^bDBCREATE()^b
 Create a database file from a database structure array
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCREATE(<cDatabase>, <aStruct>
     ^b   [<cDriver>]) --> NIL

 ^bArguments^b

     ^b<cDatabase>^b is the name of the new database file, with an optional
     drive and directory, specified as a character string.  If specified
     without an extension, .dbf is assumed.

     ^b<aStruct>^b is an array that contains the structure of <cDatabase> as
     a series of subarrays, one per field.  Each subarray contains the
     definition of each field's attributes and has the following structure:

     ^bField Definition Subarray^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bPosition     Metasymbol     Dbstruct.ch^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     1            cName          DBS_NAME
     2            cType          DBS_TYPE
     3            nLength        DBS_LEN
     4            nDecimals      DBS_DEC
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^b<cDriver>^b specifies the replaceable database driver (RDD) to use to
     process the current work area.  <cDriver> is the name of the RDD
     specified as a character expression.  If you specify <cDriver> as a
     literal value, you must enclose it in quotes.

 ^bReturns^b

     DBCREATE() always returns NIL.

 ^bDescription^b

     DBCREATE() is a database function that creates a database file from an
     array containing the structure of the file.  You may create the array
     programmatically or by using DBSTRUCT().  DBCREATE() is similar to the
     CREATE FROM command which creates a new database file structure from a
     structure extended file.  Use CREATE or COPY STRUCTURE EXTENDED commands
     to create a structure extended file.

     Before using DBCREATE(), you must first create the <aStruct> array and
     fill it with the field definition arrays according to the structure in
     Field Definition Subarray table (above).  There are some specific rules
     for creating a field definition array, including:

     ^b^CFE^b  Specify all field attributes with a value of the proper data
        type for the attribute.  The decimals attribute must be specified--
        even for non-numeric fields.  If the field does not have a decimals
        attribute, specify zero.

     ^b^CFE^b  Specify the type attribute using the first letter of the data
        type as a minimum.  Use longer and more descriptive terms for
        readability.  For example, both "C" and "Character" can be specified
        as the type attribute for character fields.

     ^b^CFE^b  In CA-Clipper, character fields contain up to 64,000
        characters.  Unlike the CREATE FROM command, DBCREATE() does not use
        the decimals attribute to specify the high-order part of the field
        length.  Specify the field length directly, regardless of its
        magnitude.

     To make references to the various elements of the field definition
     subarray more readable, the header file called Dbstruct.ch is supplied.
     It contains the #defines to assign a name to the array position for each
     field attribute.  It is located in \CLIP53\INCLUDE.

 ^bNotes^b

     ^b^CFE  Duplicate field names:^b DBCREATE() does not check for duplicate
        field names.  Therefore, be careful not to use the same field name
        twice.

     ^b^CFE  EG_ARG error:^b DBCREATE() generates an EG_ARG error if the
        filename is NIL.

 ^bExamples^b

     ^b^CFE^b  This example creates an empty array and then adds field
        definition subarrays using the AADD() function before creating
        People.dbf.  You might use this technique to add field definitions to
        your structure array dynamically:

        aDbf := {}
        AADD(aDbf, { "Name", "C", 25, 0 })
        AADD(aDbf, { "Address", "C", 1024, 0 })
        AADD(aDbf, { "Phone", "N", 13, 0 })
        //
        DBCREATE("People", aDbf)

     ^b^CFE^b  This example performs the same types of actions but declares
        the structure array as a two-dimensional array, and then uses
        subscript addressing to specify the field definitions.  It will be
        created using the DBFMDX RDD:

        #include "Dbstruct.ch"
        //
        LOCAL aDbf[1][4]
        aDbf[1][ DBS_NAME ] := "Name"
        aDbf[1][ DBS_TYPE ] := "Character"
        aDbf[1][ DBS_LEN ]  := 25
        aDbf[1][ DBS_DEC ]  := 0
        //
        DBCREATE("Name", aDbf, "DBFMDX")

 ^bFiles^b   Library is CLIPPER.LIB, header file is Dbstruct.ch.

!Seealso:"AFIELDS()*"  C53G999.NGO:"COPY STRU EXTE"  C53G999.NGO:"CREATE FROM"  "DBSTRUCT()"  
!Short: DBCREATEIND()   Create an index file
 ^bDBCREATEINDEX()^b
 Create an index file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBCREATEINDEX(<cIndexName>, <cKeyExpr>,
     ^b   [<bKeyExpr>], [<lUnique>]) --> NIL

 ^bArguments^b

     ^b<cIndexName>^b is a character value that specifies the file name of
     the index file to be created.

     ^b<cKeyExpr>^b is a character value that expresses the index key
     expression in textual form.

     ^b<bKeyExpr>^b is a code block that expresses the index key expression
     in executable form.

     ^b<lUnique>^b is an optional logical value that specifies whether a
     unique index is to be created.  If <lUnique> is omitted, the current
     global _SET_UNIQUE setting is used.

 ^bReturns^b

     DBCREATEINDEX() always returns NIL.

 ^bDescription^b

     DBCREATEINDEX() creates an index for the database (.dbf) file associated
     with the current work area.  If the work area has active indexes, they
     are closed.  After the new index is created, it becomes the controlling
     index for the work area and is positioned to the first logical record.

     DBCREATEINDEX() performs the same function as the standard INDEX
     command.  For more information, refer to the INDEX command.

 ^bNotes^b

     ^b^CFE  Side effects:^b DBCREATEINDEX() is guaranteed to create an index
        that, when made active, will impose the specified logical order on
        the database.  The key expression is not necessarily evaluated at any
        particular time, by any particular means, or on any particular record
        or series of records.  If the key expression relies on information
        external to the database file or work area, the effect is
        unpredictable.  If the key expression changes the state of the work
        area (e.g., by moving to a different record or changing the contents
        of a record), the effect is unpredictable.

     ^b^CFE  Evaluation context:^b When the key expression is evaluated, the
        associated work area is automatically selected as the current work
        area before the evaluation; the previously selected work area is
        automatically restored afterward.

     ^b^CFE  Network environment:^b DBCREATEINDEX() creates the new index for
        the exclusive use of the current process.

     ^b^CFE  Illegal expression:^b If <cKeyExpr> evaluates to an illegal
        expression, the code block will always evaluate to end-of-file (EOF).

 ^bExamples^b

     ^b^CFE^b  This example creates an index file, Name, indexed on the Name
        field:

        USE Employees NEW
        DBCREATEINDEX( "Name", "Name", { || Name })

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBCLEARIND()"  "DBREINDEX()"  "DBSETINDEX()"  "DBSETORDER()"  
!Short: DBDELETE()      Mark a record for deletion
 ^bDBDELETE()^b
 Mark a record for deletion
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBDELETE() --> NIL

 ^bReturns^b

     DBDELETE() always returns NIL.

 ^bDescription^b

     DBDELETE() marks the current record as deleted.  Records marked for
     deletion can be filtered using SET DELETED or removed from the file
     using the PACK command.

     DBDELETE() performs the same function as the standard DELETE command
     with a scope of the current record.  For more information, refer to the
     DELETE command.

 ^bNotes^b

     ^b^CFE  Logical records:^b If the global _SET_DELETED status is true
        (.T.), deleted records are not logically visible.  That is, database
        operations which operate on logical records will not consider records
        marked for deletion.  Note, however, that if _SET_DELETED is true
        (.T.) when the current record is marked for deletion, the record
        remains visible until it is no longer the current record.

     ^b^CFE  Network environment:^b For a shared database on a network,
        DBDELETE() requires the current record to be locked.  For more
        information, refer to the "Network Programming" chapter of the
        Programming and Utilities Guide.

 ^bExamples^b

     ^b^CFE^b  The following example deletes a record after a successful
        record lock:

        cLast := "Winston"
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "LASTNAME" )
        //
        IF ( Sales->(DBSEEK(cLast)) )
           IF Sales->( RLOCK() )
              Sales->( DBDELETE() )
              ? "Record deleted: ", Sales->( DELETED() )
           ELSE
              ? "Unable to lock record..."
           ENDIF
        ELSE
           ? "Not found"
        ENDIF

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBRECALL()"  C53G999.NGO:"DELETE"  C53G999.NGO:"RECALL"  
!Short: DBEDIT()        Browse records in a table layout
 ^bDBEDIT()^b
 Browse records in a table layout
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBEDIT([<nTop>], [<nLeft>],
     ^b   [<nBottom>], <nRight>],
     ^b   [<acColumns>],
     ^b   [<cUserFunction>],
     ^b   [<acColumnSayPictures> | <cColumnSayPicture>],
     ^b   [<acColumnHeaders> | <cColumnHeader>],
     ^b   [<acHeadingSeparators> | <cHeadingSeparator>],
     ^b   [<acColumnSeparators> | <cColumnSeparator>],
     ^b   [<acFootingSeparators> | <cFootingSeparator>],
     ^b   [<acColumnFootings> | <cColumnFooting>]) --> NIL

 ^bArguments^b

     ^b<nTop>^b, ^b<nLeft>^b, ^b<nBottom>^b, and ^b<nRight>^b define the
     upper-left and lower-right coordinates of the DBEDIT() window.  Row
     values can range from zero to MAXROW() and column positions can range
     from zero to MAXCOL().  If not specified, the default coordinates are 0,
     0, MAXROW(), and MAXCOL().

     ^b<acColumns>^b is an array of character expressions containing database
     field names or expressions to use as column values for each row
     displayed.  If this argument is not specified, DBEDIT() displays all
     fields in the current work area as columns.

     ^b<cUserFunction>^b is the name of a user-defined function that executes
     when an unrecognizable key is pressed or there are no keys pending in
     the keyboard buffer.  Specify the function name as a character
     expression without parentheses or arguments.  Note that the behavior of
     DBEDIT() is affected by the presence of this argument.  Refer to the
     discussion below for more information.

     ^b<acColumnSayPictures>^b is a parallel array of picture clauses to
     format each column.  Specifying <cColumnSayPicture> instead of an array
     displays all columns with the same format.  Refer to TRANSFORM() or
     @...SAY for more information on pictures.

     ^b<acColumnHeaders>^b is a parallel array of character expressions that
     define the headings for each column.  Specifying <cColumnHeader> gives
     the same heading for all columns.  To display a multi-line heading,
     embed a semicolon in the heading expression where you want the string to
     break.  If not specified, column headings are taken from the <acColumns>
     array or the field names in the current work area, if the <acColumns>
     argument is not specified.

     ^b<acHeadingSeparators>^b is a parallel array of character expressions
     that define the characters used to draw horizontal lines separating
     column headings from the field display area. Specifying
     <cHeadingSeparator> instead of an array uses the same heading separator
     for all columns.  If this argument is not specified, the default
     separator is a double graphics line.

     ^b<acColumnSeparators>^b is a parallel array of character expressions
     that define the characters used to draw vertical lines separating the
     columns.  Specifying <cColumnSeparator> instead of an array uses the
     same separator for all columns.  If this argument is not specified, the
     default separator is a single graphics line.

     ^b<acFootingSeparators>^b is a parallel array of character expressions
     that define the characters used to draw horizontal lines separating
     column footings from the field display area.  Specifying
     <cFootingSeparator> instead of an array uses the same footing separator
     for all columns.  If this argument is not specified, there is no footing
     separator.

     ^b<acColumnFootings>^b is a parallel array of character expressions that
     define footings for each column.  Specifying <cColumnFooting> instead of
     an array gives the same footing for all columns.  To display a multi-
     line footing, embed a semicolon in the footing expression where you want
     the string to break.  If this argument is not specified, there are no
     column footings.

 ^bReturns^b

     DBEDIT() always returns NIL.

 ^bDescription^b

     DBEDIT() is a user interface and compatibility function that displays
     records from one or more work areas in a table form.  The DBEDIT()
     window display is a grid of cells divided into columns and rows.
     Columns correspond to database fields and rows correspond to database
     records.  Each column is defined by an element of the <acColumns> array.
     The display width of each column is determined by the evaluation of the
     column expression in <acColumns> array or the column picture specified
     in the <acColumnSayPictures> array.

     All cursor movement keys are handled within DBEDIT(), including Page up,
     Page down, Home, End, the four arrow keys, and all Ctrl key combinations
     that produce cursor movement.  The navigation keys that DBEDIT()
     responds to when a user function argument is not specified are listed in
     the Active Keys table below:

     ^bDBEDIT() Active Keys^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bKey                 Action^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Up arrow            Up one row
     Down arrow          Down one row
     Left arrow          Column left
     Right arrow         Column right
     Ctrl+Left arrow     Pan left one column
     Ctrl+Right arrow    Pan right one column
     Home                Leftmost current screen column
     End                 Rightmost current screen column
     Ctrl+Home           Leftmost column
     Ctrl+End            Rightmost column
     PgUp                Previous screen
     PgDn                Next screen
     Ctrl+PgUp           First row of current column
     Ctrl+PgDn           Last row of current column
     Return              Terminate DBEDIT()
     Esc                 Terminate DBEDIT()
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     When the user function argument (<cUserFunction>) is specified, all keys
     indicated in the Active Keys table are active with the exception of Esc
     and Return.  When DBEDIT() calls the user function, it automatically
     passes two arguments:

     ^b^CFE^b  The current mode passed as a numeric value

     ^b^CFE^b  The index of the current column in <acColumns> passed as a
        numeric value

     The mode parameter indicates the current state of DBEDIT() depending on
     the last key executed.  The possible mode values are listed in the
     DBEDIT() Modes table below:

     ^bDBEDIT() Modes^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bStatus  Dbedit.ch      Description^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     0       DE_IDLE        Idle, any cursor movement keystrokes have been
                            handled and no keystrokes are pending
     1       DE_HITTOP      Attempt to cursor past top of file
     2       DE_HITBOTTOM   Attempt to cursor past bottom of file
     3       DE_EMPTY       No records in work area
     4       DE_EXCEPT      Key exception
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     The index parameter points to the position of the current column
     definition in the <acColumns> array.  If <acColumns> is not specified,
     the index parameter points to the position of the field in the current
     database structure.  Access the field name using FIELD().

     A user-defined function must return a value that indicates to DBEDIT()
     the action to perform.  The User Function Return Values table below
     lists the possible return values and the corresponding actions:

     ^bDBEDIT() User Function Return Values^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bValue   Dbedit.ch      Description^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     0       DE_ABORT       Abort DBEDIT()
     1       DE_CONT        Continue DBEDIT()
     2       DE_REFRESH     Force reread/repaint and continue; after repaint,
                            process keys and go to idle
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     A number of instances affect calls to the user function:

     ^b^CFE^b  A key exception occurs.  This happens when DBEDIT() fetches a
        keystroke that it does not recognize from the keyboard.  Any pending
        keys remain in the keyboard buffer until fetched within the user
        function or until DBEDIT() continues.

     ^b^CFE^b  DBEDIT() enters the idle mode (i.e., all pending keys have
        been processed).  This happens when the keyboard is empty or after a
        screen refresh.  In this instance, there is one call to the user
        function and then DBEDIT() waits for a key.

     ^b^CFE^b  Beginning or end of file is encountered.  This is the same as
        idle.  All executable keys are performed, and there is one call to
        the user function with the appropriate status message.

     Note that when DBEDIT() is first executed, all keys pending in the
     keyboard buffer are executed and then DBEDIT() enters the idle mode with
     a user function call.  If no keys are pending, the idle mode is
     immediate.

     The user function should handle all modes and status messages received
     from DBEDIT().

     A user-defined function must ensure that the DBEDIT() status is
     equivalent to DE_EXCEPT (4); otherwise, the value of LASTKEY() is
     meaningless and a Return value of DE_REFRESH (2) will place the
     application into an endless loop.  For example:

     FUNCTION DBEditFunc ( nMode, nColumnPos )
        LOCAL RetVal := DE_CONT

        IF ( nMode == DE_EXCEPT )
           IF ( LASTKEY() == K_F5 )
                    RetVal := DE_REFRESH
           ENDIF
        ENDIF
        RETURN(  RetVal )

     DBEDIT() is fully re-entrant, which means you can make nested calls to
     it.  Using this feature, you can have multiple browse windows on the
     screen at the same time.

     DBEDIT() is a compatibility function and, therefore, no longer
     recommended as a programmable browse facility.  As such, it is
     superseded by the TBrowse object class.  For more information, refer to
     TBrowse class in this chapter.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a generic call to DBEDIT():

        USE Names NEW
        DBEDIT()

     ^b^CFE^b  This example demonstrates calling DBEDIT() with a user
        function:

        #include "dbedit.ch"
        #include "inkey.ch"

        // Array must be visible to other user-defined programs in
        // program

        STATIC acColumns := {}

        PROCEDURE Main()

           USE Names NEW
           INDEX ON Names->Lastname + Names->FirstName TO Names

           CLS

           acColumns := { "LastName", "FirstName" }

           DBEDIT( 5, 5, 20, 70, acColumns, "UserFunc" )

        RETURN


        FUNCTION UserFunc( nMode, nCol )
           LOCAL nKey := LASTKEY()
           LOCAL nRetVal := DE_CONT         // Default return value

           DO CASE
           CASE nMode == DE_IDLE
              nRetVal := IdleFunc()
           CASE nMode == DE_HITTOP
              TONE( 100, 3 )
           CASE nMode == DE_HITBOTTOM
              TONE( 100, 3 )
              nRetVal := AppendFunc( nKey )
           CASE nMode == DE_EMPTY
              nRetVal := EmptyFunc()
           CASE nMode == DE_EXCEPT
              nRetVal := ExceptFunc( nKey, nCol )
           OTHERWISE
              TONE( 100, 3 )
           ENDCASE

        RETURN nRetVal

        FUNCTION AppendFunc( nKey )
           LOCAL nRetVal := DE_CONT         // Default return value

           IF nKey == K_DOWN                  // If DOWN ARROW
              APPEND BLANK                  // Append blank record
        // Note: The appended record will appear at the top of the
        //       DBEDIT() screen when the database file is indexed.

              nRetVal := DE_REFRESH         // Refresh screen
           ENDIF


        RETURN nRetVal

        FUNCTION ExceptFunc( nKey, nCol )
           LOCAL nRetVal := DE_CONT         // Default return value

           DO CASE
           CASE nKey == K_ESC                  // If ESCAPE
              nRetVal := DE_ABORT               // Exit
           CASE nKey == K_RETURN               // If RETURN
              nRetVal := EditFunc( nCol )      // Function to edit
                                               // field

           // Toggle DELETED status
           CASE nKey == K_DEL .AND. LASTREC() != 0  // DELETE pressed
              IF DELETED()
                 RECALL
              ELSE
                 DELETE
              ENDIF
           OTHERWISE
                 TONE( 100, 1 )
           ENDCASE

        RETURN nRetVal


        FUNCTION EditFunc( nCol )
           LOCAL cIndexVal         // Value of current key expression
           LOCAL nRetVal            // Return value
           LOCAL nField            // Position of current field
           LOCAL cFieldVal         // Value of current field
           LOCAL nCursSave         // Preserve state of cursor

           // This will return an error if no index is open
           cIndexVal := &( INDEXKEY(0) )

           nField := FIELDPOS( acColumns[nCol] )

           IF nField != 0
              nCursSave := SETCURSOR()         // Save state of cursor
              SETCURSOR(1)                     // Change cursor shape
              cFieldVal := FIELDGET( nField )         // Save contents
                                                     // of field
              @ ROW(), COL() GET cFieldVal            // GET new value
              READ
              FIELDPUT( nField, cFieldVal )            // REPLACE with
                                                     // new value
              SETCURSOR( nCursSave )                  // Restore cursor
                                                     // shape
           ENDIF


           IF cIndexVal != &( INDEXKEY(0) )         // If key expression

                                                  // changed
              nRequest := DE_REFRESH               // Refresh screen
           ELSE                                    // Otherwise
              nRequest := DE_CONT                  // Continue
           ENDIF

        RETURN nRequest

        FUNCTION IdleFunc()
           // Idle routine
        RETURN DE_CONT

        FUNCTION EmptyFunc()
           // Empty Records routine
        RETURN DE_CONT

 ^bFiles^b   Library is EXTEND.LIB, header files are Dbedit.ch and Inkey.ch.

!Seealso:C53G999.NGO:"@...GET"  "ACHOICE()"  "BROWSE()*"  C53G999.NGO:"MEMOEDIT()"  C53G999.NGO:"READ"  
!Short: DBEVAL()        Evaluate code block for each record matching scope/condition
 ^bDBEVAL()^b
 Evaluate a code block for each record matching a scope and condition
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBEVAL(<bBlock>,
     ^b   [<bForCondition>],
     ^b   [<bWhileCondition>],
     ^b   [<nNextRecords>],
     ^b   [<nRecord>],
     ^b   [<lRest>]) --> NIL

 ^bArguments^b

     ^b<bBlock>^b is a code block to execute for each record processed.

     ^b<bForCondition>^b is an optional condition specified as a code block
     that is evaluated for each record in the scope.  It provides the same
     functionality as the FOR clause of record processing commands.

     ^b<bWhileCondition>^b is an optional condition specified as a code block
     that is evaluated for each record from the current record until the
     condition returns false (.F.).  It provides the same functionality as
     the WHILE clause of record processing commands.

     ^b<nNextRecords>^b is an optional number that specifies the number of
     records to process starting with the current record.  It is the same as
     the NEXT clause.

     ^b<nRecord>^b is an optional record number to process.  If this argument
     is specified, <bBlock> will be evaluated for the specified record.  This
     argument is the same as the RECORD clause.

     ^b<lRest>^b is an optional logical value that determines whether the
     scope of DBEVAL() is all records, or, starting with the current record,
     all records to the end of file.  This argument corresponds to the REST
     and ALL clauses of record processing commands.  If true (.T.) , the
     scope is REST; otherwise, the scope is ALL records.  If <lRest> is not
     specified the scope defaults to ALL.

 ^bReturns^b

     DBEVAL() always returns NIL.

 ^bDescription^b

     DBEVAL() is a database function that evaluates a single block for each
     record within the current work area that matches a specified scope
     and/or condition.  On each iteration, DBEVAL() evaluates the specified
     block.  All records within the scope or matching the condition are
     processed until the end of file is reached.

     By default, DBEVAL() operates on the currently selected work area.  It
     will operate on an unselected work area if you specify it as part of an
     aliased expression.

     DBEVAL() is similar to AEVAL() which applies a block to each element in
     an array.  Like AEVAL(), DBEVAL() can be used as a primitive for the
     construction of user-defined commands that process database files.  In
     fact, many of the standard CA-Clipper database processing commands are
     created using DBEVAL().

     Refer to the Code Blocks section in the "Basic Concepts" chapter of the
     Programming and Utilities Guide for more information on the syntax and
     theory of code blocks; and refer also to the Database System section in
     the same chapter for information on record scoping and conditions.  Also
     refer to the CA-Clipper standard header file, Std.ch, found in
     \CLIP53\INCLUDE for examples of CA-Clipper database command definitions
     that use DBEVAL().

 ^bExamples^b

     ^b^CFE^b  This example uses DBEVAL() to implement Count(), a user-
        defined function that counts the number of records in a work area
        matching a specified scope.  The scope is passed as an array to
        Count().  To make the example more interesting, there is a user-
        defined command to create the scope array, thereby allowing you to
        specify the scope in a familiar form.  Additionally, there is a set
        of manifest constants that define the attributes of the scope object.

        // Scope command definition
        #command CREATE SCOPE <aScope> [FOR <for>] ;
           [WHILE <while>] [NEXT <next>] [RECORD <rec>] ;
           [<rest:REST>] [ALL];
        =>;
           <aScope> := { <{for}>, <{while}>, <next>, ;
              <rec>, <.rest.> }
        //

        // Scope attribute constants
        #define FOR_COND      1
        #define WHILE_COND    2
        #define NEXT_SCOPE    3
        #define REC_SCOPE     4
        #define REST_SCOPE    5
        //
        // Create a scope and count records using it
        LOCAL mySet, myCount
        USE Customer NEW
        CREATE SCOPE mySet FOR Customer = "Smith" WHILE ;
                  Zip > "90000"
        myCount := Count( mySet )
        RETURN

        FUNCTION Count( aScope )
           LOCAL nCount := 0
           DBEVAL( {|| nCount++},;
              aScope[ FOR_COND ],;
              aScope[ WHILE_COND ],;
              aScope[ NEXT_SCOPE ],;
              aScope[ REC_SCOPE ],;
              aScope[ REST_SCOPE ];
           )
           RETURN nCount

 ^bFiles^b   Library is CLIPPER.LIB

!Seealso:"AEVAL()"  "EVAL()"  
!Short: DBF()*          Return current alias name
 ^bDBF()*^b
 Return current alias name
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBF() --> cAlias

 ^bReturns^b

     DBF() returns the alias of the current work area as a character string.
     If there is no active database file in the current work area, DBF()
     returns a null string ("").

 ^bDescription^b

     DBF() is a compatibility function that replicates the DBF() function in
     dBASE III PLUS.  CA-Clipper implements it by invoking the ALIAS()
     function without an argument.

     DBF() is a compatibility function and, therefore, no longer recommended.
     It is superseded entirely by the ALIAS() function.

 ^bFiles^b   Library is EXTEND.LIB, source file is SOURCE\SAMPLE\DBF.PRG

!Seealso:"ALIAS()"  C53G999.NGO:"USED()"  
!Short: DBFIELDINFO()   Return and optionally change information about a field
 ^bDBFIELDINFO()^b
 Return and optionally change information about a field
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBFIELDINFO(<nInfoType>,
     ^b   <nFieldPos>,
     ^b   [<expNewSetting>]) --> uCurrentSetting

 ^bArguments^b

     ^b<nInfoType>^b determines the type of information as specified by the
     constants below.  Note, however, that not all constants are supported
     for all RDDs, nor are all constants supported by all field types.  These
     constants are defined in the Dbstruct.ch header file, which must be
     included (#include) in your application.

     ^bField Information Type Constants^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bConstant            Description^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     DBS_BLOB_LEN        Returns the storage length of the data in a BLOB
                         (memo) file.
     DBS_BLOB_OFFSET     Returns the file offset of the data in a BLOB (memo)
                         file.
     DBS_BLOB_POINTER    Returns a numeric pointer to the data in a blob
                         file. This pointer can be used with BLOBDirectGet(),
                         BLOBDirectImport(), etc.
     DBS_BLOB_TYPE       Returns the data type of a BLOB (memo) field. This
                         is more efficient than using Type() or ValType()
                         since the data itself does not have to be retrieved
                         from the BLOB file in order to determine the type.
     DBS_DEC             Number of decimal places for the field.
     DBS_LEN             Length of the field.
     DBS_NAME            Name of the field.
     DBS_TYPE            Data type of the field.
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^b<nFieldPos>^b is the position of the field in the database file
     structure.

     ^b<expNewSetting>^b is reserved for CA-Clipper future use.  It can be
     omitted or specified as NIL.

 ^bReturns^b

     DBFIELDINFO() returns the current setting.

 ^bDescription^b

     DBFIELDINFO() retrieves information about the state of a field.  By
     default, this function operates on the currently selected work area.  It
     can be made to operate on an unselected work area by specifying it
     within an aliased expression.

     The field information that is available is defined by the RDD.

     To support RDDs for other database models (such as dictionary-based
     databases) that store more information about each field or column, the
     CA-Clipper 5.3 RDD API has been enhanced.  The DBFIELDINFO() is designed
     to allow for additional <nInfoType> values that can be defined by third-
     party RDD developers.

 ^bExamples^b

     ^b^CFE^b  The following example uses DBFIELDINFO() to retrieve field
        information:

        #include Dbstruct.ch

        QOut(DBFIELDINFO(DBS_NAME, 1))         // Same as FIELDNAME(1)

        FUNCTION DBOUTSTRUCT()
           LOCAL aStruct := {}
           LOCAL nFcount, i

           nFcount := FCOUNT()
           FOR i := 1 TO nFcount
              AADD(aStruct, {FIELDNAME(i), ;
                                DBFIELDINFO(DBS_TYPE, i), ;
                                DBFIELDINFO(DBS_LEN, i),  ;
                                DBFIELDINFO(DBS_DEC, i)})
           NEXT
           RETURN aStruct

 ^bFiles^b   Library is CLIPPER.LIB, header file is Dbstruct.ch.

!Seealso:"DBINFO()"  "DBORDERINFO()"  "DBRECORDINFO()"  
!Short: DBFILEGET()     Insert the contents of a field into a file
 ^bDBFILEGET()^b
 Insert the contents of a field into a file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBFILEGET(<nFieldPos>, <cTargetFile>, <nMode>)
     ^b   --> lSuccess

 ^bArguments^b

     ^b<nFieldPos>^b is the position of the field in the database file
     structure.

     ^b<cTargetFile>^b is the name of the file where the field data will be
     written, including an optional drive, directory and extension. See
     SetDefault() and SetPath() for file searching and creation rules. No
     default extension is assumed.

     If <cTargetFile> does not exist, it is created. If it exists, this
     function attempts to open the file in exclusive mode and if successful,
     the file is written to without warning or error. If access is denied
     because, for example, another proess is using the file, NetErr() is set
     to TRUE.

     ^b<nMode>^b is a constant defining the copy mode, as shown in the table
     below:

     ^bDBFILEGET() Constants^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bConstant            Description^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     FILEGET_APPEND      Appends to the file.
     FILEGET_OVERWRITE   Overwrites the file.  This is the default.
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bReturns^b

     DBFILEGET() returns true (.T.) if successful; otherwise it returns false
     (.F.).

 ^bDescription^b

     DBFILEGET() provides a mechanism for copying the contents of a field
     into a file.  By default, this function operates on the currently
     selected work area.  It can be made to operate on an unselected work
     area by specifying it within an aliased expression.

     DBFILEGET() is used in conjunction with DBFILEPUT() to transfer data
     back and forth between files and database fields.

 ^bExamples^b

     ^b^CFE^b  This example exports the contents of a field that stores a
        picture to a .GIF file, so that the file can be programmatically
        displayed:

        FUNCTION ShowPix()
           LOCAL cPixFile := "picture.gif"
           LOCAL nPos

           // Customer database with a picture of each
           // customer stored in a field called "Pix"
           USE customer NEW VIA "DBFCDX"
           nPos := FieldPos("Pix")

           // Export the file's data for the current Pix field
           IF ! DBFILEGET(nPos, cPixFile, FILEGET_OVERWRITE )
              Alert("Export of picture " + cPixFile +
              " failed!")

           ELSE
              // Code for displaying picture would go here
           ENDIF

 ^bFiles^b   Library is CLIPPER.LIB, header is Dbinfo.ch

!Seealso:"DBFILEPUT()"  
!Short: DBFILEPUT()     Insert the contents of a file into a field
 ^bDBFILEPUT()^b
 Insert the contents of a file into a field
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBFILEPUT(<nFieldPos>, <cSourceFile>)
     ^b   --> lSuccess

 ^bArguments^b

     ^b<nFieldPos>^b is the position of the field in the database file
     structure.

     ^b<cSourceFile>^b is the name of the file containing the data to insert
     into the specified field, including an optional drive, directory and
     extension.  See SetDefault() and SetPath() for file searching rules. No
     default extension is assumed.

     This function attempts to open <cSourceFile> in shared mode. If the file
     does not exist, a runtime error is raised.  If the file is successfully
     opened, the operation proceeds.  If access is denied because, for
     example, another process has exclusive use of the file, NetErr() is set
     to true (.T.).

     ^bNote: ^b There are no restrictions on the size of <cSourceFile> except
     that you must have enough disk space to make the copy.

 ^bReturns^b

     DBFILEPUT() returns true (.T.) if successful; otherwise, it returns
     false (.F.).

 ^bDescription^b

     DBFILEPUT() provides a mechanism for copying the contents of a file into
     a field.  By default, this function operates on the currently selected
     work area.  It can be made to operate on an unselected work area by
     specifying it within an aliased expression.

     DBFILEPUT() is used in conjunction with DBFILEGET() to transfer data
     back and forth between files and database fields.  You can use
     DBFILEPUT() with a variety of field types, including graphics images,
     word processor files, and printer fonts.  These two functions are
     excellent for creating databases of documents, graphics, sounds, etc.

     ^bNote:^b DBFieldInfo ( DBS_BLOB_TYPE, <nFieldPos> ) will return "C"
     (string) for any memo field created using DBFILEPUT().

 ^bExamples^b

     ^b^CFE^b  This example imports information from a word processing
        document into a field, then uses BLOBGet() to extract the first 25
        characters of the field:

        FUNCTION Populate()
           USE customer NEW VIA "DBFCDX"
           DO WHILE .NOT. EOF()
              GetPix( "Pix", Substr(LastName, 1, 4) + CustID)
              Customer->DBSkip()
           ENDDO

        FUNCTION GetPix(cPixField, cPixFile)
           LOCAL nPos
           nPos := FieldPos(cPixField)

           // Import the picture field into the indicated field
           IF ! DBFILEPUT(nPos, cPixFile)
              Alert("Import of picture " + cPixFile + ;
                    " failed!")
           ENDIF

 ^bFiles^b   Library is CLIPPER.LIB

!Seealso:"DBFILEGET()"  
!Short: DBFILTER()      Return the current filter expression as a character string
 ^bDBFILTER()^b
 Return the current filter expression as a character string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBFILTER() --> cFilter

 ^bReturns^b

     DBFILTER() returns the filter condition defined in the current work area
     as a character string.  If no FILTER has been SET, DBFILTER() returns a
     null string ("").

 ^bDescription^b

     DBFILTER() is a database function used to save and re-execute an active
     filter by returning the filter expression as a character string that can
     be later recompiled and executed using the macro operator (&).  This
     function operates like the DBRELATION() and DBRSELECT() functions which
     save and re-execute the linking expression of a relation within a work
     area.

     Since each work area can have an active filter, DBFILTER() can return
     the filter expression of any work area.  This is done by referring to
     DBFILTER() within an aliased expression as demonstrated below.

 ^bNotes^b

     ^b^CFE  Declared variables:^b A character string returned by DBFILTER()
        may not operate correctly when recompiled and executed using the
        macro operator (&) if the original filter expression contained
        references to local or static variables, or otherwise depended on
        compile-time declarations.

 ^bExamples^b

     ^b^CFE^b  This example opens two database files, sets two filters, and
        then displays the filter expressions for both work areas:

        USE Customer INDEX Customer NEW
        SET FILTER TO Last = "Smith"
        USE Invoices INDEX Invoices NEW
        SET FILTER TO CustId = "Smi001"
        SELECT Customer
        //
        ? DBFILTER()                      // Result: Last = "Smith"
        ? Invoices->(DBFILTER())      // Result: Custid = "Smi001"

     ^b^CFE^b  This user-defined function, CreateQry(), uses DBFILTER() to
        create a memory file containing the current filter expression in the
        private variable cFilter:

        FUNCTION CreateQry( cQryName )
           PRIVATE cFilter := DBFILTER()
           SAVE ALL LIKE cFilter TO (cQryName + ".qwy")
           RETURN NIL

     ^b^CFE^b  You can later RESTORE a query file with this user-defined
        function, SetFilter():

        FUNCTION SetFilter()
        PARAMETER cQryName
           RESTORE FROM &cQryName..qwy ADDITIVE
           SET FILTER TO &cFilter.
           RETURN NIL

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBRELATION()"  "DBRSELECT()"  C53G999.NGO:"SET FILTER"  
!Short: DBGOBOTTOM()    Move to the last logical record
 ^bDBGOBOTTOM()^b
 Move to the last logical record
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBGOBOTTOM() --> NIL

 ^bReturns^b

     DBGOBOTTOM() always returns NIL.

 ^bDescription^b

     DBGOBOTTOM() moves to the last logical record in the current work area.

     DBGOBOTTOM() performs the same function as the standard GO BOTTOM
     command.  For more information, refer to the GO command.

 ^bNotes^b

     ^b^CFE  Logical records:^b DBGOBOTTOM() operates on logical records.  If
        there is an active index, DBGOBOTTOM() moves to the last record in
        indexed order.  If a filter is set, only records which meet the
        filter condition are considered.

     ^b^CFE  Controlling order:^b If more than one index is active in the
        work area, the operation is performed using the controlling order as
        set by DBSETORDER() or the SET ORDER command.  For more information,
        refer to the SET ORDER command.

     ^b^CFE  Network environment:^b For a shared file on a network, moving to
        a different record may cause updates to the current record to become
        visible to other processes.  For more information, refer to the
        "Network Programming" chapter in the Programming and Utilities Guide.
        This function will not affect the locked status of any record.

 ^bExamples^b

     ^b^CFE^b  The following example uses DBGOBOTTOM() to position the record
        pointer on the last logical record:

        cLast := "Winston"
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "LASTNAME" )
        //
        Sales->( DBGOBOTTOM() )
        IF ( Sales->Last == "Winston" )
           IF RLOCK()
              Sales->( DBDELETE() )
              ? "Record deleted: ", Sales->( DELETED() )
           ELSE
              ? "Unable to lock record..."
           ENDIF
        END

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"BOF()"  "DBGOTOP()"  "DBSEEK()"  "DBSKIP()"  "EOF()"  C53G999.NGO:"GO"  
!Short: DBGOTO()        Position record pointer to a specific identity
 ^bDBGOTO()^b
 Position record pointer to a specific identity
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBGOTO(<xIdentity>) --> NIL

 ^bArguments^b

     ^b<xIdentity>^b is a unique value guaranteed by the structure of the
     data file to reference a specific item in a data source (database).  In
     a Xbase data structure (.dbf) <xIdentity> is the record number.  In
     other data formats, <xIdentity> is the unique primary key value.
     <xIdentity> could be an array offset or virtual memory handle if the
     data set is in memory instead of on disk.

 ^bReturns^b

     DBGOTO() always returns NIL.

 ^bDescription^b

     DBGOTO() is a database function that positions the record pointer in the
     current work area at the specified <xIdentity>.  In an Xbase data
     structure, this identity is the record number because every record, even
     an empty record, has a record number.  In non-Xbase data structures,
     identity may be defined as something other than record number.

 ^bExamples^b

     ^b^CFE^b  This example saves the current record number, searches for a
        key, and then restores the record pointer to the saved position:

        FUNCTION KeyExists( xKeyExpr )

           LOCAL nSavRecord := RECNO()      // Save the current record
                                            // pointer position
           LOCAL lFound

           SEEK xKeyExpr
           IF ( lFound := FOUND() )
           .
           .< statements >
           .
           ENDIF

           DBGOTO( nSavRecord )               // Restore the record
                                            // pointer position
           RETURN ( lFound )

!Seealso:"BOF()"  "DBGOBOTTOM()"  "DBGOTOP()"  "DBSEEK()"  "DBSKIP()"  
!Short: DBGOTOP()       Move to the first logical record
 ^bDBGOTOP()^b
 Move to the first logical record
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBGOTOP() --> NIL

 ^bReturns^b

     DBGOTOP() always returns NIL.

 ^bDescription^b

     DBGOTOP() moves to the first logical record in the current work area.

     DBGOTOP() performs the same function as the standard GO TOP command.
     For more information, refer to the GO TOP command.

 ^bNotes^b

     ^b^CFE  Logical records:^b DBGOTOP() operates on logical records.  If
        there is an active index, DBGOTOP() moves to the first record in
        indexed order.  If a filter is set, only records which meet the
        filter condition are considered.

     ^b^CFE  Controlling order:^b If more than one index is active in the
        work area, the operation is performed using the controlling order as
        set by DBSETORDER() or the SET ORDER command.  For more information,
        refer to the SET ORDER command.

     ^b^CFE  Network environment:^b For a shared file on a network, moving to
        a different record may cause updates to the current record to become
        visible to other processes.  For more information, refer to the
        "Network Programming" chapter in the Programming and Utilities Guide.
        This function will not affect the locked status of any record.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates the typical use of DBGOTOP():

        DBGOTOP()
        WHILE ( !EOF() )
           ? FIELD->Name
           DBSKIP()
        END

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"BOF()"  "DBGOBOTTOM()"  "DBSEEK()"  "DBSKIP()"  "EOF()"  C53G999.NGO:"GO"  
!Short: DBINFO()        Return and optionally change database file information
 ^bDBINFO()^b
 Return and optionally change information about a database file opened in a
 work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBINFO(<nInfoType>, [<expNewSetting>])
     ^b   --> uCurrentSetting

 ^bArguments^b

     ^b<nInfoType>^b determines the type of information, as specified by the
     constants below.  Note, however, that not all constants are supported
     for all RDDs.  These constants are defined in the Dbinfo.ch header file,
     which must be included (#include) in your application.

     ^bFile Information Type Constants^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bConstant                 Description^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     DBI_ALIAS                Alias name of the work area as a string.
     DBI_BLOB_DIRECT_LEN      Returns the storage length of a data item in a
                              BLOB file.  <expNewSetting> must specify a
                              valid BLOB pointer obtained from
                              DbFieldInfo(DBS_BLOB_POINTER, <nFieldpos>),
                              BLOBDirectPut() or BLOBDirectImport().
     DBI_BLOB_DIRECT_TYPE     Returns the data type of a data item in a BLOB
                              file. <expNewSetting> must specify a valid BLOB
                              pointer obtained from
                              DbFieldInfo (DBS_BLOB_POINTER, <nFieldpos>),
                              BLOBDirectPut(), or BLOBDirectImport().
     DBI_BLOB_INTEGRITY       Tests a BLOB file for the integrity of its
                              internal tables and returns a logical value
                              indicating the success, true (.T.) or failure,
                              false (.F.) of the integrity check.  If the
                              integrity check fails, you can run
                              dbInfo(DBI_BLOB_RECOVER) which will
                              automatically correct the BLOB file's tables.
                              Checking a BLOB file's integrity is a disk
                              intensive operation and should only be
                              performed when the file's integrity is in
                              question.
     DBI_BLOB_OFFSET          Returns the file offset of a data item in a
                              BLOB file. <expNewSetting> must specify a valid
                              BLOB pointer obtained from
                              DbFieldInfo(DBS_BLOB_POINTER, <nFieldpos>),
                              BLOBDirectPut(), or BLOBDirectImport().
     DBI_BLOB_RECOVER         Recovers a damaged BLOB file by correcting its
                              internal tables. You should run this function
                              only is dbInfo(DBI_BLOB_INTEGRITY) returns
                              false (.F.). Note that this function can only
                              correct the BLOB file's internal tables, it
                              cannot restore any data that may have become
                              corrupted.
     DBI_BOF                  Logical value indicating the work area's
                              beginning of file status (see BOF()).
     DBI_CANPUTREC            Logical value indicating whether the work area
                              supports putting records.
     DBI_CHILDCOUNT           Number of relations set from this work area.
     DBI_DB_VERSION           String containing version information of the
                              host RDD.  If the optional <expNewSetting>
                              parameter is provided, and it is one (1), the
                              result is a more detailed version of the
                              version being returned.
     DBI_DBFILTER             Filter expression as a string (see DBFILTER()).
     DBI_EOF                  Logical value indicating the work area's end of
                              file status (see EOF()).
     DBI_FCOUNT               Number of fields (see FCOUNT()).
     DBI_FILEHANDLE           Integer representing the DOS file handle for
                              this database file.
     DBI_FOUND                Logical value indicating the success or failure
                              of the last seek operation in the work area
                              (see FOUND()).
     DBI_FCOUNT               Number of fields (see FCOUNT()).
     DBI_FULLPATH             Returns the full path name of the opened
                              database file.
     DBI_GETDELIMITER         Default delimiter.
     DBI_GETHEADERSIZE        Header size of the file (see HEADER()).
     DBI_GETLOCKARRAY         Array of locked records.
     DBI_GETRECSIZE           Record size of the file (see RECSIZE()).
     DBI_ISDBF                Logical value indicating whether the RDD
                              provides support for the .dbf file format.
     DBI_ISFLOCK              File lock status.
     DBI_LASTUPDATE           Last date on which the file was updated (see
                              LUPDATE()).
     DBI_LOCKCOUNT            Number of locked records.
     DBI_LOCKOFFSET           Current locking offset as a numeric value.
     DBI_MEMOBLOCKSIZE        Block size for the memo file associated with
                              this database.
     DBI_MEMOEXT              Default extension for the memo file associated
                              with this database.
     DBI_MEMOHANDLE           Integer representing the DOS file handle for
                              the memo file associated with this database
                              file.
     DBI_RDD_VERSION          String containing version information of the
                              RDD for this database.  If the optional
                              <expNewSetting> parameter is provided, and it
                              is one (1), the result is a more detailed
                              version of the version being returned.
     DBI_SETDELIMITER         Default delimiter.
     DBI_SHARED               Shared flag value.
     DBI_TABLEEXT             Database file extension.
     DBI_VALIDBUFFER          Logical value indicating whether the current
                              buffer is valid.
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^bImportant! ^b DBI_USER is a constant that returns the minimum value
     that third-party RDD developers can use for defining new <nInfoType>
     parameters.  Values less than DBI_USER are reserved for Computer
     Associates development.

     ^b<expNewSetting>^b is reserved for RDDs that allow the file information
     to be changed, in addition to being retrieved.  None of the RDDs
     supplied with CA-Clipper support this argument.  It can be omitted or
     specified as NIL.

 ^bReturns^b

     DBINFO() returns the current setting if <expNewSetting> is not
     specified, .  If <expNewSetting> is specified, the previous setting is
     returned.

 ^bDescription^b

     DBINFO() retrieves information about a database file.  By default, this
     function operates on the currently selected work area.  It can be made
     to operate on an unselected work area by specifying it within an aliased
     expression.

 ^bExamples^b

     ^b^CFE^b  The following examples return work area information:

        #include Dbinfo.ch

        ? DBINFO(DBI_GETHEADERSIZE)         // Same as HEADER()
        ? DBINFO(DBI_LASTUPDATE)            // Same as LUPDATE()
        ? DBINFO(DBI_GETRECSIZE)            // Same as RECSIZE()
        ? DBINFO(DBI_FILEHANDLE)            // DOS file handle for
                                            // the current database
                                            // file

 ^bFiles^b   Library is CLIPPER.LIB, header file is Dbinfo.ch.

!Short: DBORDERINFO()   Return and optionally change order and index file information
 ^bDBORDERINFO()^b
 Return and optionally change information about orders and index files
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBORDERINFO(<nInfoType>,   [<cIndexFile>],
     ^b   [<cOrder> | <nPosition>],
     ^b   [<expNewSetting>]) --> uCurrentSetting

 ^bArguments^b

     ^b<nInfoType>^b determines the type of information as specified by the
     constants below.  Note, however, that not all constants are supported
     for all RDDs.  These constants are defined in the Dbinfo.ch header file,
     which must be included (#include) in your application.

     ^bOrder/Index Information Type Constants^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bConstant                      Description^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     DBOI_CONDITION                For condition of the specified order as a
                                   string.
     DBOI_CUSTOM                   Logical flag indicating whether the
                                   specified order is custom-built (for RDDs
                                   that support custom-built orders).  Note
                                   that although you can turn the custom-
                                   built flag on for a standard order by
                                   specifying true (.T.) for the <uNewSetting>
                                   argument, you cannot turn a custom-built
                                   order into a standard order.  Specifying
                                   false (.F.) for <uNewSetting> is the same
                                   as not specifying the argument at all--
                                   both return the current setting.
     DBOI_EXPRESSION               Order key expression of the specified
                                   order as a string.
     DBOI_FILEHANDLE               Handle of the specified index file as a
                                   number.
     DBOI_HPLOCKING                Logical flag indicating whether the
                                   specified index file uses the high
                                   performance index locking schema.
     DBOI_INDEXEXT (DBOI_BAGEXT)   Default index file extension as a string.
     DBOI_INDEXNAME (DBOI_BAGNAME) Name of the specified index file as a
                                   string.
     DBOI_ISCOND                   Logical flag that determines whether the
                                   specified order was defined using a FOR
                                   condition.
     DBOI_ISDESC                   Logical flag that determines if the
                                   specified order is descending.  For
                                   drivers that support dynamically setting
                                   the descending flag at runtime, specify
                                   the new value as a logical, using
                                   DBORDERINFO(DBOI_ISDESC, [<cIndexFile>],
                                   [<cOrder> | <nPosition>], <lNewSetting>).
                                   The current setting is returned before it
                                   is changed.
     DBOI_KEYADD                   Logical flag indicating whether a key has
                                   been successfully added to the specified
                                   custom-built order.
     DBOI_KEYCOUNT                 Number of keys in the specified order.
     DBOI_KEYDEC                   Number of decimals in the key of the
                                   specified order.
     DBOI_KEYDELETE                Logical flag indicating whether a key has
                                   been successfully deleted from the
                                   specified custom-built order.
     DBOI_KEYGOTO                  Logical flag indicating whether the record
                                   pointer has been successfully moved to a
                                   record specified by its logical record
                                   number in the controlling order.
     DBOI_KEYSINCLUDED             Number of keys included in the specified
                                   order so far.  This is primarily useful
                                   for conditional orders.  It can be used
                                   during the status display process (with
                                   the EVAL clause of the INDEX command).
     DBOI_KEYSIZE                  Size of the key in the specified order as
                                   a number.
     DBOI_KEYTYPE                  Data type of the key in the specified
                                   order as a string.
     DBOI_KEYVAL                   Key value of the current record from the
                                   controlling order.
     DBOI_LOCKOFFSET               Locking offset for the specified index
                                   file as a numeric value.
     DBOI_NAME                     Name of the specified order as a string.
     DBOI_NUMBER                   Numeric position of the specified order in
                                   the order list.
     DBOI_ORDERCOUNT               Number of orders in the specified index
                                   file.
     DBOI_POSITION                 Logical record number of the current
                                   record within the specified order.
     DBOI_RECNO                    Physical record number of the current
                                   record within the specified order.
     DBOI_SCOPEBOTTOM              Bottom boundary of the scope (as a number)
                                   for the specified order.
     DBOI_SCOPEBOTTOMCLEAR         Clears the bottom boundary of the scope
                                   for the specified order.
     DBOI_SCOPETOP                 Top boundary of the scope (as a number)
                                   for the specified order.
     DBOI_SCOPETOPCLEAR            Clears the top boundary of the scope for
                                   the specified order.
     DBOI_SETCODEBLOCK             Key for the specified order as a code
                                   block.
     DBOI_SKIPUNIQUE               Logical flag indicating whether the record
                                   pointer has been successfully moved to the
                                   next or previous unique key in the
                                   controlling order.
     DBOI_UNIQUE                   Logical flag indicating whether the
                                   specified order has the unique attribute
                                   set.
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^bImportant! ^b DBOI_USER is a constant that returns the minimum value
     that third-party RDD developers can use for defining new <nInfoType>
     parameters.  Values less than DBOI_USER are reserved for Computer
     Associates development.

     ^b<cIndexFile>^b is the name of an index file, including an optional
     drive and directory (no extension should be specified).  Use this
     argument with <cOrder> to remove ambiguity when there are two or more
     orders with the same name in different index files.

     ^b<cOrder>^b | ^b<nPosition>^b is the name of the order about which you
     want to obtain information or a number representing its position in the
     order list.  For single-order index files, the order name is the
     eight-letter index file name.  Using the order name is the preferred
     method since the position may be difficult to determine using
     multiple-order index files.  Invalid values are ignored.  If no index
     file or order is specified, the controlling order is assumed.

     ^b<expNewSetting>^b is reserved for RDDs that allow the file information
     to be changed, in addition to being retrieved.  None of the RDDs
     supplied with CA-Clipper support this argument.  It can be omitted or
     specified as NIL.

 ^bReturns^b

     If <expNewSetting> is not specified, DBORDERINFO() returns the current
     setting.  If <expNewSetting> is specified, the previous setting is
     returned.

 ^bDescription^b

     DBORDERINFO() retrieves information about the orders and index files.
     By default, DBORDERINFO() operates on the currently selected work area.
     It can be made to operate on an unselected work area by specifying it
     within an aliased expression.

 ^bExamples^b

     ^b^CFE^b  This example uses DBOI_NAME to save the current controlling
        order.  After changing to a new controlling order, it uses the saved
        value to restore the original order:

        #include Dbinfo.ch

        USE Customer INDEX Name, Serial NEW
        cOrder := DBORDERINFO(DBOI_NAME)               // Name
        Customer->DBSETORDER("Serial")
        ? DBORDERINFO(DBOI_NAME)                     // Serial
        Customer->DBSETORDER(cOrder)
        ? DBORDERINFO(DBOI_NAME)                     // Name

     ^b^CFE^b  This example uses aliased expressions to return the default
        index file extension (using DBOI_INDEXEXT) in two different work
        areas:

        #include Dbinfo.ch

        USE Sales INDEX All_Sales VIA "DBFCDX" NEW
        USE Customer INDEX Name, Serial VIA "DBFNTX" NEW
        ? Sales->DBORDERINFO(DBOI_INDEXEXT)                  // .CDX
        ? Customer->DBORDERINFO(DBOI_INDEXEXT)               // .NTX

     ^b^CFE^b  In this example, DBORDERINFO(DBOI_INDEXEXT) checks for the
        existence of the Customer index file independent of the RDD linked
        into the current work area:

        #include Dbinfo.ch

        USE Customer NEW
        IF !FILE( "Customer" + DBORDERINFO(DBOI_INDEXEXT))
                 Customer->DBCREATEINDEX("Customer", "CustName",;
                                               {||Customer->CustName} )
        ENDIF

     ^b^CFE^b  This example accesses the key expression of several orders
        from the same index file:

        #include Dbinfo.ch

        USE Customer INDEX All_Cust VIA "DBFMDX" NEW
        Customer->DBSETORDER("Serial")
        ? DBORDERINFO(DBOI_EXPRESSION,, "Name")
        // Result: key expression for name order
        ? DBORDERINFO(DBOI_EXPRESSION,, "Serial")
        // Result: key expression for serial order

     ^b^CFE^b  This example uses DBORDERINFO() as part of a TOTAL ON key
        expression.  Since DBORDERINFO() returns the expression as a string,
        it is specified using a macro expression to force evaluation of the
        key expression:

        #include Dbinfo.ch

        USE Sales INDEX Salesman NEW
        TOTAL ON &(DBORDERINFO(DBOI_EXPRESSION)) ;
           FIELDS SaleAmount TO Summary

     ^b^CFE^b  In this example, All_Cust.mdx contains three orders named
        CuAcct, CuName, CuZip.  The DBOI_INDEXNAME constant is used to
        display the name of the index file using one of its orders:

        #include Dbinfo.ch

        USE Customer VIA "DBFNTX" NEW
        Customer->DBSETINDEX("All_Cust")
        ? DBORDERINFO(DBOI_INDEXNAME,, "CuName")
        // Returns: All_Cust

     ^b^CFE^b  The following example searches for CuName in the order list:

        #include Dbinfo.ch

        USE Customer VIA "DBFNTX" NEW
        Customer->DBSETINDEX("CuAcct")
        Customer->DBSETINDEX("CuName")
        Customer->DBSETINDEX("CuZip")
        ? DBORDERINFO(DBOI_NUMBER,, "CuName")            // 2

     ^b^CFE^b  This example retrieves the FOR condition from an order:

        #include Dbinfo.ch

        USE Customer NEW
        INDEX ON Customer->Acct TO Customer ;
           FOR Customer->Acct > "AZZZZZ"
        ? DBORDERINFO(DBOI_CONDITION,, "Customer")
        // Returns: Customer->Acct > "AZZZZZ"

 ^bFiles^b   Library is CLIPPER.LIB, header file is Dbinfo.ch.

!Seealso:"DBFIELDINFO()"  "DBINFO()"  "DBRECORDINFO()"  
!Short: DBRECALL()      Reinstate a record marked for deletion
 ^bDBRECALL()^b
 Reinstate a record marked for deletion
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBRECALL() --> NIL

 ^bReturns^b

     DBRECALL() always returns NIL.

 ^bDescription^b

     DBRECALL() causes the current record to be reinstated if it is marked
     for deletion.

     DBRECALL() performs the same function as the RECALL command.  For more
     information, refer to the DELETE and RECALL commands.

 ^bNotes^b

     ^b^CFE  Logical records:^b Reinstating a deleted record affects the
        record's logical visibility if the global _SET_DELETED status is true
        (.T.).  For more information, refer to the DBDELETE() function and
        the DELETE and RECALL commands.

     ^b^CFE  Network environment:^b For a shared database on a network,
        DBRECALL() requires the current record to be locked.  For more
        information, refer to the "Network Programming" chapter in the
        Programming and Utilities Guide.

 ^bExamples^b

     ^b^CFE^b  The following example recalls a record if it is deleted and
        attempts to lock the record if successful:

        cLast := "Winston"
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "LASTNAME" )
        //
        IF ( Sales->(DBSEEK(cLast)) )
           IF Sales->( DELETED() )
              IF Sales( RLOCK() )
                 Sales( DBRECALL() )
                 ? "Record recalled"
              ELSE
                 "Unable to lock record..."
              ENDIF
           ENDIF
        ELSE
           ? "Not found"
        ENDIF

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBDELETE()"  C53G999.NGO:"DELETE"  C53G999.NGO:"RECALL"  
!Short: DBRECORDINFO()  Return and optionally change information about a record
 ^bDBRECORDINFO()^b
 Return and optionally change information about a record
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBRECORDINFO(<nInfoType>,
     ^b   [<nRecord>],
     ^b   [<expNewSetting>]) --> uCurrentSetting

 ^bArguments^b

     ^b<nInfoType>^b determines the type of information, as specified by the
     constants below.  Note, however, that not all constants are supported
     for all RDDs.  These constants are defined in the Dbinfo.ch header file,
     which must be included (#include) in your application.

     ^bRecord Information Type Constants^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bConstant       Description^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     DBRI_DEL       Deleted flag status of the record
     DBRI_LOCK      Locked flag status of the record
     DBRI_SIZE      Length of the record
     DBRI_RECNO     Position of the record
     DBRI_UPDAT     Updated flag status of the record
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     ^bImportant! ^b DBI_USER is a constant that returns the minimum value
     that third-party RDD developers can use for defining new <nInfoType>
     parameters.  Values less than DBI_USER are reserved for Computer
     Associates development.

     ^b<nRecord>^b is the record to obtain information.  If omitted, the
     current record is used.

     ^b<expNewSetting>^b is reserved for RDDs that allow the file information
     to be changed, in addition to being retrieved.  None of the RDDs
     supplied with CA-Clipper support this argument.  It can be omitted or
     specified as NIL.

 ^bReturns^b

     If <expNewSetting> is not specified, DBRECORDINFO() returns the current
     setting.  If <expNewSetting> is specified, the previous setting is
     returned.

 ^bDescription^b

     DBRECORDINFO() retrieves information about the state of a record (row).
     The type of information is specified by the <nInfoType> parameter.  By
     default, this function operates on the currently selected record.

     DBRECORDINFO() is designed to allow for additional <nInfoType> values
     that can be defined by third-party RDD developers.

 ^bExamples^b

     ^b^CFE^b  The following example uses DBRECORDINFO() to retrieve field
        information:

        #include "Dbinfo.ch"

        DBRECORDINFO(DBRI_SIZE)               // Same as RECSIZE()

        DBRECORDINFO(DBRI_LOCK, 200)         // Is record 200 locked?

        DBRECORDINFO(DBRI_DEL, 201)         // Is record 201 locked?

        DBRECORDINFO(DBRI_UPDAT)            // Is the current record
                                            // updated?

        DBRECORDINFO(DBRI_RECNO, 230)         // On which position is

                                            // record 230?
                                            // If no orders are active,
                                            // the position is 230;
                                            // otherwise, the relative
                                            // position within the order
                                            // will be returned.

 ^bFiles^b   Library is CLIPPER.LIB, header file is Dbinfo.ch.

!Seealso:"DBFIELDINFO()"  "DBINFO()"  "DBORDERINFO()"  
!Short: DBREINDEX()     Recreate all active indexes for the current work area
 ^bDBREINDEX()^b
 Recreate all active indexes for the current work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBREINDEX() --> NIL

 ^bReturns^b

     DBREINDEX() always returns NIL.

 ^bDescription^b

     DBREINDEX() rebuilds all active indexes associated with the current work
     area.  After the indexes are recreated, the work area is moved to the
     first logical record in the controlling order.

     DBREINDEX() performs the same function as the standard REINDEX command.
     For more information, refer to the REINDEX command.

 ^bExamples^b

     ^b^CFE^b  The following example reindexes the work area:

        cLast := "Winston"
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "LASTNAME" )
        //
        IF ( Sales->(DBSEEK(cLast)) )
           IF RLOCK()
              DELETE FOR Sales->LastName == "Winston"
              Sales->( DBREINDEX() )
           ELSE
              ? "Unable to lock record..."
           ENDIF
        ELSE
           ? "Not found"
        ENDIF

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBCLEARIND()"  "DBCREATEIND()"  "DBSETINDEX()"  "DBSETORDER()"  
!Short: DBRELATION()    Return the linking expression of a specified relation
 ^bDBRELATION()^b
 Return the linking expression of a specified relation
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBRELATION(<nRelation>) --> cLinkExp

 ^bArguments^b

     ^b<nRelation>^b is the position of the desired relation in the list of
     current work area relations.  The relations are numbered according to
     the order in which they were defined with SET RELATION.

 ^bReturns^b

     DBRELATION() returns a character string containing the linking
     expression of the relation specified by <nRelation>.  If there is no
     RELATION SET for <nRelation>, DBRELATION() returns a null string ("").

 ^bDescription^b

     DBRELATION() is a database function used with DBRSELECT() to determine
     the linking expression and work area of an existing relation created
     with the SET RELATION command.

     DBRELATION() returns the linking expression defined by the TO clause.
     DBRSELECT() returns the work area linked as defined by the INTO clause.

     By default, DBRELATION() operates on the currently selected work area.
     It will operate on an unselected work area if you specify it as part of
     an aliased expression (see example below).

 ^bNotes^b

     ^b^CFE  Declared variables:^b A character string returned by
        DBRELATION() may not operate correctly when recompiled and executed
        using the macro operator (&) if the original expression contained
        references to local or static variables, or otherwise depends on
        compile-time declarations.

 ^bExamples^b

     ^b^CFE^b  This example opens three database files, sets two child
        relations from the parent work area, and then displays the linking
        expression to the second child work area:

        USE Invoices INDEX Invoices NEW
        USE BackOrder INDEX BackOrder NEW
        USE Customer INDEX Customer NEW
        SET RELATION TO CustNum INTO Invoices, OrderNum ;
              INTO BackOrder
        //
        ? DBRELATION(2)                  // Result: OrderNum

     ^b^CFE^b  Later you can query the same linking expression from an
        unselected work area by using an aliased expression like this:

        USE Archive NEW
        ? Customer->(DBRELATION(2))   // Result: OrderNum

     ^b^CFE^b  This example is a user-defined function, Relation(), that
        returns the results of both DBRELATION() and DBRSELECT() as an array:

        FUNCTION Relation( nRelation )
           RETURN { DBRELATION(nRelation), ;
                 ALIAS(DBRSELECT(nRelation)) }

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBFILTER()"  "DBRSELECT()"  C53G999.NGO:"SET RELATION"  
!Short: DBRLOCK()       Lock the record at the current or specified identity
 ^bDBRLOCK()^b
 Lock the record at the current or specified identity
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBRLOCK([<xIdentity>]) --> lSuccess

 ^bArguments^b

     ^b<xIdentity>^b is a unique value guaranteed by the structure of the
     data file to reference a specific item in a data source (database).  In
     a .dbf <xIdentity> is the record number.  In other data formats,
     <xIdentity> is the unique primary key value.

 ^bReturns^b

     DBRLOCK() returns lSuccess, a logical data type that is true (.T.) if
     successful, false (.F.) if unsuccessful.

 ^bDescription^b

     DBRLOCK() is a database function that locks the record identified by the
     value <xIdentity>.  In Xbase, <xIdentity> is the record number.

     If you do not specify <xIdentity>, all record locks are released and the
     current record is locked.  If you specify <xIdentity>, DBRLOCK()
     attempts to lock it and, if successful, adds it to the locked record
     list.

 ^bExamples^b

     ^b^CFE^b  This example shows two different methods for locking multiple
        records:

     FUNCTION dbRLockRange( nLo, nHi )

              LOCAL nRec
              FOR nRec := nLo TO nHi

                 IF ! DBRLOCK( nRec )
                    DBRUNLOCK()      // Failed - unlock everything
                 ENDIF
              NEXT
           RETURN DBRLOCKLIST()      // Return array of actual locks

        FUNCTION dbRLockArray( aList )

              LOCAL nElement, nLen, lRet
              lRet := .T.
              nLen := LEN( aList )
              FOR nElement := 1 TO nLen
                 IF ! DBRLOCK( aList[ nElement ] )
                    DBRUNLOCK()      // Failed - unlock everything
                    lRet := .F.
                 ENDIF
              NEXT
           RETURN DBRLOCKLIST()

!Seealso:"DBUNLOCK()"  "DBUNLOCKALL()"  "FLOCK()"  C53G999.NGO:"RLOCK()"  C53G999.NGO:"UNLOCK"  
!Short: DBRLOCKLIST()   Return an array of the current lock list
 ^bDBRLOCKLIST()^b
 Return an array of the current lock list
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBRLOCKLIST() --> aRecordLocks

 ^bReturns^b

     DBRLOCKLIST() returns an array of the locked records in the current or
     aliased work area.

 ^bDescription^b

     DBRLOCKLIST() is a database function that returns a one-dimensional
     array that contains the identities of record locks active in the
     selected work area.

 ^bExamples^b

    PROCEDURE PrintCurLocks()

    LOCAL aList
    LOCAL nSize
    LOCAL nCount

    aList := DBRLOCKLIST()
    nSize := LEN( aList )

    ? "Currently locked records: "
    FOR nCount := 1 TO nSize
       ?? aList[ nCount ]
       ?? SPACE( 1 )

        NEXT
        ?

        RETURN

!Seealso:"DBRLOCK()"  "DBRUNLOCK()"  C53G999.NGO:"RLOCK()"  C53G999.NGO:"UNLOCK"  
!Short: DBRSELECT()     Return the target work area number of a relation
 ^bDBRSELECT()^b
 Return the target work area number of a relation
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBRSELECT(<nRelation>) --> nWorkArea

 ^bArguments^b

     ^b<nRelation>^b is the position of the desired relation in the list of
     current work area relations.  The relations are numbered according to
     the order in which they were defined with SET RELATION.

 ^bReturns^b

     DBRSELECT() returns the work area number of the relation specified by
     <nRelation> as an integer numeric value.  If there is no RELATION SET
     for <nRelation>, DBRSELECT() returns zero.

 ^bDescription^b

     DBRSELECT() is a database function used in combination with DBRELATION()
     to determine the work area and linking expression of an existing
     relation created with the SET RELATION command.  DBRSELECT() returns the
     work area defined by the INTO clause.  DBRELATION() returns the linking
     expression defined by the TO clause.  To determine the alias of the
     relation instead of the work area number, use the expression
     ALIAS(DBRSELECT(<nRelation>)).

     By default, DBRSELECT() operates on the currently selected work area.
     It will operate on an unselected work area if you specify it as part of
     an aliased expression (see example below).

 ^bExamples^b

     ^b^CFE^b  This example opens three database files, sets two child
        relations from the parent work area, and then displays the linking
        expression to the second child work area, as well as the target work
        area of the relation:

        USE Invoices INDEX Invoices NEW
        USE BackOrder INDEX BackOrder NEW
        USE Customer INDEX Customer NEW
        SET RELATION TO CustNum INTO Customer, ;
              OrderNum INTO BackOrder
        //
        ? DBRELATION(2), DBRSELECT(2)         // Result: OrderNum 3

        ? ALIAS(DBRSELECT(2))               // Result: BACKORDER

     ^b^CFE^b  Later, you can query the same information from an unselected
        work area by using an aliased expression:

        USE Archive NEW
        ? Customer->(DBRELATION(2))      // Result: OrderNum
        ? Customer->(DBRSELECT(2))         // Result: 3

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBFILTER()"  "DBRELATION()"  C53G999.NGO:"RLOCK()"  C53G999.NGO:"UNLOCK"  C53G999.NGO:"SET RELATION"  
!Short: DBRUNLOCK()     Release all or specified record locks
 ^bDBRUNLOCK()^b
 Release all or specified record locks
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBRUNLOCK([<xIdentity>]) --> NIL

 ^bArguments^b

     ^b<xIdentity>^b is a unique value guaranteed by the structure of the
     data file to reference a specific item in a data source (database).  In
     a .dbf <xIdentity> is the record number.  In other data formats,
     <xIdentity> is the unique primary key value.

 ^bReturns^b

     DBRUNLOCK() always returns NIL.

 ^bDescription^b

     DBRUNLOCK() is a database function that releases the lock on <xIdentity>
     and removes it from the Lock List.  If <xIdentity> is not specified, all
     record locks are released.

 ^bExamples^b

     PROCEDURE dbRUnlockRange( nLo, nHi )

        LOCAL nCounter

        // Unlock the records in the range from nLo to nHi
        FOR nCounter := nLo TO nHi
           DBRUNLOCK( nCounter )
        NEXT

        RETURN

!Seealso:C53G999.NGO:"RLOCK()"  "DBRLOCK()"  "DBRLOCKLIST()"  
!Short: DBSEEK()        Move to the record having the specified key value
 ^bDBSEEK() ^b
 Move to the record having the specified key value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSEEK(<expKey>, [<lSoftSeek>], [<lLast>]) --> lFound

 ^bArguments^b

     ^b<expKey>^b is a value of any type that specifies the key value
     associated with the desired record.

     ^b<lSoftSeek>^b is an optional logical value that specifies whether a
     soft seek is to be performed.  This determines how the work area is
     positioned if the specified key value is not found (see below).  If
     <lSoftSeek> is omitted, the current global _SET_SOFTSEEK setting is
     used.

     ^b<lLast>^b is specified as true (.T.) to seek the last occurrence of
     the specified key value.  False (.F.), the default, seeks the first
     occurrence.

     ^bNote:^b  This parameter is only supported for specific RDDs.  DBFNTX
     is NOT one of them.

 ^bReturns^b

     DBSEEK() returns true (.T.) if the specified key value was found;
     otherwise, it returns false (.F.).

 ^bDescription^b

     DBSEEK() moves to the first logical record whose key value is equal to
     <expKey>.  If such a record is found, it becomes the current record and
     DBSEEK() returns true (.T.); otherwise, it returns false (.F.).  the
     positioning of the work area is as follows: for a normal (not soft)
     seek, the work area is positioned to LASTREC() + 1 and EOF() returns
     true (.T.); for a soft seek, the work area is positioned to the first
     record whose key value is greater than the specified key value.  If no
     such record exists, the work area is positioned to LASTREC() + 1 and
     EOF() returns true (.T.).

     For a work area with no active indexes, DBSEEK() has no effect.

     DBSEEK() performs the same function as the standard SEEK command.  For
     more information, refer to the SEEK command.

 ^bNotes^b

     ^b^CFE  Logical records: ^b DBSEEK() operates on logical records which
        are considered in indexed order.  If a filter is set, only records
        which meet the filter condition are considered.

     ^b^CFE  Controlling order: ^b If the work area has more than one active
        index, the operation is performed using the controlling order as set
        by DBSETORDER() or the SET ORDER command.  For more information,
        refer to the SET ORDER command.

     ^b^CFE  Network environment: ^b For a shared file on a network, moving
        to a different record may cause updates to the current record to
        become visible to other processes.  For more information, refer to
        the "Network Programming" chapter in the Programming and Utilities
        Guide.  This function will not affect the locked status of any
        record.

 ^bExamples^b

     ^b^CFE^b  In this example, DBSEEK() moves the pointer to the record in
        the database, Employee, in which the value in FIELD "cName" matches
        the entered value of cName:

        ACCEPT "Employee name: " TO cName
        IF ( Employee->(DBSEEK(cName)) )
           Employee->(VIEWRECORD())
        ELSE
           ? "Not found"
        END

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBGOBOTTOM()"  "DBGOTOP()"  "DBSKIP()"  "EOF()"  C53G999.NGO:"FOUND()"  
!Short: DBSELECTAR()    Change the current work area
 ^bDBSELECTAREA()^b
 Change the current work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSELECTAREA(<nArea> | <cAlias>) --> NIL

 ^bArguments^b

     ^b<nArea>^b is a numeric value between zero and 250, inclusive, that
     specifies the work area being selected.

     ^b<cAlias>^b is a character value that specifies the alias of a
     currently occupied work area being selected.

 ^bReturns^b

     DBSELECTAREA() always returns NIL.

 ^bDescription^b

     DBSELECTAREA() causes the specified work area to become the current work
     area.  All subsequent database operations will apply to this work area
     unless another work area is explicitly specified for an operation.
     DBSELECTAREA() performs the same function as the standard SELECT
     command.  For more information, refer to the SELECT command.

 ^bNotes^b

     ^b^CFE  Selecting zero:^b Selecting work area zero causes the lowest
        numbered unoccupied work area to become the current work area.

     ^b^CFE  Aliased expressions:^b The alias operator (->) can temporarily
        select a work area while an expression is evaluated and automatically
        restore the previously selected work area afterward.  For more
        information, refer to the alias operator (->).

 ^bExamples^b

     ^b^CFE^b  The following example selects a work area via the alias name:

        cLast := "Winston"
        DBUSEAREA( .T., "DBFNTX", "Sales", "Sales", .T. )
        DBSETINDEX( "SALEFNAM" )
        DBSETINDEX( "SALELNAM" )
        //
        DBUSEAREA( .T., "DBFNTX", "Colls", "Colls", .T. )
        DBSETINDEX( "COLLFNAM" )
        DBSETINDEX( "COLLLNAM" )
        //
        DBSELECTAREA( "Sales" )      // select "Sales" work area
        //
        IF ( Sales->(DBSEEK(cLast)) )
           IF Sales->( DELETED() ) .AND. Sales->( RLOCK() )
              Sales->( DBRECALL() )
              ? "Deleted record has been recalled."
           ENDIF
        ELSE
           ? "Not found"
        ENDIF

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBUSEAREA()"  C53G999.NGO:"RLOCK()"  C53G999.NGO:"UNLOCK"  C53G999.NGO:"SELECT"  C53G999.NGO:"SELECT()"  C53G999.NGO:"RLOCK()"  
!Short: DBSETDRIVER()   Return the database driver and optionally set a new driver
 ^bDBSETDRIVER()^b
 Return the default database driver and optionally set a new driver
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSETDRIVER([<cDriver>]) --> cCurrentDriver

 ^bArguments^b

     ^b<cDriver>^b is an optional character value that specifies the name of
     the database driver that should be used to activate and manage new work
     areas when no driver is explicitly specified.

 ^bReturns^b

     DBSETDRIVER() returns the name of the current default driver.

 ^bDescription^b

     DBSETDRIVER() sets the database driver to be used when activating new
     work areas without specifying a driver.  If the specified driver is not
     available to the application, the call has no effect.  DBSETDRIVER()
     returns the name of the current default driver, if any.

 ^bExamples^b

     ^b^CFE^b  This example makes the "DBFNDX" driver the default driver.  If
        the driver is unavailable, a message is issued:

        DBSETDRIVER("DBFNDX")
        IF ( DBSETDRIVER() <> "DBFNDX" )
           ? "DBFNDX driver not available"
        ENDIF

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBUSEAREA()"  C53G999.NGO:"RLOCK()"  C53G999.NGO:"UNLOCK"  C53G999.NGO:"USE"  
!Short: DBSETFILTER()   Set a filter condition
 ^bDBSETFILTER()^b
 Set a filter condition
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSETFILTER(<bCondition>, [<cCondition>]) --> NIL

 ^bArguments^b

     ^b<bCondition>^b is a code block that expresses the filter condition in
     executable form.

     ^b<cCondition>^b stores the filter condition as a character string for
     later retrieval by the DBFILTER() function.  If you omit this optional
     parameter, the DBFILTER() function will return an empty string for the
     work area.

 ^bReturns^b

     DBSETFILTER() always returns NIL.

 ^bDescription^b

     DBSETFILTER() sets a logical filter condition for the current work area.
     When a filter is set, records which do not meet the filter condition are
     not logically visible.  That is, database operations which act on
     logical records will not consider these records.

     The filter expression supplied to DBSETFILTER() evaluates to true (.T.)
     if the current record meets the filter condition; otherwise, it should
     evaluate to false (.F.).

     The filter expression may be a code block (<bCondition>) or both a code
     block and equivalent text (<cCondition>).  If both versions are
     supplied, they must express the same condition.  If the text version is
     omitted, DBFILTER() will return an empty string for the work area.

     DBSETFILTER() performs the same function as the standard SET FILTER
     command.  For more information, refer to the SET FILTER command.

 ^bNotes^b

     ^b^CFE  Logical records:^b DBSETFILTER() affects the logical visibility
        of records (see above).

     ^b^CFE  Side effects:^b Setting a filter condition is only guaranteed to
        restrict visibility of certain records as described above.  The
        filter expression is not necessarily evaluated at any particular
        time, by any particular means, or on any particular record or series
        of records.  If the filter expression relies on information external
        to the database file or work area, the effect is unpredictable.  If
        the filter expression changes the state of the work area (e.g., by
        moving to a different record or changing the contents of a record),
        the effect is unpredictable.

     ^b^CFE  Evaluation context:^b When the filter expression is evaluated,
        the associated work area is automatically selected as the current
        work area before the evaluation; the previously selected work area is
        automatically restored afterward.

 ^bExamples^b

     ^b^CFE^b  This example limits data access to records in which the Age
        field value is less than 40:

        USE Employee NEW
        DBSETFILTER( {|| Age < 40}, "Age < 40" )
        DBGOTOP()

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBCLEARFIL()"  "DBFILTER()"  C53G999.NGO:"SET DELETED"  C53G999.NGO:"SET FILTER"  
!Short: DBSETINDEX()    Empty orders from an order bag into the order list
 ^bDBSETINDEX()^b
 Empty orders from an order bag into the order list
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSETINDEX(<cOrderBagName>) --> NIL

 ^bArguments^b

     ^b<cOrderBagName>^b is the name of a disk file containing one or more
     orders.  You may specify <cOrderBagName> as the file name with or
     without the path name or extension.  If you do not include the extension
     as part of <cOrderBagName>, CA-Clipper uses the default extension of the
     current RDD.

 ^bReturns^b

     DBSETINDEX() always returns NIL.

 ^bDescription^b

     DBSETINDEX() is a database function that adds the contents of an order
     bag into the order list of the current work area.  Any orders already
     associated with the work area continue to be active.  If the newly
     opened order bag is the only order associated with the work area, it
     becomes the controlling order; otherwise, the controlling order remains
     unchanged.  If the order bag contains more than one order, and there are
     no other orders associated with the work area, the first order in the
     new order bag becomes the controlling order.

     ^bNote:^b DBSETINDEX() does not close all currently open index files.

     DBSETINDEX() is a compatibility command and therefore is not
     recommended.  It is superseded by the ORDLISTADD() function.

 ^bExamples^b

     USE Customer NEW
     DBSETINDEX( "Cust01" )         // Open the index Cust01
                                   // in the current work area
     DBSETINDEX( "Cust02" )         // Open the index Cust02
                                   // leaving Cust01 open

!Seealso:C53G999.NGO:"ORDLISTADD()"  
!Short: DBSETORDER()    Set the controlling order
 ^bDBSETORDER()^b
 Set the controlling order
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSETORDER(<nOrderNum>) --> NIL

 ^bArguments^b

     ^b<nOrderNum>^b is a numeric value that specifies which of the active
     indexes is to be the controlling index.

 ^bReturns^b

     DBSETORDER() always returns NIL.

 ^bDescription^b

     DBSETORDER() controls which of the current work area's active indexes is
     the controlling index.  The controlling index is the index which
     determines the logical order of records in the work area.

     Active indexes are numbered from 1 to the number of active indexes,
     based on the order in which the indexes were opened.  <nOrderNum>
     specifies the number of the desired index.

     DBSETORDER() performs the same function as the standard SET ORDER
     command.  For more information, refer to the SET ORDER command.

 ^bNotes^b

     ^b^CFE  Setting order to zero:^b Setting order to zero causes the work
        area to be accessed in natural (record number) order.  Only the
        logical order of the records is affected; any open indexes continue
        to be active and are properly maintained.

 ^bExamples^b

     ^b^CFE^b  This example sets the second named index, Age, as the
        controlling index:

        USE Employee NEW
        SET INDEX TO Name, Age
        DBSETORDER(2)

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBCLEARIND()"  "DBCREATEIND()"  "DBREINDEX()"  "DBSETINDEX()"  
!Short: DBSETRELAT()    Relate two work areas
 ^bDBSETRELATION()^b
 Relate two work areas
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSETRELATION(<nArea> | <cAlias>, <bExpr>, <cExpr>)
     ^b   --> NIL

 ^bArguments^b

     ^b<nArea>^b is a numeric value that specifies the work area number of
     the child work area.

     ^b<cAlias>^b is a character value that specifies the alias of the child
     work area.

     ^b<bExpr>^b is a code block that expresses the relational expression in
     executable form.

     ^b<cExpr>^b is a character value that expresses the relational
     expression in textual form.

 ^bReturns^b

     DBSETRELATION() always returns NIL.

 ^bDescription^b

     DBSETRELATION() relates the work area specified by <nArea> or <cAlias>
     (the child work area) to the current work area (the parent work area).
     Any existing relations remain active.

     Relating work areas synchronizes the child work area with the parent
     work area.  This is achieved by automatically repositioning the child
     work area whenever the parent work area moves to a new record.  If there
     is an active index in the child work area, moving the parent work area
     causes an automatic SEEK operation in the child work area; the seek key
     is based on the expression specified by <bExpr> and/or <cExpr>.  If the
     child work area has no active index, moving the parent work area causes
     an automatic GOTO in the child work area; the record number for the GOTO
     is based on the expression specified by <bExpr> and/or <cExpr>.

     The relational expression may be a code block (<bExpr>) or both a code
     block and equivalent text (<cExpr>).  If both versions are supplied,
     they must be equivalent.  If the text version is omitted, DBRELATION()
     will return an empty string for the relation.

     DBSETRELATION() performs the same function as the standard SET RELATION
     command with the ADDITIVE clause.  For more information, refer to the
     SET RELATION command.

 ^bNotes^b

     ^b^CFE  Side effects:^b DBSETRELATION() is only guaranteed to
        synchronize the work areas as described above.  The relational
        expression is not necessarily evaluated at any particular time, by
        any particular means, or on any particular record or series of
        records.  If the relational expression relies on information external
        to the parent work area or its associated database file, the effect
        is unpredictable.  If the expression changes the state of either work
        area (e.g., by moving to a different record or changing the contents
        of a record), the effect is unpredictable.

     ^b^CFE  Evaluation context:^b When the relational expression is
        evaluated, the parent work area is automatically selected as the
        current work area before the evaluation; the previously selected work
        area is automatically restored afterward.

     ^b^CFE  Soft seeking:^b Seek operations that occur as part of relational
        positioning are never soft seeks.  If a relational movement is
        unsuccessful, the child work area is positioned to LASTREC() + 1, its
        FOUND() status returns false (.F.), and its EOF() status returns true
        (.T.).

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a typical use of the DBSETRELATION()
        function:

        USE Employee NEW
        USE Department NEW INDEX Dept
        SELECT Employee
        DBSETRELATION("Department", {|| Employee->Dept},;
                        "Employee->Dept")
        LIST Employee->Name, Department->Name

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBCLEARREL()"  "DBRELATION()"  "DBRSELECT()"  C53G999.NGO:"FOUND()"  
!Short: DBSKIP()        Move relative to the current record
 ^bDBSKIP()^b
 Move relative to the current record
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSKIP([<nRecords>]) --> NIL

 ^bArguments^b

     ^b<nRecords>^b is the number of logical records to move, relative to the
     current record.  A positive value means to skip forward, and a negative
     value means to skip backward.  If <nRecords> is omitted, a value of 1 is
     assumed.

 ^bReturns^b

     DBSKIP() always returns NIL.

 ^bDescription^b

     DBSKIP() moves either forward or backward relative to the current
     record.  Attempting to skip forward beyond the last record positions the
     work area to LASTREC() + 1 and EOF() returns true (.T.).  Attempting to
     skip backward beyond the first record positions the work area to the
     first record and BOF() returns true (.T.).

     DBSKIP() performs the same function as the standard SKIP command.  For
     more information, refer to the SKIP command.

 ^bNotes^b

     ^b^CFE  Logical records:^b DBSKIP() operates on logical records.  If
        there is an active index, records are considered in indexed order.
        If a filter is set, only records which meet the filter condition are
        considered.

     ^b^CFE  Controlling order:^b If the work area has more than one active
        index, the skip operation is performed using the controlling order as
        set by DBSETORDER() or the SET ORDER command.  For more information,
        refer to the SET ORDER command.

     ^b^CFE  Network environment:^b For a shared file on a network, moving to
        a different record may cause updates to the current record to become
        visible to other processes.  For more information, refer to the
        "Network Programming" chapter in the Programming and Utilities Guide.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a typical use of the DBSKIP()
        function:

        DBGOTOP()

        DO WHILE ( !EOF() )
           ? FIELD->Name
           DBSKIP()
        ENDDO

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"BOF()"  "DBGOBOTTOM()"  "DBGOTOP()"  "DBSEEK()"  "EOF()"  C53G999.NGO:"SKIP"  
!Short: DBSTRUCT()      Create an array containing the structure of a database file
 ^bDBSTRUCT()^b
 Create an array containing the structure of a database file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBSTRUCT() --> aStruct

 ^bReturns^b

     DBSTRUCT() returns the structure of the current database file in an
     array whose length is equal to the number of fields in the database
     file.  Each element of the array is a subarray containing information
     for one field.  The subarrays have the following format:

     ^bDBSTRUCT() Return Array^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bPosition     Metasymbol     Dbstruct.ch^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     1            cName          DBS_NAME
     2            cType          DBS_TYPE
     3            nLength        DBS_LEN
     4            nDecimals      DBS_DEC
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     If there is no database file in USE in the current work area, DBSTRUCT()
     returns an empty array ({}).

 ^bDescription^b

     DBSTRUCT() is a database function that operates like COPY STRUCTURE
     EXTENDED by creating an array of structure information rather than a
     database file of structure information.  There is another function,
     DBCREATE(), that can create a database file from the structure array.

     By default, DBSTRUCT() operates on the currently selected work area.  It
     will operate on an unselected work area if you specify it as part of an
     aliased expression as shown below.

     Note, a header file, Dbstruct.ch, located in \CLIP53\INCLUDE contains a
     series of manifest constants for each field attribute.

 ^bExamples^b

     ^b^CFE^b  This example opens two database files and then creates an
        array containing the database structure using DBSTRUCT() within an
        aliased expression.  The field names are then listed using AEVAL():

        #include "Dbstruct.ch"
        //
        LOCAL aStruct
        USE Customer NEW
        USE Invoices NEW
        //
        aStruct := Customer->(DBSTRUCT())
        AEVAL( aStruct, {|aField| QOUT(aField[DBS_NAME])} )

 ^bFiles^b   Library is CLIPPER.LIB, header file is Dbstruct.ch.

!Seealso:"AFIELDS()*"  C53G999.NGO:"COPY STRU EXTE"  
!Short: DBUNLOCK()      Release all locks for the current work area
 ^bDBUNLOCK()^b
 Release all locks for the current work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBUNLOCK() --> NIL

 ^bReturns^b

     DBUNLOCK() always returns NIL.

 ^bDescription^b

     DBUNLOCK() releases any record or file locks obtained by the current
     process for the current work area.  DBUNLOCK() is only meaningful on a
     shared database in a network environment.

     DBUNLOCK() performs the same function as the standard UNLOCK command.
     For more information, refer to the UNLOCK command.

 ^bNotes^b

     ^b^CFE  Network environment:^b Releasing locks may cause updates to the
        database to become visible to other processes.  For more information,
        refer to the "Network Programming" chapter in the Programming and
        Utilities Guide.

 ^bExamples^b

     ^b^CFE^b  The following example illustrates a basic use of the
        DBUNLOCK() function:

        cLast := "Winston"
        USE Sales SHARED NEW VIA "DBFNTX"
        DBSETINDEX( "LASTNAME" )
        //
        IF ( Sales->(DBSEEK(cLast)) )
           IF Sales->( RLOCK() )
              Sales->( DBDELETE() )

              ? "Record deleted: ", Sales( DELETED() )
              Sales->( DBUNLOCK() )
           ELSE
              ? "Unable to lock record..."
           ENDIF
        ELSE
           ? "Not found"
        ENDIF

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBUNLOCKALL()"  "FLOCK()"  C53G999.NGO:"RLOCK()"  C53G999.NGO:"UNLOCK"  
!Short: DBUNLOCKALL()   Release all locks for all work areas
 ^bDBUNLOCKALL()^b
 Release all locks for all work areas
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBUNLOCKALL() --> NIL

 ^bReturns^b

     DBUNLOCKALL() always returns NIL.

 ^bDescription^b

     DBUNLOCKALL() releases any record or file locks obtained by the current
     process for any work area.  DBUNLOCKALL() is only meaningful on a shared
     database in a network environment.  It is equivalent to calling
     DBUNLOCK() on every occupied work area.

     DBUNLOCKALL() performs the same function as the UNLOCK ALL command.  For
     more information, refer to the UNLOCK ALL command.

 ^bExamples^b

     ^b^CFE^b  The following example marks a record for deletion if an
        RLOCK() attempt is successful, then clears all locks in all work
        areas:

        cLast := "Winston"
        USE Sales SHARED NEW VIA "DBFNTX"
        DBSETINDEX( "SALEFNAM" )
        DBSETINDEX( "SALELNAM" )
        //
        USE Colls SHARED NEW VIA "DBFNTX"
        DBSETINDEX( "COLLFNAM" )
        DBSETINDEX( "COLLLNAM" )
        //
        DBSELECTAREA( "Sales" )      // select "Sales" work area
        //
        IF ( Colls->(DBSEEK(cLast)) )
           IF Colls->( DELETED() )
              ? "Record deleted: ", Colls->( DELETED() )

              IF Colls->( RLOCK() )
                 Colls->( DBRECALL() )
                 ? "Record recalled..."
              ENDIF
           ENDIF
        ELSE
           ? "Not found"
           DBUNLOCKALL()            // remove all locks in
        ENDIF                        // all work areas

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBUNLOCK()"  "FLOCK()"  C53G999.NGO:"RLOCK()"  C53G999.NGO:"UNLOCK"  
!Short: DBUSEAREA()     Use a database file in a work area
 ^bDBUSEAREA()^b
 Use a database file in a work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDBUSEAREA( [<lNewArea>], [<cDriver>], <cName>, [<xcAlias>],
     ^b  [<lShared>], [<lReadonly>]) --> NIL

 ^bArguments^b

     ^b<lNewArea>^b is an optional logical value.  A value of true (.T.)
     selects the lowest numbered unoccupied work area as the current work
     area before the use operation.  If <lNewArea> is false (.F.) or omitted,
     the current work area is used; if the work area is occupied, it is
     closed first.

     ^b<cDriver>^b is an optional character value.  If present, it specifies
     the name of the database driver which will service the work area.  If
     <cDriver> is omitted, the current default driver is used (see note
     below).

     ^b<cName>^b specifies the name of the database (.dbf) file to be opened.

     ^b<xcAlias>^b is an optional character value.  If present, it specifies
     the alias to be associated with the work area.  The alias must
     constitute a valid CA-Clipper identifier.  A valid <xcAlias> may be any
     legal identifier (i.e., it must begin with an alphabetic character and
     may contain numeric or alphabetic characters and the underscore).
     Within a single application, CA-Clipper will not accept duplicate
     aliases.  If <xcAlias> is omitted, a default alias is constructed from
     <cName>.

     ^b<lShared>^b is an optional logical value.  If present, it specifies
     whether the database (.dbf) file should be accessible to other processes
     on a network.  A value of true (.T.) specifies that other processes
     should be allowed access; a value of false (.F.) specifies that the
     current process is to have exclusive access.  If <lShared> is omitted,
     the current global _SET_EXCLUSIVE setting determines whether shared
     access is allowed.

     ^b<lReadonly>^b is an optional logical value that specifies whether
     updates to the work area are prohibited.  A value of true (.T.)
     prohibits updates; a value of false (.F.) permits updates.  A value of
     true (.T.) also permits read-only access to the specified database
     (.dbf) file.  If <lReadonly> is omitted, the default value is false
     (.F.).

 ^bReturns^b

     DBUSEAREA() always returns NIL.

 ^bDescription^b

     DBUSEAREA() associates the specified database (.dbf) file with the
     current work area.  It performs the same function as the standard USE
     command.  For more information, refer to the USE command.

 ^bNotes^b

     ^b^CFE  Current driver:^b If no driver is specified in the call to
        DBUSEAREA() the default driver is used.  If more than one driver is
        available to the application, the default driver is the driver
        specified in the most recent call to DBSETDRIVER().  If DBSETDRIVER()
        has not been called, the DBFNTX driver is used. If the default driver
        is undetermined, DBFNTX will be used.

 ^bExamples^b

     ^b^CFE^b  This example is a typical use of the DBUSEAREA() function:

        DBUSEAREA(.T., "DBFNDX", "Employees")

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DBCLOSEAREA()"  "DBSETDRIVER()"  C53G999.NGO:"SELECT()"  C53G999.NGO:"SET()"  C53G999.NGO:"USE"  
!Short: DELETED()       Return the deleted status of the current record
 ^bDELETED()^b
 Return the deleted status of the current record
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDELETED() --> lDeleted

 ^bReturns^b

     DELETED() returns true (.T.) if the current record is marked for
     deletion; otherwise, it returns false (.F.).  If there is no database
     file in USE in the current work area, DELETED() returns false (.F.).

 ^bDescription^b

     DELETED() is a database function that determines if the current record
     in the active work area is marked for deletion.  Since each work area
     with an open database file can have a current record, each work area has
     its own DELETED() value.

     By default, DELETED() operates on the currently selected work area.  It
     will operate on an unselected work area if you specify it as part of an
     aliased expression (see example below).

     In applications, DELETED() is generally used to query the deleted status
     as a part of record processing conditions, or to display the deleted
     status as a part of screens and reports.

 ^bExamples^b

     ^b^CFE^b  This example uses DELETED() in the current and in an
        unselected work area:

        USE Customer NEW
        USE Sales NEW
        ? DELETED()                     // Result: .F.
        DELETE
        ? DELETED()                     // Result: .T.
        ? Customer->(DELETED())         // Result: .F.

     ^b^CFE^b  This example uses DELETED() to display a record's deleted
        status in screens and reports:

        @ 1, 65 SAY IF(DELETED(), "Inactive", "Active")

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"DELETE"  C53G999.NGO:"PACK"  C53G999.NGO:"RECALL"  C53G999.NGO:"SET DELETED"  
!Short: DESCEND()       Create a descending index key value
 ^bDESCEND()^b
 Create a descending index key value
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDESCEND(<exp>) --> ValueInverted

 ^bArguments^b

     ^b<exp>^b is any valid expression of character, date, logical, or
     numeric type.  Memo type is treated in the same way as character type.

 ^bReturns^b

     DESCEND() returns an inverted expression of the same data type as the
     <exp>, except for dates which return a numeric value.  A DESCEND() of
     CHR(0) always returns CHR(0).

 ^bDescription^b

     DESCEND() is a conversion function that returns the inverted form of the
     specified expression to be used with INDEX to create descending order
     indexes.  Specify that part of the index expression you want to be
     descending as the DESCEND() argument.  To subsequently perform a lookup
     with SEEK, specify DESCEND() in the search expression.

 ^bNotes^b

     ^b^CFE^b  The preferred way to create a descending index is to use the
        DESCENDing clause of the INDEX command.  Using DESCENDING is the same
        as specifying the DESCEND() function, but without the performance
        penalty during index updates.  If you create a DESCENDING index, you
        will not need to use the DESCEND() function during a SEEK.
        DESCENDING is an attribute of the index (.ntx) file, where it is
        stored and used for REINDEXing purposes.

 ^bExamples^b

     ^b^CFE^b  This example uses DESCEND() in an INDEX expression to create a
        descending order date index:

        USE Sales NEW
        INDEX ON DESCEND(OrdDate) TO SalesDate

        Later, use DESCEND() to SEEK on the descending index:

        SEEK DESCEND(dFindDate)

     ^b^CFE^b  This example illustrates how to create a descending order
        index using more than one data type.  Here, the key is created using
        the concatenation of date and character fields after the appropriate
        type conversion has taken place.  This example uses STR() instead of
        DTOS(), since DESCEND() of a date returns a numeric value:

        USE Sales NEW
        INDEX ON STR(DESCEND(SaleDate)) + Salesman TO LastSale

 ^bFiles^b   Library is EXTEND.LIB.

!Seealso:C53G999.NGO:"FIND*"  C53G999.NGO:"INDEX"  C53G999.NGO:"SEEK"  
!Short: DEVOUT()        Write a value to the current device
 ^bDEVOUT()^b
 Write a value to the current device
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDEVOUT(<exp>, [<cColorString>]) --> NIL

 ^bArguments^b

     ^b<exp>^b is the value to display.

     ^b<cColorString>^b is an optional argument that defines the display
     color of <exp>.  If the current DEVICE setting is SCREEN, the output is
     displayed in the specified color.

     If not specified, <exp> is displayed as the standard color of the
     current system color as defined by SETCOLOR().  <cColorString> is a
     character expression containing the standard color setting.  If you want
     to specify a literal color setting, enclose it in quote marks.

 ^bReturns^b

     DEVOUT() always returns NIL.

 ^bDescription^b

     DEVOUT() is a full-screen display function that writes the value of a
     single expression to the current device at the current cursor or
     printhead position.  Use DEVOUT() with DEVPOS() in Std.ch to implement
     the @...SAY command.

 ^bExamples^b

     ^b^CFE^b  This example shows the relationship between the DEVOUT()
        function and the @...SAY command:

        DEVPOS(10, 10)
        DEVOUT("Hello there", "BG+/B"))
        //
        @ 10, 10 SAY "Hello there" COLOR "BG+/B"

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"COL()"  "DEVPOS()"  C53G999.NGO:"QOUT()"  C53G999.NGO:"ROW()"  C53G999.NGO:"SETPOS()"  
!Short: DEVOUTPICT()    Write a value to the current device using a picture clause
 ^bDEVOUTPICT()^b
 Write a value to the current device using a picture clause
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDEVOUTPICT(<exp>, <cPicture>, [<cColorString>])
     ^b   --> NIL

 ^bArguments^b

     ^b<exp>^b is the value to display.

     ^b<cPicture>^b defines the formatting control for the display of <exp>.
     The picture specified here is the same as one used with @...SAY or
     TRANSFORM and can include both templates and functions.

     ^b<cColorString>^b is an optional argument that defines the display
     color of <exp>.  If the current DEVICE is SCREEN, output displays in the
     specified color.

     If not specified, <exp> displays as the standard color of the current
     system color as defined by SETCOLOR().  <cColorString> is a character
     expression containing the standard color setting.  If you want to
     specify a literal color setting, it must be enclosed in quote marks.

 ^bReturns^b

     DEVOUTPICT() always returns NIL.

 ^bDescription^b

     DEVOUTPICT() is a full-screen display function that writes the value of
     a single expression to the current device at the current cursor or
     printhead position.  DEVOUTPICT() is used in combination with DEVPOS()
     in Std.ch to implement the @...SAY command used with a PICTURE clause.

 ^bExamples^b

     ^b^CFE^b  This example shows the relationship between the DEVOUTPICT()
        function and the @...SAY command:

        DEVPOS(10, 10)
        DEVOUTPICT("Hello there", "@!", "BG+/B"))
        //
        @ 10, 10 SAY "Hello there" PICTURE "@!" COLOR "BG+/B"

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"@...SAY"  "COL()"  "DEVOUT()"  "DEVPOS()"  C53G999.NGO:"QOUT()"  C53G999.NGO:"ROW()"  
!Short: DEVPOS()        Move the cursor or printhead to a new position
 ^bDEVPOS()^b
 Move the cursor or printhead to a new position depending on the current
 device
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDEVPOS(<nRow>, <nCol>) --> NIL

 ^bArguments^b

     ^b<nRow>^b and ^b<nCol>^b are the new row and column positions of the
     cursor or printhead.

 ^bReturns^b

     DEVPOS() always returns NIL.

 ^bDescription^b

     DEVPOS() is an environment function that moves the screen or printhead
     depending on the current DEVICE.  If DEVICE is SET to SCREEN, DEVPOS()
     behaves like SETPOS(), moves the cursor to the specified location, and
     updates ROW() and COL() with the new cursor position.

     If DEVICE is SET to PRINTER, DEVPOS() moves the printhead instead.  It
     does this by sending the number of linefeed and/or formfeed characters
     to the printer, and advancing the printhead to the new position.  If the
     current SET MARGIN value is greater than zero, it is added to <nCol>.
     The printhead is then advanced to the specified <nRow> and <nCol>
     position and PROW() and PCOL() are updated.  If either <nRow> or <nCol>
     are less than the current PROW() and PCOL() values, the printhead is
     moved according to the following special rules:

     ^b^CFE^b  If <nRow> is less than PROW(), an automatic EJECT (CHR(12)) is
        sent to the printer followed by the number of linefeed characters
        (CHR(10)) required to position the printhead on <nRow> of the
        following page.

     ^b^CFE^b  If <nCol> including the current SET MARGIN value is less than
        PCOL(), a carriage return character (CHR(13)) and the number of space
        characters required to position the printhead at <nCol> are sent to
        the printer.

     To circumvent these rules, use SETPRC() to reset PROW() and PCOL() to
     new values before using DEVPOS().  See the SETPRC() discussion for more
     information.

     If the printer is redirected to a file using the SET PRINTER command,
     DEVPOS() updates the file instead of the printer.

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"@...SAY"  "DEVOUT()"  C53G999.NGO:"PCOL()"  C53G999.NGO:"PROW()"  C53G999.NGO:"SET DEVICE"  
!Short: DIRCHANGE()     Change the current DOS directory
 ^bDIRCHANGE()^b
 Change the current DOS directory
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDIRCHANGE(<cDir>) --> nSuccess

 ^bArguments^b

     ^b<cDir>^b is the name of the directory to change to, including the
     drive.

 ^bReturns^b

     DIRCHANGE() returns 0 if successful; -1 if there is an argument error.
     Otherwise, DIRCHANGE() returns the DOS error code.

 ^bDescription^b

     DIRCHANGE() changes the current DOS directory.  This function may also
     be used to determine whether or not a directory exists.

 ^bExamples^b

     ^b^CFE^b  The following example attempts to change to the "c:\dos"
        directory.  If it is unsuccessful, an error message is displayed.

        nResult :=  DIRCHANGE("c:\dos")

        IF nResult != 0
           ? "Cannot change directory. "
           DO CASE
              CASE nResult == 3
                 ?? "Directory does not exist."
              CASE nResult == 5
                 ?? "Access to directory denied."
           END
           BREAK
        ENDIF

       You may also use something like this:

        DIRCHANGE( "..\..\test" )

 ^bFiles^b   Library is EXTEND.LIB.

!Seealso:"CURDIR()"  C53G999.NGO:"DIR*"  "DIRMAKE()"  "DIRREMOVE()"  "DISKCHANGE()"  
!Short: DIRECTORY()     Create an array of directory and file information
 ^bDIRECTORY()^b
 Create an array of directory and file information
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDIRECTORY(<cDirSpec>, [<cAttributes>]) --> aDirectory

 ^bArguments^b

     ^b<cDirSpec>^b identifies the drive, directory and file specification
     for the directory search.  Wildcards are allowed in the file
     specification.  If <cDirSpec> is omitted, the default value is *.*.

     ^b<cAttributes>^b specifies inclusion of files with special attributes
     in the returned information.  <cAttributes> is a string containing one
     or more of the following characters:

     ^bDIRECTORY() Attributes^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bAttribute    Meaning^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     H            Include hidden files
     S            Include system files
     D            Include directories
     V            Search for the DOS volume label and exclude all other files
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     Normal files are always included in the search, unless you specify V.

 ^bReturns^b

     DIRECTORY() returns an array of subarrays, with each subarray containing
     information about each file matching <cDirSpec>.  The subarray has the
     following structure:

     ^bDIRECTORY() Subarray Structure^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bPosition     Metasymbol     Directry.ch^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     1            cName          F_NAME
     2            cSize          F_SIZE
     3            dDate          F_DATE
     4            cTime          F_TIME
     5            cAttributes    F_ATTR
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     If no files are found matching <cDirSpec> or if <cDirSpec> is an illegal
     path or file specification, DIRECTORY() returns an empty ({}) array.

 ^bDescription^b

     DIRECTORY() is an environment function that returns information about
     files in the current or specified directory.  It is similar to ADIR(),
     but returns a single array instead of adding values to a series of
     existing arrays passed by reference.

     Use DIRECTORY() to perform actions on groups of files.  In combination
     with AEVAL(), you can define a block that can be applied to all files
     matching the specified <cDirSpec>.

     The header file, Directry.ch, in the \CLIP53\INCLUDE subdirectory
     contains #defines for the subarray subscripts, so that the references to
     each file subarray are more readable.

 ^bExamples^b

     ^b^CFE^b  This example creates an array of information about files in
        the current directory and then lists the names of the files using
        AEVAL() and QOUT():

        #include "Directry.ch"
        //
        aDirectory := DIRECTORY("*.*", "D")
        AEVAL( aDirectory, {|aFile| QOUT(aFile[F_NAME])} )

 ^bFiles^b   Library is CLIPPER.LIB, header file is Directry.ch.

!Seealso:"AEVAL()"  "CURDIR()"  
!Short: DIRMAKE()       Create a directory
 ^bDIRMAKE()^b
 Create a directory
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDIRMAKE(<cNewDir>) --> nSuccess

 ^bArguments^b

     ^b<cNewDir>^b is the name of the directory to be created, including an
     optional drive.  If you do not specify a drive, the current one is used.

 ^bReturns^b

     DIRMAKE() returns 0 if successful; -1 if there is an argument error.
     Otherwise, DIRMAKE() returns the DOS error code.

 ^bDescription^b

     DIRMAKE() creates a specified directory.  Note that first you must have
     sufficient rights to create a directory.  To create nested
     subdirectories, you must create each subdirectory separately, starting
     from the top-level directory that you want to create (see example
     below.)

 ^bExamples^b

     ^b^CFE^b  This example assumes that C:\TEST exists and uses DIRMAKE()
        twice to create a nested subdirectory under it:

        DIRMAKE("c:\test\one")    // Create top-most one
        nResult := DIRMAKE("c:\test\one\two")
        IF nResult != 0
           ? "Cannot make directory, DOS error ", nResult
           BREAK
        ENDIF

       You may also use something like this:

        DIRMAKE( ".\test" )

 ^bFiles^b   Library is EXTEND.LIB.

!Seealso:"DIRCHANGE()"  "DIRREMOVE()"  
!Short: DIRREMOVE()     Remove a directory
 ^bDIRREMOVE()^b
 Remove a directory
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDIRREMOVE(<cDirName>) --> nSuccess

 ^bArguments^b

     ^b<cDirName>^b is the name of the directory to erase, including an
     optional drive.  If you do not specify a drive, the current one is used.

 ^bReturns^b

     DIRREMOVE() returns 0 if successful; -1 if there is an argument error.
     Otherwise, DIRREMOVE returns the DOS error code.

 ^bDescription^b

     DIRREMOVE() removes a specified directory.  Note that you must first
     have sufficient rights to delete a directory.  A directory must be empty
     in order to be deleted.  Therefore, to delete a directory that contains
     subdirectories, you must first delete the subdirectories (see example
     below).

 ^bExamples^b

     ^b^CFE^b  This example uses DIRREMOVE() to delete a subdirectory named
        C:\TEST\ONE, which only contains an empty subdirectory named
        C:\TEST\ONE\TWO:

        DIRREMOVE("c:\test\one\two")        // First delete lowest dir
        nResult := DIRREMOVE("c:\test\one")  // Then delete higher dir
        IF nResult != 0
           ? "Cannot remove directory, DOS error ", siResult
           BREAK
        ENDIF


 ^bFiles^b   Library is EXTEND.LIB.

!Seealso:"DIRCHANGE()"  "DIRMAKE()"  
!Short: DISKCHANGE()    Change the current DOS disk drive
 ^bDISKCHANGE()^b
 Change the current DOS disk drive
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDISKCHANGE(<cDrive>) --> lSuccess

 ^bArguments^b

     ^b<cDrive>^b specifies the letter of the disk drive to change to.

 ^bReturns^b

     DISKCHANGE() returns true (.T.) if successful; otherwise, it returns
     false (.F.).

 ^bExamples^b

     ^b^CFE^b  This example uses DISKCHANGE() to change to drive "D":

        IF DISKCHANGE("D:")
           ? "Successfully changed"
        ELSE
           ? "Not changed"
        ENDIF


     ^b^CFE^b  This example builds a string that contains all currently
        available drives on your system:

        FUNCTION AllDrives()
           LOCAL wI, cDrives := ""

           FOR wI := 1 TO 26
              IF DISKCHANGE( Chr(wI + 64) )
                 cDrives := cDrives + Chr(wI + 64)
              ENDIF
           NEXT
        RETURN cDrives


 ^bFiles^b   Library is EXTEND.LIB.

!Seealso:"DIRCHANGE()"  "DISKNAME()"  
!Short: DISKNAME()      Return the current DOS drive
 ^bDISKNAME()^b
 Return the current DOS drive
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDISKNAME() --> cDrive

 ^bReturns^b

     DISKNAME() returns the letter of the current DOS drive, without a
     trailing colon.

 ^bExamples^b

     ^b^CFE^b  This example illustrates the relationship between
        DISKNAME()and DISKCHANGE() and shows that DISKNAME() is unaffected by
        the SET DEFAULT TO command:

        ? DISKNAME()      // C
        SET DEFAULT TO A
        ? DISKNAME()      // C
        DISKCHANGE("A")
        ? DISKNAME()      // A
        DISKCHANGE("C")
        ? DISKNAME()      // C

 ^bFiles^b   Library is EXTEND.LIB.

!Seealso:"CURDIR()"  "DISKCHANGE()"  
!Short: DISKSPACE()     Return the space available on a specified disk
 ^bDISKSPACE()^b
 Return the space available on a specified disk
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDISKSPACE([<nDrive>]) --> nBytes

 ^bArguments^b

     ^b<nDrive>^b is the number of the drive to query, where one is drive A,
     two is B, three is C, etc.  The default is the current DOS drive if
     <nDrive> is omitted or specified as zero.

 ^bReturns^b

     DISKSPACE() returns the number of bytes of empty space on the specified
     disk drive as an integer numeric value.

 ^bDescription^b

     DISKSPACE() is an environment function that determines the number of
     available bytes remaining on the specified disk drive.  It is useful
     when COPYing or SORTing to another drive to determine if there is enough
     space available before initiating the operation.  You may also use
     DISKSPACE() with RECSIZE() and RECCOUNT() to create a procedure to back
     up database files.

     DISKSPACE() ignores the SET DEFAULT drive setting.

 ^bExamples^b

     ^b^CFE^b  This example is a user-defined function that demonstrates the
        use of DISKSPACE() to back up a database file to another drive:

        FUNCTION BackUp( cTargetFile, cTargetDrive )
           LOCAL nSpaceNeeded, nTargetDrive
           //
           nSpaceNeeded := INT((RECSIZE() * ;
              LASTREC()) + HEADER() + 1)
           nTargetDrive := ASC(UPPER(cTargetDrive)) - 64
           //
           IF DISKSPACE(nTargetDrive) < nSpaceNeeded
              RETURN .F.
           ENDIF
           COPY TO (cTargetDrive + ":" + cTargetFile)
           //
           RETURN .T.

 ^bFiles^b   Library is EXTEND.LIB.

!Seealso:C53G999.NGO:"LASTREC()"  C53G999.NGO:"LUPDATE()"  C53G999.NGO:"RECSIZE()"  
!Short: DISPBEGIN()     Begin buffering screen output
 ^bDISPBEGIN()^b
 Begin buffering screen output
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDISPBEGIN() --> NIL

 ^bReturns^b

     DISPBEGIN() always returns NIL.

 ^bDescription^b

     DISPBEGIN() is a screen function that informs the CA-Clipper display
     output system that the application is about to perform a series of
     display operations.

     Use DISPBEGIN() with DISPEND() to allow the display output system to
     buffer display updates.  Display output which occurs after DISPBEGIN()
     but before DISPEND() is allowed to accumulate in internal buffers.  When
     DISPEND() executes, any pending updates appear on the physical display.
     This is useful in applications where complex screen displays are slow
     and the appearance of performance is desired.

     DISPBEGIN() and DISPEND() calls are optional.  They are not required for
     normal output.

 ^bNotes^b

     ^b^CFE  Nested calls:^b DISPBEGIN() calls are nested internally.  If
        several DISPBEGIN() calls occur, buffering is allowed until a
        corresponding number of DISPEND() calls occur.

     ^b^CFE  Guaranteed operations:^b Display updates performed between
        DISPBEGIN() and DISPEND() are not guaranteed to be buffered--some
        updates may become visible before DISPEND() is called.  However, all
        updates are guaranteed to be visible after the closing call to
        DISPEND().

     ^b^CFE  Terminal operations:^b Terminal input operations such as INKEY()
        or READ should not be performed between DISPBEGIN() and DISPEND().
        Doing this may cause input or display output to be lost.

     ^b^CFE  Incompatible operations:^b Display output by other than the
        CA-Clipper display functions (e.g., by add-on libraries or by DOS via
        OUTSTD(), etc.) may not be compatible with DISPBEGIN() and DISPEND().
        Output may be lost.

 ^bExamples^b

     ^b^CFE^b  This example buffers screen output, updates the screen, and
        then displays the buffered screen output:

        DISPBEGIN()            // Start screen buffering
        //
        SETPOS(10, 10)
        DISPOUT("A display update")
        SETPOS(11, 10)
        DISPOUT("Another display update")
        //
        DISPEND()               // Display buffered screen data

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DISPEND()"  
!Short: DISPBOX()       Display a box on the screen
 ^bDISPBOX()^b
 Display a box on the screen
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDISPBOX(<nTop>, <nLeft>, <nBottom>, <nRight>,
     ^b   [<cnBoxString>], [<cColorString>]) --> NIL

 ^bArguments^b

     ^b<nTop>^b, ^b<nLeft>^b, ^b<nBottom>^b, and ^b<nRight>^b define the
     coordinates of the box.  DISPBOX() draws a box using row values from
     zero to MAXROW(), and column values from zero to MAXCOL().  If <nBottom>
     and <nRight> are larger than MAXROW() and MAXCOL(), the bottom-right
     corner is drawn off the screen.

     ^b<cnBoxString>^b is a numeric or character expression that defines the
     border characters of the box.  If specified as a numeric expression, a
     value of 1 displays a single-line box and a value of 2 displays a
     double-line box.  All other numeric values display a single-line box.

     If <cnBoxString> is a character expression, it specifies the characters
     to be used in drawing the box.  This is a string of eight border
     characters and a fill character.  If <cnBoxString> is specified as a
     single character, that character is used to draw the whole box.

     If this argument is not specified, a single-line box is drawn.

     ^b<cColorString>^b defines the display color of the box that is drawn.
     If not specified, the box is drawn using the standard color setting of
     the current system color as defined by SETCOLOR().

 ^bReturns^b

     DISPBOX() always returns NIL.

 ^bDescription^b

     DISPBOX() is a screen function that draws a box at the specified display
     coordinates in the specified color.  If you specify <cnBoxString>,
     DISPBOX() draws a box on the screen using configurable border and fill
     characters.  DISPBOX() draws the box using <cnBoxString> starting from
     the upper left-hand corner, proceeding clockwise and filling the screen
     region with the ninth character.  If the ninth character is not
     specified, the screen region within the box is not painted.  Existing
     text and color remain unchanged.

     In cases where cnBoxString respects CA-Clipper conventions, the behavior
     of DISPBOX() is unchanged.  The behavior of this function can easily be
     modified to take advantage of graphic mode.  For example, you can
     replace the standard window frames using single or double lines with new
     graphical frames that have an impressive 3-D look.  Simply replace the
     cBoxString parameter using the following:

     CHR(2) + CHR(nColor+1) // draws a box of thickness 16x8x16x8
     CHR(3) + CHR(nColor+1) // draws a box of thickness 8x8x8x8
     CHR(4) + CHR(nColor+1) // draws a box of thickness

                            // 16x16x16x16
     CHR(5) + CHR(nColor+1) // draws a box of thickness 16x8x8x8

     Note that <nColor> is a numeric color representation.  You must add 1 to
     this value.

     In general, CHR(2) + CHR(nColor+1) can be used instead of CA-Clipper's
     B_SINGLE or B_DOUBLE defines.

     CA-Clipper graphics comes with two #defines LLG_BOX_GRAY_STD and
     LLG_BOX_GRAY_SQUARE to allow gray (nColor=7) boxes of width 16x8 or
     16x16.

     You can completely customize the box by passing chr(1) + ... as the
     first parameter:

     CHR(1)             + ;  // Box entirely defined
     CHR(nBackColor+1)  + ;  // Color used as background fill
     CHR(nLightColor+1) + ;  // Color used to lighten the frame
     CHR(nDarkColor+1)  + ;  // Color used to darken the frame
     CHR(nWidthUp)      + ;  // Thickness of upper edge of box
     CHR(nWidthRight)   + ;  // Thickness of right edge of box
     CHR(nWidthDown)    + ;  // Thickness of lower edge of box
     CHR(nWidthLeft)         // Thickness of left edge of box

     After DISPBOX() executes, the cursor is located in the upper corner of
     the boxed region at <nTop> + 1 and <nLeft> + 1.  ROW() and COL() are
     also updated to reflect the new cursor position.

     Note that Box.ch, located in \CLIP53\INCLUDE, provides constants for
     various border configurations.

 ^bNotes^b

     The number of colors available depends on the current video mode setting
     ( SET VIDEOMODE ).

 ^bExamples^b

     ^b^CFE^b  This code example displays a double-line box using a numeric
        value to specify the box border:

        #define B_SINGLE   1
        #define B_DOUBLE   2
        //
        DISPBOX(1, 1, 10, 10, B_DOUBLE, "BG+/B")

     ^b^CFE^b  This example displays a single-line top and double-line side
        box by specifying border characters with a manifest constant defined
        in Box.ch:

        #include "Box.ch"
        //
        DISPBOX(1, 1, 10, 10, B_SINGLE_DOUBLE, "BG+/B")

     ^b^CFE^b  This example displays a box with a 3-D look.  It can be used
        for graphic mode:

        // Display a box with a 3D look of constant width 16x16x16x16
        DISPBOX( nTop, nLeft, nBottom, nRight, LLG_BOX_GRAY_SQUARE )
        // Write some transparent text in the 3D frame
        GWRITEAT(  nLeft * GMODE()[LLG_MODE_FONT_COL] ,;
        nTop  * GMODE()[LLG_MODE_FONT_ROW] ,;
        "This is some Text...",;
        4,;
        LLG_MODE_SET; )

 ^bFiles^b   Library is LLIBG.LIB, header file is Llibg.ch.

!Seealso:C53G999.NGO:"GFRAME()"  C53G999.NGO:"GMODE()"  C53G999.NGO:"SET VIDEOMODE"  
!Short: DISPCOUNT()     Return the number of pending DISPEND() requests
 ^bDISPCOUNT()^b
 Return the number of pending DISPEND() requests
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDISPCOUNT() --> nDispCount

 ^bReturns^b

     DISPCOUNT() returns the number of DISPEND() calls required to restore
     the original display context.

 ^bDescription^b

     You can use DISPCOUNT() to determine the current display context.
     CA-Clipper uses display contexts to buffer and to supervise screen
     output operations.

     Each call to DISPBEGIN() defines a new display context.  Output to the
     display context is suppressed until a matching DISPEND() statement
     executes.

     Since you may nest DISPBEGIN() calls, use DISPCOUNT() to determine
     whether there are pending screen refresh requests.

 ^bExamples^b

     ^b^CFE^b  This example saves the setting of DISPCOUNT(), then releases
        all pending display contexts before writing to the screen:

        PROCEDURE ForceDisplay(cExp)
           LOCAL nSavCount

        nSavCount := DISPCOUNT()

        //  Discard pending display contexts
        DO WHILE ( DISPCOUNT() > 0)
           DISPEND()

        ENDDO

        DISPOUT(cExp)

        //  "Rewind" the current display context
        DO WHILE (DISPCCOUNT() < nSavCount )
           DISPBEGIN()
        ENDDO

        RETURN

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DISPBEGIN()"  "DISPEND()"  
!Short: DISPEND()       Display buffered screen updates
 ^bDISPEND()^b
 Display buffered screen updates
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDISPEND() --> NIL

 ^bReturns^b

     DISPEND() always returns NIL.

 ^bDescription^b

     DISPEND() is a screen function that informs the CA-Clipper display
     output system that the application has finished performing a series of
     display operations.

     DISPEND() is used with DISPBEGIN() so the display output system can
     buffer display updates.  This can be important for applications in which
     complex screen displays are slow and the appearance of performance is
     desired.

 ^bExamples^b

     ^b^CFE^b  This example buffers screen output, updates the screen, and
        then displays the buffered screen output:

        DISPBEGIN()            // Start screen buffering
        //
        SETPOS(10, 10)
        DISPOUT("A display update")
        SETPOS(11, 10)
        DISPOUT("Another display update")
        //
        DISPEND()               // Display buffered screen data

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DISPBEGIN()"  
!Short: DISPOUT()       Write a value to the display
 ^bDISPOUT()^b
 Write a value to the display
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDISPOUT(<exp>, [<cColorString>]) --> NIL

 ^bArguments^b

     ^b<exp>^b is the value to display.

     ^b<cColorString>^b is an optional argument that defines the display
     color of <exp>.  If unspecified, <exp> is displayed as the standard
     color of the current system color as defined by SETCOLOR().
     <cColorString> is a character expression containing the standard color
     setting.  You can specify a literal color setting, if you enclose it in
     quote marks.

 ^bReturns^b


     DISPOUT() always returns NIL.

 ^bDescription^b

     DISPOUT() is a simple output function that writes the value of a single
     expression to the display at the current cursor position.  This function
     ignores the SET DEVICE setting; output always goes to the screen.  You
     can only use this function within a procedure or function.

 ^bExamples^b

     ^b^CFE^b  This example performs screen output at a specified location in
        different colors.  Note how the cursor position is saved and restored
        using ROW(), COL(), and SETPOS():

        PROCEDURE Showit
           LOCAL nRow, nCol
           ? nCol := COL()            // save original
           ?? nRow := ROW()            // cursor position

           INKEY(2)

           SETPOS(nRow, nCol)
           DISPOUT("This is a test of DISPOUT()")
           ? COL()                     // display current
           ?? ROW()                     // cursor position

           INKEY(2)

           SETPOS(nRow, nCol)
           DISPOUT(space(26))         // clear original position
           SET DEVICE TO PRINTER      // ignores SET DEVICE

           SETPOS(nRow, nCol)         // display at
           DISPOUT("           all through")
                                      // original position

           RETURN

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"COL()"  C53G999.NGO:"OUTSTD()"  C53G999.NGO:"QOUT()"  C53G999.NGO:"ROW()"  C53G999.NGO:"SETCOLOR()"  C53G999.NGO:"SETPOS()"  
!Short: DOSERROR()      Return the last DOS error number
 ^bDOSERROR()^b
 Return the last DOS error number
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDOSERROR([<nNewOsCode>]) --> nOsCode

 ^bArguments^b

     ^b<nNewOsCode>^b, if specified, alters the value returned by DOSERROR().
     The value must be a numeric value that reflects a DOS error number.

 ^bReturns^b

     DOSERROR() returns the DOS error number as an integer numeric value.

 ^bDescription^b

     DOSERROR() is an error function that returns the last DOS error code
     associated with an activation of the runtime error block.  When a
     runtime error occurs, the DOSERROR() function is set to the current DOS
     error if the operation has an associated DOS error.  The function value
     is retained until another runtime error occurs.  If the failed operation
     has no associated DOS error, the DOSERROR() returns zero.  With low-
     level file functions, FERROR() returns the same value as DOSERROR().

     Through use of the optional <nNewOsCode>, you may customize to the
     reporting activation the returned value for any DOS error.

     For a complete list of DOS error numbers and accompanying descriptions,
     refer to the Error Messages and Appendices Guide.

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"ERRORBLOCK()"  "FERROR()"  
!Short: DOW()           Convert a date value to a numeric day of the week
 ^bDOW()^b
 Convert a date value to a numeric day of the week
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDOW(<dDate>) --> nDay

 ^bArguments^b

     ^b<dDate>^b is a date value to convert.

 ^bReturns^b

     DOW() returns the day of the week as a number between zero and seven.
     The first day of the week is one (Sunday) and the last day is seven
     (Saturday).  If <dDate> is empty, DOW() returns zero.

 ^bDescription^b

     DOW() is a date conversion function that converts a date value to a
     number identifying the day of the week.  It is useful when you want date
     calculations on a weekly basis.  DOW() is similar to CDOW(), which
     returns the day of week as a character string instead of a number.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate CDOW() and its relationship to
        DOW():

        ? DATE()                        // Result: 09/01/89
        ? DOW(DATE())                  // Result: 3
        ? CDOW(DATE())                  // Result: Tuesday
        ? DOW(DATE() - 2)               // Result: 1
        ? CDOW(DATE() - 2)            // Result: Sunday

     ^b^CFE^b  This is a user-defined function that uses DOW() to calculate
        the date of last Monday from any other date:

        FUNCTION LastMonday(dDate)
           RETURN (dDate - DOW(dDate) + 2)

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"CDOW()"  "DATE()"  "DAY()"  
!Short: DTOC()          Convert a date value to a character string
 ^bDTOC()^b
 Convert a date value to a character string
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDTOC(<dDate>) --> cDate

 ^bArguments^b

     ^b<dDate>^b is the date value to convert.

 ^bReturns^b

     DTOC() returns a character string representation of a date value.  The
     return value is formatted in the current date format.  The default
     format is mm/dd/yy.  A null date returns a string of spaces equal in
     length to the current date format.

 ^bDescription^b

     DTOC() is a date conversion function used for formatting purposes when
     you want to display the date in the SET DATE format and when a character
     expression is required (in a LABEL FORM, for example).  If you need a
     specialized date format, you can use TRANSFORM() or a custom expression.

     If you are INDEXing a date in combination with a character string, use
     DTOS() instead of DTOC() to convert the date value to a character
     string.

 ^bExamples^b

     ^b^CFE^b  These examples show general uses of DTOC():

        ? DATE()                  // Result: 09/01/90
        ? DTOC(DATE())            // Result: 09/01/90
        ? "Today is " + DTOC(DATE())
                                // Result: Today is 09/01/90

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"CTOD()"  "DATE()"  "DTOS()"  C53G999.NGO:"SET CENTURY"  C53G999.NGO:"SET DATE"  
!Short: DTOS()          Convert a date value to a string formatted as yyyymmdd
 ^bDTOS()^b
 Convert a date value to a character string formatted as yyyymmdd
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bDTOS(<dDate>) --> cDate

 ^bArguments^b

     ^b<dDate>^b is the date value to convert.

 ^bReturns^b

     DTOS() returns a character string eight characters long in the format
     yyyymmdd.  When <dDate> is a null date (CTOD("")), DTOS() returns a
     string of eight spaces.  The return value is not affected by the current
     date format.

 ^bDescription^b

     DTOS() is a date conversion function that is used when creating index
     expressions consisting of a date value and a character expression.
     DTOS() converts a date value to a character string that can be
     concatenated to any other character expression.  The return value is
     structured to preserve date order (year, month, and day).

 ^bExamples^b

     ^b^CFE^b  These examples illustrate DTOS() in conjunction with several
        other functions:

        ? DATE()                        // Result: 09/01/90

        ? DTOS(DATE())                  // Result: 19900901
        ? LEN(DTOS(CTOD("")))           // Result: 8

     ^b^CFE^b  This example demonstrates how to create an index with a
        compound date and character key using DTOS():

        USE Sales NEW
        INDEX ON DTOS(Date) + Salesman TO DateName

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"CTOD()"  "DATE()"  "DTOC()"  C53G999.NGO:"INDEX"  
!Short: EMPTY()         Determine if the result of an expression is empty
 ^bEMPTY()^b
 Determine if the result of an expression is empty
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bEMPTY(<exp>) --> lEmpty

 ^bArguments^b

     ^b<exp>^b is an expression of any data type.

 ^bReturns^b

     EMPTY() returns true (.T.) if the expression results in an empty value;
     otherwise, it returns false (.F.).  The criteria for determining whether
     a value is considered empty depends on the data type of <exp> according
     to the following rules:

     ^bList of Empty Values^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bData Type    Contents^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     Array        Zero-length
     Character    Spaces, tabs, CR/LF, or ("")
     Numeric      0
     Date         Null (CTOD(""))
     Logical      False (.F.)
     Memo         Same as character
     NIL          NIL
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bDescription^b

     The EMPTY() function has a number of uses.  You can use it to determine
     if a user entered a value into a Get object before committing changes to
     a database file.  It can also determine whether a formal parameter is
     NIL or unsupplied.  In addition, it can test an array for zero-length.

 ^bNotes^b

     ^b^CFE  Space characters:^b The EMPTY() function treats carriage
        returns, line feeds, and tabs as space characters and removes these
        as well.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate use of EMPTY() against several
        different data types:

        ? EMPTY(SPACE(5)), EMPTY("")        // Result: .T. .T.
        ? EMPTY(0), EMPTY(CTOD(""))         // Result: .T. .T.
        ? EMPTY(.F.), EMPTY(NIL)            // Result: .T. .T.

     ^b^CFE^b  This example uses EMPTY() to determine whether the user
        entered a value into the first Get object before writing the new
        value to the database file:

        LOCAL cCust := SPACE(15), nAmount := 0
        USE Sales NEW
        @ 10, 10 GET cCust
        @ 11, 10 GET nAmount PICTURE "999.99"
        READ
        //
        IF !EMPTY(cCust)
           APPEND BLANK
           REPLACE Sales->Cust WITH cCust, Sales->Amount ;
              WITH nAmount
        ENDIF

     ^b^CFE^b  This example uses EMPTY() as part of the VALID clause to force
        the user to enter data into the current Get object:

        LOCAL cCode := SPACE(5)
        @ 2, 5 SAY "Enter code" GET cCode VALID !EMPTY(cCode)
        READ

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"LEN()"  
!Short: EOF()           Determine when end of file is encountered
 ^bEOF()^b
 Determine when end of file is encountered
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bEOF() --> lBoundary

 ^bReturns^b

     EOF() returns true (.T.) when an attempt is made to move the record
     pointer beyond the last logical record in a database file; otherwise, it
     returns false (.F.).  If there is no database file open in the current
     work area, EOF() returns false (.F.).  If the current database file
     contains no records, EOF() returns true (.T.).

 ^bDescription^b

     EOF() is a database function used to test for an end of file boundary
     condition when the record pointer is moving forward through a database
     file.  Any command that can move the record pointer can set EOF().

     The most typical application is as a part of the <lCondition> argument
     of a DO WHILE construct that sequentially processes records in a
     database file.  Here <lCondition> would include a test for .NOT. EOF(),
     forcing the DO WHILE loop to terminate when EOF() returns true (.T.).

     EOF() and FOUND() are often used interchangeably to test whether a SEEK,
     FIND, or LOCATE command failed.  With these commands, however, FOUND()
     is preferred.

     When EOF() returns true (.T.), the record pointer is positioned at
     LASTREC() + 1 regardless of whether there is an active SET FILTER or SET
     DELETED is ON.  Further attempts to move the record pointer forward
     return the same result without error.  Once EOF() is set to true (.T.),
     it retains its value until there is another attempt to move the record
     pointer.

     By default, EOF() operates on the currently selected work area.  It can
     be made to operate on an unselected work area by specifying it within an
     aliased expression (see example below).

 ^bExamples^b

     ^b^CFE^b  This example demonstrates EOF() by deliberately moving the
        record pointer beyond the last record:

        USE Sales
        GO BOTTOM
        ? EOF()            // Result: .F.
        SKIP
        ? EOF()            // Result: .T.

     ^b^CFE^b  This example uses aliased expressions to query the value of
        EOF() in unselected work areas:

        USE Sales NEW
        USE Customer NEW
        ? Sales->(EOF())
        ? Customer->(EOF())

     ^b^CFE^b  This example illustrates how EOF() can be used as part of a
        condition for sequential database file operations:

        USE Sales INDEX CustNum NEW
        DO WHILE !EOF()
           nOldCust := Sales->CustNum
           nTotalAmount := 0
           DO WHILE nOldCust = Sales->CustNum .AND. (!EOF())
              ? Sales->CustNum, Sales->Description, ;
                    Sales->SaleAmount
              nTotalAmount += Sales->SaleAmount
              SKIP
           ENDDO
           ? "Total amount: ", nTotalAmount
        ENDDO

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"BOF()"  C53G999.NGO:"DO WHILE"  C53G999.NGO:"FOUND()"  C53G999.NGO:"GO"  C53G999.NGO:"LASTREC()"  C53G999.NGO:"LOCATE"  
!Short: ERRORBLOCK()    Post a code block to execute when a runtime error occurs
 ^bERRORBLOCK()^b
 Post a code block to execute when a runtime error occurs
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bERRORBLOCK([<bErrorHandler>]) --> bCurrentErrorHandler

 ^bArguments^b

     ^b<bErrorHandler>^b is the code block to execute whenever a runtime
     error occurs.  When evaluated, the <bErrorHandler> is passed an error
     object as an argument by the system.

 ^bReturns^b

     ERRORBLOCK() returns the current error handling code block.  If no error
     handling block has been posted since the program was invoked,
     ERRORBLOCK() returns the default error handling block.

 ^bDescription^b

     ERRORBLOCK() is an error function that defines an error handler to
     execute whenever a runtime error occurs.  Specify the error handler as a
     code block with the following form,

     { |<oError>| <expression list>,... }

     where <oError> is an error object containing information about the
     error.  Within the code block, messages can be sent to the error object
     to obtain information about the error.  Returning true (.T.) from the
     error handling block retries the failed operation and false (.F.)
     resumes processing.

     The error handling code block can be specified either as a list of
     expressions or as a call to a user-defined function.  A call to a user-
     defined function is more useful since you can use CA-Clipper control
     statements instead of expressions.  This is particularly the case if
     there is a BEGIN SEQUENCE pending and you want to BREAK to the nearest
     RECOVER statement.

     As this implies, error handling blocks can be used in combination with
     BEGIN SEQUENCE...END control structures.  Within an error handling
     block, you handle device, low-level, and common errors that have a
     general recovery mechanism.  If the operation needs specific error
     handling, define a BEGIN SEQUENCE then BREAK to the RECOVER statement,
     returning the error object for local processing.  See the example below.

     If no <bErrorHandler> has been specified using ERRORBLOCK() and a
     runtime error occurs, the default error handling block is evaluated.
     This error handler displays a descriptive message to the screen, sets
     the ERRORLEVEL() to 1, then QUITs the program.

     Since ERRORBLOCK() returns the current error handling block, it is
     possible to specify an error handling block for an operation saving the
     current error handling block, then restore it after the operation has
     completed.  Also, error handlers specified as code blocks, can be passed
     to procedures and user-defined functions, and RETURNed as values.

     For more information on the structure and operations of error objects,
     refer to the Error class entry in this chapter and the "Error Handling
     Strategies" chapter in the Programming and Utilities Guide.

 ^bExamples^b

     ^b^CFE^b  This code fragment posts, and then calls an error handling
        block when there is an error within a BEGIN SEQUENCE construct:

        LOCAL bErrorHandler, bLastHandler, objErr
        bErrorHandler := { |oError| ;
              MyErrorHandler(oError) }
        //
        // Save current handler
        bLastHandler := ERRORBLOCK(bErrorHandler)
        //
        BEGIN SEQUENCE
           .
           . <operation statements>
           .
        // Receive error object from BREAK
        RECOVER USING oErrorInfo
           .
           . <recovery statements>
           .
        END
        ERRORBLOCK(bLastHandler)      // Restore handler
        RETURN

        FUNCTION MyErrorHandler( oError )
           //
           BREAK oError      // Return error object to RECOVER
           RETURN NIL

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"BEGIN SEQUENCE"  
!Short: ERRORLEVEL()    Set the CA-Clipper return code
 ^bERRORLEVEL()^b
 Set the CA-Clipper return code
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bERRORLEVEL([<nNewReturnCode>]) --> nCurrentReturnCode

 ^bArguments^b

     ^b<nNewReturnCode>^b is the new return code setting.  This can be a
     value between zero and 255.  The default value at startup is zero.  If
     not specified, ERRORLEVEL() reports the current setting without
     assigning a new value.

 ^bReturns^b

     ERRORLEVEL() returns the current CA-Clipper exit code as a numeric
     value, if one has been set using ERRORLEVEL() with an argument;
     otherwise, it returns zero.

 ^bDescription^b

     ERRORLEVEL() is a dual purpose environment function.  It returns the
     current CA-Clipper return code and optionally sets a new return code.
     The return code is a value set by a child process so the parent process
     can test the termination state of the child process.  Typically, the
     parent process is DOS and the child process is an application program.
     Retrieve a return code with the DOS ERRORLEVEL command or INT 21
     Function 4Dh.

     When a CA-Clipper program terminates, the return code is set to 1 if the
     process ends with a fatal error.  If the process ends normally, the
     return code is set to zero, or the last ERRORLEVEL() set in the program.

     Typically, you would set a return code with ERRORLEVEL() to indicate an
     error state to the program that invoked the current CA-Clipper program.
     In most cases this is the application batch file.  Here you would test
     the return code using the DOS ERRORLEVEL command.  Refer to your DOS
     manual for more information.

 ^bNotes^b

     ^b^CFE^b  ERRORLEVEL() is not updated after a RUN command terminates.
        To obtain the return code of the invoked program, you must create an
        assembler or C routine that queries the child process return code
        using INT 21 Function 4Dh.  Refer to your DOS documentation for more
        information.

 ^bExamples^b

     ^b^CFE^b  This example saves the current CA-Clipper return code, then
        sets a new value:

        nOldCode := ERRORLEVEL()      // Get current error level
        ERRORLEVEL(1)                 // Set new error level

     ^b^CFE^b  This example uses ERRORLEVEL() to set a return code that can
        be tested by the parent process:

        #define ERR_FILE_MISSING      255
        #define ERR_POST_INCOMPLETE   254
        //
        IF !FILE("Sysfile.dbf")
           @ 0, 0
           @ 1, 0
           @ 0, 0 SAY "Fatal error: System ;
                       file is missing...quitting"
           ERRORLEVEL(ERR_FILE_MISSING)
           QUIT
        ENDIF

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"QUIT"  
!Short: EVAL()          Evaluate a code block
 ^bEVAL()^b
 Evaluate a code block
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bEVAL(<bBlock>, [<BlockArg list>]) --> LastBlockValue

 ^bArguments^b

     ^b<bBlock>^b is the code block to be evaluated.

     ^b<BlockArg list>^b is a list of arguments to send to the code block
     before it is evaluated.

 ^bReturns^b

     EVAL() returns the value of the last expression within the block.  A
     code block can return a value of any type.

 ^bDescription^b

     EVAL() is a code block function.  It is the most basic code block
     evaluation facility in the CA-Clipper system.  A code block is a special
     data value that refers to a piece of compiled program code.  For more
     information on code blocks, refer to the "Basic Concepts" chapter in the
     Programming and Utilities Guide.

     To execute or evaluate a code block, call EVAL() with the block value
     and any parameters.  The parameters are supplied to the block when it is
     executed.  Code blocks may be a series of expressions separated by
     commas.  When a code block is evaluated, the returned value is the value
     of the last expression in the block.

     The CA-Clipper compiler usually compiles a code block at compile time.
     There are, however, occasions at runtime when you may need to compile a
     code block from a character string.  You can do this by using the macro
     operator (&).

     EVAL() is often used to create iteration functions.  These are functions
     that apply a block to each member of a data structure.  AEVAL(),
     ASORT(), ASCAN(), and DBEVAL() are iteration functions (e.g., AEVAL()
     applies a block to each element within an array).

 ^bExamples^b

     ^b^CFE^b  This example creates a code block that increments a number,
        and then evaluates it:

        bBlock := { |nArg| nArg + 1 }
        ? EVAL(bBlock, 1)                     // Result: 2

     ^b^CFE^b  This example demonstrates compiling a code block at runtime
        using the macro operator (&):

        // Compile a string to a block
        bBlock := &("{ |nArg| nArg + 1 }")

        // Evaluate the block
        ? EVAL(bBlock, 1)                     // Result: 2

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"AEVAL()"  "ASCAN()"  "ASORT()"  "DBEVAL()"  
!Short: EXP()           Calculate e**x
 ^bEXP()^b
 Calculate e**x
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bEXP(<nExponent>) --> nAntilogarithm

 ^bArguments^b

     ^b<nExponent>^b is the natural logarithm for which a numeric value is to
     be calculated.

 ^bReturns^b

     EXP() returns a numeric value that is equivalent to the value e raised
     to the specified power.

 ^bDescription^b

     EXP() is a mathematical function that calculates the value, y, (the
     antilogarithm) of the following equation,

     ^be**x = y

     where e is the base of natural logarithms (2.71828...) and x is
     <nExponent>.  The maximum value of <nExponent> is 45 before a numeric
     overflow occurs.  EXP() and LOG() are inverse functions.

     The number of decimal places displayed is determined solely by SET
     DECIMALS regardless of the current SET FIXED value.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates several invocations of EXP():

        ? EXP(1)                       // Result: 2.72
        SET DECIMALS TO 10
        ? EXP(1)                       // Result: 2.7182818285
        ? LOG(EXP(1))                  // Result: 1.0000000000

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"LOG()"  C53G999.NGO:"SET DECIMALS"  C53G999.NGO:"SET FIXED"  
!Short: FCLOSE()        Close an open binary file and write DOS buffers to disk
 ^bFCLOSE()^b
 Close an open binary file and write DOS buffers to disk
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFCLOSE(<nHandle>) --> lError

 ^bArguments^b

     ^b<nHandle>^b is the file handle obtained previously from FOPEN() or
     FCREATE().

 ^bReturns^b

     FCLOSE() returns false (.F.) if an error occurs while writing;
     otherwise, it returns true (.T.).

 ^bDescription^b

     FCLOSE() is a low-level file function that closes binary files and
     forces the associated DOS buffers to be written to disk.  If the
     operation fails, FCLOSE() returns false (.F.).  FERROR() can then be
     used to determine the reason for the failure.  For example, attempting
     to use FCLOSE() with an invalid handle returns false (.F.), and FERROR()
     returns DOS error 6, invalid handle.  See FERROR() for a complete list
     of error numbers.

     ^bWarning!^b  This function allows low-level access to DOS files and
     devices.  It should be used with extreme care and requires a thorough
     knowledge of the operating system.

 ^bExamples^b

     ^b^CFE^b  This example uses FCLOSE() to close a newly created binary
        file and displays an error message if the close fails:

        #include "Fileio.ch"
        //
        nHandle := FCREATE("Testfile", FC_NORMAL)
        IF !FCLOSE(nHandle)
           ? "Error closing file, error number: ", FERROR()
        ENDIF

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"FCREATE()"  "FERROR()"  "FOPEN()"  
!Short: FCOUNT()        Return the number of fields in the current .dbf file
 ^bFCOUNT()^b
 Return the number of fields in the current .dbf file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFCOUNT() --> nFields

 ^bReturns^b

     FCOUNT() returns the number of fields in the database file in the
     current work area as an integer numeric value.  If there is no database
     file open, FCOUNT() returns zero.

 ^bDescription^b

     FCOUNT() is a database function.  It is useful in applications
     containing data-independent programs that can operate on any database
     file.  These include generalized import/export and reporting programs.
     Typically, you use FCOUNT() to establish the upper limit of a FOR...NEXT
     or DO WHILE loop that processes a single field at a time.

     By default, FCOUNT() operates on the currently selected work area.

 ^bExamples^b

     ^b^CFE^b  This example illustrates FCOUNT(), returning the number of
        fields in the current and an unselected work area:

        USE Sales NEW
        USE Customer NEW
        ? FCOUNT()                     // Result: 5
        ? Sales->(FCOUNT())            // Result: 8

     ^b^CFE^b  This example uses FCOUNT() to DECLARE an array with field
        information:

        LOCAL aFields := ARRAY(FCOUNT())
        AFIELDS(aFields)

     ^b^CFE^b  This example uses FCOUNT() as the upper boundary of a FOR loop
        that processes the list of current work area fields:

        LOCAL nField
        USE Sales NEW
        FOR nField := 1 TO FCOUNT()
           ? FIELD(nField)
        NEXT

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"AFIELDS()*"  "FIELDNAME()"  C53G999.NGO:"TYPE()"  
!Short: FCREATE()       Create and/or truncate a binary file to zero-length
 ^bFCREATE()^b
 Create and/or truncate a binary file to zero-length
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFCREATE(<cFile>, [<nAttribute>]) --> nHandle

 ^bArguments^b

     ^b<cFile>^b is the name of the file to create.  If the file already
     exists, its length is truncated to zero without warning.

     ^b<nAttribute>^b is one of the binary file attributes shown in the table
     below.  If this argument is omitted, the default value is zero.

     ^bBinary File Attributes^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bValue   Fileio.ch      Attribute Description^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     0       FC_NORMAL      Normal    Create normal read/write file (default)
     1       FC_READONLY    Read-only Create read-only file
     2       FC_HIDDEN      Hidden    Create hidden file
     4       FC_SYSTEM      System    Create system file
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bReturns^b

     FCREATE() returns the DOS file handle number of the new binary file in
     the range of zero to 65,535.   If an error occurs, FCREATE() returns
     -1 and FERROR() is set to indicate an error code.

 ^bDescription^b

     FCREATE() is a low-level file function that either creates a new file or
     opens and truncates an existing file.  If <cFile> does not exist, it is
     created and opened for writing.  If it does exist and can be opened for
     writing, it is truncated to zero-length.  If it cannot be opened for
     writing, FCREATE() returns -1 and FERROR() returns the appropriate error
     value.

     When FCREATE() successfully creates a new file, the file is left open in
     compatibility sharing mode and read/write access mode.  The file
     attribute specified by the <nAttribute> argument is applied to the new
     file when it is closed, allowing writing to a newly created read-only
     file.  For a list of access modes, see FOPEN().

     Since a file handle is required in order to identify an open file to
     other file functions, always assign the return value from FCREATE() to a
     variable for later use.

     Like other file functions, FCREATE() does not use either the DEFAULT or
     PATH settings for its operation.  Instead, it writes to the current DOS
     directory unless a path is explicitly stated.

     ^bWarning! ^b This function allows low-level access to DOS files and
     devices.  It should be used with extreme care and requires a thorough
     knowledge of the operating system.

 ^bExamples^b

     ^b^CFE^b  This example creates a file called Testfile and opens it for
        reading and writing:

        #include "Fileio.ch"

        //
        IF (nHandle := FCREATE("Testfile", FC_NORMAL)) == -1
           ? "File cannot be created:", FERROR()
           BREAK
        ELSE
           FWRITE(nHandle, "Hello there")
           FCLOSE(nHandle)
        ENDIF

 ^bFiles^b   Library is CLIPPER.LIB, header file is Fileio.ch.

!Seealso:"FCLOSE()"  "FERROR()"  "FOPEN()"  
!Short: FERASE()        Delete a file from disk
 ^bFERASE()^b
 Delete a file from disk
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFERASE(<cFile>) --> nSuccess

 ^bArguments^b

     ^b<cFile>^b is the name of the file to be deleted from disk, including
     extension, optionally preceded by a drive and/or path specification.

 ^bReturns^b

     FERASE() returns -1 if the operation fails and zero if it succeeds.  In
     the case of a failure, FERROR() can be used to determine the nature of
     the error.

 ^bDescription^b

     FERASE() is a file function that deletes a specified file from disk.
     FERASE() is the same as the ERASE command but returns a value and can be
     specified within an expression.  When FERASE() is called, <cFile> is
     deleted from disk only if found in the current DOS directory or in the
     directory explicitly specified as part of the file name.  Like the other
     file functions and commands, FERASE() does not use either SET DEFAULT or
     SET PATH to locate <cFile>.

     ^bWarning! ^b Files must be CLOSEd before removing them with FERASE().

 ^bExamples^b

     ^b^CFE^b  This example deletes a set of files matching a wildcard
        pattern:

        #include "Directry.ch"
        AEVAL(DIRECTORY("*.BAK"), { |aFile| ;
           FERASE(aFile[F_NAME]) })

     ^b^CFE^b  This example erases a file and displays a message if the
        operation fails:

        IF FERASE("AFile.txt") == -1
           ? "File erase error:", FERROR()
           BREAK
        ENDIF

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:C53G999.NGO:"CLOSE"  C53G999.NGO:"ERASE"  "FERROR()"  C53G999.NGO:"FRENAME()"  C53G999.NGO:"RENAME"  
!Short: FERROR()        Test for errors after a binary file operation
 ^bFERROR()^b
 Test for errors after a binary file operation
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFERROR() --> nErrorCode

 ^bReturns^b

     FERROR() returns the DOS error from the last file operation as an
     integer numeric value.  If there is no error, FERROR() returns zero.

     ^bFERROR() Return Values^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     ^bError   Meaning^b
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
     0       Successful
     2       File not found
     3       Path not found
     4       Too many files open
     5       Access denied
     6       Invalid handle
     8       Insufficient memory
     15      Invalid drive specified
     19      Attempted to write to a write-protected disk
     21      Drive not ready
     23      Data CRC error
     29      Write fault
     30      Read fault
     32      Sharing violation
     33      Lock Violation
     컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

 ^bDescription^b

     FERROR() is a low-level file function that indicates a DOS error after a
     file function is used.  These functions include FCLOSE(), FCREATE(),
     FERASE(), FOPEN(), FREAD(), FREADSTR(), and FRENAME().  FERROR() retains
     its value until the next execution of a file function.

     ^bWarning! ^b This function allows low-level access to DOS files and
     devices.  It should be used with extreme care and requires a thorough
     knowledge of the operating system.

 ^bExamples^b

     ^b^CFE^b  This example tests FERROR() after the creation of a binary
        file and displays an error message if the create fails:

        #include "Fileio.ch"
        //
        nHandle := FCREATE("Temp.txt", FC_NORMAL)
        IF FERROR() != 0
           ? "Cannot create file, DOS error ", FERROR()
        ENDIF

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"DOSERROR()"  "FCLOSE()"  "FCREATE()"  "FERASE()"  "FOPEN()"  
!Short: FIELDBLOCK()    Return a set-get code block for a given field
 ^bFIELDBLOCK()^b
 Return a set-get code block for a given field
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFIELDBLOCK(<cFieldName>) --> bFieldBlock

 ^bArguments^b

     ^b<cFieldName>^b is the name of the field to which the set-get block
     will refer.

 ^bReturns^b

     FIELDBLOCK() returns a code block that, when evaluated, sets (assigns)
     or gets (retrieves) the value of the given field.  If <cFieldName> does
     not exist in the specified work area, FIELDBLOCK() returns an empty
     block.

 ^bDescription^b

     FIELDBLOCK() is a database function that builds a code block.  When
     executed with an argument, the code block created by this function
     assigns the value of the argument to <cFieldName>.  When executed
     without an argument, the code block retrieves the value of <cFieldName>.

     Note that the specified field variable may not exist when the code block
     is created, but must exist before the code block is executed.

 ^bNotes^b

     ^b^CFE  Work area:^b The code block returned by FIELDBLOCK() sets or
        gets the value of the specified field in whatever work area is
        current when the block is run.  For example, given work areas 1 and
        2, both containing field FName:

     SELECT 1
        FName:= "Kate"
        SELECT 2

        FName := "Cindy"
        bFName := FIELDBLOCK("FName")
        SELECT 1
        ? EVAL(bFName)               // Result: "Kate"
        SELECT 2
        ? EVAL(bFName)               // Result: "Cindy"

        The function FIELDWBLOCK() provides a set-get block for a field in a
        specific work area.

 ^bExamples^b

     ^b^CFE^b  This example compares FIELDBLOCK() to a code block created
        using the macro operator.  Note that using FIELDBLOCK() avoids the
        speed and size overhead of the macro operator:

        // Set-Get block defined using macro operator
        bSetGet := &( "{ |setVal| IF( setVal == NIL,;
                        FName, FName := setVal ) }" )
        // Set-Get block defined using FIELDBLOCK()

        // bSetGet created here is the functional
        // equivalent of bSetGet above
        bSetGet := FIELDBLOCK("FName")

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"FIELDWBLOCK()"  C53G999.NGO:"MEMVARBLOCK()"  
!Short: FIELDGET()      Retrieve the value of a field using the field position
 ^bFIELDGET()^b
 Retrieve the value of a field using the ordinal position of the field in the
 database structure
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFIELDGET(<nField>) --> ValueField

 ^bArguments^b

     ^b<nField>^b is the ordinal position of the field in the record
     structure for the current work area.

 ^bReturns^b

     FIELDGET() returns the value of the specified field.  If <nField> does
     not correspond to the position of any field in the current database
     file, FIELDGET() returns NIL.

 ^bDescription^b

     FIELDGET() is a database function that retrieves the value of a field
     using its position within the database file structure rather than its
     field name.  Within generic database service functions this allows,
     among other things the retrieval of field values without use of the
     macro operator.

 ^bExamples^b

     ^b^CFE^b  This example compares FIELDGET() to functionally equivalent
        code that uses the macro operator to retrieve the value of a field:

        LOCAL nField := 1, FName, FVal
        USE Customer NEW
        //
        // Using macro operator
        FName := FIELD( nField )           // Get field name
        FVal := &FName                     // Get field value
        // Using FIELDGET()
        FVal := FIELDGET( nField )         // Get field value

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"FIELDPUT()"  
!Short: FIELDNAME()     Return a field name from the current database (.dbf) file
 ^bFIELDNAME()/FIELD()^b
 Return a field name from the current database (.dbf) file
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFIELDNAME/FIELD(<nPosition>) --> cFieldName

 ^bArguments^b

     ^b<nPosition>^b is the position of a field in the database file
     structure.

 ^bReturns^b

     FIELDNAME() returns the name of the specified field as a character
     string.  If <nPosition> does not correspond to an existing field in the
     current database file or if no database file is open in the current work
     area, FIELDNAME() returns a null string ("").

 ^bDescription^b

     FIELDNAME() is a database function that returns a field name using an
     index to the position of the field name in the database structure.  Use
     it in data-independent applications where the field name is unknown.  If
     information for more than one field is required, use AFIELDS() to create
     an array of field information or COPY STRUCTURE EXTENDED to create a
     database of field information.

     If you need additional database file structure information, use TYPE()
     and LEN().  To obtain the number of decimal places for a numeric field,
     use the following expression:

     LEN(SUBSTR(STR(<idField>), RAT(".", ;

                 STR(<idField>)) + 1))

     By default, FIELDNAME() operates on the currently selected work area as
     shown in the example below.

 ^bExamples^b

     ^b^CFE^b  These examples illustrate FIELDNAME() used with several other
        functions:

        USE Sales
        ? FIELDNAME(1)              // Result: BRANCH
        ? FCOUNT()                  // Result: 5
        ? LEN(FIELDNAME(0))         // Result: 0
        ? LEN(FIELDNAME(40))        // Result: 0

     ^b^CFE^b  This example uses FIELDNAME() to list the name and type of
        each field in Customer.dbf:

        USE Customer NEW
        FOR nField := 1 TO FCOUNT()
           ? PADR(FIELDNAME(nField), 10),;
                  VALTYPE(&(FIELDNAME(nField)))
        NEXT

     ^b^CFE^b  This example accesses fields in unselected work areas using
        aliased expressions:

        USE Sales NEW
        USE Customer NEW
        USE Invoices NEW
        //
        ? Sales->(FIELDNAME(1))            // Result: SALENUM
        ? Customer->(FIELDNAME(1))         // Result: CUSTNUM

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"AFIELDS()*"  C53G999.NGO:"COPY STRU EXTE"  "DBSTRUCT()"  "FCOUNT()"  
!Short: FIELDPOS()      Return the position of a field in a work area
 ^bFIELDPOS()^b
 Return the position of a field in a work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFIELDPOS(<cFieldName>) --> nFieldPos

 ^bArguments^b

     ^b<cFieldName>^b is the name of a field in the current or specified work
     area.

 ^bReturns^b

     FIELDPOS() returns the position of the specified field within the list
     of fields associated with the current or specified work area.  If the
     current work area has no field with the specified name, FIELDPOS()
     returns zero.

 ^bDescription^b

     FIELDPOS() is a database function that is the inverse of the FIELDNAME()
     function.  FIELDPOS() is most often used with the FIELDPUT() and
     FIELDGET() functions.

     FIELDPOS() return the names of fields in any unselected work area by
     referring to the function using an aliased expression.  See the example
     below.

 ^bExamples^b

     ^b^CFE^b  This example demonstrates a typical specification of the
        FIELDPOS() function:

        USE Customer NEW
        ? FIELDPOS("Name")                     // Result: 1
        ? FIELDGET(FIELDPOS("Name"))           // Result: Kate

     ^b^CFE^b  This example uses FIELDPOS() to return the position of a
        specified field in a unselected work area:

        USE Customer NEW
        USE Invoices NEW
        ? Customer->(FIELDPOS("Name"))         // Result: 1
        ? Customer->(FIELDGET(FIELDPOS("Name")))
                                               // Result: Kate

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"FIELDGET()"  "FIELDPUT()"  
!Short: FIELDPUT()      Set the value of a field variable using the field position
 ^bFIELDPUT()^b
 Set the value of a field variable using the ordinal position of the field in
 the database structure
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFIELDPUT(<nField>, <expAssign>) --> ValueAssigned

 ^bArguments^b

     ^b<nField>^b is the ordinal position of the field in the current
     database file.

     ^b<expAssign>^b is the value to assign to the given field.  The data
     type of this expression must match the data type of the designated field
     variable.

 ^bReturns^b

     FIELDPUT() returns the value assigned to the designated field.  If
     <nField> does not correspond to the position of any field in the current
     database file, FIELDPUT() returns NIL.

 ^bDescription^b

     FIELDPUT() is a database function that assigns <expAssign> to the field
     at ordinal position <nField> in the current work area.  This function
     allows you to set the value of a field using its position within the
     database file structure rather than its field name.  Within generic
     database service functions this allows, among other things, the setting
     of field values without use of the macro operator.

 ^bExamples^b

     ^b^CFE^b  This example compares FIELDPUT() to functionally equivalent
        code that uses the macro operator to set the value of a field:

        // Using macro operator
        FName := FIELD(nField)           // Get field name
        FIELD->&FName := FVal            // Set field value
        // Using FIELDPUT()
        FIELDPUT(nField, FVal)           // Set field value

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"FIELDGET()"  
!Short: FIELDWBLOCK()   Return a set-get code block for a field in a given work area
 ^bFIELDWBLOCK()^b
 Return a set-get code block for a field in a given work area
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFIELDWBLOCK(<cFieldName>, <nWorkArea>)
     ^b   --> bFieldWBlock

 ^bArguments^b

     ^b<cFieldName>^b is the name of the field specified as a character
     string.

     ^b<nWorkArea>^b is the work area number where the field resides
     specified as a numeric value.

 ^bReturns^b

     FIELDWBLOCK() returns a code block that, when evaluated, sets (assigns)
     or gets (retrieves) the value of <cFieldName> in the work area
     designated by <nWorkArea>.  If <cFieldName> does not exist in the
     specified work area, FIELDWBLOCK() returns an empty block.

 ^bDescription^b

     FIELDWBLOCK() is a database function that builds a code block.  When
     evaluated with the EVAL() function, the code block first selects the
     designated <nWorkArea>.  If an argument was passed, the code block then
     assigns the value of the argument to <cFieldName>.  If no argument was
     passed, the code block retrieves the value of <cFieldName>.  The
     original work area is then reselected before the code block returns
     control.

     Note that the specified field variable may not exist when the code block
     is created but must exist before the code block is executed.

 ^bNotes^b

     ^b^CFE^b  FIELDWBLOCK() is similar to FIELDBLOCK(), except that
        FIELDBLOCK() incorporates a fixed work area into the set-get block.

 ^bExamples^b

     ^b^CFE^b  This example compares FIELDWBLOCK() to a code block created
        using the macro operator.  Note that using FIELDWBLOCK() avoids the
        speed and size overhead of the macro operator:

        // Set-Get block for work area 1 defined with
        // macro operator
        bSetGet := &( "{ |setVal| IF( setVal == NIL, ;
           1->FName, 1->FName := setVal ) }" )
        // Set-Get block defined using FIELDWBLOCK()

        // bSetGet created here is the functional
        // equivalent of bSetGet above
        bSetGet := FIELDWBLOCK("FName", 1)

 ^bFiles^b   Library is CLIPPER.LIB.

!Seealso:"FIELDBLOCK()"  C53G999.NGO:"MEMVARBLOCK()"  
!Short: FILE()          Determine if files exist in the default directory or path
 ^bFILE()^b
 Determine if files exist in the CA-Clipper default directory or path
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 ^bSyntax^b

     ^bFILE(<cFilespec>) --> lExists

 ^bArguments^b

     ^b<cFilespec>^b is in the current CA-Clipper default directory and path.
     It is a standard file specification that can include the wildcard
     characters * and ? as well as a drive and path reference.  Explicit
     references to a file must also include an extension.

 ^bReturns^b

     FILE() returns true (.T.) if there is a match for any file matching the
     <cFilespec> pattern; otherwise, it returns false (.F.).

 ^bDescription^b

     FILE() is an environment function that determines whether any file
     matching a file specification pattern is found.  FILE() searches the
     specified directory if a path is explicitly specified.

     If a path is not specified,  FILE() searches the current CA-Clipper
     default directory and then the CA-Clipper path.  In no case is the DOS
     path searched.  Note also that FILE() does not recognize hidden or
     system files in its search.

 ^bExamples^b

     ^b^CFE^b  In this example FILE() attempts to find Sales.dbf in other
        than the current CA-Clipper default:

        ? FILE("Sales.dbf")               // Result: .F.
        ? FILE("\APPS\