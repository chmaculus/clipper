!short: ^bRelease Note #4 -- Clipper 5.0 Compiler and Preprocessor Notes^b
'------------------------------------------------------------------------------
 Document:   ^bRelease Note #4^b
             ^bClipper 5.0 Compiler and Preprocessor Notes^b

             Copyright (c) 1991, Nantucket Corporation

 Version:    5.01a (April 19, 1991)

 Summary:    This document contains several notes about the usage of the
             Clipper 5.0 compiler as well the preprocessor.
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
!seealso: 
'------------------------------------------------------------------------------



!short:컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
!short: 1   Compiler Optimizations
'------------------------------------------------------------------------------
 ^b1   Compiler Optimizations^b
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     The Clipper compiler in contrast to previous versions of Clipper
     performs three types of optimization to your code.

     ^B^CFE^B  Shortcutting
     ^B^CFE^B  Constant folding
     ^B^CFE^B  Dead code removal

     Optimizations have impact on what code is generated by the compiler
     and therefore what code is actually executed at runtime.  This is
     important since it may affect how your programs operate.

   ^bShortcutting^b

     Beginning with Clipper version 5.0, the compiler automatically
     performs optimizations (called ^bshortcutting^b) on logical
     expressions containing .AND. and .OR. operators.  When an
     expression evaluation is shortcut, it ends when the result becomes
     evident.

     With .AND. this means that <lCondition1> and <lCondition2> are both
     evaluated only when <lCondition1> evaluates to true (.T.).  If
     <lCondition1> evaluates to false (.F.), the .AND. operation is
     false (.F.) and <lCondition2> is therefore ^bnot^b evaluated.  For
     example:

     ? .F. .AND. .T.        // Result: .F.  ^B(shortcut)^B
     ? .F. .AND. .F.        // Result: .F.  ^B(shortcut)^B
     ? .T. .AND. .T.        // Result: .T.
     ? .T. .AND. .F.        // Result: .F.

     With .OR. this means that <lCondition1> and <lCondition2> are both
     evaluated only when <lCondition1> evaluates to false (.F.).  If
     <lCondition1> evaluates to true (.T.), the .OR. operation is true
     (.T.) and <lCondition2> is therefore ^bnot^b evaluated.  For
     example:

     ? .T. .OR. .T.         // Result: .T.  ^b(shortcut)^b
     ? .T. .OR. .F.         // Result: .T.  ^b(shortcut)^b
     ? .F. .OR. .T.         // Result: .T.
     ? .F. .OR. .F.         // Result: .F.

     If the program (.prg) file is compiled with the /Z option, all
     operands of .AND. and .OR. operators are guaranteed to be evaluated
     at runtime.  Note that the scope of the optimization is the scope
     of the compile.  For example, the following compiler command-line
     suppresses shortcutting for Test.prg:

     C>CLIPPER Test /N /W /Z

   ^bConstant Folding^b

     In Clipper 5.0, the compiler will perform simple evaluation where
     both operands of a binary operator are constant values.  As an
     example,

     nVar := 1 + 2 + 3

     is generated as nVar := 6.  Likewise,

     cVar := "Hello " + "There"

     is generated as cVar := "Hello There."

   ^bDead Code Removal^b

     The Clipper compiler automatically removes statements that never
     execute.  This is referred to as ^bdead code removal^b.  For
     example, the compiler never generates code for the following
     constructs:

     IF .F.
       <statements>
     ENDIF

     DO WHILE .F.
       <statements>
     ENDDO

     ^bExample:^b  In the STD.CH, the definition for the extended
     expression version of the SET CURSOR command takes advantage of
     dead code removal to allow a logical command argument to be
     transformed into numeric efficiently:

     #command SET CURSOR (<x>) ;
           => SETCURSOR( IF(<x>, 1, 0) )

     In this example, depending on whether you specify true (.T.) or
     false (.F.) as the SET CURSOR argument, the compiler generates
     either SETCURSOR(1) or SETCURSOR(0).  The IF() evaluation and the
     non-executed case are removed.
!seealso: 
'------------------------------------------------------------------------------



!short: 2   GetList Compiler Warning
'------------------------------------------------------------------------------
 ^b2   GetList Compiler Warning^b
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     Compiling with the /W option to generate warning messages when
     ambiguous variable references are encountered generates one or more
     warning messages for GetList if the current program (.prg) file
     contains any of the following commands:

     @...GET
     CLEAR
     CLEAR ALL
     READ
     READ SAVE

     These messages can be suppressed by declaring GetList with a MEMVAR
     statement.  This can either be a procedure or file-wide
     declaration.  To make the declaration procedure-wide, place the
     MEMVAR statement before the first executable statement of each
     procedure or user-defined function that uses any of these
     commands.  For example:

     FUNCTION DoEntry
       MEMVAR GetList
       USE Customer NEW
       .
       .
       .
       READ
       RETURN NIL

     The better approach is to use file-wide declaration.  To do this
     place the MEMVAR declaration at the top and outside the body of the
     first procedure or user-defined function in any (.prg) file that
     references any of these commands.  As with any other file-wide
     declarations, the (.prg) file must be compiled with the /N option.
     For example, the following code fragment demonstrates a typical
     (.prg) file that conforms with this structure:

     /***
     *   A typical Clipper 5.0 (.prg) file
     *
     */

     // File-wide declarations
     MEMVAR GetList

     FUNCTION Main
       .
       .
       .
       RETURN NIL

     FUNCTION SubMain
       .
       .
       .
       RETURN NIL
!seealso: 
'------------------------------------------------------------------------------



!short: 3   Modifying the Standard Header File (STD.CH)
'------------------------------------------------------------------------------
 ^b3   Modifying the Standard Header File (STD.CH)^b
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     In the Getting Started guide as well as in other parts of the
     documentation, it is stated or implied that the standard command
     set used by CLIPPER.EXE to compile Clipper 5.0 programs is defined
     in STD.CH located in the \INCLUDE directory.  This is not quite
     correct.  The standard command set is in fact defined as a part of
     the compiler and never taken directly from STD.CH unless this file
     is specified on the compile command-line with the /U option.  This
     increases the compiling speed of the standard command and function
     set and guarantees that the compiler can always compile the
     standard commands.

     For example, the following compiler invocation command-lines show
     how different configurations of /U can used to use different
     command sets:

     C>CLIPPER Myprog               // Compile with standard command set
     C>CLIPPER Myprog /USTD.CH      // Compile with STD.CH
     C>CLIPPER Myprog /UOTHER.CH    // Compile with OTHER.CH
     C>CLIPPER Myprog /U            // Compile with no command set

     If you are using an alternate command set on a regular basis, you
     might want to add it to your CLIPPERCMD like this:

     C>SET CLIPPERCMD=/UALTSTD.CH
!seealso: 
'------------------------------------------------------------------------------



