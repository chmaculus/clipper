!short: ^bRelease Note #8 -- Code Block Notes^b
'------------------------------------------------------------------------------
 Document:   ^bRelease Note #8^b
             ^bCode Block Notes^b

             Copyright (c) 1991, Nantucket Corporation

 Version:    5.01a (April 19, 1991)

 Summary:    This document contains notes about the nature and usage of
             code blocks in Clipper 5.0.
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
!seealso: 
'------------------------------------------------------------------------------



!short:컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
!short: 1   Early and Late Evaluation of Macros in Code Blocks
'------------------------------------------------------------------------------
 ^b1   Early and Late Evaluation of Macros in Code Blocks^b
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     When a code block contains a macro, an ambiguity arises regarding
     when the macro is evaluated.  There are two possibilities, early or
     late evaluation.

   ^bEarly Evaluation^b

     The macro is expanded at the time the code block is created, and
     the expanded value remains constant for all subsequent evaluations
     of the block.

     Clipper 5.0 uses early evaluation by default, with an alternate
     method available for late evaluation.

     As an example of early evaluation, consider a SET FILTER command in
     which the filter expression is a macro:

     SET FILTER TO &cFilter

     A filter expression, specified by a SET FILTER command, is executed
     each time a SKIP command is issued.  The macro string contained in
     cFilter above, however, should be expanded only once, when the
     command is first issued.  Otherwise, if the macro is re-expanded
     each time the filter block is evaluated, the macro variable
     (cFilter above) must be preserved for the duration of the filter.

     In Clipper 5.0, the SET FILTER command is implemented by use of a
     code block.  The code for the above command, after preprocessing,
     is similar to the following example:

     DBFILTER( { || &cFilter } )

     Early evaluation of the macro within the code block results in the
     desired behavior: cFilter is evaluated when the block is defined
     (as part of the creation of the block).  The block is created via
     the macro system and remains constant through all subsequent block
     evaluations, regardless of any change to the value of cFilter.

   ^bLate Evaluation^b

     The macro is re-evaluated each time the block is evaluated.

     As an example of a situation where late evaluation is required,
     consider a block which must perform a macro operation on one of its
     own parameters.

     The following block attempts to assign a value to a variable by use
     of a macro:

     assignVarByNameBlock := { |vName, value| &vName := value }

     Because Clipper 5.0 implements early evaluation, this code block
     would not have the desired effect: instead of evaluating the macro
     each time the block is run, Clipper would evaluate the macro when
     the block was first created.  The initial value of vName would
     become part of the block.

     Late evaluation is available by using a macro expression.  The
     above code block will function correctly if defined as follows:

     assignVarByNameBlock := { |vName, value| &(vName) := value }

     The use of a macro expression (the macro operator applied to a
     parenthesized expression) prevents the early evaluation from taking
     place, and the code block will re-evaluate the macro string
     contained in vName during each block evaluation.
!seealso: 
'------------------------------------------------------------------------------



!short: 2   Visibility of Locals Referenced in a Code Block
'------------------------------------------------------------------------------
 ^b2   Visibility of Locals Referenced in a Code Block^b
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴

     A local variable referenced in a code block is still visible after
     the declaring function is no longer active as long there is an
     active reference to the code block.  For example:

     bBlock := MyFunc()

     FOR i := 1 TO 10
       ? EVAL( bBlock )
     NEXT
     RETURN

     FUNCTION MyFunc()
       LOCAL nNumber
       LOCAL bBlock

       nNumber := 10
       bBlock := {|| nNumber++}

       RETURN bBlock

     In this example, each time the code block returned by MyFunc() is
     evaluated, it increments nNumber and returns the new value.

     nNumber is accessible via the code block as the function defining
     the code block's activation record becomes ^bdetached^b from the
     activation stack when the function returns.  The function's local
     variables then become, in essence, a free-floating array.  The
     detached activation lives in object memory and stays alive as long
     as any of the blocks referring to it are alive.

     This facility has significant ramifications for the capabilities of
     a code block.  In particular, it solves the problem where a code
     block instance needs long term ownership of some values.  It means,
     generally, that you need to macro-compile a code block only if the
     actual code to be executed isn't known until runtime--not, for
     example, because you wanted the block to always contain or operate
     on a value which isn't known until runtime.

     Note also that every call to the function will generate unique
     instances of the local variables.  If a code block refers to those
     variables, then those variables will continue to exist as long as
     there is a code block that refers to them.

!seealso: 
'------------------------------------------------------------------------------



