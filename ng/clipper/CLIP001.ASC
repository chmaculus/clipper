!Short: ?/??           Displays an expression list on the next line of CRT.
^B?/??^B

    To display the results of one or more expressions separated by a space.

^USyntax^U

    ?/?? <exp list>

^UArgument^U

    <exp list> is the list of values of any data type to display.  The list
    can consist of any combination of data types including memo type.

^UUsage^U

    The single question mark issues a carriage return and line feed before
    the expression list is displayed.  The double question mark does not.
    When used in a program, ?? displays the expression list beginning with
    the current cursor or printer position.
!Seealso:"@...SAY...GET"  "TEXT"  
!Short: @...BOX        Permits box drawing.
^B@...BOX^B

    @...BOX is used to draw boxes on the screen.  You may specify the size
    and relative position of the box on the screen, and up to 9 different
    characters can be used in drawing the box.

^USyntax^U

    @ <exp N1>, <exp N2>, <exp N3>, <exp N4> BOX <exp C>

^UArguments^U

    <exp N1> is the top row.  Values may be in the range of zero to 24.

    <exp N2> is the left most column.  Values may be in the range of zero
    to 79.

    <exp N3> is the bottom row.  Values may be in the range of zero to 24.

    <exp N4> is the right most column.  Values may be in the range of zero
    to 79.

    <exp C> is a string of eight border characters and one fill character.
    @...BOX draws the box using this string starting from the upper left
    hand corner and then proceeds clockwise.

^UUsage^U

    For the string, you may specify up to 8 different ASCII characters for
    each of the four corners and sides.  If you choose to specify a 9th
    character in the string, that character will be used to fill the box.
    The characters that are specified in the string will be displayed
    starting from the upper left hand corner and then drawn clockwise.  A
    typical use of this command would involve specifying the appropriate
    single- or double-line box drawing characters in the string.
!Seealso:"@...CLEAR"  "@...TO"  
!Short: @...CLEAR      Clears a rectangular section of the screen.
^B@..CLEAR^B

    To clear a rectangular region of the screen.

^USyntax^U

    @ <exp N1>,<exp N2> CLEAR [TO <exp N3>, <exp N4>]

^UUsage^U

    <expN1..expN2> define the coordinates of the upper right corner.  The
    first expression is the row and the second is the column coordinate.

^UOptions^U

    ^BTo:^B The TO clause defines the lower right corner coordinates (<exp
    N3> and <exp N4>) of the region to CLEAR.  If this clause is not
    specified, the corner coordinates default to row 24, column 79.
!Seealso:"@...BOX"  "CLEAR"  CLIP002.NGO:"SCROLL"  
!Short: @...PROMPT     Used to place menu selections on the screen.
^B@...PROMPT^B

    @...PROMPT is used to place menu selections on the screen.  The menu
    selection will be placed at the location specified by the row and
    column.

^USyntax^U

    @ <exp N1>, <exp N2> PROMPT <exp C> [MESSAGE <exp C>]

^UArguments^U

    <exp N1> is the row where the prompt displays.

    <exp N2> is the column where the prompt displays.

    <exp C> is the prompt string.

^UOptions^U

    ^BMessage:^B The MESSAGE clause defines the message to display each
    time the current PROMPT is highlighted.  The message displays on the
    row specified by SET MESSAGE.

^UUsage^U

    @...PROMPT is the display portion of the Clipper light-bar menu system.
    Each @...PROMPT statement paints a menu prompt and defines an
    associated MESSAGE to be displayed on the line specified by SET MESSAGE
    TO.  The light-bar menu is then invoked with MENU TO.  Prompts can be
    painted in any order and configuration of row and column position.
    MENU TO navigates them in the order they are defined.

    There can be up to 32 PROMPTS per menu.

    ^RColor:^R PROMPTS are painted in the current standard color.  The
    highlight appears in the current enhanced color.
!Seealso:"MENU"  "SET COLOR"  "SET MESSAGE"  "SET WRAP"  CLIP002.NGO:"ACHOICE()"  
!Short: @...SAY...GET    Displays user-formatted data on screen/printer.
^B@...SAY...GET^B

    To display and input data at specified row and column positions.

^USyntax^U

    @ <exp N1>, <exp N2> [SAY <exp> [PICTURE <clause>]] [GET <variable>
    [PICTURE <exp C>] [RANGE <exp N1>,<exp N2>] [VALID <expL>]

^UArguments^U

    <exp N1> is the row coordinate.

    <exp N2> is the column coordinate.

^UOptions^U

    ^BSay:^B The SAY clause displays the result of an <exp> of any type
    (including a memo field) at the specified coordinates on the current
    DEVICE.  Clipper supports two devices: PRINT and SCREEN.  If DEVICE is
    SET TO PRINT. output is directed to the printer.  Otherwise it is
    directed to the SCREEN.  To direct @...SAYS to a file, SET DEVICE TO
    PRINT and then SET PRINTER TO <output filename>.  Output destined for
    the printer is then redirected to the specified text file.

    @...SAYs to the printer behave a little differently than to the screen.
    If you address a printer row and column position less than the last
    position printed since an EJECT or SETPRC(), Clipper performs an EJECT
    and resets the internal PROW() and PCOL() values.  Your printing logic
    must, therefore, proceed sequentially from left to right down the page.

    SAYs display in standard color (see SET COLOR).

    ^BGet:^B The GET clause displays a <variable> (a field or memory
    variable) at a specified screen coordinate and adds it to the list of
    pending GETs.  A subsequent READ invokes a full-screen edit mode
    allowing you to edit the contents of the pending GETs with a full
    complement of editing and navigation keys.  For a complete list of
    keys, see READ.

    Clipper supports GETting fields from other work areas if fields are
    referenced using the alias.

    GETs display in enhanced color unless there is an unselected COLOR
    SETting.  if this is the case, the current GET displays in the enhanced
    color and all other active GETs display in the unselected color.

    Note that GETs are not directed to the printer or a file with SET
    DEVICE TO PRINT.

    ^BPicture:^B The PICTURE clause defines the mask for entry into a GET
    and formats the output of a SAY.  Clipper provides two mechanisms to
    control formatting: ^Bfunction^B and/or a ^Btemplate^B.  Functions
    apply to the entire SAY or GET while templates mask characters position
    by position.

    ^BFunctions:^B A PICTURE function is a symbol preceded by an "@."  If a
    template symbol follows the function, it must be preceded with a space.
    Note that more than one function can be applied within the same
    PICTURE.  The following table summarizes the available functions:

^BPICTURE FUNCTIONS^B

    ^UFunc^U  ^UType^U   ^UDescription^U

     A     C     Allows only alphabetic characters into a GET
     B     N     Displays numbers left-justified
     C     N     Displays CR (credit) after positive numbers
     D     D,N   Displays dates in SET DATE format
     E     D,N   Displays dates in British format, numerics in European
                 format (command and period reversed)
     K     ALL   Clears GET if first key is not a cursor key
     R     C     Non-template characters are inserted
    S<n>   C     Allows horizontal scrolling within a GET
     X     N     Displays DB (debit) after negative numbers
     Z     N     Displays zeros as blanks
     (     N     Encloses negative numbers in parentheses w/ leading spaces
     )     N     Encloses negative numbers in parentheses w/o leading spaces
     !     C     Converts alphabetic characters to upper case

    ^BTemplates^B: Template symbols follow functions in the PICTURE string
    if they are specified.  Each position in the output or input stream is
    mapped to the symbol in the same position in the template.  Clipper
    provides a number of template symbols as follows:

    Template    Description

       A        Displays only alphabetic characters
       N        Displays only alphabetic and numeric characters
       X        Displays any character
       9        Displays digits for any data type with sign for numerics
       #        Displays digits, signs, and spaces for any data type
       L        Displays logicals as "T" or "F"
       Y        Allows only "Y" or "N"
       !        Converts an alphabetic character to upper case
       $        Displays a dollar sign in place of a leading space in a
                numeric
       *        Displays an asterisk in place of a leading space in a
                numeric
       .        Specifies a decimal point position.
       ,        Specifies a comma position.

    Other characters specified in the template overwrite the character at
    the same position in the source stream and output.  If, however, you
    use the "R" function, non-template symbols specified are inserted into
    the display but not output if the PICTURE applies to a GET.

    ^BRange:^B The RANGE clause limits entry into date and numeric type
    variables by specifying the lower and upper bounds of acceptable input
    (the lower must precede the upper).  If the value is not within the
    RANGE, an indicating message displays in the SCOREBOARD area and
    control returns to the GET.  Note that the RANGE check is performed
    unless you press Esc to terminate the GET.  In this case, there is no
    RANGE check and the <variable> is restored to its original value.

    ^BValue:^B The VALID clause allows you the validate an entry into a GET
    with a logical expression.  Like RANGE, the VALID expression evaluates
    whenever you attempt to terminate the associated GET unless you press
    Esc and ESCAPE is ON.  If the expression returns false (.F.) control
    returns to the GET and you cannot leave the GET until the expression
    returns true (.T.) or you press Esc.

    Note that the expression may contain or be a user-defined function.
    This is useful for lookups and other types of post-processing
    functions.  One of the unique capabilities of Clipper is that within a
    user-defined function called by VALID, you can change the contents of
    the current GET.  You do this simply by STOREing or REPLACEing a new
    value into the current GET variable.  When control returns to the GET,
    Clipper updates it with the new value of the variable.

^UUsage^U

    ^BHelp:^B You can create a help system that operates within a screen
    consisting of @...SAY...GETs by first SETting KEY TO a specific help
    procedure.  Then within the procedure, use READVAR() to determine the
    current GET and display the appropriate help screen.  Note that within
    a SET KEY procedure, you can change the contents of the current GET in
    the same way you would from within a VALID.
!Seealso:"?/??"  "@...TO"  "@...CLEAR"  CLIP002.NGO:"PCOL()"  CLIP002.NGO:"PROW()"  
!Short: @...TO         To draw single or double line boxes on the screen.
^B@...TO^B

    To draw single or double line boxes on the screen.

^USyntax^U

    @ <exp N1>, <exp N2> TO <exp N3>, <exp N4> [DOUBLE]

^UArguments^U

    <exp N1..exp N4> define the coordinates of the box.  ExpN1 and expN2
    define the upper left corner and expN3 and expN4 define the lower right
    corner.  If the two row coordinates (<expN1> and <expN3> are the same,
    Clipper draws a horizontal line.  If the two column coordinates
    (<expN2> and <expN4> are the same, Clipper draws a vertical line.

^UOptions^U

    ^BDouble:^B The DOUBLE clause paints the box with a double line.  if
    this clause is not specified, the box is painted with a single line.

^UUsage^U

    @...TO is very similar to @...BOX with two exceptions.  First, @...BOX
    allows you to define the characters of the box and second, it supports
    a fill character.  @...TO, however, is easier to use since you do not
    have to remember the box characters.
!Seealso:"@...BOX"  "@...CLEAR"  CLIP002.NGO:"ACHOICE"  CLIP002.NGO:"DBEDIT()"  CLIP002.NGO:"SCROLL()"  
!Short: ACCEPT         Allows input of character data into memory variable.
^BACCEPT^B

    To enter a string from the keyboard into a specified memory variable.

^USyntax^U

    ACCEPT [<prompt>] TO <memvar>

^UArgument^U

    <memvar> is the name of the memory variable where the keyboard entry is
    placed.

^UOption^U

    ^BPrompt:^B The <prompt> is a character string displayed before the
    input area.

^UUsage^U

    ACCEPT takes entry from the keyboard and places it into a newly created
    character memory variable.  Return confirms entry and is the only key
    that terminates ACCEPT.  If ^C1B^CD9 is entered in response to the
    ACCEPT command, the content of the memory variable is null (without any
    contents, or ASCII 0).
!Seealso:"@...SAY...GET"  "INPUT"  "WAIT"  CLIP002.NGO:"INKEY()"  
!Short: APPEND BLANK   Adds a new record at the end of the current database.
^BAPPEND BLANK^B

    To add a new record to the end of the currently selected database file.

^USyntax^U

    APPEND BLANK

^UUsage^U

    APPEND BLANK option adds a blank record and makes it the current
    record.

^UNetwork^U

    When operating under a network and the current database file is shared,
    APPEND BLANK attempts to add and then lock a new record.  If another
    user has locked the database file or attempted to APPEND BLANK at the
    same time, NETERR() returns true (.T.).  Note that a newly APPENDed
    record remains locked until you lock another record or perform an
    UNLOCK.  Note also that APPENDing BLANK does not release an FLOCK() by
    the current user.
!Seealso:"APPEND FROM"  "SET CONFIRM"  "SET FORMAT"  
!Short: APPEND FROM    Adds records from other files to selected dBASE file.
^BAPPEND FROM^B

    APPEND FROM copies records from an existing file to the end of the
    active database file.  The FROM file does not have to be a database
    file.

^USyntax^U

    APPEND [<scope>] [FIELDS <field list>] FROM <file>/(<expC>)
    [FOR <condition>] [WHILE <condition>] [SDF]/[DELIMITED
    [WITH BLANK/<delimiter>/(<expC>)]]

^UArgument^U

    <file> is the name of the source file.  If no file type is specified, a
    ^R.dbf^R extension is assumed.  If there is a type option specified,
    the file extension is assumed to be ^R.txt^R unless specified.

^UOptions^U

    ^BFields:^B If the FIELDS clause is specified, data is APPENDed only
    into the fields specified.

    ^BScope:^B The <scope> is the portion of the source database file to
    APPEND FROM.  In Clipper, NEXT<n> APPENDS the first <n> records and
    supersedes any FOR or WHILE condition.  RECORD <n> APPENDs only source
    database file record number <n> to the target database file.  The
    default scope is ALL records.

    ^BCondition:^B The FOR clause specifies the conditional set of records
    to APPEND FROM within the given scope.  The WHILE clause specifies the
    set of records meeting the condition from the first record in the
    source file until the condition fails.

    ^BType:^B There are three types of files Clipper can import: SDF,
    DELIMITED, and (.dbf) files.

    SDF identifies a System Data Format ASCII file.  Each record is the
    same length and ends with a carriage return and line feed.

    DELIMITED identifies an ASCII text file, where fields are separated by
    commas and character fields are bounded by double quotation marks (the
    default delimiter).  Note that the delimiters are not required and
    Clipper correctly APPENDs character fields not bounded by them.  Fields
    and records are variable length and end with a carriage return and line
    feed.  The end-of-file mark is Ctrl-Z (1A hex).

    DELIMITED WITH BLANK identifies an ASCII text file, where fields are
    separated by one space and character fields are not bounded by
    delimiters.

    DELIMITED WITH <delimiter> identifies a delimited ASCII text file,
    where character fields are delimited with the specified delimiter.

^UUsage^U

    ^BDeleted Records^B in the source database file are APPENDed but not
    marked as deleted in the target database file.  If DELETED is ON,
    however, none of the deleted source records are APPENDed.

    ^BFields with the same name and types^B are APPENDed.  Unlike dBASE
    III, however, the source and target fields must be the same data type.
    If they are not you will get the error message "Type conflict in
    REPLACE" when you APPEND FROM.

    ^BMatching widths^B: If a target field is larger, Clipper pads the
    source data to fill it.  If the target field is smaller, Clipper
    truncates the source data.

^UNetwork^U

    Note that APPEND FROM does not require the target file locked with
    FLOCK() or USEd EXCLUSIVEly in order to function properly.  Clipper
    automatically arbitrates contention for the target database file during
    APPENDs.
!Seealso:"COPY"  
!Short: AVERAGE        Computes and displays mean of one or more fields.
^BAVERAGE^B

    To average a series of numeric expressions to memory variables for a
    range of records in the current database file.

^USyntax^U

    AVERAGE [<scope>] <expression list> TO <memvar list> [FOR <condition>]
    [WHILE <condition>]

^UArguments^U

    <exp list> is a list of the numeric values to AVERAGE for each record
    processed.

    <memvar list> identifies the receiving memory variables for the
    averages and is created when the command executes.  Existing memory
    variables with the same names are overwritten.  This list must contain
    the same number of elements as the list of expressions to AVERAGE.

^UOptions^U

    ^BScope:^B The <scope> is the portion of the current database file to
    AVERAGE.  The default scope is ALL.

    ^BCondition:^B The FOR clause specifies the conditional set of records
    to AVERAGE within the given scope.  The WHILE clause specifies the set
    of records meeting the condition from the current record until the
    condition fails.
!Seealso:"SUM"  "TOTAL"  
!Short: BEGIN SEQUENCE..END   To define a control structure for error scoping.
^BBEGIN SEQUENCE...END^B

    BEGIN SEQUENCE...END defines a control structure for user-defined error
    scoping within the flow of a program.

^USyntax^U

    BEGIN SEQUENCE
       <statements>...
       [BREAK]
       <statements>...
    END

^UOptions^U

    ^BBreak:^B The BREAK statement branches execution to the statement
    immediately following the matching END statement.

^UUsage^U

    BEGIN SEQUENCE...END is a control structure that allows relatively easy
    definition of exception handling.  When an exception occurs, issue a
    BREAK to branch control to the program statement immediately following
    the END statement that terminates the current SEQUENCE program
    structure.  BREAK can occur in a nested or the current procedure.
    Nested procedures can be nested any number of levels below the BEGIN
    SEQUENCE structure which may also include any of the runtime error
    procedures.  The latter allows you to define local recovery operations
    for runtime error conditions specific to the context in which they
    occur.  It can also be used to simulate RETURN TO MASTER (see below for
    example).

^UExamples^U

    The following code fragment demonstrates the SEQUENCE construct within
    a nested or the current procedure:

    ^RBEGIN SEQUENCE          ^R
    ^R   <statements>...      ^R
    ^R   IF break_cond        ^R
    ^R      BREAK             ^R
    ^R   ENDIF                ^R
    ^R   <statements>...      ^R
    ^REND                     ^R
    ^R                        ^R
    ^R<recovery statements>...^R

    The following code fragment demonstrates simulation of RETURN TO
    MASTER.

    ^R*1st level menu                                         ^R
    ^R*                                                       ^R
    ^RDO WHILE .T.                                            ^R
    ^R   BEGIN SEQUENCE                                       ^R
    ^R   CLEAR                                                ^R
    ^R   @ 01,01 say "Master Menu..."                         ^R
    ^R   @ 05,05 PROMPT "Go one level down"                   ^R
    ^R   @ 06,05 PROMPT "No operation     "                   ^R
    ^R   @ 07,05 PROMPT "Quit             "                   ^R
    ^R   MENU TO first                                        ^R
    ^R   DO CASE                                              ^R
    ^R      CASE first = 1                                    ^R
    ^R         DO menu2                                       ^R
    ^R      CASE first = 2                                    ^R
    ^R         @23,01 say "No-op choice...press any key..."   ^R
    ^R         inkey(0)                                       ^R
    ^R      CASE first = 3                                    ^R
    ^R         EXIT                                           ^R
    ^R   ENDCASE                                              ^R
    ^R   END SEQUENCE                                         ^R
    ^RENDDO                                                   ^R
    ^RRETURN                                                  ^R
    ^R                                                        ^R
    ^R*********                                               ^R
    ^R* 2nd level menu                                        ^R
    ^R*                                                       ^R
    ^RPROCEDURE menu2                                         ^R
    ^RDO WHILE .T.                                            ^R
    ^R   CLEAR                                                ^R
    ^R   @ 01,01 say "Menu 2 ..."                             ^R
    ^R   @ 05,05 PROMPT "Go one level down"                   ^R
    ^R   @ 06,05 PROMPT "No operation     "                   ^R
    ^R   @ 07,05 PROMPT "Quit             "                   ^R
    ^R   MENU TO second                                       ^R
    ^R   DO CASE                                              ^R
    ^R      CASE second = 1                                   ^R
    ^R         DO menu3                                       ^R
    ^R      CASE second = 2                                   ^R
    ^R         @23,01 say "No-op choice...press any key..."   ^R
    ^R         inkey(0)                                       ^R
    ^R      CASE first = 3                                    ^R
    ^R         EXIT                                           ^R
    ^R   ENDCASE                                              ^R
    ^R   @ 24,01 say "exiting"                                ^R
    ^R   INKEY(0)                                             ^R
    ^RENDDO                                                   ^R
    ^RRETURN                                                  ^R
    ^R                                                        ^R
    ^R*********                                               ^R
    ^R* 3rd level menu                                        ^R
    ^R*                                                       ^R
    ^RPROCEDURE menu3                                         ^R
    ^RDO WHILE .T.                                            ^R
    ^R   CLEAR                                                ^R
    ^R   @ 01,01 say "Menu 3 ..."                             ^R
    ^R   @ 05,05 PROMPT "Return to Master "                   ^R
    ^R   @ 06,05 PROMPT "No operation     "                   ^R
    ^R   @ 07,05 PROMPT "Quit             "                   ^R
    ^R   MENU TO third                                        ^R
    ^R   DO CASE                                              ^R
    ^R      CASE third = 1                                    ^R
    ^R         BREAK                                          ^R
    ^R      CASE third = 2                                    ^R
    ^R         @23,01 say "No-op choice...press any key..."   ^R
    ^R         inkey(0)                                       ^R
    ^R      CASE third = 3                                    ^R
    ^R         EXIT                                           ^R
    ^R   ENDCASE                                              ^R
    ^R   @ 24,01 say "exiting"                                ^R
    ^R   INKEY(0)                                             ^R
    ^RENDDO                                                   ^R
    ^RRETURN                                                  ^R
!Seealso:"RETURN"  
!Short: CALL           To execute separately compiled or assembled programs.
^BCALL^B

    To execute separately compiled or assembled routines and programs.

^USyntax^U

    CALL <process> WITH <exp list>

^UArguments^U

    <exp list> is the list of expressions of any data type to pass to the
    external process.

^UUsage^U

    CALLed programs must be defined as FAR processes ending with a FAR
    return.  All data references consist of four-byte pointers in the form
    SEGMENT:OFFSET, and are on top of the stack in the order passed (see
    the example below).  All data types are passed by reference.  Your
    program must preserve the BP, SS, SI, DI, ES, and DS registers.

    ^BPassing Parameters:^B The CALL command parameter list may consist of
    up to seven parameters.  The DX:BX and ES:BX registers point to the
    first parameter, similar to dBASE III.  If you wish to convert a dBASE
    III load module, add the following statements to your .ASM file:

    PUBLIC <proc>

    and

    mov ds,dx

    Character strings are passed by reference and are null terminated (a 0
    byte at the end of the string).  The length of any data item must be
    preserved, as the data area contains many data items consecutively in
    memory.  If an item is lengthened, you will in all likelihood write
    over other data.
    The CALL command executes a binary program file that has been
    loaded in memory with the LOAD command.  Each loaded file is treated as
    a subroutine or module rather than as an external program (which could
    be executed with the RUN command).  As a result, each time you want to
    execute the program, it can simply run from memory without having to be
    reloaded from a disk.  Up to 16 binary program files can be loaded in
    memory at one time, and each can be up to 32,000 bytes in length.

    When you CALL the binary program file, you specify the name of the file
    without the .bin extension.  The program module name is the same as the
    file loaded in memory.  When you call the file, you can pass either a
    character expression or a memory variable of any data type to the
    binary program file.  All character type memory variables and
    expressions end with a null (ASCII value zero).

    Numeric variables are passed as 8 byte floating point representation,
    consisting of a 53 bit characteristic and an 11 bit exponent biased by
    1023.  To pass numeric parameters as integers, use WORD() to convert
    them from the Clipper internal format to integer.  If the numeric value
    you are passing is greater than -+32,767, it cannot be passed as an
    integer and therefore the use of WORD() is inappropriate.

    Note also that if you use WORD() to pass a numeric value, it is passed
    by value.

    ^BCompiling and Linking:^B CALLed programs must conform to the
    following rules:

    - The program must be in the "INTEL 8086 relocatable object file
      format", with the .OBJ file extension.

    - Must follow C language calling and parameter passing conventions.

    - Must be available to the Clipper Linker at link time.  You will need
      runtime support for any language other than assembly language.  See
      your compiler manual for details.

^UExamples^U

    The following example in C changes the variable "var" from "123" to
    "ABC".

    ^Rvar = "123"              ^R
    ^RCALL Test WITH var, "ABC"^R
    ^R? var                    ^R
    ^RRETURN                   ^R

    To CALL a C program, use the following simple program as a basis:

    ^R/* Compile as large module*/^R
    ^Rtest (p1, p2)               ^R
    ^R                            ^R
    ^Rchar *p1;                   ^R
    ^Rchar *p2;                   ^R
    ^R                            ^R
    ^R{                           ^R
    ^R    while (*p2)             ^R
    ^R    *p1++ = *p2++;          ^R
    ^R}                           ^R
!Seealso:"DO"  CLIP002.NGO:"WORD()"  
!Short: CANCEL/QUIT    To terminate program processing and close all open files.
^BCANCEL^B

    To terminate program processing, close all open files, and return
    control to the operating system.

^USyntax^U

    CANCEL/QUIT

^UUsage^U

    CANCEL or QUIT can be used from anywhere in a program to terminate and
    return to the operating system.  A RETURN executed at the highest level
    procedure performs the same action.
!Seealso:"QUIT"  "RETURN"  
!Short: CLEAR          Clears the screen, home the cursor and clear pending GETs.
^BCLEAR^B

    To clear the screen, home the cursor, and clear all pending GETs.

^USyntax^U

    CLEAR [SCREEN]

^UOption^U

    ^BScreen:^B The SCREEN clause suppresses the automatic clearing of GETs
    when the screen is CLEARed.

^UUsage^U

    After CLEAR erases the screen the cursor is positioned at 0,0.

    If you are editing GETs, do not execute a CLEAR within a procedure
    invoked  either by SET KEY or the VALID clause since it will release
    all pending GETs.  To clear the screen without CLEARing GETs, use CLEAR
    SCREEN or @0,0 CLEAR.
!Seealso:"@...CLEAR"  "CLEAR GETS"  
!Short: CLEAR ALL      Closes open databases, releases all memory variables.
^BCLEAR ALL^B

    To close all open database (and related index, format, and memo) files,
    release all memory variables, and SELECT work area 1.

^USyntax^U

    CLEAR ALL
!Seealso:"CLEAR MEMORY"  "CLOSE"  "RELEASE"  
!Short: CLEAR GETS     Releases all @...GETs issued since the last CLEAR or READ.
^BCLEAR GETS^B

    CLEAR GETS releases all @...GETs issued since the last CLEAR ALL, CLEAR
    GETS, or READ command.

^USyntax^U

    CLEAR GETS
!Short: CLEAR MEMORY   Releases all memory variables.
^BCLEAR MEMORY^B

    CLEAR MEMORY releases all memory variables.

^USyntax^U

    CLEAR MEMORY

^UUsage^U

    CLEAR MEMORY releases all PUBLIC and PRIVATE memory variables, while
    RELEASE ALL only releases PRIVATE memory variables declared in the
    program currently being executed.
!Seealso:"CLEAR ALL"  "RELEASE"  
!Short: CLEAR TYPEAHEAD   Empties the type-ahead buffer.
^BCLEAR TYPEAHEAD^B

    CLEAR TYPEAHEAD empties the type-ahead buffer.

^USyntax^U

    CLEAR TYPEAHEAD

^UUsage^U

    CLEAR TYPEAHEAD is useful in user-interface procedures to guarantee
    that keys processed from the keyboard buffer are appropriate to the
    current activity and not pending from a previous activity.  This is
    particularly useful in the user functions of ACHOICE() and DBEDIT().
!Seealso:"KEYBOARD"  "SET TYPEAHEAD"  CLIP002.NGO:"ACHOICE()"  CLIP002.NGO:"DBEDIT()"  CLIP002.NGO:"LASTKEY()"  CLIP002.NGO:"NEXTKEY()"  
!Short: CLOSE          Closes various types of files.
^BCLOSE^B

    CLOSE is used to close alternate files, database files, format files,
    index files, and procedure files.

^USyntax^U

    CLOSE ALL/ALTERNATE/DATABASES/FORMAT/INDEX

^UOptions^U

    ^BAll^B: CLOSEs all alternate, database, and index files in all work
    areas.  Additionally, it releases all active filters, relations and
    formats.

    ^BAlternate^B: CLOSEs the currently open alternate file.  It does not,
    however, release the alternate file name pointed to by SET ALTERNATE TO
    <filename>.  SET ALTERNATE TO with no argument also CLOSEs the
    alternate file.

    ^BDatabases^B: CLOSEs all open database and associated index files in
    all work areas and releases all active filters.  It does not, however,
    have any effect on the active format.

    ^BFormat^B: Releases the current format performing the same action as
    SET FORMAT TO with no argument.

    ^BIndexes^B: CLOSEs all index files open in the current work area.

^UUsage^U

    In Clipper, a number of other commands also CLOSE files including:

    ^CF9  QUIT
    ^CF9  CANCEL
    ^CF9  RETURN from the highest level procedure
    ^CF9  CLEAR ALL
    ^CF9  USE with no argument

    Clipper also closes files from a runtime error message prompt.  When
    you terminate program execution in response to a runtime error the
    following options close files:

    ^CF9  Quit option from (Q/A/I) prompt

    ^CF9  Pressing "N" from the Continue option
!Seealso:"CANCEL/QUIT"  "CLEAR ALL"  "CLEAR MEMORY"  "QUIT"  "RETURN"  "SET ALTERNATE"  "USE"  
!Short: COMMIT         To perform a solid-disk write for all work areas.
^BCOMMIT^B

    COMMIT performs a solid-disk write for all work areas.

^USyntax^U

    COMMIT

^UUsage^U

    COMMIT flushes all Clipper buffers to DOS and then performs a solid-
    disk write.

    This requires DOS 3.3 or greater.
!Seealso:"SKIP"  
!Short: CONTINUE       Points to next record meeting LOCATE conditions.
^BCONTINUE^B

    CONTINUE searches for the next record in the active database file that
    meets the condition specified by the most recent LOCATE command.

^USyntax^U

    CONTINUE

^UUsage^U

    CONTINUE searches from the current record position for the next record
    meeting the most recent LOCATE condition executed in the current work
    area.  It terminates when a match is found or the end of the LOCATE
    scope is reached.

    If the CONTINUE is successful, the matching record becomes the current
    record and FOUND() returns true (.T.).  If it is unsuccessful, FOUND()
    always returns false (.F.) and the positioning of the record pointer
    depends on the controlling scope of the pending LOCATE.

    Each work area may have an active LOCATE condition.  In Clipper, a
    LOCATE condition remains pending until a new LOCATE condition is
    specified.  No other commands release the condition.
!Seealso:"LOCATE"  
!Short: COPY           Copies database file in USE to a new file.
^BCOPY^B

    COPY duplicates all or part of an active database file to a new file.

^USyntax^U

    COPY TO <file>/(<expC1>) [<scope>] [FIELDS <fields list>]
    [FOR <condition>] [WHILE <condition>] [SDF/DELIMITED/DELIMITED WITH
    <delimiter>/(<expC2>)]

^UArguments^U

    <file> is the name of the new file.  If no type clause is specified,
    (.dbf) is the default file type and no extension is necessary.  If
    there is a type clause specified, the file extension is assumed to be
    (.txt) unless specified.

^UOptions^U

    ^BFields^B: The FIELDS clause specifies the list of fields to copy to
    the target database file.  The default is all fields.

    ^BScope^B: The <scope> is the portion of the current database file to
    COPY.  The default is ALL.

    ^BCondition^B: The FOR clause specifies the conditional set of records
    to COPY within the given scope.  The WHILE clause specifies the set of
    records meeting the condition from the current record until the
    condition fails.

    ^BSDF^B: The SDF clause specifies the output file type as a System Data
    Format ASCII file.  Records are fixed length, each separated by a
    carriage return/line feed pair.  Fields are fixed length and there is
    no field separator.  Character fields are padded with trailing blanks,
    numeric fields are padded with leading blanks, date fields are written
    in the form "yyyymmdd," and logical fields are written in the form T/F.
    The end-of-file mark is Ctrl-Z (1A hex).

    ^BDelimited^B: The DELIMITED clause specifies the output file type as a
    DELIMITED ASCII file.  Records are variable length, each separated by a
    carriage return/line feed pair.  Fields are variable length and
    separated by commas.  Character fields are bounded by delimiters (the
    double quote mark is the default unless you specify a different
    character using the WITH clause).  Leading and trailing spaces for
    numeric and character fields are truncated, date fields are written in
    the form "yyyymmdd," and logical fields are written in the form T/F.
    Ctrl-Z (1A hex) is the end-of-file mark.

    ^BNote^B: DELIMITED WITH BLANK, DIF, SYLK, and WKS file type options
    are not supported in addition to the TYPE keyword.

^UUsage^U

    All records contained in the active database file are copies unless
    limited by a scope or FOR/WHILE clause.  Records marked for deletion
    will be copied unless DELETED is ON or a FILTER has been SET.

^UNetwork^U

     When you COPY in a network environment, Clipper opens the target
     database file EXCLUSIVE.
!Seealso:"APPEND FROM"  "COPY FILE"  "COPY STRUCTURE"  "SET DELETED"  
!Short: COPY FILE      Duplicates any closed file.
^BCOPY FILE^B

    COPY FILE creates a duplicate of any closed file.

^USyntax^U

    COPY FILE <file1>.<ext>/(<expC1>) TO <file2>.<ext>/(<expC2>)

^UArguments^U

    <file1> is the name of the source file to COPY including the extension.

    <file2> is the name of the target file including the extension.

^UUsage^U

    COPY FILE copies files from the Clipper default drive and directory.
!Seealso:"CLOSE"  "COPY"  "SET DEFAULT"  "USE"  
!Short: COPY STRUCTURE Creates empty database with fields from current database.
^BCOPY STRUCTURE^B

    To create an empty database file with field definitions from the
    current database file.

^USyntax^U

    COPY STRUCTURE TO <file>/(<expC1>) [FIELDS <fields list>]

^UArguments^U

    <file> is the target database file.  The default extension is (.dbf)
    unless another is specified.

^UOptions^U

    ^BFields^B: The <field list> is the set of fields to COPY to the new
    database structure in the order specified.  The default is all fields.
!Seealso:"COPY STRUCTURE EXTENDED"  "CREATE"  
!Short: COPY STRUCTURE EXTENDED  Creates database filled with field definitions.
^BCOPY STRUCTURE EXTENDED^B

    To create a database file whose contents are the field definitions of
    the current database file.

^USyntax^U

    COPY TO <file>/(<expC1>) STRUCTURE EXTENDED [FIELDS <fields list>]

^UArguments^U

    <file> is the name of the structure extended database file.

^UOptions^U

    ^BFields^B: The <field list> is one or more fields in the current
    database file whose definitions will appear in the new database file as
    records in the order specified.

^UUsage^U

    COPY STUCTURE EXTENDED creates a database file with four fields:
    Field_name, Field_type, Field_len, and Field_dec.  The structure
    extended file contains the structure of the current database file with
    a record for the definition of each field.

    Used in application programs this permits you to create or modify the
    structure of a database file programmatically.  To create a new
    database file from the structure extended file, use CREATE FROM.  If
    you only need an empty structure extended file, use CREATE.
!Seealso:"CREATE"  "CREATE FROM"  "TYPE()"  
!Short: COUNT          Counts and displays # of records for specified criteria.
^BCOUNT^B

    COUNT tallies the number of records in the current work area to a
    memory variables within the specified scope and specified conditions.

^USyntax^U

    COUNT [<scope>] [FOR <condition>] [WHILE <condition>] TO <memvar>

^UArgument^U

    <memvar> is a memory variable assigned the COUNT result.  If the
    variable does not exist or is not numeric type, COUNT creates it as
    numeric.

^UOptions^U

    ^BScope^B: The <scope> is the portion of the current database file to
    COUNT.  The default is ALL.

    ^BCondition^B: The FOR clause specifies the conditional set of records
    to COUNT within the given scope.  The WHILE clause specifies the set of
    records meeting the condition from the current record until the
    condition fails.
!Seealso:"AVERAGE"  "SUM"  "TOTAL"  CLIP002.NGO:"LASTREC()"  
!Short: CREATE         Creates an empty structure extended database file.
^BCREATE^B

    To create an empty structure extended database file.

^USyntax^U

    CREATE <file>/(<expC>)

^UArgument^U

    <file> is the name of the empty structure extended file.

^UUsage^U

    Like COPY STRUCTURE EXTENDED, CREATE produces a structure extended file
    with four fields: Field_name, Field_type, Field_len, and Field_dec and
    can be used in conjunction with CREATE FROM to form a new database
    files.  Unlike COPY STRUCTURE EXTENDED, CREATE produces an empty
    database file and does not require the presence of another database
    file to create it.
!Seealso:"CREATE FROM"  "COPY STRUCTURE EXTENDED"  
!Short: CREATE FROM    Creates new database file from a structure extended file.
^BCREATE FROM^B

    To create a new database file from an structure extended file.

^USyntax^U

    CREATE <file1>/(<expC1>) FROM <file2>/(<expC2>)

^UArgument^U

    <file1> is the name of the new database file to create from the
    structure extended file (<file2>).  The field definitions in the new
    database file are taken from the records of <file2>.

    <file2> is the name of a structure extended file to use as the
    structure definition for the new database file.

^UUsage^U

    CREATE FORM produces a new database file with the field definitions
    taken from the contents of a structure extended file.  To qualify as a
    structure extended file, a database file must contain the following
    four fields:

    Field     Name             Type          Length    Decimals
      1       Field_name       Character       10
      2       Field_type       Character        1
      3       Field_len        Numeric          3         0
      4       Field_dec        Numeric          3         0

    ^BData dictionaries^B: For data dictionary applications, you can have
    any number of other fields within the structure extended file to
    describe the extended field attributes.  You may, for example, want to
    have fields to describe such field attributes as a description, key
    flag, label, color, picture, and a validation expression for the VALID
    clause.  When you CREATE FROM, Clipper creates the new database file
    from the required fields only.  All other fields in the extended
    structure are ignored.  Moreover, Clipper is not sensitive to the order
    of the required fields.

    ^BField lengths greater than 999^B: It is possible to create a
    character field greater than 999 characters by specifying the Field_dec
    equal to the INT() of the desired length divided by 256 and the
    Field_len equal to the remainder of the length divided by 256.
!Seealso:"COPY STRUCTURE EXTENDED"  "CREATE"  
!Short: DECLARE        Creates an array.
^BDECLARE^B

^UPurpose^U

    To create one or more memory variable arrays.

^USyntax^U

    DECLARE <array name> [<exp N>] [,<array list>]

^UArguments^U

    <array> is the name of an array to create.  Note that you can create
    more than one array with a single DECLARE statement.

    <expN> is the number of elements in the array up to a maximum of 4096.
    An array DECLAREd with less than one element defaults to one; more than
    4096 elements defaults to 4096.

    ^BNote^B: The square brackets surrounding <expN> are a required part of
    the command syntax and in this case do not signify an optional
    argument.

^UUsage^U

    DECLARE creates single dimensional private arrays whose scope is the
    current procedure.  At the same time, PUBLIC and private arrays created
    in higher-level procedures with the same name are hidden.  An array
    uses one memory variable slot of the allotted memory variables.

    Unlike memory variables, arrays and array elements cannot be saved in
    (.mem) files.

    To assign a value to an array element, use the assignment operator (=)
    or the STORE command.  To STORE a value to an entire array, use
    AFILL().  To retrieve a value from an array, refer to the element using
    a subscript indicating its position in the array.

    To determine the number of elements in an array, use LEN() by
    specifying only the array name as the function argument.

    The LEN() function may be used to return the number of elements in an
    array, if the array name is the only parameter specified in the
    function.

    ^BData types^B: Elements within the same array can be mixed type and
    obey all the typing rules of ordinary memory variables.  The TYPE()
    function returns an "A" for an array reference and the data type of an
    element if the reference includes the subscript.

    ^BUse within macro variables^B: References to arrays and array elements
    can be made with macro variables with one exception: the brackets
    cannot be in a macro variable when DECLAREing the array.  Note,
    however, that you cannot use or expand an array element as a macro
    variable.  If you wish to use an array element in a macro, assign the
    contents of the array element to a memory variable and then use the
    memory variable as the macro variable.  For example:

    ^RDECLARE fields[FLDCOUNT()]^R
    ^RAFIELDS(fields)           ^R
    ^Rfld_name = fields[1]      ^R
    ^R? &fld_name               ^R

    ^BPassing parameters^B: Array and array elements can be passed as
    parameters to Clipper procedures, user_defined functions, and external
    procedures that use the Extend System.  Arrays are passed by reference
    and array elements are passed by value.  You cannot, however, pass
    entire arrays to external procedures using the CALL command.  In this
    case, you can only pass array elements one at a time.

    ^BPUBLIC arrays^B: To create PUBLIC arrays, use the PUBLIC statement.
    Note that PUBLIC arrays follow all the same rules as private arrays
    with the exception of the scope which is all procedures.  See PUBLIC
    for more information.
!Seealso:"PUBLIC"  
!Short: DELETE         Marks records for deletion.
^BDELETE^B

    DELETE marks records in the active database file for deletion.

^USyntax^U

    DELETE [<scope>] [FOR <condition>] [WHILE <condition>]

^UOptions^U

    ^BScope^B: The <scope> is the portion of the current database file to
    DELETE.  If a scope is not specified, DELETE acts only on the current
    record.  If a condition is specified the default scope becomes ALL.

    ^BCondition^B: The FOR clause specifies the conditional set of records
    to DELETE within the given scope.  The WHILE clause specifies the set
    of records meeting the condition from the current record until the
    condition fails.

^UUsage^U

    DELETE tags records so they can be filtered with SET DELETED ON,
    queried with DELETED(), and physically removed from the database file
    with PACK.  In addition, display commands such as LIST and DISPLAY
    identify deleted records with an asterisk (*).  Once records are
    deleted, you can reinstate them by using RECALL.  If you need to remove
    all records from a database file, use ZAP instead of DELETE ALL and
    PACK.

^UNetwork^U

    In a network environment, DELETE requires the current record be locked
    with RLOCK() if you are DELETEing a single record.  If you are
    DELETEing several records the current database file must be locked with
    FLOCK() or USEd EXCLUSIVEly.
!Seealso:"PACK"  "RECALL"  "SET DELETED"  "ZAP"  
!Short: DIR            To display a listing of files from the specified path.
^BDIR^B

    To display a listing of files from the specified path.

^USyntax^U

    DIR [<drive>] [<path>] [<skeleton>]

^UOptions^U

    ^BSkeleton^B: The <skeleton> is a standard wildcard (* and ?) notation
    for files.  If specified, DIR displays all matching files.  If not
    specified, DIR displays a list of database (.dbf) files.

^UUsage^U

    DIR displays two formats of listing depending on whether you specify a
    <skeleton>.  Not specifying a skeleton displays a standard listing of
    database files from the current directory and includes the database
    filename, date of last update, and number of records.  Specifying a
    skeleton displays a list of files including filename, extension, number
    of bytes, and date of last update.

    To create applications where you present directory information to the
    user, use ADIR() instead of DIR.  ADIR() allows you to fill a number of
    arrays with the attributes of files.  Then with these arrays you can
    create any kind of file selection or display menu.
!Short: DISPLAY        Displays records and fields in table form.
^BDISPLAY^B

    To display the result of one or more expressions for each record
    processed.

^USyntax^U

    DISPLAY [OFF] [<scope>] <exp list> [FOR <condition>]
    [WHILE <condition>] [TO PRINT] [TO FILE <file>/(<expC>)]

^UArgument^U

    <exp list> is the list of values displayed for each record processed.

^UOptions^U

    ^BScope^B: The <scope> is the portion of the current database file to
    DISPLAY.  The default is the current record.  If a condition is
    specified the scope becomes ALL.

    ^BCondition^B: The FOR clause specifies the conditional set of records
    to DISPLAY within the given scope.  The WHILE clause specifies the set
    of records meeting the condition from the current record until the
    condition fails.

    ^BOff^B: The OFF clause suppresses the display of the record number.

    ^BPrint^B: The TO PRINT clause echoes output to the printer.

    ^BFile^B: The TO FILE clause echoes output to the specified filename.
    If an extension is not specified, (.txt) is added.

^UUsage^U

    DISPLAY sends the results of the <exp list> to the screen in a tabular
    format, each column separated by a space.  Unlike other dialects,
    however, it does not display column headers or pause every 15 records.
    In fact, DISPLAY is identical to LIST with the exception that its
    default scope is NEXT 1 rather than ALL.

    To interrupt a DISPLAY, use INKEY() as a part of the condition such as:

    ^RDISPLAY Branch, Salesman, Amount FOR INKEY() <> 27^R
!Seealso:"LIST"  
!Short: DO             Executes a procedure.
^BDO^B

    To execute a procedure.

^USyntax^U

    DO <procedure> [WITH <parameter list>]

^UArguments^U

    <procedure> is the name of the procedure to execute.  This can be a
    procedure written in Clipper, C, or assembly language.

^UOption^U

    ^BWith^B: Specifies a <parameter list> of up to 128 items allowing you
    to pass memory variables or the results of expressions as parameters.
    Memory variables can either be passed by reference or value.

^UUsage^U

    ^BPassing parameters^B: Using the WITH clause passes parameters to the
    specified procedure evaluating each expression before branching.  To
    optionally capture the passed parameters in a Clipper procedure, there
    must be a PARAMETERS statement followed by the list of variables to
    receive the passed references or values.  If the passed parameter is an
    expression, field, or memory variable bounded by parentheses, it is
    evaluated and its value passed to the called procedure.  If the
    parameter is a memory variable not bounded by parentheses, it is passed
    by reference and any changes to the receiving variable are reflected in
    the source variable when the calling procedure terminates.  Note that
    fields can only be passed by value and not be reference.

    See PARAMETERS for a more detailed discussion of passing parameters.

    ^BCompiling^B: When Clipper encounters a DO statement and the specified
    procedure is not already known, it searches the current directory for a
    (.prg) file  with the same name and compiles it if it is found.
    Otherwise the called procedure is assumed to be an external.  Note that
    when you link, the linker will expect to resolve this external
    reference.
!Seealso:"PARAMETERS"  "PRIVATE"  "PROCEDURE"  "PUBLIC"  "RETURN"  "SET PROCEDURE"  
!Short: DO CASE        Sets up structure for executing one of several blocks.
^BDO CASE^B

    DO CASE is a structured programming command that selects only one
    course of action from a set of alternatives.

^USyntax^U

    DO CASE
       CASE <condition>
           <commands>
       [CASE <condition>]
           <commands>
       [OTHERWISE]
           <commands>
    ENDCASE

^UUsage^U

    ENDCASE terminates the DO CASE structure.  Command pairs such as DO
    CASE...ENDCASE, IF...ENDIF, and DO WHILE...ENDDO must be properly
    nested within DO CASE.  Nested DO CASEs are permitted.  There are no
    nesting limits within the DO CASE structure.

    CASE <condition> sets up a conditional statement for evaluation.  It is
    a logical expression such as A=B or numvar<11.  When <condition>
    evaluates to logical True, all subsequent commands are carried out
    until any one of the following commands is reached: another CASE,
    OTHERWISE, or ENDCASE.

    After one True CASE is found and its associated commands are processed,
    no further CASE statements are evaluated.  Program control will skip
    immediately to the first command after ENDCASE.  If no CASE statements
    evaluate to True, and there is no OTHERWISE statement, the program
    processes the first command following ENDCASE.  OTHERWISE causes the
    program to take an alternative path of action when all CASE statements
    evaluate to False.

    Note that like all other control structures, only the first three
    characters of the END statement are significant.

^UTips^U

    In instances where only one of many conditions will evaluate to True,
    or where only the first True instance is to be processed, the DO CASE
    command is preferable to the IF command.

    The CASE construction is often used when there are a small number of
    exceptions to a condition.  The CASE <condition> statements can
    represent the exceptions, and the OTHERWISE statement the more common
    situation.
!Seealso:"DO"  "DO WHILE"  "IF"  
!Short: DO WHILE       Executes a structured loop in programs.
^BDO WHILE^B

    DO WHILE is a structured programming command that allows command
    statements between it and its associated ENDDO to be repeated as long
    as the specified condition is True.

^USyntax^U

    DO WHILE <condition>
       <commands>
       [EXIT]
       <commands>
       [LOOP]
       <commands>
    ENDDO

^UOptions^U

    ^BExit^B: The EXIT statement unconditionally branches control from
    within a DO WHILE structure to the command immediately following the
    ENDDO.  This option is used generally when you want to terminate a DO
    WHILE structure based on an intermediate and not the DO WHILE
    condition.

    ^BLoop^B: The LOOP statement branches control to the last executed DO
    WHILE command line.  Looping is generally used where you want to
    prevent execution of statements within a DO WHILE based on an
    intermediate condition and branch immediately back to the DO WHILE
    command line.

^UUsage^U

    ENDDO must terminate a DO WHILE structure.

    DO WHILE <condition> opens a structured procedure that processes
    subsequent commands only while the condition evaluates to True.

    If <condition> evaluates to a logical True, all subsequent commands are
    carried out until an ENDDO, LOOP, or EXIT is encountered.  ENDDO and
    LOOP return control to the DO WHILE command for another evaluation of
    <condition>.  EXIT passes control to the statement following the ENDDO.

    If the condition evaluates to a logical False, all commands between DO
    WHILE and ENDDO will be skipped and program control will go to the
    command following ENDDO.

    ^BMacros^B: Macro variables can comprise all or part of the DO WHILE
    condition without limitation.

    Note that like all other control structures, only the first three
    characters of the END statement are significant.
!Seealso:"FOR..NEXT"  "IF"  "LIST"  "RETURN"  
!Short: EJECT          Causes printer to advance the paper to top of next page.
^BEJECT^B

    EJECT causes the printer to advance the paper to the top of the next
    page.

^USyntax^U

    EJECT

^UUsage^U

    EJECT issues a form feed (ASCII character value of 12) to the printer.
    For proper printer operation, the paper must initially be set to the
    top-of-form.  Refer to your printer manual for instructions on how to
    set top-of-form.

    If  you need to reset the internal printer row and column values to
    zero without sending a form-feed, use SETPRC().
!Seealso:CLIP002.NGO:"SETPRC()"  
!Short: ERASE          Deletes files from the directory.
^BERASE/DELETE FILE^B

    ERASE removes a file from the disk.

^USyntax^U

    ERASE/DELETE FILE <filename>.<ext>

^UArgument^U

    <file> is the name of the file, including extension, to be deleted from
    disk.

        
                                                                    
           ^BWarning^B: Files must be CLOSEd before ERASEing them.      
                                                                    
        
!Seealso:CLIP006.NGO:"CLOSE"  "USE"  
!Short: EXTERNAL       Declares a symbol for the CLIPPER linker.
^BEXTERNAL^B

    EXTERNAL is used to declare a symbol for the linker.

^USyntax^U

    EXTERNAL <procedure list>

^UArgument^U

    <procedure list> is the list of procedures, user-defined functions, and
    format files to add to the symbol table.

^UUsage^U

    Procedures, user-defined functions, and SET KEY procedures must be
    declared EXTERNAL if they are called with a macro or placed in
    overlays.
!Short: FIND           Points to next record matching specified string/value.
^BFIND^B

    FIND searches an indexed database file for the first record with an
    index key that matches the specified character string or number.  FIND
    conducts a very rapid record search.

^USyntax^U

    FIND <character string>/(<expC>)

^UArgument^U

    <character string> is all or part of the index key of a record you are
    searching for.  if an expression (<expC>) is specified instead of a
    literal character string, FIND operates the same as SEEK.

^UUsage^U

    FIND searches the controlling index starting with the first key and
    proceeds until a match is found or there is a key value greater than
    the search argument.  If there is a match, the record pointer is
    positioned to the record number found in the index.  If SOFTSEEK is OFF
    (the default) and FIND does not find a record, the record pointer is
    positioned to LASTREC() + 1, EOF() returns true (.T.), and FOUND()
    returns false (.F.).  If SOFTSEEK is ON, the record pointer is
    positioned to the record with the first key value greater than the
    search argument and FOUND() returns false (.F.).  In this case, EOF()
    only returns true (.T.) if there are no keys in the index greater than
    the search argument.

    ^BLeading blanks^B: If a literal search argument has leading blanks, it
    must be delimited with quote marks and have the same number of leading
    blanks as the index key.

    ^BMacro substitution^B: The search argument can be a macro variable if
    not bounded by parentheses.  The syntax for this is &<memvar>.

    ^BNumeric keys^B: Clipper stores numeric index keys with leading zeros.
    This means that to FIND a numeric key with a literal search argument,
    you must pad it with leading zeros so there are as many digits in the
    search argument as there are whole number digits in the index key.  The
    number of decimal digits does not matter unless the number contains
    decimal values other than zero.
!Seealso:"INDEX"  "SET INDEX"  "SET ORDER"  "SET SOFTSEEK"  " LOCATE"  "SEEK"  
!Short: FOR..NEXT      Permits conventional FOR..NEXT program loop.
^BFOR...NEXT^B

    FOR...NEXT permits you to accomplish a looping operation for a range of
    expressions, where you may optionally increment or decrement the range
    expression.

^USyntax^U

    FOR <memvar> = <exp N1> to <exp N2> [STEP <exp N3>]
        <commands>...
        [EXIT]
        <commands>...
    NEXT

^UArguments^U

    <memvar> is the loop control variable.

    <expN1> is the initial value assigned to the control variable and the
    lower boundary of the looping range.

    <expN2> is the upper boundary of the looping range.

^UOptions^U

    ^BStep^B: The STEP clause sets the increment of the control variable to
    <expN3>.  If no STEP clause is specified, the default increment is one.

    ^BExit^B: The EXIT clause unconditionally branches control from within
    the FOR..NEXT control structure to the statement immediately following
    the NEXT statement.

^UUsage^U

    FOR...NEXT allows you to loop from an initial value of a control
    variable to some upper boundary moving through the range of values of
    the control variable for a specified increment (or decrement).  Each
    time the FOR statement executes, Clipper evaluates all command line
    expressions.  This means that the upper boundary and increment are
    dynamic and can change as the construct operates.

^UExample^U

    The FOR...NEXT construct is particularly useful for traversing arrays.

    ^R* to walk forward through an entire array^R
    ^Rlen_array = LEN(array)                   ^R
    ^RFOR i = 1 TO len_array                   ^R
    ^R   <commands>...                         ^R
    ^RNEXT                                     ^R
!Seealso:CLIP006.NGO:"DO CASE"  CLIP006.NGO:"DO WHILE"  "IF"  
!Short: FUNCTION       Declares user-defined functions.
^BFUNCTION^B

    FUNCTION declares user-defined functions in Clipper.

^USyntax^U

    FUNCTION <procedure>...RETURN <exp>

^UArguments^U

    <procedure> is the declared name of the user-defined function.
    Procedure and user-defined function names can be up to 10 characters in
    length.

    <exp> is the function return value.  All user-defined functions must
    return a value.

^UUsage^U

    User-defined functions are the same as procedures with two exceptions.
    They must begin with the FUNCTION declaration and contain a RETURN
    statement with an argument (in order to return a value).

    To call a user -defined function, use the same notation as you would
    when calling Clipper functions:

    ^Bfunction(<parameter list>)^B

    If you are not concerned with the return value, you can use the same
    notation to place a user-defined function on a line by itself.  In this
    case the return value is ignored.

    ^BPassing parameters^B: Parameters passed to user-defined functions are
    passed by value with two exceptions.  First, if the actual parameter is
    an array reference, the entire array is passed by reference.  Second,
    if the actual parameter is preceded by the "at" sign (@), it is passed
    by reference.

    For a more detailed discussion on passing parameters, refer to the
    entry for PARAMETERS in this chapter.
!Seealso:"PROCEDURE"  "PARAMETERS"  "RETURN"  
!Short: GO/GOTO        Points to specific record regardless of current position.
^BGO^B

    GO/GOTO positions the record pointer to a specified record in the
    active database file.

^USyntax^U

    GO/GOTO <expN>/BOTTOM/TOP

^UArgument^U

    <expN> is the specific record to move the record pointer to.  GOTO
    moves the record pointer to this record even if DELETED is ON or it
    falls outside the scope of the current filter.

^UOptions^U

    ^BBottom^B: GO/GOTO BOTTOM moves to the last logical record in the
    current work area if there is an active index or LASTREC() if there
    isn't one.  If DELETED is ON or there is an active FILTER, this is the
    last record in the filter scope.

    ^BTop^B: GO/GOTO TOP moves to the first logical record in the
    current work area if there is an active index or record 1 if there
    is no index in USE.  If DELETED is ON or there is an active FILTER,
    this is the first record in the filter scope.
!Seealso:"SKIP"  CLIP002.NGO:"LASTREC()"  CLIP002.NGO:"RECNO()"  
!Short: IF             Allows conditional execution of commands.
^BIF^B

    IF is a structured programming command that enables conditional
    processing of commands.  It must terminate with ENDIF.

^USyntax^U

    IF <condition>
       <commands>
    [ELSEIF <condition>]
       <commands>
    [ELSE]
       <commands>
    ENDIF

^UArgument^U

    <condition> is a control expression.  If it evaluates to true (.T.),
    all following commands are executed until an ELSEIF, ELSE, or ENDIF is
    encountered.

^UOptions^U

    ^BElseif^B: The ELSEIF clause identifies commands to be executed when
    the <condition> evaluates to true (.T.).  You can specify any number of
    ELSEIF statements within the same IF...ENDIF control structure.

    ^BElse^B: The ELSE clause identifies commands to be executed when the
    <condition> evaluates to false (.F.).

^UUsage^U

    IF <condition> sets up a conditional statement which is a logical
    expression such as (A=B or Numvar<11) for evaluation.  If <condition>
    evaluates to logical True, all subsequent commands are carried out
    until an ELSEIF, ELSE, or ENDIF is reached.  Program control then goes
    to the first command after ENDIF.  If no condition evalutes to true
    (.T.), control passes to the first statement following the ELSE
    statement.

    Note that IF...ENDIF structures may be nested within other IF...ENDIF
    structures and other structured programming commands.  These
    structures, however, must be properly nested.

    Note also that like all Clipper control structures, only the first
    three characters of the END statement are significant.
!Seealso:CLIP006.NGO:"DO CASE"  CLIP002.NGO:"IF()"  
!Short: INDEX          Creates an index file.
^BINDEX^B

    The INDEX command creates a file that contains an index to records in
    the current database file.

^USyntax^U

    INDEX ON <key exp> TO <file>/(<expC>)

^UArguments^U

    <key exp> is an expression that returns the key value to place in the
    index for each record in the current database file.  The maximum length
    of the index key expression is 250 characters.

    <file> is the name of the index file to create.  The default extension
    is .ntx.  If, however, you have linked NDX.OBJ in order to use dBASE
    III PLUS compatible index files, the extension is .ndx.

^UUsage^U

    When an index file is used, the database records appear in key
    expression order although the index does not alter the physical order
    of records in the database file.  This allows you to create and
    maintain many logical orders of records automatically.

    Clipper uses a variation of the b-tree indexing scheme with an index
    page size of 1024 bytes.  The (.ntx) has a header for the index to tell
    the system what the index key is, where the "top" of the three is, etc.
    In addition, Clipper keeps a pointer to the place in the file where the
    most recently discarded page is kept.  As you modify keys in an index,
    the original key is removed from its location and the new key is
    inserted elsewhere.  There are times when this will cause a page to
    become empty.  When this happens, Clipper saves the position in its
    header so that it can re-use this space when it needs to create a new
    page later on.

    ^BDeleted and filtered record^B: Records that are filtered or marked
    for deletion are included in the index.

    ^BDate indexes^B: Clipper supports date indexes for both (.ntx) and
    (.ndx) index types.  For a key expression that includes a date as a
    subset of the key, create the expression as character type and use
    DTOS() to convert the date to character.

    ^BDescending order indexes^B: To create descending order indexes or
    descending suborders, use DESCEND().  This function accepts any data
    type as its argument and returns the inverse.

    ^BCompatible index files^B: Clipper supports dBASE III PLUS compatible
    index files by linking NDX.OBJ.

    ^BUnique indexes^B: When you INDEX with UNIQUE ON, Clipper creates an
    index with uniqueness as an attribute.  As indexing proceeds and two
    or more records have the same key value, Clipper includes only the
    first record in the index.  Whenever the unique index is updated,
    REINDEXed, or PACKed, only unique records are added.  This happens
    without regard to the current UNIQUE SETting.

    Note that this differs from pre-Summer '87 versions of Clipper where
    UNIQUE was a global SETting and applied to the creation and updating of
    all open indexes.

    ^BTRIM() in key expressions^B: Index key sizes under Clipper are
    calculated by evaluating the key expression on a blank record.  The
    TRIM() of any part of a key expression that includes a field,
    therefore, always evaluates to a null string.  This can lead to a size
    mismatch between the target and the defined key length.  You can,
    however, build an index key on the TRIM() of a field as long as you pad
    the key with the number of spaces equal to the length of all the
    trimmed fields.  For example, suppose you have two fields, First and
    Last, each 20 characters in length.  You want to INDEX on the following
    expression:

    ^RTRIM(Last) + First^R

    The actual expression you INDEX ON is this:

    ^RSUBSTR(TRIM(Last) + First + SPACE(20), 1, 40)^R

    Note that using TRIM() to save space in the index file does not work.
    Clipper allocates space for keys in fixed increments and using TRIM()
    only confuses the issue.  To create smaller index files, create smaller
    fixed length keys using SUBSTR() instead.
!Seealso:CLIP006.NGO:"CLOSE"  "FIND"  "REINDEX"  "SEEK"  "SET INDEX"  "SET ORDER"  "SET UNIQUE"  "USE"  CLIP002.NGO:"INDEXEXT()"  CLIP002.NGO:"INDEXKEY()"  
!Short: INPUT          Allows input of an expression result to memory variable.
^BINPUT^B

    INPUT is used to enter an expression from the keyboard and place the
    result in a specified memory variable.

^USyntax^U

    INPUT [<prompt>] TO <memvar>

^UArgument^U

    <memvar> is the name of the memory variable where the result of the
    evaluation is placed.

^UUsage^U

    INPUT takes entry from the keyboard as an expression of any data type.
    It then evaluates it placing the result into a newly created memory
    variable of the same data type.  Pressing Return confirms entry.  If
    Return is the only key pressed, INPUT terminates but does not create
    the memory variable.  Note that Esc does not terminate INPUT.

    Entering an invalid expression generates a runtime error.
!Seealso:CLIP006.NGO:"ACCEPT"  "WAIT"  
!Short: JOIN           Creates a new database by merging records from two areas.
^BJOIN^B

    To create a new database file by merging selected records and fields
    from two work areas.

^USyntax^U

    JOIN WITH <alias>/(<expC1>) TO <file>/(<expC2>) FOR <condition>
    [FIELDS <field list>]

^UArgument^U

    <alias> is the work area to merge with records from the current work
    area.

    <file> is the name of the target database file.

^UOptions^U

    ^BFor^B: The FOR <condition> selected only records meeting the
    specified condition.

    ^BFields^B: The <field list> is the projection of fields from both work
    areas into the new database file.  To specify any fields in the
    secondary work area, reference them with the alias.  if the FIELDS
    clause is not specified, all fields from the primary work area will be
    included in the target database file.

^UUsage^U

    JOIN is a project of fields and a selection of records from two work
    areas that forms a new database file based on a general condition.
    JOIN works by making a complete pass through the secondary work area
    for each record in the primary work area evaluating the condition for
    each record processed in the secondary work area.  When the condition
    is true (.T.), a new record is created in the target database file.

    Note that the number of records processed will be the RECCOUNT() of the
    primary work area times the RECCOUNT() of the secondary work area.  For
    example, if you have two database files with 100 records each, the
    number of records JOIN processes is the equivalent of sequentially
    processing a single database file of 10,000 records.  All of which
    necessitates the maxim, "use this command with prudence."
!Seealso:CLIP006.NGO:"APPEND FROM"  "REPLACE"  "SET RELATION"  
!Short: KEYBOARD       Stuffs the keyboard input buffer with specified string.
^BKEYBOARD^B

    KEYBOARD stuffs the keyboard input buffer with the given string.  Each
    execution of KEYBOARD flushes the type-ahead buffer.  Multiple keyboard
    commands cannot be used to queue multiple strings.  However, KEYBOARD
    "" can be used to clear the buffer.

^USyntax^U

    KEYBOARD <exp C>

^UUsage^U

    KEYBOARD is used in combination with commands and functions that expect
    keyboard input as data and control information.  These can be wait
    states such as ACCEPT, INPUT, and READ. or interface functions such as
    ACHOICE() and DBEDIT().

    As a typical example, you can use KEYBOARD from within a SET KEY
    procedure to reassign keys in a wait state.  Another use is within the
    ACHOICE() user function.  here you KEYBOARD the keys you want ACHOICE()
    to execute before returning control to it.  The same concept applies to
    the DBEDIT() user function.

    Each execution of KEYBOARD clears the keyboard buffer.
!Seealso:"SET KEY"  CLIP002.NGO:"LASTKEY()"  CLIP002.NGO:"NEXTKEY()"  
!Short: LABEL FORM     To display labels from a definition held in a .lbl file.
^BLABEL FORM^B

    To display labels from a definition held in a (.lbl) file.

^USyntax^U

    LABEL FORM <file1>/(<expC1>) [<scope>] [FOR <condition>]
    [WHILE <condition>] [SAMPLE] [TO PRINT] [TO FILE <file2>/(<expC2>)]

^UArgument^U

    <file1> is the name of the (.lbl) file that contains the FORM
    definition of the LABEL.  If the extension is not specified (.lbl) is
    assumed.

^UOptions^U

    ^BScope^B: The <scope> is the portion of the current database file to
    display labels.  The default is ALL.

    ^BCondition^B: The FOR clause specifies the conditional set of records
    to LABEL FORM within the given scope.  The WHILE clause specifies the
    set of records meeting the condition from the current record until the
    condition fails.

    ^BPrint^B: The TO PRINT clause echoes output to the printer.

    ^BFile^B: The TO FILE clause echoes output to the specified filename,
    <file2>.  If an extension is not specified, (.txt) is added.

    ^BSample^B: The SAMPLE clause displays test labels as rows of
    asterisks.  Each test label has the same number of columns and rows as
    the label definition.  Then following each test label display is the
    query, "Do you want more samples?"  Answering "Y" repeats the display
    of the test label.  Answering "N" causes LABEL FORM to display the
    actual labels for the specified scope and condition.

^UUsage^U

    LABEL FORM displays labels using a definition stored in a (.lbl) file.
    The .lbl file can be created using RL.EXE, which is provided with the
    Clipper distribution diskettes.

    The contents of a LABEL field must be a valid expression.  Note that
    Clipper does not support an expression list in the LABEL FORM contents.
    Anything following a comma in a LABEL FORM is ignored.
!Seealso:"REPORT FORM"  
!Short: LIST           Lists records and fields in table form.
^BLIST^B

    To LIST the result of one or more expressions for each record
    processed.

^USyntax^U

    LIST [OFF] [<scope>] <exp list> [FOR <condition>]
    [WHILE <condition>] [TO PRINT] [TO FILE <file>/(<expC>)]

^UArgument^U

    <exp list> is the list of values displayed for each record processed.

^UOptions^U

    ^BScope^B: The <scope> is the portion of the current database file to
    LIST.  The default is the current record.  If a condition is specified
    the scope becomes ALL.

    ^BCondition^B: The FOR clause specifies the conditional set of records
    to LIST within the given scope.  The WHILE clause specifies the set of
    records meeting the condition from the current record until the
    condition fails.

    ^BOff^B: The OFF clause suppresses the display of the record number.

    ^BPrint^B: The TO PRINT clause echoes output to the printer.

    ^BFile^B: The TO FILE clause echoes output to the specified filename.
    If an extension is not specified, (.txt) is added.

^UUsage^U

    LIST sends the results of the <exp list> to the screen in a tabular
    format, each column separated by a space.  LIST is identical to DISPLAY
    with the exception that its default scope is ALL rather than NEXT 1.

^UExamples^U

    One of the unique uses for LIST in Clipper is to provide the record
    movement, scope, condition, and end-of-file boundary tests for a
    procedure that traverses a database file.  The procedure itself only
    processes the current record.  In the example below, Report() operates
    only on the current record:

    ^RUSE Sales                         ^R
    ^RSET DEVICE TO PRINT               ^R
    ^RLIST Report() FOR Branch = "100"  ^R
    ^RSET DEVICE TO SCREEN              ^R
    ^R                                  ^R
    ^RFUNCTION Report                   ^R
    ^R@ PROW() + 1, 3 SAY Branch        ^R
    ^R@ PROW() + 1, COL() + 1 SAY Branch^R
    ^R@ PROW() + 1, COL() + 1 SAY Amount^R
    ^RRETURN ""                         ^R

    To interrupt a LIST, use INKEY() as a part of the condition such as:

    ^RDISPLAY Branch, Salesman, Amount FOR INKEY() <> 27^R
!Seealso:CLIP006.NGO:"DISPLAY"  
!Short: LOCATE         Points to next record matching a specified condition.
^BLOCATE^B

    LOCATE searches the active database file for a record that satisfies
    specified criteria.

^USyntax^U

    LOCATE [<scope>] [FOR <condition>] [WHILE <condition>]

^UDefaults^U

    Unless otherwise restricted by the scope or a WHILE clause, LOCATE
    searches the entire database beginning with the first record.

^UUsage^U

    The NEXT <n> option for the scope limits the search to the specified
    number of records and begins the search at the current record.

    To find the next occurrences of the specified condition, use the
    CONTINUE command.

 ^URecord Pointer^U

    If a match is found, the record pointer moves to that record and
    displays the record number.  FOUND() returns .T.

    If no match is found, the record pointer moves to the end of the file
    (EOF() is .T.) or the end of the scope if one was specified.  The
    message ^BEnd of locate scope^B will be displayed.  FOUND() returns .F.

^USpecial Cases^U

    Unless the scope is NEXT <n>, REST, or WHILE, LOCATE starts searching
    at the beginning of the file.  If there are multiple LOCATEs, the most
    recent overrides any other.

    LOCATE and CONTINUE are specific to the work area in which they are
    issued.  You can have a different LOCATE/CONTINUE for each work area.
    If you leave the work area, they will still be in effect when you
    return.
!Seealso:CLIP006.NGO:"CONTINUE"  "FIND"  "SEEK"  CLIP002.NGO:"STRTRAN()"  
!Short: MENU TO        Highlights @..PROMPT, places selection value in memvar.
^BMENU^B

    To execute a light-bar menu for the currently defined set of PROMPTs.

^USyntax^U

    MENU TO <memvar>

^UArgument^U

    <memvar> is where MENU TO places the result of the selection process.
    If the memory variable does not exist, MENU TO creates it as numeric
    type.  If it does exist, MENU TO uses it to determine the currently
    highlighted choice in the list of pending PROMPTs.

^UUsage^U

    MENU TO is the selection mechanism for the Clipper light-bar menu
    system.  Before executing it, paint the display of menu pads and define
    the associated MESSAGEs with a series of @...PROMPT statements.  Then
    invoke it with MENU TO <memvar>.  If the <memvar> does not exist, MENU
    TO creates it and places the highlight on the first PROMPT.  If it does
    exist, its value determines the first PROMPT highlighted.

    ^BNavigation and Selection^B: Pressing the arrow keys moves the
    highlight to the next or previous PROMPTs.  As each PROMPT is
    highlighted the associated MESSAGE displays on the row specified with
    SET MESSAGE.  If WRAP is ON, an Uparrow from the first PROMPT moves the
    highlight to the last PROMPT.  Likewise a Dnarrow from the last PROMPT
    moves the highlight to the first prompt.  To make a selection, press
    Return or the first character of a PROMPT.  MENU TO then returns the
    position of the selected PROMPT as a numeric value into the specified
    memory variable.  Pressing Esc terminates the menu without making a
    choice and returns zero.  The following table summarizes the active
    keys within MENU TO:

    ^UKey^U            ^UAction^U

    Uparrow        Previous Prompt
    Dnarrow        Next Prompt
    Home           First Prompt
    End            Last Prompt
    Leftarrow      Previous Prompt
    Rightarrow     Next Prompt
    PgUp           Select PROMPT, returning position
    PgDn           Select PROMPT, returning position
    Return         Select PROMPT, returning position
    Esc            Abort selection, returning zero
    First letter   Select first PROMPT with same first letter

    ^BSET KEY procedures^B: MENU TOs can be nested within SET KEY
    procedures without clearing the pending PROMPTs (unlike GET/READ).
    However, if the same memory variable is used for nested menus, it
    retains the previous value unless it is declared PRIVATE in the SET KEY
    procedure.  Therefore it is recommended that a different <memvar> be
    used for each menu.  When you are in a SET KEY procedure, you can
    access the name of the return memory variable using READVAR().  This is
    useful as status information or to stuff a new PROMPT position into the
    calling menu.

    A maximum of 32 PROMPTS per menu are allowed.
!Seealso:CLIP006.NGO:"@...PROMPT"  "SET MESSAGE"  "SET WRAP"  CLIP002.NGO:"ACHOICE()"  
!Short: NOTE/*         Inserts non-executing comments within a program file.
^BNOTE/*/&&^B

    NOTE, an asterisk (*), or double ampersand (&&) characters are used to
    indicate comment lines within a program.

^USyntax^U

    NOTE/* <text> and [<command>] &&<text>

^UUsage^U

    If a NOTE/* line ends with a semicolon, the next line will be read as
    part of the comment line.

    To insert comments on the same line as a command, use && after the
    command and before the comment.  You may also use && at the beginning
    of a line.
!Short: PACK           Removes records marked for deletion.
^BPACK^B

    PACK physically removes records that are marked for deletion from the
    active database file.

^USyntax^U

    PACK

^UUsage^U

    All open index files are automatically REINDEXed.

    After you execute a PACK command, the disk space used by the deleted
    records is reclaimed when the file is closed.  Note that PACK does not
    create a backup file or use any temporary files.  All file operations
    are internal to the current database file.
!Seealso:CLIP006.NGO:"DELETE"  "RECALL"  "REINDEX"  "SET DELETED"  "ZAP"  
!Short: PARAMETERS     Allows variables to be passed to other procedures.
^BPARAMETERS^B

    PARAMETERS identifies memory variables that receive passed values or
    references.

^USyntax^U

    PARAMETERS <parameter list>

^UArgument^U

    <memvar list> is one or more receiving memory variables separated by
    commas.  The number of receiving variables does not have to match the
    number of parameters passed.

^UUsage^U

    Parameters are defined as either format or actual.  Formal parameters
    are the receiving memory variables specified as arguments of the
    PARAMETERS statement.  Actual parameters are the arguments of the
    calling DO...WITH or user-defined function.

    There are two methods of passing parameters, by value or by reference.
    By value means that the actual parameter is evaluated and the result is
    placed in a memory location.  When the subsequent PARAMETERS executes,
    the value is transferred to the receiving variable.  Passing by
    reference, by contrast, means that a pointer to the location of the
    actual parameter is passed instead of the value.  Subsequent changes to
    the formal parameter are actually changes to the actual parameter,
    hence the term passing by reference.

    Note that in Clipper there is no argument checking and therefore no
    requirement that the number of actual parameters match the number of
    formal parameters.  To determine the number of actual parameters passed
    use PCOUNT().

    ^BPassing parameters to procedures and user-defined functions^B: The
    following rules apply when you pass memory variables and arrays to
    procedures and user-defined functions:

    1.  Memory variables and array identifiers are passed by reference to
        procedures.  Array elements, expressions, variables within
        parentheses, and fields are passed by value (fields must be bounded
        by parentheses).

    2.  Parameters are passed by value to functions by default; however,
        they can be passed by reference if the variable is preceded by the
        "at" sign (@).  Arrays are always passed by reference; array
        elements can only be passed by value.

    ^BPassing parameters from the DOS command line^B: You can pass multiple
    character strings to your program from the DOS command line.  The
    character strings must be separated by spaces.  A parameter bounded by
    quotes is passed as one string.  For example:

    ^RC>PROG "CLIPPER COMPILER" 5

    The routine that receives parameters from the DOS command should test
    the number of passed parameters with PCOUNT() to assure that critical
    parameters are defined.
!Seealso:CLIP006.NGO:"DO"  "PRIVATE"  "PROCEDURE"  "PUBLIC"  "SET PROCEDURE"  CLIP002.NGO:"PCOUNT()"  
!Short: PRIVATE        Hides memory variables/arrays in a memory variable list.
^BPRIVATE^B

    PRIVATE allows you to hide memory variables declared PUBLIC or in
    higher-level procedures from the current and lower-level
    procedures.  PRIVATE can also declare a private array and at the same
    time hide any PUBLIC array or private array of the same name from a
    higher-level procedure.

^USyntax^U

    PRIVATE <memvar list>

^UArguments^U

    <memvar list> is the list of memory variables to hide or arrays to
    declare.  The list can be any combination of memory variables and
    arrays.

^UUsage^U

    When a memory variable is declared PRIVATE in a procedure, the existing
    copy is hidden and not accessible until the declaring procedure
    terminates.  PRIVATE, unlike PUBLIC, does not create a logical
    variable.  Instead, the new variable is undefined (TYPE() will return
    "U").  Once created, the scope of the new copy is the current procedure
    and therefore automatically released when the procedure terminates.

    ^BArrays^B: In addition to declaring memory variables private, you can
    declare private arrays using the PRIVATE statement.  Declaring an array
    PRIVATE works exactly the same as making any other memory variable
    PRIVATE; PUBLIC arrays and private arrays created in higher-level
    procedures are hidden.  The array declaration using PRIVATE works the
    same as DECLARE with the exception that you can mix array and memory
    variable declarations.  For more information on arrays, see DECLARE.

    ^BNote^B: The ALL, LIKE, and EXCEPT clauses are not supported in
    Clipper.
!Seealso:CLIP006.NGO:"DECLARE"  "PARAMETERS"  "PUBLIC"  
!Short: PROCEDURE      Defines beginning of a procedure in a procedure file.
^BPROCEDURE^B

    PROCEDURE identifies the beginning of each procedure.

^USyntax^U

    PROCEDURE <procedure name>

^UUsage^U

    Each separate procedure within a procedure file must begin with the
    PROCEDURE command followed by the procedure name.  The name can be up
    to 10 characters in length and must begin with an alpha character.

    Each procedure name must be unique from all other procedures,
    functions, programs, and formats within the same application, or else
    errors in compilation or linking will occur.

    A procedure is any executable block of code beginning with the
    statement PROCEDURE <proc name> and can occur anywhere in a program
    file, but cannot be nested within other procedures.

    To terminate execution and branch back to the calling procedure,
    execute a RETURN.  Unlike FUNCTIONs, a RETURN statement is not
    required.  When compiling, Clipper assigns all statements from the
    PROCEDURE statement to the procedure name until another PROCEDURE
    statement, FUNCTION statement, or end-of-file mark (1A hex) is
    encountered.
!Seealso:CLIP006.NGO:"DO"  "SET PROCEDURE"  
!Short: PUBLIC         Makes memory variables global.
^BPUBLIC^B

    PUBLIC makes memory variables and/or arrays global by enabling them to
    be used by all procedures within a program.

^USyntax^U

    PUBLIC <memvar list>

^UArguments^U

    <memvar list> is the list of memory variables and/or arrays to declare
    PUBLIC.  If an array is specified, it is created according to the
    dimension specified.

^UOption^U

    ^BClipper^B: To include Clipper extensions in a program and still allow
    the program to run under dBASE III PLUS the special memory variable
    "clipper" is initialized to true (.T.) when declared PUBLIC.  Using
    "clipper" as the argument of an IF..ENDIF construct blocks Clipper-
    specific code so these lines of code are not executed when run under
    dBASE III PLUS.

    ^BNote^B: Compilation errors occur when the syntax of the dBASE III
    PLUS commands is not supported.  In this instance, comment out
    statements that you do not want compiled.

 ^UUsage^U

    Declaring a memory variable PUBLIC when the variable does not exist
    creates a new logical memory variable that is false (.F.).  Once
    assigned a value, its scope is global and the variable becomes
    available to all procedures within the program.  Note that you cannot
    declare an existing private variable PUBLIC.  If you do this, Clipper
    simply ignores the declaration and the memory variable retains its
    private status and scope.  Public variables, however, can be
    temporarily hidden from other procedures by declaring them PRIVATE.

    ^BArrays^B: In addition to declaring PUBLIC memory variables, you can
    declare PUBLIC arrays.  Declaring an array PUBLIC creates an array with
    the specified number of elements whose scope is all procedures in the
    current program.  Note, however, that PUBLIC array elements are
    undefined until assigned a value.

^UExample^U

    The following is an example of code using the PUBLIC memory variable
    "clipper" to allow Clipper enhancements in a program that runs under
    interpretive dBASE:

                    ^R PUBLIC Clipper            ^R
                    ^R IF clipper                ^R
                    ^R    @ 1,0,3,10 BOX "*"     ^R
                    ^R ELSE                      ^R
                    ^R    @ 1,0 say "**********" ^R
                    ^R    @ 2,0 say "*        *" ^R
                    ^R    @ 3,0 say "**********" ^R
                    ^R ENDIF                     ^R
!Seealso:CLIP006.NGO:"DECLARE"  "PARAMETERS"  "PRIVATE"  
!Short: QUIT/CANCEL    End program processing, close files, and return to OS.
^BQUIT/CANCEL^B

    QUIT/CANCEL closes all open files, terminates the program, and returns control
    to the operating system.

^USyntax^U

    QUIT/CANCEL

^UUsage^U

    QUIT or CANCEL can be used from anywhere in a program system to
    terminate and return to the operating system.  A RETURN executed at the
    highest level procedure performs the same action.
!Seealso:"RETURN"  
!Short: READ           Permits entry to fields or variables with GET.
^BREAD^B

    READ enters full-screen editing mode using the current pending GETs.

^USyntax^U

    READ [SAVE]

^UUsage^U

    READ executes full-screen editing using all GETs pending since the most
    recent CLEAR, CLEAR GETS, CLEAR ALL or READ.  If there is a FORMAT SET,
    READ passes control to it before entering full-screen edit.

    Within a READ, you can edit the contents of and navigate between GETs.
    Whenever you press a key that terminates a GET, control passes to the
    VALID clause if it has been specified.  A return value of true (.T.)
    terminates the GET and processes the navigation key.  A false (.F.)
    value does not process the navigation key.  The following keys are
    available during READ:

                          ^BFull-Screen Navigation Keys^B

    Key              Action

    Leftarrow,       Character left.  Does not move cursor to previous GET.
    Ctrl-S

    Rightarrow,      Character right.  At end of GET, moves cursor to next
    Ctrl-D           GET.

    Ctrl-Leftarrow,  Word left.
    Ctrl-A

    Ctrl-Rightarrow, Word right.
    Ctrl-F

    Uparrow,         Previous GET.
    Ctrl-E

    Downarrow,       Next GET.
    Ctrl-X, Ctrl-M,
    Return

    Home             Beginning of GET.
    End              Last character of GET.

    Ctrl-Home        Beginning of first GET.
    Ctrl-End         Beginning of last GET.

                           ^BFull-Screen Editing Keys^B

    Key              Action

    Del, Ctrl-G      Delete character at cursor position.
    Backspace        Destructive backspace.
    Ctrl-H
    Ctrl-T           Delete word right.
    Ctrl-Y           Delete from cursor position to end of GET.
    Ctrl-U           Restore current GET to original value.

                             ^BFull-Screen Mode Keys^B

    Key              Action

    Ins, Ctrl-V      Toggle insert mode.

                           ^BFull-Screen Mode Keys^B

    Key              Action

    Ins, Ctrl-V      Toggle insert mode.


                          ^BFull-Screen Escape Keys^B

    Key              Action

    Ctrl-W,          Terminate READ saving current GET.
    Ctrl-C,
    PgUp,
    PgDn

    Return, Ctrl-M   Terminate READ from last GET.

    Esc              Terminate READ without saving current GET.

    READ clears all GETs after you finish editing.

^UOptions^U

    ^BSave^B: The SAVE option does not clear GETs.  This means that the
    next time you issue READ, the same set of GETs appears for editing.
!Seealso:CLIP006.NGO:"@...SAY...GET"  CLIP006.NGO:"CLEAR GETS"  "SET FORMAT"  CLIP002.NGO:"LASTKEY()"  
!Short: RECALL         Unmarks records marked for deletion.
^BRECALL^B

    RECALL reinstates records that are marked for deletion in the active
    database file.

^USyntax^U

    RECALL [<scope>] [FOR <condition>] [WHILE <condition>]

^UOptions^U

    ^BScope^B: The <scope> is the portion of the current database file to
    RECALL.  The default scope is the current record.  If a condition is
    specified the scope becomes ALL.

    ^BCondition^B: The FOR clause specifies the conditional set of records
    to RECALL within the given scope.  The WHILE clause specifies the set
    of records meeting the condition from the current record until the
    condition fails.

^UUsage^U

    If DELETED is ON, RECALL only reinstates the current record or a
    specific record if you specify the RECORD scope.

^UNetwork^U

    In a network environment, RECALL requires the current record be locked
    with RLOCK() if you are RECALLing a single record; the current database
    file be locked with FLOCK() or USEd EXCLUSIVEly, if you are RECALLing
    several records.
!Seealso:CLIP006.NGO:"DELETE"  "PACK"  "SET DELETED"  "ZAP"  
!Short: REINDEX        Rebuilds existing index files.
^BREINDEX^B

    REINDEX rebuilds all open index (.ntx) files in the current work area.

^USyntax^U

    REINDEX

^UUsage^U

    When REINDEXing, the major consideration is the UNIQUE SETting.  If you
    have UNIQUE ON, be aware that all indexes open in the current work area
    will be indexed UNIQUE regardless of how they were originally created.
    Remember, in Clipper UNIQUE is a global SETting and not an attribute of
    the index.
!Seealso:"INDEX"  "PACK"  "SET INDEX"  "SET UNIQUE"  "USE"  
!Short: RELEASE        Deletes memory variables to free up memory space.
^BRELEASE^B

    RELEASE deletes memory variables.

^USyntax^U

    RELEASE <memvar list> / [ALL[LIKE/EXCEPT <skeleton>]]

^UArguments^U

    <memvar list> is a list of memory variables to delete.

    <skeleton> is a wildcard mask specifying a group of memory variables to
    delete or exclude from deletion.

^UUsage^U

    RELEASE deletes memory variables in two basic ways.  If the scope of
    the deletion is a list, then the specified memory variables are deleted
    regardless of the memory variable scope unless they are hidden.  This
    means that PUBLIC and private memory variables declared in higher level
    procedures are RELEASEd.  If, however, the ALL clause is specified,
    then only memory variables defined in the current procedures are
    RELEASEd.

    Note that a hidden memory variable does not become accessible when the
    local copy is RELEASEd but only when the procedure in which it was
    declared PRIVATE terminates.
!Seealso:CLIP006.NGO:"CLEAR ALL"  CLIP006.NGO:"CLEAR MEMORY"  "QUIT"  
!Short: RENAME         Renames a file.
^BRENAME^B

    RENAME changes the name of a disk file.

^USyntax^U

    RENAME <file1>.<ext> TO <file2>.<ext>

^UArguments^U

    Both the old and new filenames must include file extensions.

^UUsage^U

    The new filename cannot be an existing file in the same directory.

    ^BWarning^B: The file to be RENAMEd must be CLOSEd before executing
    this command!  Note that if you rename a database file with an
    associated memo file, you must also rename the corresponding memo
    (.dbt) file to match.
!Seealso:CLIP006.NGO:"COPY FILE"  "ERASE"  "RUN"  
!Short: REPLACE        Replaces data fields with specified values.
^BREPLACE^B

    REPLACE changes the contents of specified fields in the active database
    file.

^USyntax^U

    REPLACE [<scope>] [<alias>->]<field1> WITH <exp1>
    [,<field2> WITH <exp2>...] [FOR <condition>] [WHILE <condition>]

^UArguments^U

    <field> is the name of the target field to change.  This can be a field
    of any type including memo.  There is one target field per WITH clause.

    <exp> is the replacement expression.

^UOptions^U

    ^BAlias^B: Fields in other work areas can be REPLACEd by preceding the
    field name with the alias.

    ^BScope^B: The <scope> is the portion of the current database file to
    REPLACE.  The default is the current record.  If a condition is
    specified the scope becomes ALL.

    ^BCondition^B: The FOR clause specifies the conditional set of records
    to REPLACE within the given scope.  The WHILE clause specifies the set
    of records meeting the condition from the current record until the
    condition fails.

^UUsage^U

    The field and the WITH expression must have the same data type.  With
    numeric fields, the WITH expression may not be larger than the field
    width.  If it is, asterisks replace the field contents, and some data
    may be lost.

^UIndexed Files^U

    Replacements on a key field of an indexed database file also update the
    index file if it is in use.  When the replacement is made, the record
    moves to a new position in the index file.  If you specify a scope,
    WHILE, or FOR when making replacements on an indexed field, not all of
    the records you intended will be replaced.  For example, if you REPLACE
    ALL, only the first record and those that follow the new key field
    value will be replaced.  That's because each record is reindexed as the
    REPLACE is done, and the record pointer is moved to follow the replaced
    record.  To REPLACE all the records, you should use the database file
    without an index, and then REINDEX afterwards.

^UMemo Fields^U

    Since Clipper supports the manipulation of memo fields in the same way
    as character fields, you can REPLACE a memo field with a character
    string.

^UNetwork^U

    In a network environment, REPLACE requires the current record be locked
    with RLOCK() if you are REPLACEing a single record; the current
    database file be locked with FLOCK() or USEd EXCLUSIVEly, if you are
    REPLACEing several records.  If a field is being REPLACEd in an
    unselected work area, that record must also be locked with FLOCK().
!Seealso:CLIP006.NGO:"APPEND"  "JOIN"  "UPDATE"  CLIP002.NGO:"STRTRAN()"  
!Short: REPORT FORM    Displays data in report form.
^BREPORT FORM^B

    To display a tabular and optionally grouped report with page and column
    headings from a definition held in a .frm file.

^USyntax^U

    REPORT FORM <file1>/(<expC1>) [<scope>] [FOR <condition>]
    [WHILE <condition>] [TO PRINT] [TO FILE <file2>/(<expC2>)]
    [SUMMARY] [PLAIN] [HEADING <expC3>] [NOEJECT]

^UArgument^U

    <file1> is the name of the (.fmt) file that contains the FORM
    definition of the REPORT.  If the extension is not specified (.frm) is
    assumed.

^UOptions^U

    ^BScope^B: The <scope> is the portion of the current database file to
    report.  The default is ALL.

    ^BCondition^B: The FOR clause specifies the conditional set of records
    to report within the given scope.  The WHILE clause specifies the set
    of records meeting the condition from the current record until the
    condition fails.

    ^BPrint^B: The TO PRINT clause echoes output to the printer.

    ^BFile^B: The TO FILE clause echoes output to the specified filename,
    <file2>, without form feed characters (ASCII 12).  If an extension is
    not specified, (.txt) is added.

    ^BSummary^B: The SUMMARY clause causes the REPORT FORM to display only
    group, subgroup, and grand total lines.  Detail lines are suppressed.

    ^BPlain^B: The PLAIN clause suppresses the display of the date, page
    number, and pagination.  In addition, the report title and column
    headings display only at the top of the report.

    ^BHeading^B: The HEADING clause places the result of <expC3> on the
    first line of each page.  <expC3> is evaluated only once at the
    beginning of the report and before the record pointer is moved.

    ^BNoeject^B: The NOEJECT clause suppresses the initial page eject when
    the TO PRINT clause is used.

^UUsage^U

    The REPORT FORM executes a report using a definition stored in a (.frm)
    file. The .frm file can be created using RL.EXE, which is provided with
    the Clipper distribution diskettes.

    If you want to include form feed characters when sending the REPORT
    FORM TO FILE, add the lines of code shown below to your program:

    ^RSET PRINTER TO <file>      ^R
    ^RREPORT FORM <file> TO PRINT^R
    ^RRSET PRINTER TO            ^R
!Seealso:"LABEL FORM"  "LIST"  
!Short: RESTORE        Retrieves and activates memory variables from memory file.
^BRESTORE^B

    RESTORE retrieves and activates memory variables from a memory file.

^USyntax^U

    RESTORE FROM <filename> [ADDITIVE]

^UDefaults^U

    A .mem file extension is assumed unless otherwise specified.

^UUsage^U

    When you RESTORE memory variables in a program file, all of the
    currently active memory variables are deleted unless ADDITIVE is
    specified.  Unless you redeclare memory variables as PUBLIC in a
    program file, the variables are restored as PRIVATE.  Memory variables
    you restore from the dot prompt, however, always come back as PUBLIC.

    No more than 64,000 memory variables may be active at any time.

^UOptions^U

    To retain the current memory variables, include the ADDITIVE option,
    which causes the RESTOREd memory variables to be added to the current
    one.  Any current memory variables with the same name are overwritten.
    To restore variables in a memory file as PUBLIC, you must redeclare
    them as PUBLIC before you RESTORE the memory file and use the ADDITIVE
    option.
!Seealso:"PUBLIC"  "RELEASE"  "SAVE"  "STORE"  
!Short: RESTORE SCREEN Allows multiple screens to be restored (with SAVE SCREEN).
^BRESTORE SCREEN^B

    RESTORE SCREEN redisplays a previously saved screen.

^USyntax^U

    RESTORE SCREEN [FROM <memvar>]

^UOption^U

    ^BFrom^B: The FROM clause redisplays a screen from the specified
    <memvar>.

^UUsage^U

    RESTORE SCREEN is used generally in conjunction with the SAVE SCREEN to
    avoid repainting the original screen that has been temporarily
    replaced.  Note, however, that <memvar> is an ordinary character
    variable and as such can be created and manipulated in any way you
    wish.
!Seealso:"RESTORE"  "SAVE SCREEN"  
!Short: RETURN         Returns control to calling program - executes next command.
^BRETURN^B

    RETURN is used to restore control to either the calling procedure or
    the operating system.

^USyntax^U

    RETURN [<exp>]

^UArgument^U

    <exp> evaluates to the return value if the current program structure is
    a user-defined function.

^UUsage^U

    When RETURN is used in the highest level program, control passes to the
    operating system.  In a procedure, Clipper returns to the calling
    procedure and releases all PRIVATE memory variables.

    There can be more than one RETURN in a procedure or user-defined
    function.  A procedure or user-defined function need not, however, end
    with a RETURN.  Since user-defined functions must return values, each
    must contain at least one RETURN with an argument.

    Note that Clipper does not support RETURN TO MASTER or any other form
    of RETURN specifying the level of the call to return to, although
    RETURN TO MASTER can be simulating via BEGIN SEQUENCE...BREAK.
!Seealso:CLIP006.NGO:"BEGIN SEQUENCE..END"  CLIP006.NGO:"CANCEL"  "PRIVATE"  "PUBLIC"  
!Short: RUN/!          To execute a DOS command or program from within application.
^BRUN/!^B

    To execute a DOS command or program from within a compiled application.

^USyntax^U

    RUN/! <DOS command>/(<expC>)

^UArgument^U

    <DOS command> is any executable program including resident DOS commands
    and COMMAND.COM.

^UUsage^U

    When you RUN a DOS program, Clipper executes another copy of
    COMMAND.COM passing the DOS command to run at the same time.  This has
    two implications.  First, you must have enough memory for COMMAND.COM
    (27K for DOS 3.2) and the program you wish to execute.  Second,
    COMMAND.COM must be available on the path specified by COMSPEC (the
    default is the root directory of the disk where you boot DOS).  If
    COMMAND.COM is not located on this disk or the disk is changed, SET
    COMSPEC to the new location prior to running the Clipper application.

    ^BMemory Resident programs^B: You should not RUN memory resident
    programs from within Clipper since you may lose memory when the
    application terminates.

    ^BDOS Access^B: One of the options you may want to give your users is
    direct access to DOS.  You can do this with the command:

    RUN COMMAND

    If you use this technique, you may also want to change the DOS prompt
    in order to give instructions on how to return to the application
    program.  To set this up, create a batch file to set the DOS access
    prompt, load the application program, and restore the DOS prompt after
    the application program terminates as follows:

    ^Recho off                                ^R
    ^Rprompt Dir: $p$_Type EXIT to return.$_$g^R
    ^R<your application program>              ^R
    ^Rprompt $p$                              ^R

    Then instruct the suer to execute the batch file in place of the
    application .EXE file.

^UExample^U

    The following demonstrates how you can use RUN in combination with
    MEMOREAD() and MEMOWRIT() to create a user-defined function that calls
    your editor with the current memo field:

    ^RFUNCTION EditorMemo                              ^R
    ^RPARAMETERS editor, memofld                       ^R
    ^RIF MEMOWRIT("Clipedit.tmp", &memofld)            ^R
    ^R   RUN (editor + " Clipedit.tmp")                ^R
    ^R   REPLACE &memofld WITH MEMOREAD("Clipedit.tmp")^R
    ^R   RETURN 0                                      ^R
    ^RELSE                                             ^R
    ^R   RETURN -1                                     ^R
    ^RENDIF                                            ^R

    EditorMemo() returns -1 if there is an error and zero if successful.
!Seealso:"INDEX"  "PACK"  "SET INDEX"  "SET UNIQUE"  "USE"  
!Short: SAVE           Stores all or part of current memory variables to disk file.
^BSAVE^B

    SAVE stores all or part of the current set of memory variables to a
    disk file.

^USyntax^U

    SAVE TO <filename> [ALL [LIKE/EXCEPT <skeleton>]]

^UArguments^U

    <file> is the name of the file where specified memory variables are
    SAVEd.  If no extension is specified, Clipper creates the file with a
    .mem extension.

    <skeleton> is the wildcard mask to specify a group of memory variables
    to SAVE.

^UUsage^U

    SAVE copies the specified memory variables to a memory file without any
    reference to scope (public or private).  Note that hidden memory
    variables are not SAVEd even if they are PUBLIC.

    Note also that you cannot SAVE arrays to memory files.
!Seealso:"RESTORE"  "RESTORE SCREEN"  "SAVE SCREEN"  
!Short: SAVE SCREEN    For writing multiple screens to a buffer (w/ RESTORE SCREEN).
^BSAVE SCREEN^B

    SAVE SCREEN saves the current SCREEN to a buffer or optional memory
    variable.

^USyntax^U

    SAVE SCREEN [TO <memvar>]

^UOption^U

    ^BTo^B: The TO clause specifies a memory variable to SAVE the current
    SCREEN.  The variable created is character type and the length of the
    screen is 4000 bytes.

^UUsage^U

    SAVE SCREEN is used in conjunction with RESTORE SCREEN to
    eliminate the need to repaint an original screen that has been
    temporarily replaced.

    In addition to ordinary memory variables, you can also SAVE SCREENs to
    array elements making screen management easier.  Note, however, you
    cannot SAVE arrays to .mem files in order to SAVE multiple screens to
    disk.
!Seealso:"RESTORE SCREEN"  "SAVE"  
!Short: SEEK           Points to next record matching a specified expression.
^BSEEK^B

    SEEK searches an indexed database file for the first record with an
    index key that matches the specified character string or number.  SEEK
    conducts a very rapid record search.

^USyntax^U

    SEEK <exp>

^UArgument^U

    <exp> is an expression to be matched with an index key.

^UUsage^U

    SEEK searches the controlling index starting with the first key and
    proceeds until a match is found or there is a key value greater than
    the search argument.  If there is a match, the record pointer is
    positioned to the record number found in the index.  If SOFTSEEK is OFF
    (the default) and SEEK does not find a record, the record pointer is
    positioned to LASTREC() + 1, EOF() returns true (.T.), and FOUND()
    returns false (.F.).  If SOFTSEEK is ON, the record pointer is
    positioned to the record with the first key value greater than the
    search argument and FOUND() returns false (.F.).  In this case, EOF()
    only returns true (.T.) if there are no keys in the index greater than
    the search argument.
!Seealso:"FIND"  "INDEX"  "SET INDEX"  "SET ORDER"  "SET SOFTSEEK"  "LOCATE"  
!Short: SELECT         Switches among up to 10 open database files/work areas.
^BSELECT^B

    SELECT changes the current work area.

^USyntax^U

    SELECT <work area>/<alias>/(<expN>)

^UArgument^U

    <work area> is a number between zero and 254 inclusive.  Zero
    designates the first available work area beginning with work area one.

    <alias> is the name of an existing work area if there is a database
    file open in that area.  The first 10 work areas can be referred to
    with the letters A through J.  Specifying a non-existent alias produces
    a run-time error.

    (<expN>) is a numeric expression that evaluates to a number between
    zero and 254.  The expression must be bounded by opposing parentheses
    to be evaluated.

^UUsage^U

    Clipper supports 254 work areas.  SELECTing 0 selects the first unused
    area.  Within each work area, you can open a database file and up to 15
    index files.  Each work area has a number of attributes which include:

    ^BAttribute^B                  ^BFunction^B
    Alias name                 ALIAS()
    Work area number           SELECT()
    Database file              ALIAS()
    Index file(s)              INDEXORD()/INDEXKEY()
    Exclusivity                FLOCK()/NETERR()

    Filter condition
    Deleted filter
    Locate condition
    Relation(s)

    Number of records          LASTREC()/RECCOUNT()
    Number of fields           FCOUNT()
    Record number              RECNO()
    Beginning-of-file flag     BOF()
    End-of-file flag           EOF()
    Found flag                 FOUND()
!Seealso:"USE"  "SET INDEX"  CLIP002.NGO:"SELECT()"  
!Short: SET ALTERNATE  Creates a file for saving output.
^BSET ALTERNATE^B

    SET ALTERNATE directs output from commands other than @...SAY...GET to
    a text file.

^USyntax^U

    SET ALTERNATE TO [<file>/(<expC>)]

    SET ALTERNATE ON/OFF

^UOption^U

    ^BTo^B: Specifying a <file> as the argument of the TO clause opens a
    standard ASCII text file with a default extension of .txt.  The
    filename can optionally include an extension, drive letter, and/or
    path.  If a file with the same name exists, subsequent ouput will
    overwrite the current contents of that file.

    ^BToggle^B: SET ALTERNATE on/OFF toggles the echo of output to the
    current alternate file.  Note that when you SET ALTERNATE OFF, the
    alternate file is not closed.

^UUsage^U

    Alternate files are not related to work areas and only one may be open
    at a time.  To close an alternate file, use CLOSE ALTERNATE, CLOSE ALL,
    or SET ALTERNATE TO with no argument.  Note that @...SAYs cannot be
    echoed to a disk file using SET ALTERNATE, but SET PRINTER TO
    <filename> does support this feature.
!Seealso:CLIP006.NGO:"CLOSE"  CLIP006.NGO:"DISPLAY"  "LABEL FORM"  "REPORT FORM"  "SET PRINTER TO"  "TEXT"  
!Short: SET BELL ON    Toggles bell during data entry operations.
^BSET BELL^B

    SET BELL toggles sounding of the bell during full-screen operations.

^USyntax^U

    SET BELL on/OFF/(<expL>)

^UUsage^U

    The bell sounds in the following instances:

    o  You enter a character at the last character position in a GET.

    o  You attempt to enter an invalid data type into a GET.  The data type
       is controlled by the data type of the field, memory variable, or by
       the PICTURE template.

    Note that you can sound the bell explicitly using the command ??CHR(7).
!Seealso:"SET CONFIRM"  
!Short: SET CENTURY    Toggles four-digit/two-digit year display.
^BSET CENTURY^B

    SET CENTURY toggles the year's century digits for the input and display
    of date fields and memory variables.

^USyntax^U

    SET CENTURY on/OFF/(<expL>)

^UUsage^U

    When CENTURY is OFF, the century digits of dates are not displayed and
    cannot be input.  if a calculation is performed on a date resulting in
    a non-twentieth century value, the date contains the correct century
    although it does not display.  Dates entered without century digits
    default to the twentieth century.

    When CENTURY is ON, a date field displays with a four-digit year and
    non-twentieth century dates can both be displayed and input.

    Clipper supports all dates in the range 01/01/0100 to 12/31/2999.
!Seealso:"SET DATE"  CLIP002.NGO:"YEAR"  
!Short: SET COLOR TO   Sets screen display attributes.
^BSET COLOR^B

    SET COLOR allows the selection of colors for use on color monitors, or
    screen attributes for use on monochrome monitors.

^USyntax^U

    SET COLOR TO [<standard> [,<enhanced>] [,<border>] [,<background>]
    [<unselected>]}/(<expC>)

^UOptions^U

    ^BStandard/Enhanced^B: The "standard" and "enhanced" displays are color
    pairs with a foreground and an optional background color.  "Standard"
    is used by all output, such as @...SAY and ?.  "Enhanced" setting
    affects only the display of GETs.

    ^BBorder^B: Sets the border color.

    ^BBackground^B: The "background" is not currently supported by any
    machines for which Nantucket provides drivers.

    ^BAttributes^B: High intensity and blinking are the attributes of
    colors.  High intensity is denoted by "+" and blinking with "*".  Each
    attribute specified is applied to the foreground color no matter where
    it occurs in the setting definition.

    SET COLOR TO with no argument restores the default values which are:
    W/N,N/W,,,N/W

^UUsage^U

    There are number of colors supported for enhancing screen display.
    Each color is denoted by a letter or number.  When you specify a color
    setting, numbers and letters should not be mixed.  When numbers are
    used, the number to the left of the slash is written to the high order
    4 bits of the color attribute byte, and the number to the right is
    written to the low order 4 bits.

    The following table lists the colors available:

         ^UColor              Letter         Number^U
         BLACK              N              0
         BLUE               B              1
         GREEN              G              2
         CYAN               BG             3
         RED                R              4
         MAGENTA            RB             5
         BROWN              GR             6
         WHITE              W              7
         GREY               N+
         YELLOW             GR+
         BLANK              X
         Underline          U
         Inverse Video      I

    On monochrome monitors, color is not supported.  Clipper, however,
    supports the monochrome attributes reverse video (I) and underlining
    (U).


    ^BNote^B: SET COLOR TO using numbers is not supported if you link
    ANSI.OBJ.

    ^BColor variables^B: To make managing color easier, consider the
    assignment of colors to memory variables.  This will allow you to
    centralize the assignment of colors and implementation of runtime color
    configuration for users.

    To set each color configuration, assign the complete SET COLOR argument
    as a character string to a single memory variable.  Then use macro
    substitution or bound the color variable when you SET COLOR.

    Use the ISCOLOR() function to set up different color configurations for
    color and monochrome monitors.

!Short: SET CONFIRM    Toggles return key-press to complete a GET.
^BSET CONFIRM^B

    SET CONFIRM toggles between terminating the current GET when it is full
    or requiring a terminating key press.

^USyntax^U

    SET CONFIRM on/OFF/(<expL>)

^UUsage^U

    The following keys terminate GETs in Clipper.

       Ctrl-Home
       Ctrl-End
       Uparrow
       Dnarrow
       Ctrl-C,PgUp
       Ctrl-W,PgDn
       Esc
       Return

    Note that CONFIRM has no effect on MENU TO.
!Seealso:CLIP006.NGO:"@...SAY...GET"  "READ"  "SET BELL"  
!Short: SET CONSOLE    Toggles output to the screen
^BSET CONSOLE^B

    SET CONSOLE turns the screen display on and off from within a program.

^USyntax^U

    SET CONSOLE ON/off/(<expL>)

^UUsage^U

    SET CONSOLE OFF affects all output and prompts sent to the screen by
    all display commands including prompts for ACCEPT, INPUT, and WAIT.
    Full-screen commands such as @...SAY...GET, @...PROMPT, @...BOX,
    @...CLEAR TO, @...TO, and CLEAR display to the screen independent of
    the current CONSOLE SETting.
!Seealso:"SET DEVICE"  
!Short: SET CURSOR     Toggle screen cursor on and off.
^BSET CURSOR^B

    SET CURSOR turns the screen cursor on and off.

^USyntax^U

    SET CURSOR ON/off/(<expL>)

^UUsage^U

    When the CURSOR is OFF, keyboard entry and screen display are
    unaffected.  The cursor is merely hidden and data entry may still be
    accomplished without the cursor being visible.

    The primary usefulness of this command is to suppress the cursor while
    the screen is being painted.  Ideally, the only time the cursor should
    show in a production program is when you are in full-screen edit, the
    memo editor, or some kind of line editor.
!Seealso:"SET CONSOLE"  
!Short: SET DATE       Determines the format for date displays.
^BSET DATE^B

    SET DATE determines the format for date displays.

^USyntax^U

    SET DATE AMERICAN/ANSI/BRITISH/FRENCH/GERMAN/ITALIAN

^UDefaults^U

    DATE is normally SET to AMERICAN.

^UUsage^U

    SET DATE allows more flexibility in date output.

           
             AMERICAN           mm/dd/yy   
             ANSI               yy.mm.dd   
             BRITISH/FRENCH     dd/mm/yy   
             GERMAN             dd.mm.yy   
             ITALIAN            dd-mm-yy   
           

    To configure a compiled application to the proper date setting at
    runtime, pass a DOS environmental variable to your application program,
    retrieve its value with GETE() and SET DATE with this value.  For
    example, in DOS:

    SET CLIP_DATE=BRITISH

    Later in the configuration section of your application program:

    ^Rdate_set = UPPER(GETE("CLIP_DATE"))^R
    ^RDO CASE                            ^R
    ^RCASE date_set = "AMERICAN"         ^R
    ^R   SET DATE AMERICAN               ^R
    ^RCASE date_set = "ANSI"             ^R
    ^R   SET DATE ANSI                   ^R
    ^RCASE date_set = "BRITISH"          ^R
    ^R   SET DATE BRITISH                ^R
    ^R...                                ^R
!Seealso:"SET CENTURY"  
!Short: SET DECIMALS   Sets the minimum number of decimals displayed.
^BSET DECIMALS^B

    SET DECIMALS determines the minimum number of decimal places that the
    system displays for the results of numeric functions and calculations.

^USyntax^U

    SET DECIMALS TO <expN>

^UUsage^U

    The functions and arithmetic operations affected by SET DECIMALS are
    SQRT(), EXP(), LOG(), and division if SET FIXED is OFF.  All other
    calculations display the number of decimal places that would normally
    result from the calculation.  If SET FIXED is ON, all numerics obey the
    DECIMALS SETting.
!Seealso:"SET FIXED"  
!Short: SET DEFAULT    Specifies the default drive for file operations.
^BSET DEFAULT^B

    SET DEFAULT TO allows you to select the drive where all operations
    take place and all files are stored, unless otherwise directed.

^USyntax^U

    SET DEFAULT TO <drive>[:<path>]

^UArguments^U

    <drive> identifies a disk drive name or letter.

    <path> identifies the directory that you want to make the default.  If
    you specify both a drive and directory, a colon must be included after
    the drive letter.

    SET DEFAULT TO without an argument defaults to the last directory used
    on the designated drive.

^UUsage^U

    The default drive and directory are those where your Clipper
    application is initially started.  Once in the application, you can
    change this with SET DEFAULT.

    Note that the default drive and directory do not constitute the search
    path for accessing files.  To set a search path for file access, use
    SET PATH.  SET DEFAULT is used primarily to specify the location where
    new files are written.

    Note also that SET DEFAULT does not change the DOS drive and directory.
    Executing a RUN accesses the last drive and directory set in DOS.
!Seealso:"SET PATH"  
!Short: SET DELETED    Toggles hiding records marked for deletion.
^BSET DELETED^B

    SET DELETED determines whether records that are marked for deletion are
    included or ignored by other commands.

^USyntax^U

    SET DELETED on/OFF/(<expL>)

^UDefaults^U

    SET DELETED is normally OFF.

^UUsage^U

    WHen SET DELETED is ON, most commands ignore deleted records.  If,
    however, you refer to a record by record number (GOTO or any command
    that supports the RECORD scope) the record displays even if marked for
    deletion.  Additionally, SET DELETED ON has no effect on INDEX and
    REINDEXing.

    RECALL ALL, however, honors SET DELETED and does not recall any
    records.
!Seealso:CLIP006.NGO:"DELETE"  "INDEX"  "RECALL"  "SET INDEX"  "USE"  
!Short: SET DELIMITERS Displays full-screen fields delimited or in reverse video.
^BSET DELIMITERS^B

    SET DELIMITERS determines how field widths are indicated in the full-
    screen mode.

^USyntax^U

    SET DELIMITERS ON/OFF

    SET DELIMITERS TO [<expC>]/DEFAULT

^UDefaults^U

    SET DELIMITERS is normally OFF so that entry fields are not enclosed by
    specified delimiter characters.

    SET DELIMITERS ON uses colons (:) to set off the field areas, unless
    another delimiter is chosen with the SET DELIMITERS TO command.

^UUsage^U

    SET DELIMITERS TO <character string> sets the characters used to mark
    the field area.  The character string must be one or two characters.  A
    space may be used in the character expression to suppress either the
    right or left (or both) delimiters.
!Seealso:CLIP006.NGO:"@...SAY...GET"  
!Short: SET DEVICE     Directs output to screen or printer.
^BSET DEVICE^B

    SET DEVICE determines whether @...SAY commands are routed to the screen
    or the printer.

^USyntax^U

    SET DEVICE TO PRINT/SCREEN

^UDefaults^U

    SET DEVICE is normally set TO SCREEN.

^UUsage^U

    With SET DEVICE TO PRINT, the output from @...SAY commands is sent to
    the printer.  @...GET commands are ignored.  An @ command that
    specifies coordinates of lower values than previous @ commands results
    in a page eject.

    On some printers, @...SAYs may not appear until the print buffer is
    emptied.  To empty the buffer, issue an EJECT command or print a blank
    line.  EJECT resets the internal printer row and column values to zero.
    Additionally, you can specify new internal printer row and column
    values with SETPRC().
!Seealso:CLIP006.NGO:"@...SAY...GET"  CLIP006.NGO:"EJECT"  "SET PRINTER"  CLIP002.NGO:"PROW()"  CLIP002.NGO:"PCOL()"  CLIP002.NGO:"SETPRC()"  
!Short: SET ESCAPE     Allows user to escape from program during execution.
^BSET ESCAPE^B

    SET ESCAPE determines whether the user can terminate a READ with Esc.

^USyntax^U

    SET ESCAPE ON/off/(<expL>)

^UDefaults^U

    SET ESCAPE is normally ON.

^UUsage^U

    With SET ESCAPE ON, a user may complete a GET by pressing Esc, thereby
    bypassing execution of any VALID clause.

    With SET ESCAPE OFF, will not allow an escape to terminate a READ.

    Note that SET ESCAPE OFF no longer disables program termination with
    Alt-C.  This function is now performed by SETCANCEL().
!Seealso:"READ"  "SET KEY"  CLIP002.NGO:"SETCANCEL()"  
!Short: SET EXACT      Sets requirement for exact matches in character comparisons.
^BSET EXACT^B

    SET EXACT determines whether a comparison between two character strings
    requires the strings to be the same length.

^USyntax^U

    SET EXACT on/OFF/(<expL>)

^UDefaults^U

    When EXACT is OFF two characters are compared according to the
    following rules:

    1.  The strings are first considered equivalent (.T.).

    2.  Strings are then compared by character position for each character
        in both strings until the length of the string on the right side of
        the operator is exhausted or the comparison returns false (.F.).

    This has two implications:

    1.  Two strings may equate even though they vary in length.

    2.  A string of length greater than zero can equate to a null string.
        This happens because a null string on the right side of the
        operator has a length of zero and so no comparisons are made.  The
        result returns is then the initial value, true (.T.).

    With SET EXACT ON, two strings must match exactly, except for trailing
    blanks.  The same characters (upper and lower case) must be in the same
    order, and be of the same length to return true (.T.).
!Seealso:CLIP006.NGO:"DISPLAY"  "FIND"  "LIST"  "LOCATE"  "SEEK"  
!Short: SET EXCLUSIVE  Determines how files will be opened (for network).
^BSET EXCLUSIVE^B

    SET EXCLUSIVE determines the way in which database and related memo and
    index files are opened.  It is used in conjunction with multi-user
    environments.

^USyntax^U

    SET EXCLUSIVE ON/OFF

^UUsage^U

    When EXCLUSIVE is ON, all database and associated files are opened as
    non-shareable and cannot be USEd by other users until they are CLOSEd.

    When EXCLUSIVE is OFF, all non-shared access must be controlled
    programmatically using RLOCK(), FLOCK(), and USE...EXCLUSIVE.
!Seealso:"USE"  CLIP002.NGO:"RLOCK()"  
!Short: SET FILTER     Isolates records in file meeting specified criteria.
^BSET FILTER^B

    SET FILTER allows display of only those records of a database file that
    meet a specified condition.

^USyntax^U

    SET FILTER TO [<condition>]

^UUsage^U

    SET FILTER applies only to the database file open in the work area
    where the command is issued.  Therefore, a different filter condition
    may be set for each open database file.

    SET FILTER TO <condition> sets up a filter based on a valid expression.
    The condition can filter records in the active database file based on
    any of the allowed data types, for example, on a character field (SET
    FILTER TO Lastname='Smith') or on a date filed (SET FILTER TO
    Department=CTOD('12/25/85').

    Filters are not activated until ^Bafter^B the record pointer is moved
    within a file.  This means that your filter condition is not in effect
    unless something has caused the pointer to change position since the
    condition was set.  The best way to assure that a filter is in effect
    is to execute a GOTO TOP command after setting the filter.

    As with SET DELETED, a filter has no effect on INDEX and REINDEX.  You
    may, however, directly access filtered records with GOTO or commands
    using the RECORD scope.
!Seealso:"SET DELETED"  
!Short: SET FIXED      Fixes the number of decimal places to be displayed.
^BSET FIXED^B

    SET FIXED determines whether a fixed number of decimal places are
    displayed for all numeric output.

^USyntax^U

    SET FIXED on/OFF/(<expL>)

^UOption^U

    ^BOn^B: When FIXED is ON, display of all numeric output is controlled
    by the DECIMALS SETting (two places if the SET DECIMALS default value
    is in effect).

    ^BOff^B: When FIXED is OFF, display of numeric output is dependent on
    the type of operation performed and according to the following rules:


                   ^BNumeric Decimal Display When FIXED is OFF^B

    Operation                     Decimal Digits Displayed
    Addition/Subtraction          Same as operand with the greatest
                                  number of decimal digits
    Multiplication                Sum of operand decimal digits
    Division                      SET DECIMALS
    Exponentation                 SET DECIMALS
    EXP(), LOG(), SQRT()          SET DECIMALS
    VAL()                         Same as operand
!Seealso:"SET DECIMALS"  CLIP002.NGO:"LOG()"  CLIP002.NGO:"SQRT()"  CLIP002.NGO:"VAL()"  
!Short: SET FORMAT     Opens a format file for data entry.
^BSET FORMAT^B

    SET FORMAT activates a format procedure so that whenever a READ is
    performed the format procedure is executed.

^USyntax^U

    SET FORMAT TO <procedure>

^UArgument^U

    <procedure> is a format (.fmt) file, a program (.prg) file, or a
    PROCEDURE.

    SET FORMAT TO with no argument deactivates the current format.

^UUsage^U

    Format procedures are like any other procedure in Clipper differing
    only by the method by which you invoke them.  Unlike the interpreted
    environment, formats are not opened at runtime and executed when the
    application is run.  Instead, when Clipper encounters a SET FORMAT
    statement while compiling, it attempts to compile the specified file
    from disk as it would any other procedural reference.  Because of this
    general character, format procedures can be stored in procedure files.

    ^BNote^B: If you are compiling .CLP files with a program that contains
    format references, the accompanying format files must have .prg file
    extensions in order to compile correctly.

    In Clipper there can only be one active format procedure, unlike other
    dialects where each work area can have an active format.

    Format declarations cannot be nested.  Clipper ignores SET FORMAT
    statements within format procedures at compile time.

    Clipper does not clear the screen before executing format files.

    Commands, however, are allowed in format files, which gives more
    flexibility.

    Clipper does not support multiple-page format procedures and so READ
    statements within format procedures are ignored.

^BExample^B

    ^RUSE Sales                             ^R
    ^RSET FORMAT TO Sales_scr               ^R
    ^RDO WHILE LASTKEY() <> 27              ^R
    ^R   APPEND BLANK                       ^R
    ^R   READ                               ^R
    ^RENDDO                                 ^R
    ^R                                      ^R
    ^RPROCEDURE Sales_scr                   ^R
    ^RCLEAR                                 ^R
    ^R@ 12, 12 SAY "Branch :  " GET Branch  ^R
    ^R@ 13, 14 SAY "Salesman: " GET Salesman^R
    ^RRETURN                                ^R
!Seealso:CLIP006.NGO:"@...SAY...GET"  "READ"  
!Short: SET FUNCTION   Assign a character string to a function key.
^BSET FUNCTION^B

    SET FUNCTION assigns to a function key a string of characters that are
    stuffed into the keyboard buffer when the key is pressed.

^USyntax^U

    SET FUNCTION <expN> to <expC>

^UArgument^U

    <expN> is the function key number.

    <expC> is the character string of up to 2000 characters submitted to
    the keyboard when the function key is pressed in a wait state.

^UUsage^U

    SET FUNCTION can assign to a function key a string to stuff the
    keyboard.  This string may contain control characters, such as a Ctrl-C
    (which is the equivalent of a PgDn), to complete a READ.

    ^BNote^B: A SET KEY definition takes precedence over a SET FUNCTION
    assignment for the same key.

    Function keys between 2 and 40 inclusive can be assigned using this
    command.  Function key 1, however, is reserved for use with Help.prg
    and cannot be assigned a string.

    Function Key                  Actual Key
    1  - 10                       F1 - F10
    11 - 20                       Shift-F1 - Shift-F10
    21 - 30                       Ctrl-F1 - Ctrl-F10
    31 - 40                       Alt-F1 - Alt-F10
!Seealso:"SET KEY"  
!Short: SET INDEX      Opens the specified index file(s).
^BSET INDEX^B

    SET INDEX opens the specified index files in the current work area.

^USyntax^U

    SET INDEX TO [<file list>/(<expC1>)...]

^UArgument^U

    <file list> are the names of one or more (up to 15) index (.ntx or
    .ndx) files to open in the current work area, separated by commas.

^UUsage^U

    SET INDEX assumes an .ntx or .ndx filename extension unless otherwise
    specified.  You may include a drive letter and/or path name with the
    index filename.

    CLOSE INDEX or SET INDEX TO without a filename closes all indexes open
    in the current work area.

    When more than one index file is opened for the active database file,
    the first index becomes the controlling index.  The record pointer is
    then positioned at the first logical record in the index.  During
    database file processing, all open indexes are updated whenever a key
    value is appended or changed.  To change the controlling index without
    issuing another SET INDEX command, use SET ORDER.

    ^BMacro Variables^B: Index files may be specified by using macro
    variables.  Each file listed, however, must be a separate variable.
    For example, this is not permissible:

    ^Rntx_list = "Name, Account"^R
    ^RSET INDEX TO &ntx_list    ^R

    Note that macros substituting a null string ("") or spaces are ignored.
!Seealso:CLIP006.NGO:"CLOSE"  "INDEX"  "REINDEX"  "SET ORDER"  "USE"  
!Short: SET INTENSITY  Sets on the reverse video in full-screen operations.
^BSET INTENSITY^B

    SET INTENSITY toggles the display of GETs between enhanced and standard
    color settings.

^USyntax^U

    SET INTENSITY ON/off/(<expL>)

^UUsage^U

    When INTENSITY is OFF, GETs appear in the same color as SAYs, the
    standard color setting.  If INTENSITY is ON (the default), GETs appear
    in the enhanced color setting.  Note that INTENSITY has no effect on
    other display commands and functions such as MENU...TO, ACHOICE(), and
    DBEDIT().
!Seealso:CLIP006.NGO:"@..SAY..GET"  "SET COLOR"  
!Short: SET KEY        Redefines keys to perform procedures from wait state.
^BSET KEY^B

    SET KEY allows a procedure to be executed from any wait state when a
    designated key is pressed.

^USyntax^U

    SET KEY <expN> TO [<proc>]

^UArgument^U

    <expN> is the INKEY() value of the designated key.

    <procedure> is the procedure that executes when the assigned key is
    pressed.  If the procedure is not specified the current key
    redefinition is released.

^UUsage^U

    A wait state is defined as any command that pauses program execution,
    such as: WAIT, ACCEPT, READ, INPUT, MENU TO.  Note that INKEY() is not
    a wait state.

    A maximum of 32 keys may be SET at one time.  At start-up, the system
    assumes that KEY 28 is SET to HELP.

    Like Help.prg, three automatic parameters are passed to the SET KEY
    procedure.  The parameters are "calling program", "line number", and
    "input variable".  "Calling program" and "input variable" are both
    character type and "line number" is numeric type.

    As a rule, CLEAR or READ should not be used in SET KEY procedures if
    the wait state is READ since both commands clear the pending GETs in
    the calling program.  To clear the screen, use @ 0,0 CLEAR instead.

    ^BNote^B: SET KEY takes precedence over SET FUNCTION for the definition
    of a function key.
!Seealso:"KEYBOARD"  "SET FUNCTION"  CLIP002.NGO:"LASTKEY()"  
!Short: SET MARGIN     Sets the left margin of the printer.
^BSET MARGIN^B

    SET MARGIN adjusts the left-hand margin for all printed output.  The
    video display is unaffected.

^USyntax^U

    SET MARGIN TO <exp N>

^UDefaults^U

    The left-hand margin defaults to a value of zero.

^UUsage^U

    SET MARGIN TO sets the margin for all printed output from commands
    which can direct output to the printer, for example, DISPLAY and LIST,
    as well as the ? command (with SET PRINT ON) and @...SAY commands (with
    SET DEVICE TO PRINT).

    The SET MARGIN setting is added to the left margin settings specified
    with LABEL and REPORT FORM.
!Seealso:CLIP006.NGO:"@...SAY...GET"  "SET DEVICE"  "SET PRINT"  
!Short: SET MESSAGE    Allows messages to be displayed with PROMPTs.
^BSET MESSAGE^B

    SET MESSAGE TO sets the screen row where @...PROMPT...MESSAGEs display.

^USyntax^U

    SET MESSAGE TO [<exp N> [CENTER]]

^UArgument^U

    <expN> specifies the row position where the messages display.

    Messages appear on row <expN>, column 0 unless the CENTER option is
    used.  The display of messages is suppressed by SET MESSAGE TO 0 or SET
    MESSAGE TO without an argument.

^UOption^U

    ^BCenter^B: The CENTER option centers the message on the specified row.
!Seealso:CLIP006.NGO:"@..PROMPT"  "MENU"  "SET WRAP"  
!Short: SET ORDER      Identifies the specified index as the controlling index.
^BSET ORDER^B

    SET ORDER identifies the specified open index as the controlling index.

^USyntax^U

    SET ORDER TO [<exp N> ]

^UArgument^U

    <expN> specifies the index to make the controlling index by pointing to
    its position in the list of open indexes in the current work area.
    This number can be in the range of zero to 15.

    SETting ORDER TO 0 restores the database file to natural order (record
    number order) while leaving all indexes open.

^UUsage^U

    When you SET ORDER TO a new controlling index, all indexes are properly
    updated when you either append or edit records.  Unlike dBASE III PLUS,
    this includes SET ORDER TO 0.  After a change of controlling indexes,
    the record pointer still points to the same record number in the new
    index allowing you to switch orders efficiently.

    To return the ordinal position of the current controlling index, use
    INDEXORD().
!Seealso:"INDEX"  "REINDEX"  "SET INDEX"  "USE"  CLIP002.NGO:"INDEXEXT()"  CLIP002.NGO:"INDEXKEY()"  CLIP002.NGO:"INDEXORD()"  
!Short: SET PATH       Specifies a path for file search.
^BSET PATH^B

    SET PATH specifies the search path that Clipper follows when attempting
    to access files.

^USyntax^U

    SET PATH TO [<path list>]

^UArgument^U

    <path list> identifies the paths where Clipper searches for a file if
    it is not found in the current directory.  A path is a pointer to a
    directory.  It includes a list of all the directories from the root to
    the specified directory separated by backslashes.  A path list then is
    the sequence of paths to search, each separated by a comma or semi-
    colon.

    Note: Because the semi-colon is a path list separator, continuation of
    a path command line with a semi-colon is not supported.

    SET PATH TO with no argument releases the path list and Clipper only
    searches the current directory.

^UUsage^U

    SET PATH allows Clipper to find and update existing files in another
    drive and/or directory.  When you attempt to access a file Clipper
    first looks for it in the current drive and directory.  The current
    disk drive and directory is established when your Clipper application
    is loaded, or by SET DEFAULT.  If the file is not found, Clipper then
    searches the path list you specified path by path until the first
    instance of the file is found.  Note that FILE() respects the PATH
    SETting when searching for the existence of a file.

    The path, however, is only for finding existing files.  If you wish to
    create new files in another drive or directory, use SET DEFAULT TO
    <directory> or explicitly declare the path when specifying the
    filename.

    To configure a compiled application to a site-specific path setting at
    runtime, pass a DOS environmental variable to your application program,
    retrieve its value with GETE(), and SET PATH with this value.  For
    example, in DOS

       ^RC> SET CLIP_PATH=C:\APPS\DATA, C:\APPS\PROGS^R

    Later in the configuration section of your application program:

    ^Rpath_set = GETE(:CLIP_PATH")^R
    ^RSET PATH TO &path_set       ^R
!Seealso:CLIP006.NGO:"DIR"  "SET DEFAULT"  
!Short: SET PRINT      Sends output to the printer.
^BSET PRINT^B

    SET PRINT ON directs all output not formatted with the @...SAY command
    to the printer as well as to the screen.

^USyntax^U

    SET PRINT ON/OFF

^UDefaults^U

    SET PRINT is normally OFF.

^UUsage^U

    When SET PRINT is ON, all screen output, including LIST and ?, is
    routed to the printer.

    Use SET DEVICE TO PRINT to direct @...SAY commands to the printer.  SET
    PRINT ON does not affect @...SAY commands.

    Note that a number of commands such as REPORT and LABEL FORM can direct
    output to the printer from their respective command lines.  To suppress
    output to the screen in these instances, however, you must still SET
    CONSOLE OFF.
!Seealso:CLIP006.NGO:"EJECT"  "SET CONSOLE"  "SET DEVICE"  "SET PRINTER"  
!Short: SET PRINTER    Determines destination of the print output.
^BSET PRINTER^B

    Selects a DOS device for printer output.

^USyntax^U

    SET PRINTER TO [<device>/<file>/(<expC>)]

^UArgument^U

    <device> sends the printed output to the network or the local device.
    For some networks, the work station's printer should first be
    redirected to the file server (usually by running the network spooler
    program).

    <file> sends all printer output including @...SAYs to the specified
    filename.  If you do not specify a file extension, Clipper appends a
    .prn extension to the filename.

    SET PRINTER TO with no arguments closes the print spool file and
    resets the default destination.

    SETting the PRINTER TO a non-existent device creates a file with the
    name of the device.

^UUsage^U

    The default device is PRN.

    SET PRINTER directs printed output from any print-related command to
    the specified device.  Device names include LPT1, LPT2, LPT3 (all
    parallel ports), COM1, and COM2 (serial ports).

    ^BNote:^B When specifying device names, be sure not to specify a
    trailing colon.

    This capability has several uses:

    o  You can swap ports for managing multiple printers.

    o  You can direct output to a file for printing later or transfer to a
       remote computer via telecommunications.

    o  You can empty the printer spooler and reset the default device.
!Seealso:CLIP006.NGO:"@...SAY...GET"  "SET DEVICE"  "SET PRINT"  
!Short: SET PROCEDURE  Compiles procedures & functions into current object file.
^BSET PROCEDURE^B

    SET PROCEDURE compiles all procedures and user-defined functions within
    the specified file into the current object file.

^USyntax^U

    SET PROCEDURE TO [<file>]

^UArgument^U

    <filename> is the name of the procedure file.  If the file has no
    extension, then .prg is assumed.

^UUsage^U

    A procedure file may contain any number of procedures or user-defined
    functions.  When a SET PROCEDURE TO command is encountered, Clipper
    compiles the procedures and user-defined functions in the file.
    Essentially, a procedure file in Clipper operates much as an include
    directive does in other compiled environments.

    CLOSE PROCEDURE and SET PROCEDURE TO with no argument are both ignored
    when encountered.
!Seealso:CLIP006.NGO:"DO"  "FUNCTION"  "PROCEDURE"  "RETURN"  
!Short: SET RELATION   Links two databases together according to key expression.
^BSET RELATION^B

    SET RELATION links two open database files according to a key
    expression, record number, or numeric expression.

^USyntax^U

    SET RELATION [ADDITIVE] TO [<key exp1>/RECNO()/<expN1>
    INTO <alias1>/<expC1>] [,TO <key exp2>/RECNO()/<expN2>
    INTO <alias2>/<expC2>]...

^UArguments^U

    <key exp> is an expression used to perform a SEEK in the child work
    area each time the record pointer moves in the parent work area.  For
    this to work, the child work area must have an index in USE.

    RECNO() relates the parent to the child work area using the parent
    record number to perform a GOTO to the same record number in the child
    work area each time the record pointer moves in the parent work area.
    For this type of relation, it is recommended that the child work area
    not have an index in USE.

    <expN> is an expression used to perform a GOTO to the matching record
    number in the child work area each time the record pointer moves in the
    parent work area.  For this type of relation to execute correctly, the
    child work area must not have an index in USE.

    <alias> identifies the child work area.

    To release all RELATIONs in a work area, specify SET RELATION TO with
    no arguments.

    Clipper supports eight relations per work area.  Note that cyclical
    relations are not supported.  You cannot relate a database file to
    itself, either directly or indirectly.

^UOption^U

    ^BAdditive^B: The ADDITIVE clause adds the specified child relations to
    the relations already set in the current work area.  If this clause is
    not specified, existing relations in the current work area are released
    before the newly specified child relations are set.

^UUsage^U

    A relation defined by SET RELATION causes the record pointer to move in
    the child work area in accordance with the movement of the record
    pointer in the parent work area.  If there is not a match in the child
    work area, the child record pointer is positioned to LASTREC() + 1,
    EOF() returns true (.T.) and FOUND() returns false (.F.).

    ^BNote^B: SET RELATION does not obey SOFTSEEK and always behaves as if
    SOFTSEEK is OFF.  If a match is not found in the child work area, the
    child record pointer is positioned to LASTREC() + 1.
!Seealso:"INDEX"  "REPLACE"  "SET INDEX"  "SET ORDER"  "UPDATE"  "USE"  
!Short: SET SCOREBOARD Toggles display of messages within READ and MEMOEDIT().
^BSET SCOREBOARD^B

    SET SCOREBOARD toggles the display of messages within READ and
    MEMOEDIT() ON or off.

^USyntax^U

    SET SCOREBOARD ON/off/(<expL>)

 ^UUsage^U

    When SCOREBOARD is ON, messages from modes display on line 0.  These
    include the RANGE clause error message, the abort query message for
    MEMOEDIT(), and a message indicating insert mode both within MEMOEDIT()
    and READ.
!Short: SET SOFTSEEK   Toggles for "relative" SEEKing.
^BSET SOFTSEEK^B

    SET SOFTSEEK toggles for "relative" SEEKing (looking for the next
    higher key value when a search fails using SEEK).

^USyntax^U

    SET SOFTSEEK on/OFF/(<expL>)

 ^UUsage^U

    If SOFTSEEK is ON and a match for the SEEK argument is not found, the
    record pointer is set to the next record in the index with a higher key
    value than the search key.  If there is no record with higher key
    value, the record pointer is positioned at LASTREC() + 1, EOF() returns
    true (.T.), and FOUND() returns false (.F.).

    If SOFTSEEK is OFF and a SEEK is unsuccessful, the record pointer is
    positioned at LASTREC() + 1, EOF() returns true (.T.), and FOUND()
    returns false (.F.).

    Note that SET EXACT has no effect on a SEEK if SOFTSEEK is ON.  Note
    also that SET RELATION ignores SOFTSEEK and so updates the record
    pointer in child work areas as if SOFTSEEK is OFF.
!Seealso:"INDEX"  "SEEK"  "SET EXACT"  "SET RELATION"  
!Short: SET TYPEAHEAD  Specifies the size of the keyboard buffer.
^BSET TYPEAHEAD^B

    SET TYPEAHEAD sets the size of the keyboard buffer.

^USyntax^U

    SET TYPEAHEAD TO <expN>

^UArguments^U

    <expN> determines the number of characters the keyboard buffer can hold
    from a minimum of zero to a maximum of 32,768.

    Note that setting the keyboard buffer size to zero may disable Alt-C
    and Alt-D if you are performing a very tight loop operation.
!Seealso:CLIP006.NGO:"ACCEPT"  "INPUT"  "KEYBOARD"  "READ"  "SET KEY"  CLIP002.NGO:"LASTKEY"  
!Short: SET UNIQUE     Only first records with identical keys appear in index file.
^BSET UNIQUE^B

    SET UNIQUE determines whether all records with the same key value are
    included in the index file.

^USyntax^U

    SET UNIQUE on/OFF/(<expL>)

^UUsage^U

    When you INDEX with UNIQUE ON, Clipper creates an index with uniqueness
    as an attribute.  As indexing proceeds and two or more records have the
    same key value, Clipper includes only the first record in the index.
    Whenever the unique index is updated, REINDEXed, or PACKed, only unique
    records are added.  This happens without regard to the current UNIQUE
    SETting.

    Note that this differs from previous versions of Clipper where UNIQUE
    was a global SETting and applied to the creation and updating of all
    open indexes.
!Seealso:"FIND"  "INDEX"  "REINDEX"  "SEEK"  "SET INDEX"  "USE"  
!Short: SET WRAP       Toggles wrapping in menus.
^BSET WRAP^B

    SET WRAP toggles wrapping in MENUs.

^USyntax^U

    SET WRAP on/OFF/(<expL>)

^UUsage^U

    When WRAP is ON and the highlight is on the last menu option,
    Rightarrow or Dnarrow moves it to the first option.  If the first
    option is highlighted, Leftarrow or Uparrow moves it to the last
    option.
!Seealso:CLIP006.NGO:"@...PROMPT"  "MENU TO"  "SET MESSAGE"  
!Short: SKIP           Moves pointer forward/backward relative to current position.
^BSKIP^B

    SKIP moves the record pointer forward or backward in the active
    database file.

^USyntax^U

    SKIP <exp N1> [ALIAS <work area>/<alias>/(<expN2>)]

^UArgument^U

    <expN1> specifies the number of records to move the record pointer from
    the current position.  A positive value moves the record pointer
    forward and a negative value moves the record pointer backwards.  A
    zero argument flushes the current work area buffer to DOS buffers.

^UOption^U

    ^BAlias^B: The ALIAS clause moves the record pointer in the designated
    work area instead of the current work area.

^UUsage^U

    SKIP without a numeric argument moves the current record position to
    the next record.  SKIPping backward beyond the beginning-of-file moves
    the pointer to the first record and BOF() returns true (.T.).  SKIPping
    forward beyond the end-of-file positions the record pointer at
    LASTREC() + 1 and EOF() returns true (.T.).

    If an index file is in use, SKIP moves the specified number of
    positions as defined by the index.

    ^BFlushing Clipper buffers^B: Any command that causes a record to be
    read into Clipper's internal buffers flushes the current database file
    buffer to a DOS buffer if a change has been made to that buffer;s
    contents since it was read from disk.  SKIP 0 can be used to force a
    flush of the current database file buffer without causing record
    movement.  Note that the specific time information is written to disk
    depends on DOS unless you execute a COMMIT to force an actual disk-
    write.  SKIP 0 itself does not necessarily cause a disk write.  Note
    also that the command does not flush INDEX buffers.

^UExample^U

    The following demonstrates movement of the record pointer in a remote
    work area:

    ^RSKIP ALIAS 4^R

    This is the same as:

    ^RSELECT 4^R
    ^RSKIP    ^R
    ^RSELECT 1^R
!Seealso:CLIP006.NGO:"COMMIT"  CLIP002.NGO:"RECNO()"  CLIP006.NGO:"CONTINUE"  "GOTO"  "FIND"  "LOCATE"  "SEEK"  
!Short: SORT           Creates copy of database file sorted on one or more fields.
^BSORT^B

    SORT copies records from the current work area to another database file
    in sorted order.

^USyntax^U

    SORT [<scope>] ON <field1> [/A][/C][/D] [,<field2> [/A][/C][/D]]...
    TO <file>/(<expC>) [FOR <condition>] [WHILE <condition>]

^UArguments^U

    <field1..fieldN> are the fields to use as sort keys.  Note that SORT
    does not work with substrings and expressions as keys.

    <file> is the name of the target file for the sorted records.  Unless
    otherwise specified, the new file is assigned the (.dbf) extension.

^UOptions^U

    ^BOrder^B SOFT supports three sorting options:

    o  /A sorts in ascending order.
    o  /D sorts in descending order.
    o  /C sorts ignoring the case of the specified character field.

    Unless otherwise specified, the default SORT is ascending order.

    ^BScope^B: The <scope> is the portion of the current database file to
    SORT.  The default is ALL.

    ^BCondition^B: The FOR clause specifies the conditional set of records
    to SORT within the given scope.  The WHILE clause specifies the set of
    records meeting the condition from the current record until the
    condition fails.

^UUsage^U

    Clipper SORTs character fields in accordance with ASCII value of each
    character within the string.  Numeric fields are SORTed in numeric
    order, and date fields are SORTed chronologically.  Logical and memo
    fields cannot be SORTed.

    SORT performs as much of its operation as possible in memory and then
    it spools to a temporary disk file (Clipsort.tmp).  This temporary file
    can be as large as the size of the source database file.  Note also
    that a SORT uses up to three file handles: the source database file,
    the target database file, and the temporary file.

    ^BDeleted source records^B: SORT copies deleted records to the target
    database file and the deleted records retain their deleted status.

^UNetwork^U

    In a network environment, the database file to be SORTed should be
    locked with FLOCK() or USEd EXCLUSIVEly.
!Seealso:"INDEX"  
!Short: STORE          Creates and initializes one or more memory variables.
^BSTORE^B

    STORE initializes and/or assigns a value to one or more memory
    variables.

^USyntax^U

    STORE <exp> TO <memvar list>   -or-   <memvar> = <exp>

^UArguments^U

    <exp> is a value of any data type assigned to the target memory
    variable(s).

    <memvar list> are the memory variables to initialize and/or assign
    values.  Memory variable names can be up to 10 characters in length and
    contain letters, numbers, and underscores (_).  The first character,
    however, must be a letter.

^UUsage^U

    STORE both creates and assigns values to memory variables. Unlike other
    languages, there is no type declaration necessary.  Clipper
    automatically assigns the data type based on the resulting value of the
    expression before the value is stored.  The scope of a memory variable
    is private unless it is explicitly declared PUBLIC prior to
    initialization.  A private memory variable is released when the
    procedure where it is initialized terminates with a RETURN.  RELEASE,
    CLEAR MEMORY, and CLEAR ALL also release memory variables.

    Fields and memory variables can have the same name.  When there is a
    name conflict, field names take precedence unless the memory variable
    is identified with the memory variable alias M-><memvar> or you have
    compiled with the (-v) switch.  The (-v) switch changes this so that
    memory variables have precedence over field names.

    In Clipper, the maximum number of memory variables that can exist at one
    time is 2048.  Arrays, however, count only as one memory variable, each
    containing up to 2048 elements (memory permitting).

    Assigning a memo field to a non-existent memory variable creates a
    memory variable of character type.
!Seealso:CLIP006.NGO:"CLEAR MEMORY"  "PRIVATE"  "PUBLIC"  "RELEASE"  "RESTORE"  "SAVE"  
!Short: SUM            Computes & displays sum of selected arithmetic fields.
^BSUM^B

    SUM totals expressions involving numeric fields in the active database
    file.

^USyntax^U

    SUM [<scope>] <expN list> TO <memvar list> [FOR <condition>]
    [WHILE <condition>]

^UArgument^U

    <expN list> is the list of numeric values to SUM for each record
    processed.

    <memvar list> identifies the receiving memory variables for the SUM and
    are created at the time of execution of the command.  Existing memory
    variables with the same names are overwritten.  This list must contain
    the same number of elements as the list of expressions to SUM.

^UOption^U

    ^BScope:^B The <scope> is the portion of the current database file to
    SUM.  The default scope is ALL.

    ^BCondition:^B The FOR clause specifies the conditional set of records
    to SUM within the given scope.  The WHILE clause specifies the set of
    records meeting the condition from the current record until the
    condition fails.
!Seealso:CLIP006.NGO:"AVERAGE"  "TOTAL"  
!Short: TEXT           Displays a block of text data in a command file.
^BTEXT^B

    TEXT is used to display blocks of text to the screen or printer.  The
    command provides a simple, convenient way to write to the output
    device.

^USyntax^U

    TEXT [TO PRINT] [TO FILE <file>]
    <text>...
    ENDTEXT

^UArgument^U

    <text> is the block of literal characters to display to the screen.
    Text is displayed exactly as formatted.

^UOptions^U

    ^BPrint^B: The TO PRINT clause echoes the display to the printer.

    ^BFile^B: The TO FILE clause echoes the display to the specified
    <file>.  If no extension is specified, (.txt) is added.

^UUsage^U

    Macro variables found within TEXT..ENDTEXT are expanded.  Note,
    however, that TEXT..ENDTEXT has no provision for word-wrapping.  Text
    is displayed exactly as encountered.
!Seealso:CLIP006.NGO:"?/??"  CLIP006.NGO:"@...SAY...GET"  CLIP002.NGO:"MLCOUNT()"  CLIP002.NGO:"MEMOLINE()"  
!Short: TOTAL          Sums numeric fields of active database to second database.
^BTOTAL^B

    TOTAL summarizes records by key value, sums specified numeric fields,
    and copies summary records to a second database file.

^USyntax^U

    TOTAL ON <key exp> [<scope>] [FIELDS <field list>] TO <file>/(<expC>)
    [FOR <condition>] [WHILE <condition>]

^UArgument^U

    <key exp> defines the group of records as encountered that produce a
    new record in the target database file.  To make the summarizing
    operation accurate, the source database file should be INDEXed or
    SORTed on the TOTAL key expression.

    <file> is the name of the target file to copy the summarized records.
    Unless otherwise specified, TOTAL assumes a (.dbf) extension.

^UOption^U

    ^BFields:^B The FIELDS clause specifies the list of numeric fields to
    TOTAL.  If the FIELDS clause is not specified, no numeric fields are
    totaled.  Instead, each numeric field in the target file contains the
    value for the first record matching the key expression.

    ^BScope^B: The <scope> is the portion of the current database file to
    TOTAL.  The default is ALL.

    ^BCondition:^B The FOR clause specifies the conditional set of records
    to TOTAL within the given scope.  The WHILE clause specifies the set of
    records meeting the condition from the current record until the
    condition fails.

^UUsage^U

    In Clipper, TOTAL has two modes depending on whether you specify a
    FIELDS clause or not.  If the FIELDS clause is specified, TOTAL sums
    the specified numeric fields to the target database file grouped by the
    specified key expression.  If, however, the FIELDS clause is not
    specified, TOTAL copies only records with unique keys to the target
    database file.  With this formulation, you can eliminate records with
    duplicate key values.

    The structure of the target database file Clipper creates is identical
    to the source except that memo fields are not copied.  Note that in
    order to successfully TOTAL numeric fields, the source numeric fields
    must be large enough to hold the largest total possible for that
    numeric field.
!Seealso:CLIP006.NGO:"AVERAGE"  "SUM"  
!Short: TYPE           Displays and/or prints contents of a text file.
^BTYPE^B

    TYPE displays the contents of a text file, optionally echoing the
    display to the printer and/or another text file.

^USyntax^U

    TYPE <file>.<ext> [TO PRINT] [TO FILE <file>]

^UArgument^U

    <file>.<ext> is the name of the file including extension to display to
    the screen.

^UOptions^U

    ^BPrint^B: The TO PRINT clause echoes the display to the printer.

    ^BFile^B: The TO FILE clause echoes the display to the specified
    <file>.  If no extension is specified, (.txt) is added.

^UUsage^U

    To pause output, use Ctrl-S.  Note that you cannot interrupt the
    listing with Esc.
!Seealso:CLIP006.NGO:"COPY FILE"  
!Short: UNLOCK         Release a file or record lock set by current user.
^BUNLOCK^B

    UNLOCK releases a file or record locks set by the current user in a
    multi-user environment.

^USyntax^U

    UNLOCK [ALL]

^UOption^U

    ^BAll^B: The ALL clause releases all current locks in all work areas.
    if it not specified, locks in the current work area only are released.
!Seealso:"SET EXCLUSIVE"  "USE"  CLIP002.NGO:"RLOCK()"  
!Short: UPDATE         Allows batch updates of a database file.
^BUPDATE^B

    UPDATE updates the current database file from another database file
    based on a one-to-one or one-to-many relation.

^USyntax^U

    UPDATE ON <key exp> FROM <alias> REPLACE <field1> WITH <exp1>
    [,<field2> WITH <exp2>...] [RANDOM]

^UArguments^U

    <key exp> is an expression used that defines matching records in the
    source work area.

    <alias> is the alias of the source work area used to update records in
    the current work area.

    <field1...fieldN> are the fields in the current work area to replace
    with new values.

    <exp1...expN> identifies the values to replace into the target fields.
    Fields from the source work area must be referenced with the alias of
    the respective work area.

^UOption^U

    ^BRandom^B: The RANDOM clause causes the entire source database file to
    be read allowing the source database file to be in any order.  If this
    option is specified, the target database file must be indexed on the
    <key exp>.

^UUsage^U

    UPDATE matches records in the target work area using the key expression
    as the argument of a lookup into the source work area.  To obtain an
    accurate UPDATE, both database files must be sorted or indexed on the
    key expression.  If the source database file is not sorted or indexed,
    use the RANDOM clause.

    ^BRelations between work areas^B: UPDATE supports both one-to-one and
    one-to-many relations between the target and the source work areas.  It
    does not, however, support many-to-many or many-to-one relations.  All
    source records matching the <key exp> UPDATE only the first instance of
    the matching target records.

    ^BTypes of replacement^B: When you UPDATE, the REPLACE expression
    determines the type of UPDATE made to a target field.  If the UPDATE to
    the field adds to the target field, the formulation is:

    ^RREPLACE <target field> WITH <target field> + <expN>^R

    Likewise, if the UPDATE subtracts from the target field, the
    formulation is:

    ^RREPLACE <target field> WITH <target field> - <expN>^R

    ^BDeleted records^B: When DELETED is ON, all target records are UPDATEd
    including deleted ones.  Deleted source records, however, are ignored.

^UNetwork^U

    In order to UPDATE in a network environment, the target database file
    must be locked with FLOCK() or USEd EXCLUSIVEly.  The source file may
    either be USEd EXCLUSIVEly or shared.
!Seealso:CLIP006.NGO:"APPEND"  "REPLACE"  "SET UNIQUE"  
!Short: USE            Specifies database file to be used for all operations.
^BUSE^B

    USE opens an existing database file, its associated memo (.dbt) file,
    and optionally associated index files in the currently selected work
    area.

^USyntax^U

    USE [<file>/(<expC>)] [INDEX <file list>/(<expC>)] [,(<expC)]...]
    [EXCLUSIVE] [ALIAS <alias>/(<expC>)]

^UArgument^U

    <file> is the name of the database file to open.

^UOptions^U

    ^BIndex^B: The INDEX <file list> clause specifies the name(s) of up to
    15 index files to open in the current work area.

    ^BAlias^B: The <alias> is the name to associate with the work area when
    the database file is opened.  If this clause is not specified, the
    alias defaults to the database filename.

    ^BExclusive^B: The EXCLUSIVE clause opens the database file for non-
    shared use in a network environment.  All other users are denied access
    until the database file is CLOSEd.

^UUsage^U

    When a database file is opened, the record pointer is positioned at the
    first logical record in the file (record 1 if there is no index file
    specified).

    USE without an argument CLOSEs the active database file, associated
    index, and memo files in the current work area.
!Seealso:CLIP006.NGO:"CLOSE"  "INDEX"  "SELECT"  "SET INDEX"  
!Short: WAIT           Suspends program processing until a key is entered.
^BWAIT^B

    WAIT causes all program processing to pause until any key is pressed.

^USyntax^U

    WAIT [<prompt>] [TO <memvarC>]

^UOptions^U

    ^BPrompt^B: The <prompt> is a character string WAIT displays if
    specified.  If no <prompt> is specified, the default prompt is
    "Press any key to continue..."

    ^BMemory variable^B: The TO <memvarC> clause creates the specified
    memory variable that contains the character entered.

^UUsage^U

    WAIT returns the character entered into the specified character memory
    variable.  If a non-printable character is entered, WAIT returns zero
    to the character variable.  Function keys are ignored unless assigned
    with SET FUNCTION or SET KEY.
!Seealso:CLIP006.NGO:"ACCEPT"  "INPUT"  
!Short: ZAP            Removes all records from active database file.
^BZAP^B

    ZAP removes all records from the active database file.

^USyntax^U

    ZAP

^UUsage^U

    ZAP is equivalent, but much faster, to a DELETE ALL command followed by
    PACK.

    Any open index files in the current work area are automatically
    reindexed to reflect the empty database file.
!Seealso:CLIP006.NGO:"CLEAR"  CLIP006.NGO:"DELETE"  "PACK"  
