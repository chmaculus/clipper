!Short: ABS          Returns the absolute value of a numeric expression.
^BABS()^B

    ABS() returns a number representing the absolute value of a numeric
    expression.

^USyntax^U

    ABS(<expN>)

^UArgument^U

    <expN> is a numeric expression to evaluate.

^UUsage^U

    The ABS() function enables you to find the difference between two
    numbers without first needing to test for which is larger.

    The returned value is always a positive number.
!Short: ACHOICE      Executes a pop-up menu using character string array.
^BACHOICE()^B

    ACHOICE() executes a pop-up menu using an array of character strings as
    choices.

^USyntax^U

    ACHOICE(<expN1>,<expN2>,<expN3>,<expN4>,<array1>[,<array2>,[,<expC>
    [,<expN5>[,<expN6>]]]])

^UArgument^U

    <expN1..expN4> are the top, left, bottom and right window coordinates
    respectively.

    <array1> is an array of character strings to display as menu choices.

    <array2> is a parallel array of logical values, one for each menu
    choice.  If an element is false (.F.), the parallel menu choice is not
    available.  You can, however, specify this argument as a single logical
    value and the menu is treated as if you specified an array filled with
    that value.  This is valuable when you want all choices to be either
    available or unavailable.

    <expC> is a user-defined function that executes generally when a key
    exception is pressed.  Be sure to specify the function name without the
    parenthetical suffix or any arguments.  Note that the behavior of
    ACHOICE() is affected by the presence of this argument.  Refer to the
    discussion below for further information.

    <expN5> is the initial choice element.  If not specified, the default
    initial choice is element one in <array1>.

    <expN6> is the initial relative window row.  If not specified, the
    initial relative window row is first choice in the window, which is
    position zero.

^UReturns^U

    A numeric value.

    ACHOICE() returns the position of the menu choice in the array of
    choices.  Making a selection terminates the menu and returns the
    current element position in <array1>.  Aborting the selection
    terminates the menu and returns zero.

^UUsage^U

    ACHOICE() has two modes depending on whether or not you specify the
    user-defined function argument (<expC>).  If you do not specify a user
    function, ACHOICE() displays the list of choices within the given
    screen coordinates.  It then executes the following actions when you
    press the corresponding keys.

                   ^BACHOICE() Active Keys - No User Function^B
    ^UKey^U            ^UAction^U

    Uparrow        Up one element
    Dnarrow        Down one element
    Home           First element
    End            Last element
    Leftarrow      Abort selection, returning zero
    Rightarrow     Abort selection, returning zero
    PgUp           Up the number of elements defined for the menu window
                   to the same relative row position
    PgDn           Down the number of elements defined for the menu window
                   to the same relative row position
    Ctrl-PgUp      First element
    Ctrl-PgDn      Last element
    Return         Select element, returning position
    Esc            Abort selection, returning zero
    First letter   Next element with same first letter (does not select)

    If the number of choices in <array1> exceeds the number of rows in the
    menu window, the choices scroll when you attempt to cursor beyond the
    top or bottom of the menu window.  Note that the highlight does not
    wrap when you reach the top or bottom of the list of choices.  Pressing
    the first letter does, however, wrap the highlight within the set of
    choices whose first letter matches the key you are pressing.

    ^BThe User Function^B: If you specify a user function, the behavior of
    ACHOICE() changes to some degree.  Primarily, fewer keys are not
    automatically executed by ACHOICE() and control passes to the user
    function where you can process the key pressed and execute an
    appropriate action.  The following are keys that ACHOICE() executes
    when you specify a user function.  These keys generate an idle (mode 0)
    while all other keys generate a keyboard exception (mode 3).

                    ^BACHOICE() Active Keys - User Function^B
    ^UKey^U            ^UAction^U

    Uparrow        Up one element
    Dnarrow        Down one element
    PgUp           Up the number of elements defined for the menu window
                   to the same relative row position
    PgDn           Down the number of elements defined for the menu window
                   to the same relative row position
    Ctrl-PgUp      First element
    Ctrl-PgDn      Last element

    Note that Home, End, Return, and Esc now generate a keyboard exception
    (mode 3).

    When ACHOICE() executes the user function, it automatically passes the
    following three parameters: mode, current element in the array of
    choices, and the relative position within the menu window.  The mode
    indicates the current state of ACHOICE() depending on the key pressed
    and action taken by ACHOICE() prior to executing the user function.
    The mode parameter has the following possible values:

                               ^BACHOICE() Modes^B
    ^UMode^U      ^UDescription^U
      0       Idle
      1       Cursor past top of list
      2       Cursor past end of list
      3       Keystroke exception
      4       No item selectable

    After your user function has performed whatever operations are
    appropriate to the ACHOICE() mode or the last key pressed, you RETURN a
    value instructing ACHOICE() what operation to perform next.  The
    following table summarizes the possible return values:

                ^BReturn Values to ACHOICE() from User Function^B
    ^UValue^U     ^UAction^U
      0       Abort selection, return zero
      1       Make selection, return cursor element
      2       Continue selection process
      3       Go to next element whose first character matches last key
              pressed

    ^BColor^B: Choices are displayed in standard color, the highlight is in
    enhanced color, and the unavailable choices are displayed in the
    unselected color.  For example, the following color statement:

    ^RSET COLOR TO W+/N,BG+/B,,,W/N^R

    displays a menu that is bright white on black, the highlight is bright
    cyan on blue, and the unavailable menu choices are dim white on black.

    If you are executing ACHOICE() with all choices unavailable in order to
    have a display-only list, assign the unselected setting to the same
    setting as the standard.

    ^BNesting^B: You can call multiple copies of ACHOICE() within each copy
    of ACHOICE(), allowing you to create nested or hierarchical menus.
!Seealso:CLIP001.NGO:"MENU"  CLIP001.NGO:"SET MESSAGE"  "DBEDIT()"  
!Short: ACOPY        Copies elements from one array to another.
^BACOPY()^B

    ACOPY() copies elements from one array to another.

^USyntax^U

    ACOPY(<array1>,<array2>[,<expN1>[,<expN2>[,<expN3]]])

^UArgument^U

    <array1> is the source array.

    <array2> is the target array.

    <expN1> is the starting element position in the source array.

    <expN2> is the number of elements to copy from the source array
    beginning with <expN1>.

    <expN3> is the starting element position in the target array to begin
    the copy.

^UReturns^U

    There is no return value.
!Seealso:CLIP006.NGO:"ACHOICE"  CLIP001.NGO:"ADEL"  CLIP001.NGO:"ADIR"  CLIP001.NGO:"AFIELDS"  CLIP001.NGO:"AFILL"  CLIP001.NGO:"AINS"  CLIP001.NGO:"ASCAN"  CLIP001.NGO:"ASORT"  
!Short: ADEL         Deletes an array element.
^BADEL()^B

    ADEL() deletes an array element.

^USyntax^U

    ADEL(<array>,<expN>)

^UArgument^U

    <array> is the name of the array to delete an element from.

    <expN> is the position of the element to delete.

^UReturns^U

    There is no return value.

^UUsage^U

    The contents of the indicated array position are lost and all elements
    from that position to the end of the array are shifted up one element.
    The last position in the array then becomes undefined until a new value
    is assigned to it.
!Seealso:CLIP006.NGO:"ACHOICE"  CLIP001.NGO:"ACOPY"  CLIP001.NGO:"ADIR"  CLIP001.NGO:"AFIELDS"  CLIP001.NGO:"AFILL"  CLIP001.NGO:"AINS"  CLIP001.NGO:"ASCAN"  CLIP001.NGO:"ASORT"  
!Short: ADIR         Fills a series of arrays with file information.
^BADIR()^B

    ADIR() fills a series of arrays with directory information including
    filenames and/or return the number of files matching a skeleton.

^USyntax^U

    ADIR(<directory skeleton>[,<array1>[,<array2>[,<array3>
          [,<array4>[,<array5]]]]])

^UArguments^U

    <directory skeleton> is a wildcard pattern of files.  The standard
    wildcard characters (* and ?) are supported.  The default is "*.*"

    <array1> is the name of the array to fill with the filenames matching
    the directory skeleton.  Each element is character type.

    <array2> is the array to fill with the sizes of the corresponding files
    in <array1>.  Each element is numeric type.

    <array3> is the array to fill with the dates of the corresponding files
    in <array1>.  Each element is date type.

    <array4> is the array to fill with the times of the corresponding files
    in <array1>.  Each element is character type.

    <array5> is the array to fill with the attributes of the corresponding
    files in <array1>.  Each element is character type.  The possible
    values returned are as follows:

                    ^BAttributes of Files Returned by ADIR()^B
    ^USymbol^U       ^UDescription^U
      R          Read only
      H          Hidden
      S          System
      D          Directory
      A          Archive

    Note that if <array5> is specified, hidden, system, and directory files
    are included as well as normal files.  If <array5> is not specified
    only normal files are included.

^UReturns^U

    An integer numeric value.

    ADIR() returns the number of files matching the specified directory
    skeleton.  If the optional array name is included, elements of the
    array are filled with one filename per element until all matching files
    have been found or all of the elements have been used.

^UUsage^U

    ADIR() is useful as a tool for building file selectors and directory
    maintenance routines.  To create a file list array, you must DECLARE an
    array and then fill it with the necessary filenames.  The best way to
    do this is to first use ADIR() as the number of elements argument in
    the DECLARE statement.  For example:

    ^RDECLARE dbf_files[ADIR("*.dbf")]^R

    Then sometime later, fill the array using the directory skeleton.

    To fill arrays for some attributes while ignoring others, pass a dummy
    variable.  For example, to obtain only the filenames and corresponding
    file dates:

    ^Rdbf_count = ADIR(*.dbf")                         ^R
    ^RDECLARE dbf_files[dbf_count], dbf_date[dbf_count]^R
    ^Rdummy = ""                                       ^R
    ^RADIR(dbf_file, dummy, dbf_date)                  ^R
!Seealso:CLIP006.NGO:"ACHOICE"  CLIP001.NGO:"ACOPY"  CLIP001.NGO:"ADEL"  CLIP001.NGO:"AFIELDS"  CLIP001.NGO:"AFILL"  CLIP001.NGO:"AINS"  CLIP001.NGO:"ASCAN"  CLIP001.NGO:"ASORT"  
!Short: AFIELDS      Fills a series of arrays with field definitions.
^BAFIELDS()^B

    AFIELDS() fills a series of arrays with fieldnames, field types, field
    lengths, and field decimals.

^USyntax^U

    AFIELDS([<array1>[,<array2>[,<array3>[,<array4>]]]])

^UArguments^U

    <array1> is the name of the array to fill with fieldnames.  Each
    element is character type.

    <array2> is the array to fill with the type of fields in <array1>.
    Each element is character type.

    <array3> is the array to fill with the widths of fields in <array1>.
    Each element is numeric type.

    <array4> is the array to fill with the number of decimals define for
    fields in <array1>.  Each element is numeric type.  If the field type
    is not numeric, the element is zero.

^UReturns^U

    An integer numeric value.

    AFIELDS() returns the number of fields or the length of the shortest
    array argument, whichever is less.  If no parameters are specified,
    AFIELDS() returns zero.

^UUsage^U

    AFIELDS() fills a series of arrays with the attributes of fields from
    the current work area and returns the number of elements filled with
    field information.  If there is no database file in USE, AFIELDS()
    returns zero.  The arrays passed correspond to fieldname, field type,
    field length, and field decimals if the field is numeric.

    To fill arrays for some attributes while ignoring others, pass a dummy
    variable.  For example, to obtain the fieldnames and corresponding
    field lengths only:

    ^RDECLARE fname[FCOUNT()], ftype[FCOUNT()]^R
    ^Rdummy = ""                              ^R
    ^RAFIELDS(fname, dummy, ftype)            ^R
!Seealso:CLIP006.NGO:"ACHOICE"  CLIP001.NGO:"ACOPY"  CLIP001.NGO:"ADEL"  CLIP001.NGO:"ADIR"  CLIP001.NGO:"AFILL"  CLIP001.NGO:"AINS"  CLIP001.NGO:"ASCAN"  CLIP001.NGO:"ASORT"  
!Short: AFILL        Fills any array with one value.
^BAFILL()^B

    AFILL() fills an array with a chosen value.

^USyntax^U

    AFILL(<array>,<exp>[,<expN1>[,<expN2>]])

^UArguments^U

    <array> is the array to fill.

    <exp> is the value to place in each array element.  It can be an
    expression of any data type.

    <expN1> is the position of the first element to fill.  This argument is
    optional and defaults to 1.

    <expN2> is the number of elements to fill starting with element
    <expN1>.  This argument is optional and defaults to all elements from
    the starting element to the end of the array.

^UReturns^U

    There is no return value.

^UUsage^U

    Note that AFILL() does not work the same as similar functions in
    spreadsheet languages.  Specifically, there is no provision for
    incrementing values in the range specified.
!Seealso:CLIP006.NGO:"ACHOICE"  CLIP001.NGO:"ACOPY"  CLIP001.NGO:"ADEL"  CLIP001.NGO:"ADIR"  CLIP001.NGO:"AFIELDS"  CLIP001.NGO:"AINS"  CLIP001.NGO:"ASCAN"  CLIP001.NGO:"ASORT"  
!Short: AINS         Inserts a new position into an array.
^BAINS()^B

    AINS() inserts an undefined element into an array.

^USyntax^U

    AINS(<array>,<expN>)

^UArguments^U

    <array> is the array to insert a new element into.

    <expN> is the position to insert the new element.

^UReturns^U

    There is no return value.

^UUsage^U

    The newly inserted position remains undefined until a new value is
    assigned to it.  After the insertion, all elements after the new
    element are shifted down one position and the last array element is
    lost.
!Seealso:CLIP006.NGO:"ACHOICE"  CLIP001.NGO:"ACOPY"  CLIP001.NGO:"ADEL"  CLIP001.NGO:"ADIR"  CLIP001.NGO:"AFIELDS"  CLIP001.NGO:"AFILL"  CLIP001.NGO:"ASCAN"  CLIP001.NGO:"ASORT"  
!Short: ALIAS        Returns the alias of a work area.
^BALIAS()^B

    ALIAS() returns the alias of the specified work area.

^USyntax^U

    ALIAS([exp N])

^UArgument^U

    <expN> is the number of the specified work area.

^UReturns^U

    A character string.

    If no argument is specified, the alias of the current work area is
    returned.  If a numeric argument is specified, the alias of that area
    is returned.  If there is no database file in USE, ALIAS() returns a
    null string ("").
!Seealso:CLIP006.NGO:"SELECT"  
!Short: ALLTRIM      Removes all leading and trailing spaces.
^BALLTRIM()^B

    Removes leading and trailing spaces from a character string.

^USyntax^U

    ALLTRIM(<expC>)

^UUsage^U

    ALLTRIM() returns <expC> without leading or trailing blanks and is the
    equivalent of LTRIM(RTRIM(<expC>)).
!Seealso:CLIP001.NGO:"LTRIM"  CLIP001.NGO:"RTRIM"  
!Short: ALTD         Executes the Clipper Debugger within a program.
^BALTD()^B

    Executes the Clipper Debugger or enabless/disables the use of Alt-D to
    invoke it.

^USyntax^U

    ALTD([<expD>]

^UArgument^U

    <expN> sets the Alt_d invocation state as follows:

    Argument     Action
      None       Invokes Debugger (last screen)
       0         Disables Alt-D
       1         Enables Alt-D
       2         Invokes Debugger (View Privates)

^UReturns^U

    There is no return value.

^UUsage^U

    If there is no argumen t specified, the Debugger is invoked displaying
    the last screen displayed.  Specifying two as the argument invokes the
    Debugger displaying the Variables: View Privates screen.

    Note that ALTD(), when specified with no argument or two as the
    argument, sets the invocation state for subsequent invocations using
    the Alt-D key.
!Seealso:CLIP001.NGO:"SET ESCAPE"  "SETCANCEL"  
!Short: ASC          Returns the ASCII code value of a character.
^BASC()^B

    ASC() evaluates the leftmost character of a character string and
    returns its ASCII value in the IBM extended character set.

^USyntax^U

    ASC(<exp C>)

^UArgument^U

    <expC> is the character expression to convert to a number.

^UReturns^U

    An integer numeric value in the range of 0 to 255.

^UUsage^U

    ASC() is used primarily in expressions where you need to perform
    numeric calculations on the ASCII value of a character.
!Seealso:CLIP001.NGO:"CHR"  "INKEY"  
!Short: ASCAN        Searches for a specific value within an array.
^BASCAN()^B

    ASCAN() scans an array for a specific value.

^USyntax^U

    ASCAN(<array>,<exp>[,<expN1>[,<expN2>]])

^UArguments^U

    <array> is the array to fill.

    <exp> is the value to scan for.  This can be a valid expression of any
    data type.

    <expN1> is the starting element of the scan.  This argument is optional
    and defaults to one if not specified.

    <expN2> is the number of elements to scan from the starting position.
    This argument is optional and defaults to all elements from the
    starting element to the end of the array.

^UReturns^U

    An integer numeric value.

    ASCAN() returns the element position containing the matching value.  If
    no value is found, ASCAN() returns zero.

^UUsage^U

    ASCAN() works the same as SEEK and FIND in the way it performs a
    search.  The <exp> is tested against the target array element beginning
    with the leftmost character in the target element and proceeds until
    there are no more characters left in the <exp>.  If there is no match,
    ASCAN() proceeds to the next element in the array.  Note that ASCAN()
    is also sensitive to the status of EXACT.  If EXACT is ON, the target
    array element must match the result of <exp> character for character.
!Seealso:CLIP006.NGO:"ACHOICE"  CLIP001.NGO:"ACOPY"  CLIP001.NGO:"ADEL"  CLIP001.NGO:"ADIR"  CLIP001.NGO:"AFIELDS"  CLIP001.NGO:"AFILL"  CLIP001.NGO:"AINS"  CLIP001.NGO:"ASORT"  
!Short: ASORT        To sort an array in ascending order.
^BASORT()^B

    ASORT() sorts the contents of an array in ascending order.

^USyntax^U

    ASORT(<array>,[,<expN1>[,<expN2>]])

^UArguments^U

    <array> is the array to sort.

    <expN1> is the first element of the sort.  If omitted, the sort begins
    with position 1.

    <expN2> is the number of elements to sort.  If you omit this argument,
    the sort operation proceeds from the beginning element position to the
    end of the array.

^UReturns^U

    There is no return value.

^UUsage^U

    All elements in the range of the array being sorted must be the same
    data type.
!Seealso:CLIP006.NGO:"ACHOICE"  CLIP001.NGO:"ACOPY"  CLIP001.NGO:"ADEL"  CLIP001.NGO:"ADIR"  CLIP001.NGO:"AFIELDS"  CLIP001.NGO:"AFILL"  CLIP001.NGO:"AINS"  CLIP001.NGO:"ASCAN"  
!Short: AT           Returns the position of a string within another string.
^BAT()^B

    AT() returns a number showing the starting position of a character
    string within a second string.  The contained character string is
    called a substring.  If the substring is not contained within the
    character string, the function returns a zero (0).

^USyntax^U

    AT(<exp C>,<exp C>)

^UExample^U

    ? AT('been','Chillee beenee') returns the value 9.
!Seealso:"RAT"  "STRTRAN()"  "SUBSTR"  
!Short: BIN2I        Converts binary two-byte character string to numeric.
^BBIN2I()^B

    Converts a character string formatted as a 16-bit signed integer to a
    Clipper numeric value.

^USyntax^U

    BIN2I(<expC>)

^UArgument^U

    <expC> is a two-byte string in the form of a 16-bit signed integer
    number.  If more than two characters are specified, the remaining are
    ignored.

^UReturns^U

    An integer numeric value.

^UUsage^U

    BIN2I() is used in combination with FREAD() or FREADSTR() to convert a
    two-byte character string as a signed integer to a Clipper numeric.
    This is most useful when you are reading foreign file types and want to
    read numeric data formatted in its native form.

^UExample^U

    This example opens a database file using low-level file functions and
    reads the date of last update (bytes 1-3).  The result is the same as
    with LUPDATE():

    ^Rhandle = FOPEN("Sales.dbf")                      ^R
    ^R*                                                ^R
    ^R* Point to byte 1 in the file                    ^R
    ^RFSEEK(handle, 1, 0)                              ^R
    ^R*                                                ^R
    ^R* Read date of last update                       ^R
    ^Ryear  = BIN2I(FREADSTR(handle, 1))               ^R
    ^Rmonth = BIN2I(FREADSTR(handle, 1))               ^R
    ^Rday   = BIN2I(FREADSTR(handle, 1))               ^R
    ^R*                                                ^R
    ^R? LTRIM(STR(month)),;          && Result 9  1  87^R
    ^R    LTRIM(STR(day)), LTRIM(STR(year))            ^R
    ^RFCLOSE(handle)                                   ^R
!Seealso:CLIP001.NGO:"BIN2L"  CLIP001.NGO:"BIN2W"  CLIP001.NGO:"I2BIN"  CLIP001.NGO:"L2BIN"  CLIP001.NGO:"FOPEN"  CLIP001.NGO:"FREAD"  CLIP001.NGO:"FREADSTR"  
!Short: BIN2L        Converts binary four-byte character string to numeric.
^BBIN2L()^B

    Converts a character string formatted as a 32-bit signed integer to a
    Clipper numeric value.

^USyntax^U

    BIN2L(<expC>)

^UArgument^U

    <expC> is a four-byte string in the form of a 16-bit signed integer
    number.  If more than four characters are specified, the remaining are
    ignored.

^UReturns^U

    An integer numeric value.

^UUsage^U

    BIN2L() is used in combination with FREAD() or FREADSTR() to convert a
    four-byte character string as a signed integer to a Clipper numeric.
    This is most useful when you are reading foreign file types and want to
    read numeric data formatted in its native form.

^UExample^U

    This example opens a database file using low-level file functions and
    reads the number of records (bytes 4-7).  The result is the same as
    with LASTREC():

    ^Rhandle = FOPEN("Sales.dbf")                      ^R
    ^Rnum_recs = SPACE(4)                              ^R
    ^R*                                                ^R
    ^R* Point to byte 4 in the file                    ^R
    ^RFSEEK(handle, 4, 0)                              ^R
    ^R*                                                ^R
    ^R* Read number of records                         ^R
    ^RFREAD(handle, @num_recs, 4)                      ^R
    ^R*                                                ^R
    ^R? LTRIM(STR(BIN2L(num_recs)))     && Result 84   ^R
    ^RFCLOSE(handle)                                   ^R
!Seealso:CLIP001.NGO:"BIN2I"  CLIP001.NGO:"BIN2W"  CLIP001.NGO:"I2BIN"  CLIP001.NGO:"L2BIN"  CLIP001.NGO:"FOPEN"  CLIP001.NGO:"FCLOSE"  
!Short: BIN2W        Converts binary four-byte character string to numeric.
^BBIN2W()^B

    Converts a character string formatted as a 16-bit unsigned integer to a
    Clipper numeric value.

^USyntax^U

    BIN2W(<expC>)

^UArgument^U

    <expC> is a two-byte string in the form of a 16-bit unsigned or long
    integer number.

^UReturns^U

    An integer numeric value.

^UUsage^U

    BIN2W() is used in combination with FREAD() or FREADSTR() to convert a
    two-byte character string as a signed integer to a Clipper numeric.
    This is most useful when you are reading foreign file types and want to
    read numeric data formatted in its native form.

^UExample^U

    This example opens a database file using low-level file functions and
    reads the number of bytes per record (bytes 10-11).  The result is the
    same as with RECSIZE():

    ^Rhandle = FOPEN("Sales.dbf")                      ^R
    ^R*                                                ^R
    ^R* Point to byte 10 in the file                   ^R
    ^RFSEEK(handle, 10, 0)                             ^R
    ^R*                                                ^R
    ^R* Read record size                               ^R
    ^Rrec_size = SPACE(2)                              ^R
    ^RFREAD(handle, @rec_size, 2)                      ^R
    ^R*                                                ^R
    ^R? LTRIM(STR(BIN2W(rec_size)))    && Result 124   ^R
    ^RFCLOSE(handle)                                   ^R
!Seealso:CLIP001.NGO:"BIN2I"  CLIP001.NGO:"BIN2L"  CLIP001.NGO:"I2BIN"  CLIP001.NGO:"L2BIN"  CLIP001.NGO:"FOPEN"  CLIP001.NGO:"FREAD"  CLIP001.NGO:"FREADSTR"  
!Short: BOF          Indicates the beginning of a file.
^BBOF()^B

    BOF() indicates that an attempt has been made to move the record
    pointer past the beginning of the current database file.

^USyntax^U

    BOF()

^UUsage^U

    This function is intended for programming applications in which the
    database is read in reverse order.  A logical True (.T.) is returned
    when an attempt is made to move the record pointer before the first
    logical record of the active file.

    If no database is in USE, BOF() will return .F.

    Note that SKIP is the only record movement command that can set BOF()
    true.
!Seealso:CLIP001.NGO:"SKIP"  CLIP001.NGO:"EOF"  
!Short: CDOW         Returns the name of the day of the week from a date value.
^BCDOW()^B

    CDOW() returns the name of the day of the week from a date expression.

^USyntax^U

    CDOW(<exp D>)

^UArgument^U

    <expD> is the date value to convert.

^UReturns^U

    A character string.

    CDOW() returns the name of the day of the week with the first letter in
    upper case and the rest of the string in lower case.  The maximum
    return value length is nine characters for Wednesday.  A null date
    value returns a null string ("").

^UUsage^U

    CDOW() is useful alone or as part of date formatting expressions for
    reports, labels, and screens.
!Seealso:CLIP001.NGO:"DOW"  CLIP001.NGO:"CMONTH"  "MONTH"  CLIP001.NGO:"DAY"  "YEAR()"  CLIP001.NGO:"CTOD"  CLIP001.NGO:"DTOC"  CLIP001.NGO:"DTOS"  CLIP001.NGO:"DATE"  
!Short: CHR          Returns a character for the specified ASCII code.
^BCHR()^B

    CHR() returns a character from the IBM Extended Character Set.

^USyntax^U

    CHR(<exp N>)

^UArgument^U

    <expN> is the IBM Extended Character Set code of the character to
    return and can be in the range of zero to 255.

^UReturns^U

    A character value.

    CHR() returns the character corresponding to the IBM Extended Character
    Set code.  Note that different commands treat characters in different
    ways.  For example, @...SAY CHR(7) displays a graphic character to the
    screen whereas ? CHR(7) sounds the bell.

^UUsage^U

    CHR() enables you to send control codes to the printer.  Another
    typical application is to produce special effects on a printer and/or
    monitor by sending a value in the IBM Extended Character Set for any
    keyboard character or graphics character.  Another typical application
    is to use CHR() to ring the bell alerting the user of an error.

    A more sophisticated application is to control the keyboard.
    Typically, you use CHR() in combination with KEYBOARD to stuff the
    keyboard with key codes.  In some instances, you might find it useful
    to create key names by assigning the CHR() of the key code to a memory
    variable.  Later, you can compare the result of a CHR(INKEY()) to the
    key name variable.

    BNote^B: CHR(0) now has a length of one and is treated the same as any
    other character.  This allows you to send it to any device or file,
    including a database file.
!Seealso:CLIP001.NGO:"KEYBOARD"  CLIP001.NGO:"ASC"  "INKEY()"  
!Short: CMONTH       Returns the name of the month from a date value.
^BCMONTH()^B

    CMONTH() returns the name of the month from a date expression.

^USyntax^U

    CMONTH(<exp D>)

^UArgument^U

    <expD> is the date value to convert.

^UReturns^U

    A character string.

    CDOW() returns the name of the month from a date value with the first
    letter in upper case and the rest of the string in lower case.  The
    maximum return value length is nine characters for the month of
    September.  A null date value returns a null string ("").

^UUsage^U

    CMONTH() is useful alone or as part of date formatting expressions for
    reports, labels, and screens.
!Seealso:CLIP001.NGO:"CDOW"  CLIP001.NGO:"DOW"  "MONTH()"  CLIP001.NGO:"DAY"  "YEAR()"  CLIP001.NGO:"CTOD"  CLIP001.NGO:"DTOC"  CLIP001.NGO:"DTOS"  CLIP001.NGO:"DATE"  
!Short: COL          Returns the current column position of the cursor.
^BCOL()^B

    COL() returns the current column position of the cursor.

^USyntax^U

    COL()

^UUsage^U

    COL() is used when you want to position the cursor to a column relative
    to the current column position.  COL() is generally used in combination
    with ROW() and all variations of the @ command.  In particular, you use
    it and ROW() to create screen position-independent procedures or
    functions where you pass the upper left row and column as parameters.
!Seealso:"ROW()"  "PCOL()"  "PROW()"  
!Short: CTOD         Converts a character string to a date value.
^BCTOD()^B

    CTOD() converts a date string to a date value.

^USyntax^U

    CTOD(<exp C>)

^UArgument^U

    <expC> is a character string consisting of number representing the
    month, day, and year separated by a delimiter character (any character
    other than a number).  When you pass the date string, CTOD() evaluates
    the order of the month, day, and year substrings according to the DATE
    SETting.  The default is AMERICAN ("mm/dd/yy").

    ^BCentury^B: A twentieth-century date is assumed if you only use two
    numbers for the year.

    ^BEmpty date^B: To specify a null date, use SPACE(8), "", or "  /  /  "
    as the function argument.

^UReturns^U

    A date value.

^UUsage^U

    CTOD() is useful whenever you want to use a character string as a date
    value.  There are a number of common instances which include:

    -  Initializing a memory variable as a date.

    -  Specifying a literal date string as an argument of a RANGE clause of
       @..GET.

    -  Specifying a literal date string in order to perform date
       arithmetic.

    -  Comparing the result of a date expression to a literal date string.

    -  REPLACEing a date field with a literal date string.
!Seealso:CLIP001.NGO:"SET DATE"  CLIP001.NGO:"CDOW"  CLIP001.NGO:"DOW"  CLIP001.NGO:"CMONTH"  "MONTH"  CLIP001.NGO:"DAY"  "YEAR()"  CLIP001.NGO:"DTOC"  CLIP001.NGO:"DTOS"  CLIP001.NGO:"DATE"  
!Short: CURDIR       Returns current DOS directory path of specified drive.
^BCURDIR()^B

    Determines the current DOS directory path of a specified drive.

^USyntax^U

    CURDIR([<expC>])

^UArgument^U

    <expC> is the drive letter (A, B, ...).  If omitted, the current DOS
    drive is assumed.

^UReturns^U

    A character string.

    CURDIR() returns the DOS directory path of the drive specified by
    <expC>.  If the return value is a null string (""), either an error has
    occurred, or the root directory is the current drive.
!Seealso:CLIP001.NGO:"SET DEFAULT"  CLIP001.NGO:"SET PATH"  
!Short: DATE         Returns system date in the form "mm/dd/yy".
^BDATE()^B

    DATE() returns the system date as a date value.

^USyntax^U

    DATE()

^UReturns^U

    A date value.

    DATE() returns the system date in a format set by any combination of
    SET DATE and SET CENTURY .  The default is AMERICAN and CENTURY OFF
    ("mm/dd/yy").

^UUsage^U

    DATE() provides a means of initializing memory variables to the current
    date, comparing other date values to the current date, and performing
    date arithmetic relative to the current date.
!Seealso:CLIP001.NGO:"SET CENTURY"  CLIP001.NGO:"SET DATE"  CLIP001.NGO:"CDOW"  CLIP001.NGO:"DOW"  CLIP001.NGO:"CMONTH"  "MONTH"  CLIP001.NGO:"DAY"  "YEAR()"  CLIP001.NGO:"CTOD"  CLIP001.NGO:"DTOC"  CLIP001.NGO:"DTOS"  
!Short: DAY          Returns the numeric value of the day of the month from date.
^BDAY()^B

    DAY() returns an integer representing the day of the month.

^USyntax^U

    DAY(<exp D>)

^UReturns^U

    An integer numeric value.

    DAY() returns a number in the range of zero to 31 depending on the
    month of <expD>.  If the month is February, leap years are accounted
    for and the number returned is either 28 or 29.  In Clipper, if the
    date argument is February 29 and the year is not a leap year, the value
    returned is zero.  If the date argument is empty, then DAY() returns
    zero.
!Seealso:CLIP001.NGO:"CDOW"  CLIP001.NGO:"DOW"  CLIP001.NGO:"CMONTH"  "MONTH()"  "YEAR()"  CLIP001.NGO:"CTOD"  CLIP001.NGO:"DTOC"  CLIP001.NGO:"DTOS"  CLIP001.NGO:"DATE"  
!Short: DBEDIT       Displays and edits records using browse-style editor.
^BDBEDIT()^B

    DBEDIT() displays and edits records from one or more work areas using a
    browse-style table layout that executes within a defined window area.

^USyntax^U

    DBEDIT([<expN1>[,<expN2>[,<expN3>[,<expN4>]]]][,<array1>][,<expC>]
    [,<array2>][,<array3>][,<array4>][,<array5>][,<array6>][,<array7>])

^UArgument^U

    <expN1..expN4> are the coordinates of the DBEDIT() window.  Any, or
    all, of these arguments can be specified.

    <array1> is an array of <expC> containing field names or expressions of
    any type.  If this argument is not specified, DBEDIT() defaults to all
    fields in the current work area.

    <expC> is a user-defined function that executes when a key exception is
    pressed or when there are no more keys to process in the keyboard
    buffer.  Specify the function name without the parenthetical suffix or
    arguments.  Note that the behavior of DBEDIT() is affected by the
    presence of this argument.  Refer to the discussion below for more
    information.

    <array2> is an array of <expC> to be used as picture strings for column
    formatting and is the same as TRANSFORM().  Specifying an <expC>
    instead of an array formats all columns with the same picture.

    <array3> is an array of <expC> for column headings.

    <array4> is an array of <expC> used to draw lines separating headings
    and the field display area.  Specifying an <expC> instead of an array
    uses the same character for the heading line separator.

    <array5> is an array of <expC> used to draw lines separating displayed
    columns.  Specifying an <expC> instead of an array uses the same
    character for the column separator.

    <array6> is an array of <expC> used to draw lines separating footings
    and the field display area.  Specifying an <expC> instead of an array
    uses the same character for the footing line separator.

    <array7> is an array of <expC> to display as column footings.  To force
    a column footing onto more than one line, embed a semicolon where you
    want the string to break.  Specying an <expC> instead of an array gives
    all footings the same value.

    All arguments are optional.  You must, however, pass a dummy argument
    for any argument you wish to skip.

^UReturns^U

    A logical value.

^UUsage^U

    DBEDIT() is an interface function that displays records in a table
    form.  it is useful for full-screen editing of one or more data files.
    It formats the display according to the window coordinates and the
    fields arrray.  All cursor movement keys are handled within DBEDIT.
    This includes PgUp, PgDn, Home, End, the four arrows, and all valid
    Ctrl key combinations that produce cursor movement.  The following are
    the active keys with no function argument specified:

                             ^BDBEDIT() Active Keys^B
    ^UKey^U                  ^UAction^U

    Uparrow              Up one row
    Dnarrow              Down one row
    Leftarrow            Column left
    Rightarrow           Column right
    Ctrl-Leftarrow       Pan left one column
    Ctrl-Rightarrow      Pan right one column
    Home                 Leftmost current screen column
    End                  Rightmost current screen column
    Ctrl-Home            Leftmost column
    Ctrl-End             Rightmost column
    PgUp                 Previous screen
    PgDn                 Next screen
    Ctrl-PgUp            First row of current column
    Ctrl-PgDn            Last row of current column
    Return               Terminate DBEDIT()
    Esc                  Terminate DBEDIT()

    Note that DBEDIT() is not a wait state and so a SET KEY procedure
    cannot be invoked from within DBEDIT()'s native works unless you have
    your own wait state within the user function.

    ^BUser Function^B: When the user function argument (<expC>) is
    specified, all keys indicated above are active with the exception of
    Esc and Return.  When DBEDIT() calls the user function, it
    automatically passes two parameters: "Status" and "fld_ptr".  The
    status parameter indicates the current state of DBEDIT() depending on
    the last key executed before the user function was called.  The
    following are the possible status values:

                           ^BDBEDIT() Status Messages^B

    ^UStatus^U       ^UDescription^U

      0          Idle, any cursor movement keystrokes have been handled
                 and no keystrokes are pending
      1          Attempt to cursor past beginning-of-file
      2          Attempt to cursor past end-of-file
      3          Database file is empty
      4          Keystroke exception

    Status messages 0, 1, 2, and 4 are used to process keys.

    The other parameter, fld_ptr, is an index into the array of field names
    argument (<array>).  If <array1> is not specified, fld_ptr points to
    the current field in the database structure and can be accessed using
    FIELD().

    When the user function has been called, you must return a value
    instructing DBEDIT() what action to perform next.  The following table
    summarizes the possible request values and their consequences:

                   ^BRequests to DBEDIT() from User Function^B

    ^UValue^U     ^UDescription^U
      0       Quit DBEDIT()
      1       Continue DBEDIT()
      2       Force reread/repaint and continue screen refresh; after
              refresh, go to idle
      3       Append mode toggle

    The user function is called in a number of different instances:

    -  A key exception occurs.  This happens when DBEDIT() picks up a
       keystroke from the keyboard that is not a DBEDIT() executable key.
       Any pending keys remain in the keyboard buffer until picked up
       within the user function or DBEDIT() continues.

    -  DBEDIT() goes to idle.  This happens when the keyboard buffer is
       empty or when a request for a screen fresh has been executed
       (request = 2).  In this instance, there is one call to the user
       function.

    -  Beginning or end-of-file are encountered.  This is the same as idle.
       All executable keys are performed and then there is one call with
       the indicating status message.

    Note that when DBEDIT() is first executed, all keys pending in the
    keyboard are executed and then DBEDIT() goes to idle with a user
    function call.  If no keys are pending, the idle state is immediate.

    The structure of the user function should be set up to handle all
    status messages received from DBEDIT().  Status messages
    characteristically indicate the current state of DBEDIT() and point to
    the type of action to be taken by the user function.  The structure
    therefore should consist of a CASE structure that branches control to a
    subprocedure for each status message to process.  Although you may be
    interested in less than all five of the status message values, your
    structure should at a minimum process idle states (status = 0) and key
    exceptions (status = 4).  Ignored status messages can be processed by
    the OTHERWISE clause.  Tests for specific key pressed should then take
    place within the called subprocedure.  The following block of code
    demonstrates the basic structure of the user function.

    ^RFUNCTION UserFunc                   ^R
    ^RPARAMETERS status, fld_ptr          ^R
    ^RPRIVATE request                     ^R
    ^R                                    ^R
    ^Rkey_stroke = LASTKEY()              ^R
    ^R                                    ^R
    ^RDO CASE                             ^R
    ^RCASE status = 0                     ^R
    ^R   * Idle.                          ^R
    ^R   request = ProcessIdle(key_stroke)^R
    ^R                                    ^R
    ^RCASE status = 1                     ^R
    ^R   * Beginning-of-file.             ^R
    ^R   request = ProcessBof(key_stroke) ^R
    ^R                                    ^R
    ^RCASE status = 2                     ^R
    ^R   * End-of-file.                   ^R
    ^R   request = ProcessEof(key_stroke) ^R
    ^R                                    ^R
    ^RCASE status = 3                     ^R
    ^R   * Empty database file            ^R
    ^R   request = ProcessEmpty()         ^R
    ^R                                    ^R
    ^RCASE status = 4                     ^R
    ^R   * Key exception                  ^R
    ^R   request = KeyExcept(key_stroke)  ^R
    ^R                                    ^R
    ^ROTHERWISE                           ^R
    ^R   request = 1                      ^R
    ^R                                    ^R
    ^RENDCASE                             ^R
    ^R                                    ^R
    ^RRETURN request                      ^R

    There are two additional issues to deal with in the user function
    proper.  First, to allow further processing of keys and the subsequent
    use of LASTKEY() within called subprocedures, save the value of the
    last key pressed to a memory variable before entering the main CASE
    structure.  Then pass that key value throughout your subprocedure
    system as a parameter.  Second, to allow execution of statements after
    the CASE structure, make your request to DBEDIT() by assigning the
    request value to a memory variable and then RETURN the value as the
    last statement in the user function.

    The two most important subprocedures in the user function architecture
    are the key exception handler and the idle state processor.  In the key
    exception handler, you should account for user requests for the
    following set of actions:

    -  Exit from DBEDIT()
    -  Toggle delete status of the current record
    -  Field edit
    -  Entry into a menu system

    In addition to these basic facilities, the key exception handler is
    where most of the activity of the user function system takes place.
    For example, the following demonstrates a typical key exception
    handling subprocedure:

    ^RFUNCTION KeyExcept                             ^R
    ^RPARAMETER action_key                           ^R
    ^R                                               ^R
    ^RDO CASE                                        ^R
    ^RCASE action_key = 27                           ^R
    ^R   * Esc..exit DBEDIT()                        ^R
    ^R   RETURN 0                                    ^R
    ^R                                               ^R
    ^RCASE action_key = 13                           ^R
    ^R   * Return..field edit (see discussion below) ^R
    ^R   RETURN FieldEdit()                          ^R
    ^R                                               ^R
    ^RCASE action_key = 7 .AND. (.NOT. EOF()) .AND.; ^R
    ^R   LASTREC()<>0                                ^R
    ^R   * Del..toggle delete status                 ^R
    ^R   IF DELETED()                                ^R
    ^R      RECALL                                   ^R
    ^R   ELSE                                        ^R
    ^R      DELETE                                   ^R
    ^R   ENDIF                                       ^R
    ^R   RETURN 1                                    ^R
    ^R                                               ^R
    ^RCASE action_key = -9                           ^R
    ^R   * F10..enter menu system                    ^R
    ^R   RETURN MenuSys()                            ^R
    ^R                                               ^R
    ^ROTHERWISE                                      ^R
    ^R  * Any other key...give them the old raspberry^R
    ^R  TONE(76,5)                                   ^R
    ^R  TONE(50,5)                                   ^R
    ^R  RETURN 1                                     ^R
    ^RENDCASE                                        ^R

    The other subprocedure of interest is the idle state processor.  In the
    simplest case, you may just want to update a status area on the screen.
    In a more complex scenario, you can perform actions based on the last
    DBEDIT() key executed.

    To edit a field value, add code like the following to the CASE
    structure in your key exception handling subprocedure.

    ^RCASE keystroke = 13         && return key    ^R
    ^R                                             ^R
    ^R   * Save current key expression and value.  ^R
    ^R   index_exp = INDEXKEY(0)                   ^R
    ^R   index_val = &index_exp                    ^R
    ^R                                             ^R
    ^R   *Edit current field value.                ^R
    ^R   SET CURSOR ON                             ^R
    ^R   field_name = field_list[fld_ptr]          ^R
    ^R   @ ROW(), COL() GET &field_name            ^R
    ^R   READ                                      ^R
    ^R   SET CURSOR OFF                            ^R
    ^R                                             ^R
    ^R   * Refresh screen if key value has changed.^R
    ^R   RETURN IF(index_val &index_exp., 2, 1)    ^R

    The basic idea is to test for the key you are using for the field edit
    key and then GET the field pointed to by the fld_ptr parameter in the
    field array.  This means that if you specify a field array as an
    argument to DBEDIT() you must use the same array name in your field
    edit routine.  If you have not specified a field array, obtain the
    field name using FIELD() with fld_ptr as the argument.

    A second issue is the appearance of the cursor.  By default, the
    DBEDIT() cursor is OFF.  You must therefore SET the CURSOR ON before
    executing the READ and SET it OFF after the READ.

    A last issue is updating the screen if a key value has changed.  To set
    this up, you must save both the controlling index key expression and
    its current value before editing the current field value.  Then after
    the field edit is complete, send a request for a screen fresh (a value
    of 2) if the new key value is the same as the old key value.

    ^BNesting^B: You can call multiple copies of DBEDIT() within each copy
    of DBEDIT() allowing you multiple browse windows on the screen at one
    time.

^UExample^U

    The following demonstrates how to use DBEDIT() with a user function:

    ^RSELECT 2                                             ^R
    ^RUSE Customer INDEX Customer                          ^R
    ^RSELECT 1                                             ^R
    ^RUSE Sales INDEX Sales                                ^R
    ^RSET RELATION TO Cust_num INTO Customer               ^R
    ^R                                                     ^R
    ^RDECLARE field_list[4]                                ^R
    ^Rfield_list[1] = "Branch"                             ^R
    ^Rfield_list[2] = "Salesman"                           ^R
    ^Rfield_list[3] = "Amount"                             ^R
    ^R*                                                    ^R
    ^R* Fields in another work area must include the alias.^R
    ^Rfields[4] = "Customer->Customer"                     ^R
    ^R                                                     ^R
    ^RDBEDIT(4, 0, 22, 79, FIELD_LIST, "UserFunc")         ^R

    For an advanced example that demonstrates a full-featured browse, see
    Browse() in Examplep.prg on the distribution disk.  Note that Browse()
    is included in EXTEND.LIB so that to use it you need not compile and
    link it.  The syntax is:

    Browse([<window coordinates<])
!Seealso:CLIP001.NGO:"READ"  "ACHOICE"  "MEMOEDIT"  
!Short: DBFILTER     Determines active filter expression in current area.
^BDBFILTER()^B

    DBFILTER() determines the expression of the active filter in the
    current work area.

^USyntax^U

    DBFILTER()

^UReturns^U

    A character string.

    DBFILTER() returns as a character string the filter condition defined
    in the current work area.  If no FILTER has been SET, DBFILTER()
    returns a null string("").

^UExample^U

    The following user-defined function, CreateQry(), uses DBFILTER() to
    create a memory file containing the current filter expression in the
    memory variable "qry_string".  The memory file is named with the
    extension "qwy" to indicate that it contains a query.

    ^RFUNCTION CreateQry                        ^R
    ^RPARAMETERS qry_name                       ^R
    ^R*                                         ^R
    ^Rqry_string = DBFILTER()                   ^R
    ^RSAVE ALL LIKE qry_string TO &qry_name..qwy^R
    ^RRETURN .F.                                ^R

    You can later RESTORE a query file created by CreateQry() with the
    following user-defined function, SetFilter().  This function RESTOREs
    the query file and then SETs FILTER TO the condition stored in the
    variable "qry_string".

    ^RFUNCTION SetFilter                  ^R
    ^RPARAMETERS qry_name                 ^R
    ^R*                                   ^R
    ^RRESTORE FROM &qry_name..qwy ADDITIVE^R
    ^RSET FILTER TO &qry_string           ^R
    ^RRETURN .F.                          ^R
!Seealso:CLIP001.NGO:"DBRELATION"  CLIP001.NGO:"DBRSELECT"  CLIP001.NGO:"SET FILTER"  
!Short: DBRELATION   Determines the linking expression of specified relation.
^BDBRELATION()^B

    DBRELATION() determines the linking expression of a specified relation
    in the current work area.

^USyntax^U

    DBRELATION(<expN>)

^UArgument^U

    <expN> is the ordinal position in the list of relations defined.

^UReturns^U

    A character string.

    DBRELATION() returns a character string containing the relation
    expression of the relation pointed to by <expN>.  If there is no
    RELATION SET for <expN>, DBRELATION() returns a null string ("").

^UUsage^U

    DBRELATION() is used in combination with DBRSELECT() to query the
    linking expression and work area of an existing relation.  Using these
    functions in addition to DBFILTER(), you can create a user-defined View
    system analagous to that of dBASE III PLUS and the Clipper utility,
    DBU.EXE.  Essentially, you utilize these functions to create the View
    definition from the environment.
!Seealso:CLIP001.NGO:"DBFILTER"  CLIP001.NGO:"DBRSELECT"  CLIP001.NGO:"SET RELATION"  
!Short: DBRSELECT    Determines target work area of a specified relation.
^BDBRSELECT()^B

    DBRSELECT() determines the target work area of a specified relation
    in the current work area.

^USyntax^U

    DBRSELECT(<expN>)

^UArgument^U

    <expN> is the ordinal position in the list of relations defined.

^UReturns^U

    An integer numeric value.

    DBRSELECT() returns the work area number of the relation pointed to by
<expN>.  If there is no RELATION SET for <expN>, DBRSELECT() returns
zero.

^UUsage^U

    DBRSELECT() is used in combination with DBRELATION() to query the work
area and linking expression of an existing relation.  Using these
    functions in addition to DBFILTER(), you can create a user-defined View
    system analagous to that of dBASE III PLUS and the Clipper utility,
    DBU.EXE.  Essentially, you utilize these functions to create the View
    definition from the environment.

    Since the work area number is environment specific information, you
may want the alias name if your application is independent of a
specific work area.  In this case, use the following expression to
obtain the alias of the relation:

ALIAS(DBRSELECT(<expN>))
!Seealso:CLIP001.NGO:"DBFILTER"  CLIP001.NGO:"DBRELATION"  CLIP001.NGO:"SET RELATION"  
!Short: DESCEND      To create and SEEK descending order indexes.
^BDESCEND()^B

    DESCEND() creates and SEEKS descending order indexes.

^USyntax^U

    DESCEND(<exp>)

^UArgument^U

    <exp> is an expression of any data type.

^UReturns^U

    DESCEND() returns the same data type as the <exp> in a complemented
    form.

^UUsage^U

    DESCEND() is designed to be used in combination with INDEX and SEEK to
allow for the creation of descending order indexes.

    To use DESCEND() in an INDEX expression, use the following syntaxL:

INDEX ON DESCEND(Sales_date) TO date_dwn
!Seealso:CLIP001.NGO:"INDEX"  CLIP001.NGO:"SEEK"  
!Short: DELETED      Returns the deletion status of the current record.
^BDELETED()^B

    DELETED() identifies records that are marked for deletion.
^USyntax^U

    DELETED()

^UReturns^U

    A logical value.

    DELETED() returns true (.T.) if the current record is marked for
    deletion; otherwise, false (.F.) is returned.

^UUsage^U

    There are two areas where DELETED() may be used effectively.  First is
    querying the deletion status as a part of record processing conditions.
    Second is displaying a record's deleted status as a part of screens and
    reports.  To do this, format the return value of DELETED() using IF()
    as follows:

    ^R@ 1, 65 SAY IF(DELETED(), "Inactive", "Active")^R
!Seealso:CLIP001.NGO:"RECALL"  CLIP001.NGO:"SET DELETED"  CLIP001.NGO:"PACK"  
!Short: DISKSPACE    Determines available memory on specified disk drive.
^BDISKSPACE()^B

    DISKSPACE() determines the number of available bytes remaining on the
    specified disk drive.

^USyntax^U

    DISKSPACE([<expN>])

^UArgument^U

    <expN> is the number of the drive to query where one is drive A, two is
    B, and three is C, etc.  The default is the current drive if <expN> is
    omitted or zero.

^UReturns^U

    An integer numeric value.

    DISKSPACE() returns the number of bytes of empty space on the specified
    disk drive.  If DISKSPACE() is specified without an argument, the
    return value reflects the amount of space available on the default
    drive.  It does not honor the SET DEFAULT drive.

^UUsage^U

    DISKSPACE() is useful when COPYing or SORTing to another drive and you
    want to determine if there is enough space available before initiating
    the operation.  A variation of this concept is to use DISKSPACE() in
    combination with the RECSIZE() and RECCOUNT() functions to create a
    procedure to automatically backup database files.

^UExample^U

    The following is a user-defined function that uses DISKSPACE() to
    backup a database file to another drive:

    ^RFUNCTION BackUp                                    ^R
    ^RPARAMETERS outfile, drive                          ^R
    ^R*                                                  ^R
    ^Rneeded = INT((RECSIZE() * LASTREC() + HEADER() + 1)^R
    ^RIF DISKSPACE() < needed                            ^R
    ^R   RETURN .F.                                      ^R
    ^RENDIF                                              ^R
    ^RCOPY TO &drive.:&outfile.                          ^R
    ^RRETURN .T.                                         ^R
!Seealso:CLIP001.NGO:"LUPDATE"  "LASTREC"  CLIP001.NGO:"RECSIZE"  
!Short: DOSERROR     Determines error number of the last DOS error.
^BDOSERROR()^B

    DOSERROR() determines the error number of the last DOS error.

^USyntax^U

    DOSERROR()

^UReturns^U

    An integer numeric value.

^UUsage^U

    DOSERROR() is used in conjunction with the error function Open_error()
    to determine the exact cause of a file use error.

    When your program experiences a DOS error, the errror includes a
    number, described below.

    ^BError #^B     ^BDescription^B
       1        Invalid function number
       2        File not found
       3        Path not found
       4        Too many open files (no handles left)
       5        Access denied
       6        Invalid handle
       7        Memory control blocks destroyed
       8        Insufficient memory
       9        Invalid memory block address
      10        Invalid environment
      11        Invalid format
      12        Invalid access code
      13        Invalid data
      14        Reserved
      15        Invalid drive was specified
      16        Attempt to remove current directory
      17        Not same device
      18        No more files
      19        Attempt to write on write-protected diskette
      20        Unknown unit
      21        Drive not ready
      22        Unknown command
      23        Data error (CRC)
      24        Bad request structure length
      25        Seek error
      26        Unknown media type
      27        Sector not found
      28        Printer out of paper
      29        Write fault
      30        Read fault
      31        General failure
      32        Sharing violation
      33        Lock violation
      34        Invalid disk change
      35        FCB unavailable
      36        Sharing buffer overflow
    37-49       Reserved
      50        Network request not supported
      51        Remote computer not listening
      52        Duplicate name on network
      53        Network name not found
      54        Network busy
      55        Network device no longer exists
      56        Network BIOS command limit exceeded
      57        Network adapter hardware error
      58        Incorrect response from network
      59        Unexpected network error
      60        Incompatible remote adapter
      61        Print queue full
      62        Not enough space for print file
      63        Print file deleted (not enough space)
      64        Network name deleted
      65        Access denied
      66        Network device type incorrect
      67        Network name not found
      68        Network name limit exceeded
      69        Network BIOS session limit exceeded
      70        Temporarily paused
      71        Network request not accepted
      72        Print or disk redirection paused
     73-79      Reserved
      80        File exists
      81        Reserved
      82        Cannot make directory entry
      83        Fail on INT 24
      84        Too many redirections
      85        Duplicate redirection
      86        Invalid password
      87        Invalid parameter
      88        Network device fault
!Seealso:CLIP001.NGO:"FERROR"  
!Short: DOW          Returns a number representing day of the week.
^BDOW()^B

    DOW() converts a date value to a number identifying the day of the
    week.

^USyntax^U

    DOW(<exp D>)

^UReturns^U

    An integer numeric value.

    DOW() returns a number between zero and seven.  The first day of the
    week is one (Sunday) and the last is seven (Saturday).  If <expD> is
    empty, DOW() returns zero.

^UUsage^U

    DOW() is useful when you want date calculations on a weekly basis.  For
    example, you can use the DOW() to calculate last Monday's date with an
    expression like the following:

    ^RDATE() - DOW(DATE()) + 2^R
!Seealso:"MONTH"  CLIP001.NGO:"DAY"  "YEAR"  CLIP001.NGO:"CTOD"  CLIP001.NGO:"DTOC"  CLIP001.NGO:"DTOS"  CLIP001.NGO:"DATE"  
!Short: DTOC         Converts a date value to character string.
^BDTOC()^B

    DTOC() converts a date value to a character string.

^USyntax^U

    DTOC(<expD>)

^UArgument^U

    <expD> is the date value to convert.

^UReturns^U

    A character string.

    DTOC() returns a character string representation of a date value based
    on the DATE and CENTURY SETtings.  (See SET DATE for the supported
    formats.)  The default format return value is in the form "mm/dd/yy".
    A null date returns a string of eight or ten spaces depending on
    whether CENTURY is OFF or ON.

^UUsage^U

    DTOC() is primarily useful for formatting purposes when you want
    to display the date in the SET DATE format and a character expression
    is required (in a LABEL FORM, for example).

    If you are INDEXing a date as a part of a compound key, use DTOS()
    instead of DTOC().
!Seealso:CLIP001.NGO:"SET DATE"  CLIP001.NGO:"SET CENTURY"  CLIP001.NGO:"CDOW"  CLIP001.NGO:"DOW"  CLIP001.NGO:"CMONTH"  "MONTH()"  CLIP001.NGO:"DAY"  "YEAR"  CLIP001.NGO:"CTOD"  CLIP001.NGO:"DTOS"  CLIP001.NGO:"DATE"  
!Short: DTOS         Converts a date value to character string format
"yyyymmdd". ^BDTOS()^B

    DTOS() converts a date value to a character string suitable for
    INDEXing in a compound key.

^USyntax^U

    DTOS(<expD>)

^UArgument^U

    <expD> is the date value to convert.

^UReturns^U

    A character string.

    DTOS() returns a string eight characters long in the format "yyyymmdd".
    When <expD> evaluates to a null date, DTOS() returns a string of eight
    spaces.

^UUsage^U

    The intention of DTOS() is to facilitate the ease of creating index key
    expressions consisting of a date value and character expressions
    independent of DATE and CENTURY SETtings and preserving date order
    (year, month, and day).
!Seealso:CLIP001.NGO:"INDEX"  CLIP001.NGO:"CDOW"  CLIP001.NGO:"DOW"  CLIP001.NGO:"CMONTH"  "MONTH()"  CLIP001.NGO:"DAY"  "YEAR()"  CLIP001.NGO:"CTOD"  CLIP001.NGO:"DATE"  
!Short: EMPTY        Returns true if an expression is blank.
^BEMPTY()^B

    EMPTY() determines if the result of an expression is empty.

^USyntax^U

    EMPTY(<exp>)

^UReturns^U

    A logical value.

    EMPTY() returns a logical true (.T.) depending on the type of
    expression being evaluated if:

    -  The character expression is a null string or equal to all spaces
    -  The numeric expression equals 0
    -  The date expression contains an empty date ("  /  /  ")
    -  The logical expression equals .F.
!Short: EOF          Returns true if the end of file is reached.
^BEOF()^B

    EOF() determines if an attempt has been made to move the record pointer
    past the end of the current database file.

^USyntax^U

    EOF()

^UReturns^U

    EOF() returns True (.T.) when you attempt to move the record pointer
    beyond the last logical record of the active database file.  When EOF()
    becomes true (.T.), the record pointer is positioned to LASTREC() + 1.
    This is the case whether or not an active FILTER is SET or DELETED is
    ON.  Any further attempt to move the record pointer past LASTREC() + 1
    returns the same result without error.

    In addition, if the current database file contains no records, EOF()
    returns true (.T.).

^UUsage^U

    EOF() is used as a boundary condition test in any application where you
    are moving the record pointer downward through a database file.
!Seealso:CLIP001.NGO:"SEEK"  CLIP001.NGO:"LOCATE"  CLIP001.NGO:"SKIP"  CLIP001.NGO:"BOF"  "RECNO()"  "LASTREC()"  CLIP001.NGO:"FOUND"  
!Short: ERRORLEVEL   Returns current DOS error level.
^BERRORLEVEL()^B

    ERRORLEVEL() returns the current DOS error level setting and
optionally set the DOS error level to a new value.

^USyntax^U

    ERRORLEVEL([<exp N>])

^UArgument^U

    <expN> is the new DOS error level setting.  This can be a value
between zero and 255.

^UReturns^U

    An integer numeric value.

    ERRORLEVEL() returns the current DOS error level setting.

^UUsage^U

    ERRORLEVEL() is primarily design to use with SWITCH.EXE in order to
chain execution of application programs.  As an example, assume you
have a main application program and depending on some condition, it
needs to execute another .EXE file.  You can do this by setting the
error level just before exiting to DOS as follows:

^RDO CASE              ^R
^RIF choice = "ONE"    ^R
^R   err_lev = 1       ^R
^RELSEIF choice = "TWO"^R
^R   err_lev = 2       ^R
^RENDIF                ^R
^RERRORLEVEL(err_lev)  ^R
^RQUIT                 ^R

You then execute SWITCH from the DOS prompt specifying the list of
executable application programs corresponding to error levels
specified in the shell program.  For example:

    C>SWITCH ONE TWO THREE
!Short: EXP          Calculates number based on natural logarithm.
^BEXP()^B

    EXP() calculates ^Ue^U to the power of ^Ux^U where ^Ue^U is the base of natural
    logarithms and ^Ux^U is the numeric argument.

^USyntax^U

    EXP(<exp N>)

^UArgument^U

    <expN> is the natural logarithm for which a numeric value is to be
    calculated.

^UReturns^U

    A numeric value.

    EXP() returns a value that obeys both the DECIMALS and FIXED SETtings.

^UUsage^U
                                                                    ^Ux^U
    EXP() is useful in equations using of the natural log function ^Ue^U .

    EXP() is the inverse of LOG().
!Seealso:CLIP001.NGO:"SET DECIMALS"  CLIP001.NGO:"SET FIXED"  "LOG()"  
!Short: FCLOSE       Closes the DOS file corresponding to the specified handle.
^BFCLOSE()^B

    FCLOSE() closes an open files, writing associated DOS buffers to disk.

^USyntax^U

    FCLOSE(<expN>)

^UArgument^U

    <expN> is the file handle obtained previously from FOPEN() or
    FCREATE().

^UReturns^U

    A logical value.

    FCLOSE() returns false (.F.) if an error has occurred while writing;
    otherwise it returns true (.T.).

^UExample^U

    ^Rhandle = FCREATE("Testfile", 0)^R
    ^RFCLOSE(handle)                 ^R

^UWARNING^U: This function allows low level access to DOS files & devices.
             They should be used with extreme care and require a thorough
             knowledge of the operating system.
!Seealso:CLIP001.NGO:"FCREATE"  CLIP001.NGO:"FERROR"  CLIP001.NGO:"FOPEN"  CLIP001.NGO:"FREAD"  CLIP001.NGO:"FREADSTR"  CLIP001.NGO:"FSEEK"  CLIP001.NGO:"FWRITE"  
!Short: FCOUNT       Returns the number of fields in the current database file.
^BFCOUNT()^B

    FCOUNT() returns the number of fields in the current database.

^USyntax^U

    FCOUNT()

^UReturns^U

    An integer value.

    FCOUNT() returns the number of fields of the database file open in the
    current work area.  If there is no database file open, FCOUNT() returns
    zero.

^UUsage^U

    FCOUNT() is useful in applications where you have created data-
    independent programs that can operate on any database file.  These
    include generalized import/export and reporting programs.  Typically,
    you can use FCOUNT() to establish the upper limit of FOR/NEXT or DO
    WHILE loops that process a single record at a time.  For example, to
    display the names of all fields in the current work area.
!Seealso:CLIP001.NGO:"FIELD"  "TYPE()"  
!Short: FCREATE      Creates a new DOS file or truncates existing file to zero.
^BFCREATE()^B

    FCREATE() creates a new file or truncates an existing file to zero
    length.

^USyntax^U

    FCREATE(<expC>[,<expN>])

^UArgument^U

    <expC> is the name of the file to create.

    <expN> is the DOS file attribute.  If omitted, the default is zero.

                             ^BDOS File Attributes^B

    ^UValue^U    ^UAttribute^U     ^UDescription^U
      0      Normal        Read/write
      1      Read only     Attempting to open for output returns an error.
      2      Hidden        Excluded from normal directory searches.
      3      System        Excluded from normal directory searches.

^UReturns^U

    A numeric value.

    FCREATE() returns the DOS file handle number of the new file in the
    range of zero to 65,535.  If an error occurs, it returns -1.

^UUsage^U

    When FCREATE() successfully creates a new file, it is left open with a
    DOS open mode of 2 (mode 2 is compatibility sharing mode, read/write
    access mode).

    Since a file handle is required in order to identify an open file to
    other file functions, always assign the return value from FCREATE() to
    a memory variable for later use.

    ^BAccessing files in other directories^B: FCREATE() does not obey
    either the DEFAULT or PATH SETtings.  Instead, it writes to the current
    directory unless a path is explicitly stated.

^UExample^U

    ^Rhandle = FCREATE("Testfile", 0)^R

^UWARNING^U: This function allows low level access to DOS files & devices.
             They should be used with extreme care and require a thorough
             knowledge of the operating system.
!Seealso:CLIP001.NGO:"FCLOSE"  CLIP001.NGO:"FERROR"  CLIP001.NGO:"FOPEN"  CLIP001.NGO:"FREAD"  CLIP001.NGO:"FREADSTR"  CLIP001.NGO:"FSEEK"  CLIP001.NGO:"FWRITE"  
!Short: FERROR       Returns the DOS error number after file function terminates.
^BFERROR()^B

    FERROR() tests for a DOS error after a file function terminates.

^USyntax^U

    FERROR()

^UReturns^U

    An integer numeric value.

    FERROR() returns the DOS error from the last file operation.  If there
    is no error, FERROR() returns zero.

^UExample^U

    ^Rshandle = FCREATE("Temp.txt")                  ^R
    ^RIF FERROR() <> 0                               ^R
    ^R   ? "Cannot create file, DOS error ", FERROR()^R
    ^RENDIF                                          ^R

^UWARNING^U: This function allows low level access to DOS files & devices.
             They should be used with extreme care and require a thorough
             knowledge of the operating system.
!Seealso:CLIP001.NGO:"FCLOSE"  CLIP001.NGO:"FCREATE"  CLIP001.NGO:"FOPEN"  CLIP001.NGO:"FREAD"  CLIP001.NGO:"FREADSTR"  CLIP001.NGO:"FSEEK"  CLIP001.NGO:"FWRITE"  
!Short: FIELD        Returns the name of specified field in current work area.
^BFIELD()/FIELDNAME()^B

    FIELD() returns the field name of a specified field in the current
    database file.

^USyntax^U

    FIELD(<expN>)/FIELDNAME(<expN>)

^UArgument^U

    <expN> is the numeric position of a field in the database file
    structure.

^UReturns^U

    A character string.

    If <expN> is not within the range of the fields contained in the
    current database file, FIELD() returns a null string ("").

    Fieldnames are returned all upper case.

^UUsage^U

    FIELD() permits a database file structure to be handled as if it is an
    array, each field number a subscript pointer to the fieldname.  This
    array of fields is useful for building data-independent programs for
    import/export and reporting.

    If you need other database file structure information, use TYPE() and
    LEN().  If you need the number of decimal places a numeric field has
    defined, use the following expression:

    ^RLEN(SUBSTR(STR(<field>), RAT(".", STR(<field>)) + 1))^R

    ^BNote^B: AFIELDS() provides similar but expanded capability for
          manipulating field attribute information.
!Seealso:CLIP001.NGO:"AFIELDS"  CLIP001.NGO:"FCOUNT"  "LASTREC()"  "TYPE()"  
!Short: FILE         Returns true if a specified filename exists.
^BFILE()^B

    FILE() verifies the existence of a specified filename and returns a
    logical True (.T.) if the file exists.

^USyntax^U

    FILE(<exp C>)

^UUsage^U

    FILE() requires that the character expression input include both the
    filename and the file extension.  If the file resides on a different
    drive or directory than the default, you must either set a path using
    the SET PATH command or the drive and directory must be specified as
    part of the filename.  FILE() is not case-sensitive; any combination of
    upper or lower case letters in the filename is accepted.  Be aware that
    the DOS path is not searched.

    FILE() is useful in identifying a duplicate filename before information
    is stored to a file or for determining whether a needed file is
    available.
!Seealso:CLIP001.NGO:"SET DEFAULT"  CLIP001.NGO:"SET PATH"  
!Short: FLOCK        Locks a database file in a network environment.
^BFLOCK()^B

    FLOCK() is for locking a database file in a multi-user environment.

^USyntax^U

    FLOCK()

^UUsage^U

    FLOCK() attempts to logically lock the database file.  If a record was
    previously locked by the same user, FLOCK() will release the lock.  If
    successful, FLOCK() will return a logical True (.T.)
!Seealso:"RLOCK()"  CLIP001.NGO:"UNLOCK"  CLIP001.NGO:"SET EXCLUSIVE"  
!Short: FOPEN        Opens a DOS file.
^BFOPEN()^B

    FOPEN() opens a DOS file.

^USyntax^U

    FOPEN(<expC>,[,<expN>])

^UArgument^U

    <expC> is the name of the file to open including the path if there is
    one.

    <expN> is the requested DOS open mode indicating how the open file can
    be accessed.  Access falls into three categories:

                              ^BDOS File Open Modes^B
    ^UOpen Mode^U       ^UOperation^U
        0           Read only
        1           Write only
        2           Read/write

    The default open mode is zero.

^UReturns^U

    A numeric value.

    FOPEN() returns the file handle of the opened file in the range of zero
    to 65,535.  If an error occurs, it returns -1.

^UUsage^U

    Since a file handle is required in order to identify an open file to
    other file functions, always assign the return value from FOPEN() to a
    memory variable for later use.

    ^BAccessing files in other directories^B: FOPEN() does not obey either
    the DEFAULT or PATH SETtings.  Instead, it only searches the current
    directory unless a path is explicitly stated.

^UExample^U

    ^Rhandle = FOPEN("Temp.txt"                      ^R
    ^RIF FERROR() <> 0                               ^R
    ^R   ? "Cannot create file, DOS error ", FERROR()^R
    ^RENDIF                                          ^R

^UWARNING^U: This function allows low level access to DOS files & devices.
             They should be used with extreme care and require a thorough
             knowledge of the operating system.
!Seealso:CLIP001.NGO:"FCLOSE"  CLIP001.NGO:"FCREATE"  CLIP001.NGO:"FERROR"  CLIP001.NGO:"FREAD"  CLIP001.NGO:"FREADSTR"  CLIP001.NGO:"FSEEK"  CLIP001.NGO:"FWRITE"  
!Short: FOUND        Returns true if previous SEEK, FIND, LOCATE was successful.
^BFOUND()^B

    FOUND() returns a logical True (.T.) if the previous FIND, SEEK, LOCATE
    or CONTINUE was successful.

^USyntax^U

    FOUND()

^UReturns^U

    A logical value.

    FOUND() returns true (.T.) if the last search command was successful.

    Each work area has a FOUND() flag.  This means that if one work area
    has a RELATION SET to a child work area, querying FOUND() in the child
    work area returns true (.T.) if there is a key value matching the
    current linking value from the parent.

    Note that all commands other than search commands update FOUND() to
    false (.F.).  This means that SKIP cannot be used with FOUND().

^UUsage^U

    FOUND() is useful for determining whether a search of a database file
    is successful before performing the next step in a program.
!Seealso:CLIP001.NGO:"SEEK"  CLIP001.NGO:"LOCATE"  CLIP001.NGO:"SET RELATION"  CLIP001.NGO:"SET SOFTSEEK"  CLIP001.NGO:"EOF"  
!Short: FREAD        Reads characters from a DOS file into character variable.
^BFREAD()^B

    FREAD() reads characters from a DOS file into a character memory
    variable.

^USyntax^U

    FREAD(<expN1>,@<memvarC>,<expN2>)

^UArgument^U

    <expN1> is the file handle obtained from FOPEN(), FCREATE(), or
    predefined by DOS.

    <memvarC> is the name of an existing character memory variable passed
    by reference (preface it with the @ symbol) to use as a buffer.  The
    length of this memory variable must be at least the same as <expN2>.

    <expN2> is the number of bytes to read into the buffer starting at the
    current DOS pointer location.  The value returned by a successful
    FREAD() should be equal to <expN2>.

^UReturns^U

    An integer numeric value.

    FREAD() returns the number of bytes successfully read.  A return value
    of 0 indicates end-of-file or an error.

^UUsage^U

    FREAD() reads the file starting at the current file pointer position.
    Note that FREAD() reads all characters including control, null, and
    high-order (above CHR(128)).

    To reposition the file pointer without reading, use FSEEK().

^UExample^U

    ^Rblock = 128                                    ^R
    ^Rbuffer = SPACE(512)                            ^R
    ^Rhandle = FOPEN("Temp.txt")                     ^R
    ^R*                                              ^R
    ^RIF FERROR() <> 0                               ^R
    ^R   bytes = FREAD(handle, @buffer, block)       ^R
    ^R   if bytes <> block                           ^R
    ^R      ? "Error reading Temp.txt"               ^R
    ^R   ENDIF                                       ^R
    ^RENDIF                                          ^R

^UWARNING^U: This function allows low level access to DOS files & devices.
             They should be used with extreme care and require a thorough
             knowledge of the operating system.
!Seealso:CLIP001.NGO:"FCLOSE"  CLIP001.NGO:"FCREATE"  CLIP001.NGO:"FERROR"  CLIP001.NGO:"FOPEN"  CLIP001.NGO:"FREADSTR"  CLIP001.NGO:"FSEEK"  CLIP001.NGO:"FWRITE"  
!Short: FREADSTR     Reads characters from a DOS file.
^BFREADSTR()^B

    FREADSTR() reads characters from a DOS file.

^USyntax^U

    FREADSTR(<expN1>,<expN2>)

^UArgument^U

    <expN1> is the file handle obtained from FOPEN(), FCREATE(), or
    predefined by DOS.

    <expN2> is the number of bytes to read beginning at the current DOS file
    pointer position.  This can be a positive or negative number depending
    on the direction (forward or backward) you want to read from the
    current pointer position.

^UReturns^U

    A character string.

    FREADSTR() returns a string up to 65,535 (64K) bytes.  A null return
    value ("") indicates an error or end-of-file.

^UUsage^U

    FREADSTR() reads from the current DOS file pointer position, the number
    of characters specified by <expN2> or until a null character (ASCII 0)
    is encountered.  Like FREAD(), all characters are read including
    control characters.

^UExample^U

    The following example displays the ASCII value of the first 16 bytes of
    the text file, New.txt:

    ^Rhandle = FOPEN("Temp.txt")                           ^R
    ^RIF FERROR() <> 0                                     ^R
    ^R   ? "File open error."                              ^R
    ^R   RETURN                                            ^R
    ^RELSE                                                 ^R
    ^R   buffer = FREADSTR(handle,16)                      ^R
    ^R   ? "Length: ", LEN(buffer)                         ^R
    ^R   ?                                                 ^R
    ^R   FOR i = 1 TO LEN(buffer)                          ^R
    ^R      ?? TRANSFORM(ASC(SUBSTR(buffer, i, 1)),; "99") ^R
    ^R   NEXT                                              ^R
    ^R   FCLOSE(handle)                                    ^R
    ^RENDIF                                                ^R
    ^RRETURN                                               ^R

^UWARNING^U: This function allows low level access to DOS files & devices.
             They should be used with extreme care and require a thorough
             knowledge of the operating system.
!Seealso:CLIP001.NGO:"FCLOSE"  CLIP001.NGO:"FCREATE"  CLIP001.NGO:"FERROR"  CLIP001.NGO:"FOPEN"  CLIP001.NGO:"FREAD"  CLIP001.NGO:"FSEEK"  CLIP001.NGO:"FWRITE"  
!Short: FSEEK        Moves the file pointer to new position in a DOS file.
^BFSEEK()^B

    FSEEK() sets the file pointer to a new position in a file.

^USyntax^U

    FSEEK(<expN1>,<expN2>[,<expN3>])

^UArgument^U

    <expN1> is the file handle obtained from FOPEN(), FCREATE(), or
    predefined by DOS.

    <expN2> is the number of bytes to move the file pointer from the
    position as defined by <expN3>.  This can be a positive or negative
    number depending on the direction to move the pointer.

    <expN3> defines the method of moving and is indicated by a value from
    the following list:

                    ^BMethods of Moving the DOS File Pointer^B
    ^UMethod^U       ^UDescription^U
       0           Beginning-of-file
       1           Current pointer position
       2           End-of-file

    The default method is zero.

^UReturns^U

    A numeric value.

    FSEEK() returns the new position of the file pointer relative to the
    beginning-of-file.

^UExample^U

    ^Rhandle = FOPEN("Temp.txt"   ^R
    ^R*                           ^R
    ^R* Get length of the file.   ^R
    ^Rlength = FSEEK(handle, 0, 2)^R
    ^R*                           ^R
    ^R* Reset file position.      ^R
    ^RFSEEK(handle, 0)            ^R

^UWARNING^U: This function allows low level access to DOS files & devices.
             They should be used with extreme care and require a thorough
             knowledge of the operating system.
!Seealso:CLIP001.NGO:"FCLOSE"  CLIP001.NGO:"FCREATE"  CLIP001.NGO:"FERROR"  CLIP001.NGO:"FOPEN"  CLIP001.NGO:"FREAD"  CLIP001.NGO:"FREADSTR"  CLIP001.NGO:"FWRITE"  
!Short: FWRITE       Writes a buffer variable to a specified DOS file.
^BFWRITE()^B

    FWRITE() writes a buffer variable to a DOS file.

^USyntax^U

    FWRITE(<expN1>,<memvarC>[,<expN2>])

^UArgument^U

    <expN1> is the file handle obtained previously from FOPEN(), FCREATE(),
    or predefined by DOS.

    <memvarC> is the name of a pre-existing character memory variable to
    use as an output buffer.

    <expN2> indicates the number of bytes to write from the buffer variable
    to the file beginning with the current file pointer location.  If this
    argument is omitted, the entire contents of the buffer variable are
    written.

^UReturns^U

    A numeric value.

    FWRITE() returns the number of bytes successfully written.  If the
    return value is 0, the disk is full or an error has occurred.  Check
    FERROR() for the precise DOS error designation.  Note that the value
    returned by a successful FWRITE() should be equal to <expN2>.

^UExample^U


    ^Rbuffer = SPACE(512)                            ^R
    ^Rhandle = FOPEN("Temp.txt")                     ^R
    ^R*                                              ^R
    ^Routfile = FCREATE("Newfile.txt")               ^R
    ^RIF FERROR() <> 0                               ^R
    ^R   ? "Cannot create file, DOS error ", FERROR()^R
    ^R   RETURN                                      ^R
    ^RENDIF                                          ^R
    ^R*                                              ^R
    ^RFREAD(infile, @buffer, 512)                    ^R
    ^RIF FERROR() <> 0                               ^R
    ^R   ? "Cannot read file, DOS error ", FERROR()  ^R
    ^R   RETURN                                      ^R
    ^RENDIF                                          ^R
    ^R*                                              ^R
    ^RFWRITE(outfile, buffer, 512)                   ^R
    ^RIF FERROR() <> 0                               ^R
    ^R   ? "Cannot write file, DOS error ", FERROR() ^R
    ^RENDIF                                          ^R

^UWARNING^U: This function allows low level access to DOS files & devices.
             They should be used with extreme care and require a thorough
             knowledge of the operating system.
!Seealso:CLIP001.NGO:"FCLOSE"  CLIP001.NGO:"FCREATE"  CLIP001.NGO:"FERROR"  CLIP001.NGO:"FOPEN"  CLIP001.NGO:"FREADSTR"  CLIP001.NGO:"FSEEK"  
!Short: GETE         Retrieve the contents of a DOS environmental variable.
^BGETE()^B

    GETE() retrieves the contents of a DOS environmental variable.

^USyntax^U

    GETE(<expC>)

^UArgument^U

    <expC> is the name of the DOS environmental variable completely upper
case.  Note that when an environmental variable is SET, it is
converted to upper case.

^UReturns^U

    A character string.

    GETE() returns the contents of the specified DOS environmental
variable.  If the <expC> cannot be found, GETE() returns a null string
("").

    ^BNote^B: If you are certain that an environmental variable exists and
yet GETE() always returns a null string (""), be sure there are no
spaces between the environmental variable name and the first character
of the string assigned to it.

^UUsage^U

    GETE() is useful for passing configuration information from the DOS
environment into an application program.  Typically, this could be
configuration information that includes pointers to the location of
files (database, index, label, or reports).  This is particularly
useful for network environments.

For example, when you set up a system define environmental variables
that contain the location of various file types along with the CLIPPER
environmental variable.  The following DOS commands demonstrate:

C>SET LOC_DBF=<database file path>
C>SET LOC_NTX=<index file path>
C>SET LOC_RPT=<report file path>

In the configuration section of your application program, assign the
contents of the environmental variables to memory variables.  Then
when you access a file, preface the reference with the path variable:

loc_dbf=GETE("LOC_DBF")
USE (loc_dbf + "<alias>")

^UExample^U

    ^Rpath_set = GETE("PATH")^R
    ^RSET PATH TO &path_set. ^R
!Short: HARDCR       Replaces soft carriage returns with hard carriage returns.
^BHARDCR()^B

    HARDCR() returns the character expression with all soft carriage
    returns [CHR(141)] replaced with carriage returns [CHR(13)].

^USyntax^U

    HARDCR(<exp C>)

^UArgument^U

    <expC> is the memo field or character string to convert.

^UUsage^U

    HARDCR() enables you to display a memofield formatted with the
    automatic wordwrap of the MEMOEDIT() function.

    HARDCR() returns a string up to 65,535 (64K) in length.
!Seealso:"MEMOEDIT"  "MEMOLINE"  "MEMOREAD"  "MEMOTRAN"  "MEMOWRIT"  "MLCOUNT"  
!Short: HEADER       Determines length of header area of current database file.
^BHEADER()^B

    HEADER() determines the length of the header area of the current
    database file.

^USyntax^U

    HEADER()

^UReturns^U

    An integer numeric value.

^UUsage^U

    HEADER() can be used with LASTREC()/RECCOUNT(), RECSIZE() and
DISKSPACE() to create procedures for backing up files.
!Seealso:CLIP001.NGO:"DISKSPACE"  "LASTREC"  CLIP001.NGO:"RECSIZE"  
!Short: I2BIN        Converts integer to two-byte character string.
^BI2BIN()^B

    Converts an integer numeric value to character string formatted as an
unsigned integer.

^USyntax^U

    I2BIN(<expN>)

^UArgument^U

    <expN> is the integer number to convert.  Note that decimal digits are
    truncated.

^UReturns^U

    A character string.

    I2BIN() returns a two-byte character string as a 16-byte unsigned
integer.

^UUsage^U

    I2BIN() is used in combination with FWRITE() to convert a Clipper
numeric data type to a two-byte character string formatted as an
unsigned integer.
!Seealso:CLIP001.NGO:"BIN2I"  CLIP001.NGO:"BIN2L"  CLIP001.NGO:"BIN2W"  CLIP001.NGO:"L2BIN"  CLIP001.NGO:"FOPEN"  CLIP001.NGO:"FWRITE"  
!Short: IF/IIF       Provides for conditional processing of expressions.
^BIF()/IIF()^B

    IF() returns the result of one of two specified expressions, depending
    upon the logical state of the given condition.

^USyntax^U

    IF(<exp L>,<exp1>,<exp2>)  -or- IIF(<exp L>,<exp1>,<exp2>)

^UArguments^U

    <expL> is a logical expression to be evaluated.

    <exp1> is the value to return if <expL> is true (.T.).

    <exp2> is the value to return if <expL> is false (.F.).

    Note that unlike other dialects, <exp1> and <exp2> can evaluate to
    different data types.  Note also that only the path pointed to by the
    result of <expL> is evaluated.  This means that an undefined or
    erroneous argument for the non-executed path does not generate a run-
    time error.

^UReturns^U

    A value of any data type.

    IF() returns the evaluation of the argument pointed to by the result of
    the logical expression argument.  Since the two return arguments can be
    different data types, the value returned is the data type of the
    evaluated return argument.

^UUsage^U

    IF() is one of the most powerful and versatile functions in Clipper.
    It provides a mechanism to evaluate a condition within an expression.
    With this ability you can convert a logical data type expression to
    another data type.  For example, the following converts a logical to a
    numeric:

    ^RIF(<condition>, 0, 1)^R

    This leads to a number of applications.  You can, for example, format
    a logical field:

    ^RIF(Paid, SPACE(0), "Go get 'em")^R

    If you are printing forms, you may want to print an indicating symbol
    in different columns depending on the value of a logical field.  For
    example:

    ^R@ <row>, IF(In_hosp, 10, 12) SAY "X"^R

    INDEXing is another area where IF() is useful.  You may want to create
    a key based on a logical field or add a key depending on a condition.
    This latter might be the case if the key field is empty.  In this case,
    you want the contents of another field to be the key value.  For
    example:

    ^RINDEX ON IF(EMPTY(Name), Company, Name) TO <ntx file>^R

    Another area where you can use IF() is to force the LABEL FORM to print
    blank lines.  For example:

    ^RIF(EMPTY(<expC>), CHR(255), <expC>)^R
!Seealso:CLIP001.NGO:"IF"  
!Short: INDEXEXT     Returns "NTX" or "NDX" to indicate current type of index.
^BINDEXEXT()^B

    INDEXEXT determines whether the current application was linked using
    NDX.OBJ for dBASE III PLUS compatible indexes.

^USyntax^U

    INDEXEXT()

^UReturns^U

    A character string.

    INDEXEXT() returns "NDX" if the index file type you use is dBASE III
    PLUS compatible or "NTX" if it is Clipper compatible.
!Seealso:"INDEXKEY"  "INDEXORD"  
!Short: INDEXKEY     Returns the key expression of a specified index.
^BINDEXKEY()^B

    INDEXKEY() returns the name of an index.

^USyntax^U

    INDEXKEY(<exp N>)

^UArgument^U

    <expN> is the ordinal position of the index in the list of index files
    opened by the last USE...INDEX or SET INDEX TO command for the current
    work area.  A zero value points to the controlling index, no matter
    what its actual position in the list.

^UReturns^U

    A character string.

    INDEXKEY() returns the key expression of the specified index.  If there
    is no index for the position the function argument points to,
    INDEXKEY() returns a null string ("").
!Seealso:CLIP001.NGO:"USE"  CLIP001.NGO:"SET INDEX"  CLIP001.NGO:"SET ORDER"  "INDEXEXT"  "INDEXORD"  
!Short: INDEXORD     Returns the controlling index as a numeric value.
^BINDEXORD()^B

    INDEXKEY() determines the position of the controlling index in the list
    of index files opened by the last USE...INDEX or SET INDEX TO in the
    current work area.

^USyntax^U

    INDEXORD()

^UReturns^U

    An integer numeric value.

    INDEXORD() returns the position of the controlling index in the list of
    open index files.  A value of zero indicates there is no controlling
    index and you are accessing the current database file in natural order.
!Seealso:CLIP001.NGO:"USE"  CLIP001.NGO:"SET INDEX"  CLIP001.NGO:"SET ORDER"  "INDEXEXT"  "INDEXKEY"  
!Short: INKEY        Returns numeric ASCII value of the key pressed.
^BINKEY()^B

    INKEY() reads a character from the keyboard.

^USyntax^U

    INKEY([<expN>])

^UArgument^U

    <expN> specifies the number of seconds INKEY() waits for a key press.
    Specifying zero halts the program until a key is pressed.  Note that
    the time INKEY() waits is based on the operating system clock and
    therefore is not related to the microprocessor speed.

^UReturns^U

    An integer numeric value.

    INKEY() returns a number from -39 to 386, identifying the ASCII code of
    the key pressed (the same value as returned by LASTKEY()).  If the
    keyboard buffer is empty, INKEY() returns zero.

    INKEY() returns values for all function, Alt-function, Ctrl-function,
    Alt-letter, and Ctrl-letter key combinations.

^UUsage^U

    INKEY() is useful for polling the keyboard or pausing program
    execution.  As an instance, you can use INKEY() to terminate commands
    with a record scope such as LIST, LABEL FORM, and REPORT FORM by
    including it in a while condition as follows:

    ^RREPORT FORM Report WHILE INKEY() <> 27^R

    To make your key operations easier to maintain, create a series of
    keyname memory variables using CHR().  Later in your program, you can
    compare the result of INKEY() to the keyname variable using the
    expression, CHR(INKEY()).
!Seealso:CLIP001.NGO:"SET KEY"  CLIP006.NGO:"CHR"  "LASTKEY()"  
!Short: INT          Converts any numeric expression into an integer.
^BINT()^B

    INT() converts any numeric expression to an integer by truncating all
    digits to the right of the decimal point.

^USyntax^U

    INT(<exp N>)

^UUsage^U

    INT() is useful in operations where the decimal value portion of a
    number is not needed.
!Seealso:"ROUND()"  
!Short: ISALPHA      Returns true if first character in string is alphabetic.
^BISALPHA()^B

    ISALPHA() returns a logical True (.T.) if the specified character
    string begins with an alpha character.

^USyntax^U

    ISALPHA(<exp C>)

^UUsage^U

    ISALPHA() determines that a character is an alpha character if it is an
    upper or lower case letter between a and z.
!Seealso:"LOWER()"  "UPPER()"  
!Short: ISCOLOR      Returns true if a color display is installed.
^BISCOLOR()^B

    ISCOLOR() returns a logical True (.T.) if a color graphics card is
    installed in the computer.

^USyntax^U

    ISCOLOR()

^UUsage^U

    ISCOLOR() enables developers to design applications for both color and
    monochrome environments.

    The response of ISCOLOR() depends on whether the system is operating
    with a color graphics board.  Whether you are operating in color
    actually depends on whether you have a color monitor connected, and
    whether SET COLOR is ON or OFF.

    ^BNote^B: some monochrome adapters with graphics capability return true
    (.T.), which can throw the poor programmer for a severe loop.
!Seealso:CLIP001.NGO:"SET COLOR"  
!Short: ISLOWER      Returns true if first character in string is lowercase.
^BISLOWER()^B

    ISLOWER() returns a logical True (.T.) if the specified character
    string begins with a lower case character.

^USyntax^U

    ISLOWER(<exp C>)

^UReturns^U

    A logical value.
!Seealso:"ISALPHA"  CLIP001.NGO:"ISUPPER"  "LOWER"  "UPPER"  
!Short: ISPRINTER    Determines whether LPT1 is ready.
^BISPRINTER()^B

    ISPRINTER() returns a logical True (.T.) if LPT1 is ready; otherwise,
    it returns false (.F.).

^USyntax^U

    ISPRINTER()

^UReturns^U

    A logical value.
!Seealso:CLIP001.NGO:"SET DEVICE"  CLIP001.NGO:"SET PRINT"  
!Short: ISUPPER      Returns true if first character in string is uppercase.
^BISUPPER()^B

    ISUPPER() returns a logical True (.T.) if the specified character
    string begins with an upper case character.

^USyntax^U

    ISUPPER(<exp C>)

^UReturns^U

    A logical value.
!Seealso:"ISALPHA"  CLIP001.NGO:"ISLOWER"  "LOWER"  "UPPER"  
!Short: L2BIN        Converts integer to four-byte character string.
^BL2BIN()^B

    Converts an integer numeric value to character string formatted as a
32-bit signed integer.

^USyntax^U

    L2BIN(<expN>)

^UArgument^U

    <expN> is the integer number to convert.  Note that decimal digits are
    truncated.

^UReturns^U

    A character string.

    L2BIN() returns a four-byte character string formatted as a 32-bit
signed integer.

^UUsage^U

    L2BIN() is used in combination with FWRITE() to convert a Clipper
numeric data type to a four-byte character string formatted as a
32-bit signed integer.
!Seealso:CLIP001.NGO:"BIN2I"  CLIP001.NGO:"BIN2W"  CLIP001.NGO:"BIN2L"  CLIP001.NGO:"CHR"  CLIP001.NGO:"I2BIN"  CLIP001.NGO:"FOPEN"  CLIP001.NGO:"FWRITE"  
!Short: LASTKEY      Returns numeric ASCII value of the last key pressed.
^BLASTKEY()^B

    LASTKEY() determines the last key fetched from the keyboard buffer.

^USyntax^U

    LASTKEY()

^UReturns^U

    An integer value.

    LASTKEY() returns a number from -39 to 386 identifying the ASCII value
    of the last key fetched.  There are two classes of commands and
    functions that fetch keys: wait states and interface functions.  Wait
    state commands and functions include ACCEPT, INPUT, MENU TO,
    MEMOEDIT(), READ, and WAIT.  Interface functions include ACHOICE(),
    DBEDIT(), and INKEY().

^UUsage^U

    LASTKEY() is useful in a number of situations:

    -  To determine the key used to terminate a READ.
    -  To determine the key used to exit the current GET when within a
       user-defined function executed from a VALID clause.
    -  To identify the exception key pressed in the user function of
       ACHOICE(), DBEDIT(), or MEMOEDIT().

    If you need to know whether the user has changed the contents of any
    GETs, use UPDATED().  If you need to know the key pending in the
    keyboard buffer, use NEXTKEY().
!Seealso:CLIP001.NGO:"KEYBOARD"  CLIP006.NGO:"CHR"  "INKEY"  "NEXTKEY"  
!Short: LASTREC/RECCOUNT     Returns number of records in current work area.
^BLASTREC()/RECCOUNT()^B

    LASTREC() determines the number of physical records in the currently
    active database file.

^USyntax^U

    LASTREC() / RECCOUNT()

^UReturns^U

    An integer numeric value.

    LASTREC() returns the number of physical records in the current
    database file.  This means that filtering commands such as SET FILTER
    or SET DELETED have no effect on the return value.

    LASTREC() returns zero if there is no database file in USE in the
    current work area.
!Seealso:CLIP006.NGO:"FIELD"  
!Short: LEN          Returns number of characters in character string.
^BLEN()^B

    LEN() returns the length of a character expression or the number of
    elements in an array.

^USyntax^U

    LEN(<exp C>/<array>)

^UArguments^U

    <expC> is the character string to determine the length of.

    <Array> is the array to count.

^UReturns^U

    An integer numeric value.

    If the character expression evaluates to a null string, LEN() returns
    zero.
!Seealso:CLIP006.NGO:"LTRIM"  "TRIM"  
!Short: LEFT         Extracts characters from left side of character string.
^BLEFT()^B

    Extracts a specified number of characters from the left of a character
string.

^USyntax^U

    LEFT(<expC>,<expN>)

^UArgument^U

    <expC> is a character string from which to extract characters.

    <expN> is the number of characters to extract.

^UReturns^U

    A character string.

    LEFT() returns the leftmost <expN> characters of <expC>.  If <expN> is
negative or zero, LEFT() returns a null string ("").  If <expN> is
larger than the length of the character string, LEFT() returns the
entire string.  The maximum size of <expC> is 65,535 (64K) bytes.
!Seealso:CLIP001.NGO:"AT"  CLIP001.NGO:"LTRIM"  "RAT"  CLIP001.NGO:"RIGHT"  "SUBSTR"  
!Short: LOG          Returns natural logarithm of a given number.
^BLOG()^B

    LOG() returns the natural logarithm of a specified number.

^USyntax^U

    LOG(<exp N>)

^UReturns^U

    A numeric value.

    Specifying a number less than or equal to zero returns a numeric
    overflow (a row of asterisks).

^UUsage^U

    The natural logarithm has a base of ^Ue^U (2.7183).  LOG() returns the
    exponent in the following equation:

    ^Ue^U to the ^Ux^Uth power = ^Uy^U

    ^Uy^U is the numeric expression used by LOG().  Due to mathematical
    rounding, the values returned by LOG() and EXP() may not agree exactly.
!Seealso:CLIP006.NGO:"EXP"  CLIP001.NGO:"SET DECIMALS"  CLIP001.NGO:"SET FIXED"  
!Short: LOWER        Converts upper case characters to lower case.
^BLOWER()^B

    LOWER() converts upper case letters to lower case letters.

^USyntax^U

    LOWER(<exp C>)

^UUsage^U

    A lower case alpha character is any lower case letter between a and z.
!Seealso:"UPPER"  
!Short: LTRIM        Removes leading blanks from a character expression.
^BLTRIM()^B

    LTRIM() removes leading blanks from a character expression.

^USyntax^U

    LTRIM(<exp C>)

^UUsage^U

    Use this function to remove leading blanks that result from the STR()
    function.

    If the argument is a null string (""), LTRIM() returns a null also.
!Seealso:CLIP001.NGO:"ALLTRIM"  "TRIM"  CLIP001.NGO:"RTRIM"  "STR"  "SUBSTR"  
!Short: LUPDATE      Determines date that current database was last modified.
^BLUPDATE()^B

    Determines the date the database file in the current work area was
last modified and CLOSEd.

^USyntax^U

    LUPDATE()

^UReturns^U

    A date value.

    LUPDATE() returns the date of change of the current database file.  If
there is no database file in USE in the current work area, LUPDATE()
returns a blank date.  Note that the last date of change is not
reflected until the database file is CLOSEd.
!Seealso:CLIP001.NGO:"FIELD"  "LASTREC"  CLIP001.NGO:"RECSIZE"  
!Short: MAX          Returns the greater of two numeric or date expressions.
^BMAX()^B

    MAX() returns the larger value of two numeric or date expressions.

^USyntax^U

    MAX(<exp N1>,<exp N2>)

^UUsage^U

    Both arguments must be of the same type.

    The MAX() function compares two numeric expressions and returns the
    largest of the two.
!Seealso:"MIN()"  
!Short: MEMOEDIT     Displays and edits memofields and long strings.
^BMEMOEDIT()^B

    Allows you to display or edit memofields or long character strings.

^USyntax^U

    MEMOEDIT([<expC1>][,<expN1>,<expN2>,<expN3>,<expN4>][,<expL1>]
    [,<expC2>][,<expN5>][,<expN6>][,<expN7>][,<expN8>][,<expN9>][,<expN10>]

^UArguments^U

    <expC1> is the character string or memo field to read.

    <expN1>, <expN2>, <expN3>, <expN4> define the edit window coordinates
    in the following order: top, left, bottom, and right.  if omitted , the
    entire screen is used.

    <expL1> determines whether a memo is edited or simply displayed.  If
    you specify true (.T.), the memo is displayed and you enter the edit
    mode.  If you specify false (.F.), you are placed in the browse mode
    where the memo is simply displayed.  The default is true (.T.).

    <expC2> is the name of a user function (a Clipper user-defined
    function) to execute whenever a key is pressed.  Specify the function
    name without the parenthetical suffix or arguments.  Refer to the
    discussion below for more information.

    <expN5> determines the line length.  If <expN5> is greater than the
    width of the window (<expN4>-<expN2>-1), the window scrolls
    horizontally.  The default is (<expN4>-<expN2>-1).

    <expN6> determines the tab size and enables real tabs.  The default is
    four.

    <expN7> is the initial memo line where the cursor is placed.

    <expN8> is the initial memo column where the cursor is placed.

    <expN9> is the initial row for placing the cursor relative to the
    window position.  The default is zero.

    <expN10> is the initial column for placing the cursor relative to the
    window position.  The default is zero.

    All arguments are optional.  You must, however, pass a dummy argument
    for any argument you wish to skip.

^UReturns^U

    A character string.

    MEMOEDIT() returns the modified string if it is terminated with Ctrl-W
    or the original string if it is terminated with Esc.

^UUsage^U

    MEMOEDIT is a general purpose text editing function that you can use in
    your applications for a variety of purposes.  It supports a number of
    different modes and includes a user function to allow key
    reconfiguration and other activities germane to programming the current
    text editing task.

    The following are the active keys within MEMOEDIT():

        ^UKEY^U                         ^UPURPOSE^U
        Up arrow or ^^E              Move up one line
        Down arrow or ^^X            Move down one line
        Left arrow or ^^S            Move left one character
        Right arrow or ^^D           Move right one character
        ^^left arrow or ^^A           Move left one word
        Right arrow or ^^F           Move right one word
        HOME                        Beginning of current line
        END                         End of current line
        ^^HOME                       Beginning of the memo
        ^^END                        End of the memo
        ^^W                          Finish editing, save changes
        Esc                         Abort edit, don't save changes
        ^^Y                          Delete the current line
        ^^T                          Delete word to right of cursor
        ^^B                          Reformat paragraph

    ^BBrowse/Update modes^B: MEMOEDIT() supports two display modes
    depending on the value of <expL1>.  If <expL1> is true (.T.),
    MEMOEDIT() enter update (edit) mode; otherwise, MEMOEDIT() enters
    browse (display) mode.  In the browse mode, all navigation keys are
    active and perform the same actions as update mode with one exception.
    In update mode, the scroll state is off (Uparrow and Dnarrow move the
    cursor up or down one line).  In browse mode, the scroll state is on
    (Uparrow and Dnarrow scroll the contents of the MEMOEDIT() window up or
    down one line).

    Note that browse mode in Clipper's Autumn '86 release did ^Bnot^B allow
    cursor movement and terminated immediately.  If you wish to retain this
    behavior add a user function argument for the following function:

    ^RFUNCTION NoBrowse  ^R
    ^RPARAMETERS mode    ^R
    ^RIF mode = 3        ^R
    ^R   KEYBOARD CHR(27)^R
    ^R   RETURN 0        ^R
    ^RELSE               ^R
    ^R   RETURN 0        ^R
    ^RENDIF              ^R

    You can also retain the behavior by using the syntax:
    MEMOEDIT(<expC1>,<expN1>,<expN2>,<expn3>,<expN4>,.F.,.F.)

    When MEMOEDIT() executes, it automatically calls the user function, as
    explained below, which in this case immediately terminates MEMOEDIT().
    Follow the MEMOEDIT() call with INKEY(0) to pause the display.

    ^BUser Function^B: When MEMOEDIT() calls the user function, it
    automatically passes three parameters: "status", "line", and "col".
    The status message indicates the current state of MEMOEDIT() depending
    on the last key pressed or the last action taken prior to executing the
    user function.  The following status values are possible.

    Status      Description
      0         Idle
      1         Re-configurable or unknown keystroke (memo unaltered)
      2         Re-configurable or unknown keystroke (memo altered)
      3         Start-up

    A start-up value of 3 indicates that the current mode is the start-up
    mode.  When you specify a user function.  MEMOEDIT() makes a call to it
    immediately after being invoked.  At this point, you RETURN a request
    to configure MEMOEDIT()'s various toggle states: word-wrap. scroll, or
    insert.  MEMOEDIT() calls the user function repeatedly, remaining in
    the start-up mode until you RETURN 0.  The memo is the ndisplayed and
    you enter the display mode set by <expL1>.

    Status message 0, 1, and 2 are used to process keys.  The idle state
    (status = 0) is called once when there is no pending key to process.
    Within this state, you generally update line and column number
    displays.  MEMOEDIT() calls the user function whenever a key exception
    occurs.  Keys that instigate a key exception are all available control
    keys, function keys, and Alt keys.  Since these keys are not processed
    by MEMOEDIT() when you have a user function, they can all be re-
    configured.

    The other two parameters, line and col, indicate the current cursor
    position in the MEMOEDIT() window when the user function is called.
    The line parameter begins with position one and col begins with
    position zero.

    When the status is either 1, 2, or 3, you can return a value
    instructing MEMOEDIT() what action to perform next.  The following
    table summarizes the possible return values and their consequences:

                       ^BMEMOEDIT() User Function Requests^B

    Value      Action
      0        Perform default action
    1 - 31     Perform requsted action corresponding to key value
               (e.g., 22 = Ctrl-V = Ins = toggle insert mode)
      32       Ignore the current key (disable)
      33       Process the current key as data (insert control key)
      34       Toggle word-wrap
      35       Toggle scrolling

    The following exceptions resolve key value collisions:

     100       Next word (2 = Ctrl-B = reform)
     101       Bottom right of window (23 = Ctrl-W = save and exit)

    Note that cursor keys, Return, Backspace, Tab, Del, and character keys
    cannot be disabled.

    ^BWord-wrapping^B: Word-wrapping is a state you toggle by RETURNing a
    34 from the user function.  The default is on.  When word-wrap is on,
    MEMOEDIT() inserts a soft carriage return/line feed at the closest word
    break to the window border or line length whichever occurs first.  WHen
    word-wrap is off, MEMOEDIT() scrolls text entry beyond the window
    definition until you reach the end-of-line.  At this point, you must
    press Return (inserting a hard carriage return/line feed) to advance to
    the next line.

    Note that soft carriage returns may interfere with the result of
    display commands such as ? and REPORT FORM or processing with another
    word processor.  Use HARDCR() and MEMOTRAN() to replace these embedded
    characters as needed.

    ^BParagraph reform^B: Pressing Ctrl-B or RETURNing a 2 from a user
    function reformats the memo until a hard carriage (end-of-paragraph) or
    the end-of-memo is encountered.  This happens regardless of whether
    word-wrap is on or off.

    ^BTab characters^B: When you specify the tab size argument (<expN6>).
    MEMOEDIT() inserts a hard tab character (09H) in the text when Tab is
    pressed,  If the tab size argument has not been specified, MEMOEDIT()
    inserts space characters instead.  The size of tabs is global for the
    entire memo and set with <expN6>.  The default is four.

    Note that MEMOEDIT() does not convert tab characters to spaces if real
    tabs are on.
!Seealso:"ACHOICE"  "DBEDIT"  "HARDCR"  "MEMOLINE"  "MEMOREAD"  "MEMOTRAN"  "MEMOWRIT"  
!Short: MEMOLINE     Returns formatted line from memofield or character exp.
^BMEMOLINE()^B

    MEMOLINE() extracts a formatted line of text from a character
    expression or memo field.

^USyntax^U

    MEMOLINE(<expC>,[<expN1>][,<expN2>][,<expN3>][,<expL>])

^UArguments^U

    <expC> is the memo field or character string expression to extract
    from.

    <expN1> is the number of characters per line.  The default is 79, the
    maximum is 254, and the minimum is four.

    <expN2> is the line number to extract.  The default is one.

    <expN3> is the tab size.  The default is four.  If <expN3> is greater
    than or equal to <expN1>, then the tab size if <expN1>-1.

    <expL> toggles word wrap on and off.  Specifying true (.T.) toggles
    word wrap on; false (.F.) toggles it off.  The default is true (.T.).

    Note that most arguments are optional.  To skip an argument and specify
    further arguments, pass a dummy argument for the argument you wish to
    skip.

^UReturns^U

    A character string.

    MEMOLINE() returns the line specified by <expN2> in <expC> based on the
    number of characters per line (<expN1>), the tab size (<expN3>), and
    wrapping behavior (<expL>).

    If <expL> is true (.T.) and an end-of-line position breaks a word, it
    is word-wrapped to the next line.  The next line then begins with the
    next non-blank character.  If <expL> is false (.F.), MEMOLINE() returns
    the number of characters specified by the line width (<expN1>).  The
    next line begins with the character following the next hard carriage
    return.  This means that the intervening characters are truncated.

    If the line has fewer characters than the indicated width, it is padded
    with blanks.  If the line number is greater than the total number of
    lines in the expression, MEMOLINE returns a null string ("").

^UUsage^U

    MEMOLINE() is designed to be used in combination with MLCOUNT() to
    extract lines of text from character strings and memo fields based on
    the number of characters per line.  The basic method of operation is to
    determine the number of lines in the memo field or character string
    using MLCOUNT(), the number of characters per line, the tab size, and
    the wrapping behavior.  Then navigate through the memo or character
    string with FOR...NEXT using the result of MLCOUNT() as the upper
    boundary of the loop.  Within the loop extract the current line with
    MEMOLINE() using the same values for the characters per line, tab size,
    and word wrap arguments.

!Seealso:"HARDCR"  "MLCOUNT"  "MLPOS"  "MEMOEDIT"  "MEMOTRAN"  "MEMOEDIT"  "MEMOREAD"  "MEMOWRIT"  
!Short: MEMOREAD     Returns the specified disk file as a character string.
^BMEMOREAD()^B

    Reads the contents of a text file read from disk.

^USyntax^U

    MEMOREAD(<expC>)

^UArgument^U

    <expC> is the name of the file you want to read from disk.  Note that
    it must include an extension if there is one and can optionally include
    the path.

^UReturns^U

    A character string.

    MEMOREAD() returns the contents of a text file as a character string.
    The maximum file size that can be read is 65,535 characters (64K), the
    maximum size of a character memory variable.

^UExample^U

    The following uses MEMOREAD() to assign the contents of a text file to
    both a memo field and a character variable.

    ^RREPLACE Notes WITH MEMOREAD("Temp.txt")^R
    ^Rchrvar = MEMOREAD("Temp.txt")          ^R

    This program uses MEMOREAD() to read a file from disk, edit it, and
    write it back:

    ^R* Editor.prg                            ^R
    ^RPARAMETERS file                         ^R
    ^RMEMOWRIT(file, MEMOEDIT(MEMOREAD(file)))^R
    ^RRETURN                                  ^R
!Seealso:"HARDCR"  "MEMOEDIT"  "MEMOLINE"  "MLCOUNT"  "MEMOTRAN"  CLIP001.NGO:"REPLACE"  
!Short: MEMORY       Returns the available free pool memory.
^BMEMORY()^B

    MEMORY() returns the available free pool memory.

^USyntax^U

    MEMORY(0)

^UReturns^U

    An integer numeric value.

    MEMORY(0) returns the free pool space for data manipulation.
!Short: MEMOTRAN     Returns character string with all CRs and LFs replaced.
^BMEMOTRAN()^B

    MEMOTRAN() replaces carriage return/line feed pairs.

^USyntax^U

    MEMOTRAN (<expC1>[,<expC2>[,<expC3>]])

^UArguments^U

    <expC1> is the character string or memo field to replace soft or hard
    carriage returns in.

    <expC2> is the character you specify to replace a hard carriage
    return/line feed pair.

    <expC3> is the character you specify to replace a soft carriage
    return/line feed pair.

^UReturns^U

    A character string.

    If you do not specify <expC2> and <expC3>, MEMOTRAN() replaces all hard
    carriage returns (CHR(13)) with semicolons, all soft carriage returns
    (CHR(141) with spaces, and eliminates all line feeds.

^UUsage^U

    The default replacement values accommodate the requirements of the
    REPORT FORM command.

    If you invoke a REPORT FORM that uses MEMOTRAN() and do not use
    MEMOTRAN() anywhere else in the program, be sure to declare MEMOTRAN()
    to the linker with EXTERNAL.

^UExample^U

    To strip all formatting characters from a memofield:

            ^RREPLACE Notes WITH MEMOTRAN(Notes," "," ")^R
!Seealso:"MEMOEDIT()"  CLIP001.NGO:"REPLACE"  "HARDCR"  "MEMOLINE"  "MEMOREAD"  "MEMOWRIT"  "MLCOUNT"  
!Short: MEMOWRIT     Writes character string to specified disk file.
^BMEMOWRIT()^B

    Writes a character string to a specified disk file.

^USyntax^U

    MEMOWRIT(<expC1>,<expC2>)

^UArgument^U

    <expC1> is the disk file name.  Note that it must include an extension
    if there is one and can optionally include the path.

    <expC2> is the character string to write as the file contents.

^UReturns^U

    A logical value.

    MEMOWRIT() returns true (.T.) if the writing operation is successful.
!Seealso:"MEMOREAD()"  "MEMOTRAN"  "MLCOUNT"  
!Short: MIN          Returns the lesser of two numeric or date expressions.
^BMIN()^B

    MIN() returns the smaller value of two numeric or date expressions.

^USyntax^U

    MIN(<exp N1>,<exp N2>)

^UUsage^U

    Both arguments must be of the same data type.

    The MIN() function compares two numeric expressions and returns the
    smaller of the two.
!Seealso:"MAX"  
!Short: MLCOUNT      Returns number of lines in a memofield or character exp.
^BMLCOUNT()^B

    MLCOUNT() counts the number of word-wrapped lines in a character string
    or a memo field.

^USyntax^U

    MLCOUNT(<expC>[,<expN1>][,<expN2>][,<expL>])

^UArguments^U

    <expC> is the character string or memo field in which to count lines.

    <expN1> is the number of characters per line.  The default is 79, the
    maximum is 254, and the minimum is four.

    <expN2> is the tab size.  The default is four.  If <expN3> is greater
    than or equal to <expN1>, then the tab size if <expN1>-1.

    <expL> toggles word wrap on and off.  Specifying true (.T.) toggles
    word wrap on; false (.F.) toggles it off.  The default is true (.T.).

    Note that most arguments are optional.  To skip an argument and specify
    further arguments, pass a dummy argument for the argument you wish to
    skip.

^UReturns^U

    An integer numeric value.

    MLCOUNT() returns the number of lines in <expC> based on the number of
    characters per line (<expN1>), the tab size (<expN2>), and wrapping
    behavior (<expL>).

    If <expL> is true (.T.) and an end-of-line position breaks a word, it
    is word-wrapped to the next line and the next line then begins with the
    next non-blank character.  If <expL> is false (.F.), MLCOUNT() counts
    the number of characters specified by the line width (<expN1>) as the
    current line.  The next line begins with the character following the
    next hard carriage return.  This means that the intervening characters
    are ignored.

^UUsage^U

    MLCOUNT() is primarily used with MEMOLINE() to format memo fields or
    long character strings for printing.  To do this, first use MLCOUNT()
    to return the number of word-wrapped lines.  Then, using MEMOLINE() to
    extract each line, loop through the memo field one line at a time until
    there are no lines left.

    See MEMOLINE() for an expanded discussion.
!Seealso:"HARDCR"  "MLPOS"  "MEMOEDIT"  "MEMOREAD"  "MEMOTRAN"  "MEMOWRIT"  
!Short: MLPOS        Returns position of specified line number in memo field.
^BMLPOS()^B

    MLPOS() determines the position of a specified line number in a
    character string or memo field.

^USyntax^U

    MLPOS(<expC>,<expN1>,<expN2>)

^UArguments^U

    <expC> is the character string or memo field in which to count lines.

    <expN1> is the number of characters per line.

    <expN2> is the line number.

^UReturns^U

    An integer numeric value.

    MLPOS() returns the position in <expC> of the specified line number.
    If <expN2> is greater than the number of lines in <expC>, MLPOS()
    returns LEN(<expC>).

^UExample^U

    This example loads a text file from disk and then finds the position of
    the fifth line of text given a line length of 40 characters:

    ^Rstring = MEMOREAD("Temp.txt")^R
    ^Rloc = MLPOS(string, 40, 5)   ^R
!Seealso:"HARDCR"  "MLCOUNT"  "MEMOEDIT"  "MEMOREAD"  "MEMOTRAN"  "MEMOWRIT"  
!Short: MONTH        Returns number representing month from a date variable.
^BMONTH()^B

    MONTH() converts a date value to a number representing the month.

^USyntax^U

    MONTH(<exp D>)

^UReturns^U

    An integer numeric value.

    MONTH() returns a nuber in the range of zero to 12.  Specifying a null
    date returns zero.
!Seealso:CLIP006.NGO:"CMONTH"  CLIP006.NGO:"CDOW"  CLIP006.NGO:"DOW" "DAY" year.ngo:"YEAR" "CTOD" "DTOC""  
!Short: NETERR       Returns true if network environmental error occurs.
^BNETERR()^B

    NETERR() determines if a USE, USE...EXCLUSIVE, or APPEND BLANK has
    failed in a network environment.

^USyntax^U

    NETERR()

^UReturns^U

    NETERR() returns a logical True (.T.) if a USE, USE... EXCLUSIVE, or
    APPEND BLANK fails in a network environment.  These commands will fail
    under the following circumstances.

    ^UCommand^U                 ^UCause^U

    USE                     USE EXCLUSIVE by another process
    USE...EXCLUSIVE         USE EXCLUSIVE by another process
    APPEND BLANK            FLOCK() by another process or 2 attempts at
                            the same time
!Seealso:CLIP001.NGO:"USE..EXCLUSIVE"  CLIP006.NGO:"FLOCK"  "RLOCK"  
!Short: NETNAME      Returns text of the computer name.
^BNETNAME()^B

    To determine the current workstation identification.

^USyntax^U

    NETNAME()

^UReturns^U

    A character string.

    NETNAME() returns the workstation identification as a character string
    15 characters long.  If the workstation name was never set or the
    application is not operating under the IBM-PC Network, it returns a
    null string.
!Short: NEXTKEY      Reads the next keystroke without removing it from buffer.
^BNEXTKEY()^B

    NEXTKEY() reads the next keystroke without removing it from the
    keyboard buffer.

^USyntax^U

    NEXTKEY()

^UReturns^U

    An integer numeric value.

    NEXTKEY() returns a number from -39 to 386, identifying the ASCII code
    of the key pressed (the same value as returned by INKEY() and
    LASTKEY()).  If the keyboard buffer is empty, NEXTKEY() returns zero.

    NEXTKEY() returns values for all function, Alt-function, Ctrl-function,
    Alt-letter, and Ctrl-letter key combinations.

^UUsage^U

    Since NEXTKEY() does not remove the key from the keyboard buffer, you
    can use it to poll the keyboard and then pass control to a routine
    that uses a wait state to fetch the key from the buffer.
!Seealso:"INKEY"  "LASTKEY"  
!Short: PCOL         Returns the current column position on printer.
^BPCOL()^B

    PCOL() determines the current column position on the printer, and helps
    keep track of printer column positions within programs.

^USyntax^U

    PCOL()

^UReturns^U

    An integer numeric value.

    PCOL() returns a numeric value representing the last column position
    plus one.  For example, if you print a string five characters long
    beginning at column one, a subsequent PCOL() returns six.

    An EJECT resets PCOL() to zero.  If you need to reset the internal
    printer column value without performing an EJECT, use SETPRC().

^UUsage^U

    PCOL() helps keep track of printer column position when you want to
    place text on a line relative to other text on the line.
!Seealso:"PROW"  CLIP006.NGO:"COL"  "SETPRC"  "ROW"  
!Short: PCOUNT       Returns number of actual parameters passed to a function.
^BPCOUNT()^B

    PCOUNT() returns the number of actual parameters that have been passed
    to a procedure or user-defined function.

^USyntax^U

    PCOUNT()

^UReturns^U

    An integer numeric value.

    PCOUNT() returns the number of parameters passed.  If no parameters are
    passed, PCOUNT() returns zero.  Note that PCOUNT() retains its value
    until you attempt to pass parameters to either a procedure or a user-
    defined function.

^UUsage^U

    PCOUNT() can prove useful when polling the DOS command line for
    parameters at the top of your program.

^UExample^U

    ^RPARAMETERS file                  ^R
    ^RIF PCOUNT() = 0                  ^R
    ^R   ACCEPT "File to use: " TO file^R
    ^RENDIF                            ^R
    ^RUSE &file                        ^R
!Seealso:CLIP001.NGO:"PARAMETERS"  
!Short: PROCLINE     Returns source code line number of current program.
^BPROCLINE()^B

    PROCLINE() returns the source code line number from the beginning of
    the current program file.

^USyntax^U

    PROCLINE()

^UReturns^U

    An integer numeric value.

    When compiling your Clipper program, if you specify that no source code
    line numbers will be generated, the line number returned in PROCLINE is
    unpredictable.
!Seealso:"PROCNAME()"  
!Short: PROCNAME     Returns name of current program or procedure.
^BPROCNAME()^B

    PROCNAME() returns the name of the current program or procedure.

^USyntax^U

    PROCNAME()

^UReturns^U

    A character string.
!Seealso:"PROCLINE()"  
!Short: PROW         Returns current row position on printer.
^BPROW()^B

    PROW() determines the current row position on the printer.

^USyntax^U

    PROW()

^UReturns^U

    An integer numeric value.

    An EJECT resets PROW() to zero.  If you need to reset the internal
    printer column value without performing an EJECT, use SETPRC().  Be
    aware that if you move the print head with CHR(10), Clipper will ^Bnot^B
    take this into account and PROW() will not return the expect value.

^UUsage^U

    PROW() helps keep track of the printer row position.  It is useful when
    you want to place text on a line relative to another line on a page.
!Seealso:"PCOL"  CLIP006.NGO:"COL"  "SETPRC"  "ROW"  
!Short: RAT          Searches character string for last instance of a substring.
^BRAT()^B

    RAT() returns a number showing the starting position of the last
    instance of a specified substring within another character string.

^USyntax^U

    RAT(<exp C>,<exp C>)

^UReturns^U

    An integer numeric value.

    If the substring is contained within the target expression, RAT()
    returns the starting character position of the substring.  If the
    substring is not found, RAT() returns zero.

^UUsage^U

    RAT() is similar to the AT() function except that scanning begins from
    the right, therefore locating the last instance of a substring within a
    specified string.
!Seealso:CLIP006.NGO:"AT"  "STRTRAN()"  "SUBSTR"  
!Short: READVAR      Returns the name of the current GET/MENU variable.
^BREADVAR()^B

    READVAR() returns the name of the current GET/MENU variable.

^USyntax^U

    READVAR()

^UReturns^U

    A character string.

    READVAR() returns the name (in upper case) of the current GET/MENU
    variable or a null string (""), if none is pending.

^UUsage^U

    READVAR() is used primarily for debugging purposes or in programs using
    SET KEY.
!Seealso:CLIP001.NGO:"READ"  CLIP001.NGO:"SET KEY"  
!Short: READEXIT     Toggles the Uparrow and Dnarrow as READ exit keys.
^BREADEXIT()^B

    Toggles the Uparrow and Dnarrow as READ exit keys.

^USyntax^U

    READEXIT([<expL>])

^UArgument^U

    <expL> toggles the Uparrow or Dnarrow keys as exit keys for a READ.
Setting READEXIT() true (.T.) activates them as exit keys; false (.F.)
deactivates them.  The default setting is false.

^UReturns^U

    A logical value.

    READEXIT() returns the current setting prior to toggling to a new
setting.
!Seealso:CLIP001.NGO:"READ"  CLIP001.NGO:"READINSERT"  
!Short: READINSERT   Toggle/report current insert mode setting for READs.
^BREADINSERT()^B

    Reports the current insert mode setting for READ and MEMOEDIT() and
optionally toggle it on or off.

^USyntax^U

    READINSERT([<expL>])

^UArgument^U

    <expL> toggles the insert mode on or off.  True (.T.) turns insert on,
while false (.F.) turns inset off.  The default setting is false.

^UReturns^U

    A logical value.

    READINSERT() returns the current insert mode setting if an argument is
not specified and the previous insert mode if the argument is
specified.

^UExample^U

    The following sets the insert mode prior to entering MEMOEDIT() and
resets the mode when MEMOEDIT() terminates:

^Rins_mode = READINSERT(.T.)      && Turn on insert mode^R
^Rx = MEMOEDIT(x)                                       ^R
^RREADINSERT(ins_mode)           && Restore last setting^R
!Seealso:CLIP001.NGO:"READ"  "MEMOEDIT"  CLIP001.NGO:"READEXIT"  
!Short: RECNO        Returns the current record number of the current work area.
^BRECNO()^B

    RECNO() returns the current record number of the current work area.

^USyntax^U

    RECNO()

^UReturns^U

    An integer numeric value.

    If there are no records in a database file, RECNO() = 1 and both BOF()
    and EOF() return True (.T.).

    If the record pointer is set to point past the last record in the file
    (by using a SKIP command to skip past the last record), RECNO() returns
    a value which is one more than the number of records in the file and
    EOF() returns true (.T.).  If an attempt is made to set the record
    pointer before the first record in a file, RECNO() returns the value 1
    and BOF() returns true (.T.).

^UUsage^U

    RECNO() is useful when you want to determine a record number from
    within a program.
!Seealso:CLIP006.NGO:"BOF"  CLIP006.NGO:"EOF"  
!Short: RECSIZE      Determines record length of current database file.
^BRECSIZE()^B

    RECSIZE() determines the record length of the current database file.

^USyntax^U

    RECSIZE()

^UReturns^U

    An integer numeric value.

    RECSIZE() returns the record length for the database file in USE in
the current work area.  If no database file is in USE, RECSIZE()
returns zero.

^UUsage^U

    RECSIZE() determines the length of a record by taking the length of
each field in the record and adding one character to the total (for
the asterisk that indicates a deleted record).  WHen this value is
multipled by LASTREC(), the produce is the amount of space occupied by
the file's records.
!Seealso:CLIP001.NGO:"DISKSPACE"  CLIP001.NGO:"FIELD"  "LASTREC"  
!Short: REPLICATE    Repeats a character expression a specified number of times.
^BREPLICATE()^B

    REPLICATE() repeats a character expression a specified number of times.

^USyntax^U

    REPLICATE(<expC>,<expN>)

^UArguments^U

    <expC> is the character string to repeat.

    <expN> is the number of times to repeat <expC>.

^UReturns^U

    A character string.

    The maximum size of the string returns is 65,535 (64K) bytes.
    Specifying a zero as the numeric argument returns a null string.

^UUsage^U

    REPLICATE() is useful anywhere you want to repeatedly display, print,
    or stuff the keyboard with one or more characters.
!Seealso:"SPACE"  
!Short: RESTSCREEN   Displays a previously saved screen region.
^BRESTSCREEN()^B

    RESTSCREEN() displays a previously saved screen region to a specified
    screen area.

^USyntax^U

    RESTSCREEN(<expn1>,<expN2>,<expN3>,<expN4>,<expC>)

^UArguments^U

    <expN1..expN4> are the screen coordinates to display screen data
contained in <expC>.

<expC> is a character strnig containing the screen data to display.

^UReturns^U

    There is no return value.

^UUsage^U

    RESTSCREEN() is used to redisplay a screen region saved with
SAVESCREEN().  The screen location to restore may be the same or
different.  If you specify a new screen location, be sure that the new
screen region is the same size or you may get ambiguous results.  In
addition, do not use RESTORE SCREEN to restore screen regions saved
with SAVESCREEN() or you will get equally ambiguous results.
!Seealso:CLIP001.NGO:"RESTORE SCREEN"  CLIP001.NGO:"SAVE SCREEN"  CLIP001.NGO:"SAVESCREEN"  
!Short: RIGHT        Extracts characters from right side of character string.
^BRIGHT()^B

    Extracts a specified number of characters from the right of a
character string.

^USyntax^U

    RIGHT<expC>,<expN>)

^UArgument^U

    <expC> is a character string from which to extract characters.

    <expN> is the number of characters to extract.

^UReturns^U

    A character string.

    RIGHT() returns the rightmost <expN> characters of <expC>.  If <expN>
is negative or zero, LEFT() returns a null string ("").  If <expN> is
larger than the length of the character string, LEFT() returns the
entire string.  The maximum size of <expC> is 65,535 (64K) bytes.
!Seealso:CLIP001.NGO:"AT"  CLIP001.NGO:"LTRIM"  "RAT"  CLIP001.NGO:"LEFT"  CLIP001.NGO:"RTRIM"  "SUBSTR"  
!Short: RLOCK/LOCK   Attempts to lock the current record.
^BRLOCK()^B

    RLOCK() locks the current record in the current work area.

^USyntax^U

    RLOCK()/LOCK()

^UReturns^U

    A logical value.

    RLOCK() returns true (.T.) if you successfully lock a record.
    Otherwise it returns false (.F.).

^UUsage^U

    RLOCK() locks the current record in the selected work area.  It remains
    locked until you lock another record, UNLOCK, CLOSE the DATABASE, or
    FLOCK().

    Note that unlike dBASE III PLUS, RLOCK() does not lock other work areas
    in a relation chain.
!Seealso:CLIP006.NGO:"FLOCK"  CLIP001.NGO:"UNLOCK"  CLIP001.NGO:"SET EXCLUSIVE"  CLIP001.NGO:"USE"  
!Short: ROUND        Returns rounded numbers to specified number of decimals.
^BROUND()^B

    ROUND() rounds off numbers to a specified number of decimal places.

^USyntax^U

    ROUND(<exp N1>,<exp N2>)

^UArguments^U

    <exp N1> is a numeric expression to be rounded.

    <exp N2> is the number of decimal places you want to retain.

^UReturns^U

    A numeric value.

    ROUND() roudns <exp N1> to the number of places specified by <exp N2>.
    Specifying a zero or negative value for <exp N2> allows rounding of
    whole numbers.  A negative <exp N2> indicates the number of places to
    the left of the decimal point to round.

    The display of the return value does not obey DECIMALS SETting unless
    SET FIXED is ON.  With FIXED OFF, the display of the return value
    contains as many decimal digits as you specify for <exp N2> or zero if
    <exp N2> is less than one.

    Note that Clipper rounds up in all instances.  There is no "odd/even"
    rule.

^UUsage^U

    The ROUND() function is useful when you want to use a number with less
    precision than it currently has.
!Seealso:"INT"  
!Short: ROW          Returns current screen row location of the cursor.
^BROW()^B

    ROW() returns the row number of the current cursor position.

^USyntax^U

    ROW()

^UReturns^U

    An integer numeric value.

    ROW() returns a number in the range of zero to 24 with zero being the
    first (top) row on the screen.  When you CLEAR the screen, ROW()
    returns zero.  After a READ terminates, ROW() returns 23.

^UUsage^U

    ROW() is useful in programs to keep track of rows used for relative
    addressing of screen locations.
!Seealso:CLIP006.NGO:"COL"  "PCOL"  "PROW"  
!Short: RTRIM        Removes trailing blanks from a character expression.
^BRTRIM()^B

    RTRIM() removes trailing blanks from a character expression.

^USyntax^U

    RTRIM(<exp C>)

^UUsage^U

    Use this function to remove trailing blanks from a character string.

    If the argument is a null string (""), RTRIM() returns a null also.
!Seealso:CLIP001.NGO:"ALLTRIM"  CLIP001.NGO:"LTRIM"  "TRIM"  "STR"  "SUBSTR"  
!Short: SAVESCREEN   Saves specified screen region to be redisplayed.
^BSAVESCREEN()^B

    SAVESCREEN() saves a specified screen area to be redisplayed later.

^USyntax^U

    SAVESCREEN(<expn1>,<expN2>,<expN3>,<expN4>)

^UArguments^U

    <expN1..expN4> are the screen coordinates to save.

^UReturns^U

    A character string.

    SAVESCREEN() returns the specified screen region as a string up to
    4000 bytes in length.

^UUsage^U

    SAVESCREEN() is used to save a screen region to a memory variable.  To
restore the partial screen, use RESTSCREEN().

Typically, you would save and restore a screen region when using a
pop-up menu or for dragging a screen object.
!Seealso:CLIP001.NGO:"RESTSCREEN"  CLIP001.NGO:"RESTORE SCREEN"  CLIP001.NGO:"SAVE SCREEN"  
!Short: SCROLL       Uses window coordinates to scroll or blank part of screen.
^BSCROL()^B

    SCROLL() designates a section of the screen to scroll up, down, or
    blank out.

^USyntax^U

    SCROLL(<expN1>,<expN2>,<expN3>,<expN4>,<expN5>)

^UArguments^U

    <expN1> is the top of the window.

    <expN2> is the left of the window.

    <expN3> is the bottom of the window.

    <expN4> is the right of the window.

    <expN5> is the number of rows to scroll.  A number greater than zero
    scrolls up the specified number of rows.  A value less than zero
    scrolls down the specified number of rows, and zero blanks the
    specified area.

^UReturns^U

    There is no return value.

^UUsage^U

    SCROLL() is used to emulate windows.  This can be useful for defining a
    list in a specified part of a screen and allowing the user to scroll up
    when at the top of the window or down when at the bottom of the screen.
!Short: SECONDS      Returns system time in seconds and hundredths.
^BSECONDS()^B

    SECONDS() returns the system time as <seconds>.<hundredths>.  The
    numeric value returned is the number of seconds elapsed since midnight,
    and is based on a twenty-four hour clock, in a range from 0 to 86399.

^USyntax^U

    SECONDS(<exp N>)

^UUsage^U

    The numeric value returned by SECONDS() provides a simple method of
    calculating elapsed time during the execution of a program.
!Seealso:"TIME()"  
!Short: SELECT       Returns the number of the current work area.
^BSELECT()^B

    SELECT() returns the current work area number.

^USyntax^U

    SELECT()

^UReturns^U

    An integer numeric value.

    SELECT() returns a numeric value in the range from zero to 254.  If
    there is no database file in USE in the current work area, SELECT()
    still returns the number of the current work area.
!Seealso:CLIP001.NGO:"SELECT"  CLIP001.NGO:"USE"  CLIP006.NGO:"ALIAS"  
!Short: SETCANCEL    Toggle program termination with Alt-C, on or off.
^BSETCANCEL()^B

    SETCANCEL() toggles program termination with Alt-C, on or off.

^USyntax^U

    SETCANCEL([<expL>])

^UArguments^U

    <expL> toggles the termination capability on or off.  Specifying true
    (.T.) toggles termination on and false (.F.) toggles it off.  The
    default setting when a Clipper application loads is true (.T.).

^UReturns^U

    A logical value.

    SETCANCEL() returns the previous setting if an argument is specified;
    the current setting if an argument is not.

^UUsage^U

    SETCANCEL() serves two basic purposes: toggling the state of the
    termination key, Alt-C, and reporting the current or last state of
    SETCANCEL().

    ^BNote^B: SET KEY takes precedence over Alt-C when the termination
    state is enabled.

    ^BCaution: When SETCANCEL() has been set true (.T.), you will be unable
    to terminate a runaway program unless you have provided an alternative
    escape mechanism.
!Seealso:CLIP001.NGO:"SET ESCAPE"  CLIP006.NGO:"ALTD"  
!Short: SETCOLOR     Determines current or previous color setting.
^BSETCOLOR()^B

    SETCOLOR() determines the current or previous color setting and
optionally defines colors for the next screen painting
activity.

^USyntax^U

    SETCOLOR([<expC>])

^UArgument^U

    <expC> is a character string containing the standard, enhanced,
border, background, and unselected color settings to make the current
colors.  Unlike SET COLOR TO, SETCOLOR() with no argument does not
restore colors to their default values.

Note also that SETCOLOR() only supports color lettercombinations and
not color numbers.

^UReturns^U

A character string.

SETCOLOR() returns a string representing the last color setting if
<expC> is specified and the current setting if it is not specified.

^UUsage^U

    ^BStandard/Enhanced^B: The "standard" and "enhanced" displays are color
    pairs with a foreground and an optional background color.  "Standard"
    is used by all output, such as @...SAY and ?.  "Enhanced" setting
    affects only the display of GETs.

    ^BBorder^B: Sets the border color.  Border color is not supported on
    EGA or VGA monitors.

    ^BBackground^B: The "background" is not currently supported by any
    machines for which Nantucket provides drivers.

    ^BUnselected^B: THe "unselected" setting displays the current GET in
the "enhanced" color while other GETs are displayed in the
"unselected" color.

^BAttributes^B: High intensity and blinking are the supported
attributes of colors.  High intensity is denoted by "+" and blinking
with "*".  Each attribute specified is applied to the foreground color
no matter where it occurs in the setting definition.

    The following table lists the colors available:

         ^UColor              Letter^U
         BLACK              N
         BLUE               B
         GREEN              G
         CYAN               BG
         RED                R
         MAGENTA            RB
         BROWN              GR
         WHITE              W
         GREY               N+
         YELLOW             GR+
         BLANK              X
         Underline          U
         Inverse Video      I
!Seealso:"ISCOLOR()"  CLIP001.NGO:"SET COLOR"  
!Short: SETPRC       Sets PROW() and PCOL() functions to specified values.
^BSETPRC()^B

    SETPRC() sets the internal PROW() and PCOL() values to the specified
    values.

^USyntax^U

    SETPRC(<expN1>,<expN2>)

^UUsage^U

    <exp N1> is stored in PROW(), and <exp N2> is stored in PCOL().  This
    can be useful for sending a set-up string to the printer without
    changing where the program thinks the print head is positioned.  In
    addition, this function can be used to suppress page ejects.
!Seealso:"PROW"  "PCOL"  
!Short: SOUNDEX      Converts character string to soundex form for searching.
^BSOUNDEX()^B

    SOUNDEX() converts a character string to soundex form (phonetic
complement) useful for INDEXing and searching.

^USyntax^U

    SOUNDEX(<expC>)

^UArguments^U

    <expC> is the character string to convert to soundex form.

^UReturns^U

    A character string.

    The string returns is a code in the form A9999.

^UUsage^U

    SOUNDEX() is useful for creating indexes and searching for strings
where the precise spelling is unknown.  SOUNDEX() is based on an
algorithm by Donald E. Knuth.

Knuth, Donald E. (1973).  Sorting and Searching.  ^UThe Art of
Computer Programming^U (Vol. 3),(p. 392).  Reading, MA: Addison
Wesley.
!Seealso:CLIP001.NGO:"INDEX"  CLIP001.NGO:"SEEK"  CLIP001.NGO:"SET SOFTSEEK"  
!Short: SPACE        Create character string of specified number of spaces.
^BSPACE()^B

    SPACE() returns a string of spaces.

^USyntax^U

    SPACE(<expN>)

^UArgument^U

    <expN> is the number of spaces to return up to a maximum of 65,535
    (64K).

^UReturns^U

    A character string.

    SPACE(0) returns a null string.

^UUsage^U

    SPACE() is a general purpose character function and so can be used for
    a number of different purposes including initializing memory variables
    for data input, formatting strings, and placing the cursor
    nondestructively on the screen.
!Seealso:"REPLICATE"  
!Short: SQRT         Returns the square root of a given positive number.
^BSQRT()^B

    SQRT() returns the square root of a positive number.

^USyntax^U

    SQRT(<exp N>)

^UUsage^U

    SQRT() returns a square root value with the same number of decimal
    places as the number, or the specified number of decimal places
    specified by SET DECIMALS TO, whichever is larger.
!Seealso:CLIP001.NGO:"SET DECIMALS"  CLIP001.NGO:"SET FIXED"  
!Short: STR          Converts numeric expression to character string.
^BSTR()^B

    STR() converts a numeric expression to a character string.

^USyntax^U

    STR(<expN1>,[,<expN2>[,<expN3>]])

^UArguments^U

    <expN1> is the numeric expression to convert to a character string.

    <expN2> is the length of the character string to return including
    decimal digits, decimal point, and minus sign.

    <expN3> is the number of decimal places to return.

^UReturns^U

    A character string.

    If the optional length and decimal arguments are not specified, STR()
    returns 10 whole number digits including leading spaces, the number of
    decimals in the numeric expression for memory variables, and the entire
    contents of numeric fields including decimals digits.

    If you specify <expN2> less than the number of whole number digits in
    <expN1>, STR() returns asterisks instead of the number.

    If you specify <expN2> less than the number of decimal digits length
    required for the decimal portion of the returned string, Clipper rounds
    the number to the available number of decimal places.

    If you specify <expN2> but omit <expN3> (no decimal places), the return
    value is rounded to an integer.

    ^BDate functions^B: the STR() of YEAR(), MONTH(), and DAY() returns
    different results than other numeric values.  The STR() of MONTH() and
    DAY() returns a string of length three.  The STR() of YEAR() returns a
    string five characters in length.

^UUsage^U

    STR() is useful when you want to display or print the results of
    numeric expressions.
!Seealso:"VAL()"  "SUBSTR"  
!Short: STRTRAN      Searches and replaces within a character string.
^BSTRTRAN()^B

    STRTRAN() searches and replaces within a character string.

^USyntax^U

    STRTRAN(<expC1>,<expC2>[,<expC3>] [,<expN1>] [,<expN2>})

^UArguments^U

    <expC1> is the character string to search.

    <expC2> is the sequence of characters to locate.

    <expC3> is the sequence of characters to replace with.  If this
    argument is not specified, all instances of the search argument are
    replaced with a null string ("").

    <expN1> is the first occurrence that will be replace.  If this
    argument is omitted, the default is one.

    <expN2> is the number of occurrences to replace.  If this argument is
    not specified, the default is all.

^UReturns^U

    A character string.

^UUsage^U

    STRTRAN() performs a standard substring search within a character
    string.  When it finds a match, it replaces the search string with the
    specified replacement string.  All instances of the search string are
    replaced.

    Note that STRTRAN() replaces substrings and therefore does not account
    for whole words.  Additionally, SET EXACT ON has no effect on its
    operation.  STRTRAN() always acts as if SET EXACT is OFF.
!Seealso:CLIP006.NGO:"AT"  "RAT"  "SUBSTR"  
!Short: STUFF        To manipulate characters within a character string.
^BSTUFF()^B

    STUFF() deletes, inserts, and/or replaces characters in a character
    string.

^USyntax^U

    STUFF(<expC1>,<expN1>,<expN2>,<expC2>0

^UArguments^U

    <expC1> is the target character string.

    <expN1> is the starting position in the target string where the
    replacement occurs.

    <expN2> is the number of characters to replace in the target string
    (<expC1>).

    <expC2> is the replacement string.

^UReturns^U

    A character string.

    Essentially STUFF() replaces <expN2> characters in the target string
    (<expC1> beginning at <expN1> with <expC2>.

^UUsage^U

    With this basic structure STUFF() can perform the following six
    operations:

    ^BInsert^B: If you specify zero for <expN2>, no characters are removed
    from <expC1>, the replacement string (<expC2>) is inserted at <expN1>,
    and the entire string is returned.

    ^BReplace^B: If you specify a replacement string (<expC2>) the same length
    as <expN2>, <expC2> replaces characters beginning at <expN1>.

    ^BDelete^B: If replacement string (<expC2>) is a null string (""), the
    number of characters specified by <expN2> are removed from <expC1> and
    the string is returned without any added characters.

    ^BReplace and Insert^B: If the replacement string (<expC2>) is longer than
    <expN2>, all characters from <expN1> are replaced and the rest of the
    replacement string (<expC2> is inserted.

    ^BReplace and Delete^B: If the length of the replacement string (<expC2>)
    is less than <expN2>, all characters in the target string (<expC1>) are
    deleted from the end of <expC2> up to <expN2>.

    ^BReplace and Delete Rest^B: If <expN2> is greater than the length of the
    target string (<expC1>), the replacement string (<expC2>) is inserted
    at <expN1> and the rest of <expC1> is deleted.
!Seealso:CLIP006.NGO:"AT"  CLIP006.NGO:"LEFT"  CLIP006.NGO:"RIGHT"  "RAT"  "STRTRAN"  "SUBSTR"  
!Short: SUBSTR       Extracts a specified part of a character string.
^BSUBSTR()^B

    SUBSTR() extracts a specified number of characters from a character
    string.

^USyntax^U

    SUBSTR(<expC>,<expN1> [,<expN2>]

^UArguments^U

    <expC> is the source character string.  The maximum character string
    that you can take a substring of is 65,535 (64K) bytes, the maximum
    character string size in Clipper.

    <expN1> is the starting position in the source string to begin the
    substring.  If the starting position is positive, it is relative to the
    leftmost character in the string.  If the starting position is
    negative, the starting position is relative to the rightmost character
    in the string.

    <expN2> is the number of characters to return.  If this argument is
    omitted, the substring begins the starting position and continues to
    the end of the string.  If it is larger than the number of characters
    from the starting position to the end of the string, it is ingored.

^UReturns^U

    A character string.

^UUsage^U

    SUBSTR() is useful when you want to display or print only a portion of
    a character string.
!Seealso:CLIP006.NGO:"AT"  "RAT"  
!Short: TIME         Returns the system time in the format "hh:mm.ss".
^BTIME()^B

    TIME() returns the system time as a character string in the format
    hh:mm:ss.

^USyntax^U

    TIME()

^UUsage^U

    TIME() is useful when you want to include the time in a report or in a
    display.  To use TIME() in calculations, convert the value returned to
    a numeric value using SUBSTR() and VAL().
!Seealso:"SECONDS"  CLIP006.NGO:"DATE"  
!Short: TONE         Sounds speaker for specified tone and duration.
^BTONE()^B

    TONE() sounds a speaker tone for a specified frequency and duration.

^USyntax^U

    TONE(<expN1>,<expN2>)

^UArguments^U

    <expN1> is the frequency of the tone to sound.

<expN2> is the duration of the tone measured in increments of 1/18 of
a second.  One second, therefore, is 18.

^UReturns^U

    There is no return value.

^UUsage^U

    TONE() sounds the speaker at the specified frequency for the specified
duration.  The duration is measured in increments of 1/18 of a second.
The frequency is measured in hertz (cycles per second).  Frequencies
less than 20 are inaudible.  The following are the frequencies of
standard musical notes:

Pitch    Frequency             Pitch    Frequency
  C       130.80               mid C      261.70
  C#      138.60                 C#       277.20
  D       146.80                 D        293.70
  D#      155.60                 D#       311.10
  E       164.80                 E        329.60
  F       174.60                 F        349.20
  F#      185.00                 F#       370.00
  G       196.00                 G        392.00
  G#      207.70                 G#       415.30
  A       220.00                 A        440.00
  A#      233.10                 A#       466.20
  B       246.90                 B        493.90
!Short: TRANSFORM    Returns character string with specified picture format.
^BTRANSFORM()^B

    TRANSFORM() allows formatting of character and numeric data
    without using the @...SAY command.

^USyntax^U

    TRANSFORM(<exp>,<exp C>)

^UArguments^U

    <exp> is the character, date, or numeric expression to format.

    <expC> identifies the format of the returned character string.

^UReturns^U

    A character string.

    TRANSFORM() takes the result of an expression of any data type and
    returns a formatted character string according to the template
    specified by <expC>.  Note that since TRANSFORM() returns a character
    string, it does not solve the problem of formatting a totalled field in
    a REPORT FORM.

^UUsage^U

    TRANSFORM() allows you to format character, date, or numeric
    expressions in the same way you would with @...PICTURE converting each
    to a character string matching the specified format.  The following is
    a complete list of functions and templates that TRANSFORM() supports.
    Refer to @..PICTURE for a complete discussion on how the picture
    functions and templates work.

                             ^BTRANSFORM FUNCTIONS^B

    Function     Action

       B         Displays numbers left-justified
       C         Displays CR (credit) after positive numbers
       D         Displays dates in SET DATE format
       E         Displays dates in British format
       R         Non-template characters are inserted
       X         Displays DB (debit) after negative numbers
       Z         Displays zeros as blanks
       (         Encloses negative numbers in parentheses w/ leading spaces
       !         Converts alphabetic characters to upper case

                             ^BTRANSFORM TEMPLATES^B

    Template    Description

    A,N,X,9,#   Displays digits for any data type
       L        Displays logicals as "T" or "F"
       Y        Displays logicals as "Y" or "N"
       !        Converts an alphabetic character to upper case
       $        Displays a dollar sign in place of a leading space in a
                numeric
       *        Displays an asterisk in place of a leading space in a
                numeric
       .        Specifies a decimal point position.
       ,        Specifies a comma position.
!Seealso:"LOWER"  "STR"  "UPPER"  
!Short: TRIM         Removes trailing blanks from a character expression.
^BTRIM()/RTRIM()^B

    TRIM() removes all trailing blanks from a character expression.

^USyntax^U

    TRIM(<expC>)  -or-  RTRIM(<expC>)

^UUsage^U

    TRIM() is useful when you want to delete trailing spaces from a
    character string when concatenating with another string.  For example,
    a typical application of TRIM() is creation of formatted strings for
    names and addresses.

    ^BTests for null strings^B: you can use TRIM() as part of an expression
    to test for an empty character string.  For example, you can use the
    condition, LEN(TRIM(<expC>)=0 or the more preferred method,
    EMPTY(<expC>).
!Seealso:CLIP006.NGO:"LTRIM"  "SUBSTR"  
!Short: TYPE         Returns data type of variable, expression or field.
^BTYPE()^B

    TYPE() evaluates an expression and returns a single upper case
    character that indicates whether the expression is character, numeric,
    logical, memo, or undefined.  It is a test for the existence of a
    variable and/or the validity of an expression.

^USyntax^U

    TYPE(<exp C>)

^UUsage^U

    The TYPE() function always returns an upper case letter.

    The possible TYPE() values are:

    Character           = C
    Numeric             = N
    Logical             = L
    Memo                = M
    Array               = A
    Undefined           = U
    Error syntactical   = UE
    Error indeterminate = UI

^UUsage^U

    TYPE() returns the type of the specified expression.  With its expanded
    capabilities, it can be used to test expression validity.  There arem
    however, several special cases to note:

    ^BArray references^B: References to DECLAREd arrays return an "A".
    References to array elements return the type of the element.  Invalid
    references return "U".

    ^BIF()/IIF()^B: In order to return the appropriate data type for an IF(),
    TYPE() evaluates the condition and then returns the type of the
    evaluated path.  If either the IF() condition or the evaluated path are
    invalid, TYPE() returns "UE".

    ^BUser-defined and EXTEND.LIB functions^B: If a reference is made anywhere
    in an expression to a function not found in CLIPPER.LIB (such as a
    user-defined or EXTEND.LIB function), TYPE() returns a "UI".
!Short: UPDATED      Returns true if last READ changed any data in GETS.
^BUPDATED()^B

    UPDATED() returns a logical true (.T.) if the last READ changed any of
    the data in the associated GETs.

^USyntax^U

    UPDATED()

^UUsage^U

    Each time READ executes, it resets UPDATED() to false (.F.).  Note that
    within a READ, a change to any GET sets UPDATED() to true (.T.).
    Subsequent testing of UPDATED() within a SET KEY procedure or VALID
    reflects this status.
!Seealso:CLIP001.NGO:"READ"  
!Short: UPPER        Converts lower case characters to upper case.
^BUPPER()^B

    UPPER() converts lower case letters to upper case letters.

^USyntax^U

    UPPER(<exp C>)
!Seealso:"LOWER"  
!Short: USED         Determines if a database is in USE in current work area.
^BUSED()^B

    USED() determines if a database file is in USE in the current work
area.

^USyntax^U

    USED()

^UReturns^U

    A logical value.

    USED() returns true (.T.) if there is a database file in USE in the
current work area, false (.F.) if not.
!Seealso:CLIP001.NGO:"USE"  CLIP001.NGO:"SELECT"  "NETERR"  "SELECT()"  
!Short: VAL          Converts a character string to a number value.
^BVAL()^B

    VAL() converts numbers that are defined as characters into a numeric
    expression.

^USyntax^U

    VAL(<exp C>)

^UUsage^U

    If the expression consists of leading non-numeric characters other than
    blanks, VAL() returns a value of zero.

    VAL() displays the decimal portion of a number as designated by SET
    DECIMALS.

    The VAL() function operates from left to right, converting characters
    to numeric values until a text character is encountered.  Leading
    blanks are ignored if the argument contains both numeric and non-
    numeric characters.  The leading numeric characters will be converted
    to a numeric value.  Trailing blanks are treated as text characters
    and, when encountered, terminate the conversion process.
!Seealso:CLIP001.NGO:"SET DECIMALS"  CLIP001.NGO:"SET FIXED"  "STR()"  
!Short: WORD         Converts numeric arguments from type DOUBLE to type INT.
^BWORD()^B

    WORD() converts numeric parameters of the CALL command from type DOUBLE
    to type INT.

^USyntax^U

    WORD(<expN>)

^UArguments^U

    <expN> is the numeric value to convert to type INT.

^UUsage^U

    Use WORD() when you want to convert numeric parameters from DOUBLE to
    INT in order to reduce the overhead of the CALLed routine.  Be sure
    that the value does not exceed positive or negative 32,767.

    Example:

    ^RCALL C_proc WITH WORD(30000)^R
!Short: YEAR         Returns complete numeric value of the year from a date.
^BYEAR()^B

    YEAR() returns the numeric value of the year from a date expression.
    The result is always a four-digit number.

^USyntax^U

    YEAR(<exp D>)
!Seealso:CLIP001.NGO:"SET CENTURY"  CLIP006.NGO:"CDOW"  CLIP006.NGO:"DOW"  CLIP006.NGO:"CMONTH"  CLIP006.NGO:"DATE"  "MONTH"  
